const is_nothrow_move_constructible<basic_string<char, char_traits<char>, allocator<char>> &&> &__and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_assignable<..(*)(..)>>__and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_assignable<..(*)(..)>> &__and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_assignable<..(*)(..)>> &&const __and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_assignable<..(*)(..)>>const __and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_assignable<..(*)(..)>> &__static_gcd<1000L, 0L>__static_gcd<1000L, 0L> &__static_gcd<1000L, 0L> &&const __static_gcd<1000L, 0L>const __static_gcd<1000L, 0L> &is_enum<ServiceFlags>is_enum<ServiceFlags> &is_enum<ServiceFlags> &&const is_enum<ServiceFlags>const is_enum<ServiceFlags> &__is_nt_assignable_impl<AddrMan *&, AddrMan *&&>__is_nt_assignable_impl__is_nt_assignable_impl<AddrMan *&, AddrMan *&&> &__is_nt_assignable_impl<AddrMan *&, AddrMan *&&> &&const __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>const __is_nt_assignable_impl<AddrMan *&, AddrMan *&&> &is_assignable<AddrMan *&, AddrMan *&&>is_assignable<AddrMan *&, AddrMan *&&> &is_assignable<AddrMan *&, AddrMan *&&> &&const is_assignable<AddrMan *&, AddrMan *&&>const is_assignable<AddrMan *&, AddrMan *&&> &is_void<_Hash_node_base *>is_void<_Hash_node_base *> &is_void<_Hash_node_base *> &&const is_void<_Hash_node_base *>const is_void<_Hash_node_base *> &tuple<const int &>const CAddress *constconst CAddress *const &CAddress *&const __normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>> *_S_use_relocate()conditional<true, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>conditional<true, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const conditional<true, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const conditional<true, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>, is_assignable<AddrMan *&, AddrMan *&&>>conditional<true, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>, is_assignable<AddrMan *&, AddrMan *&&>> &conditional<true, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>, is_assignable<AddrMan *&, AddrMan *&&>> &&const conditional<true, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>, is_assignable<AddrMan *&, AddrMan *&&>>const conditional<true, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>, is_assignable<AddrMan *&, AddrMan *&&>> &is_nothrow_move_assignable<..(*)(..)>is_nothrow_move_assignable<..(*)(..)> &is_nothrow_move_assignable<..(*)(..)> &&const is_nothrow_move_assignable<..(*)(..)>const is_nothrow_move_assignable<..(*)(..)> &is_nothrow_move_constructible<..(*)(..)>is_nothrow_move_constructible<..(*)(..)> &is_nothrow_move_constructible<..(*)(..)> &&const is_nothrow_move_constructible<..(*)(..)>const is_nothrow_move_constructible<..(*)(..)> &remove_reference<..(*&)(..)>remove_reference<..(*&)(..)> &remove_reference<..(*&)(..)> &&const remove_reference<..(*&)(..)>const remove_reference<..(*&)(..)> &remove_reference<basic_string<char, char_traits<char>, allocator<char>> &&>remove_reference<basic_string<char, char_traits<char>, allocator<char>> &&> &remove_reference<basic_string<char, char_traits<char>, allocator<char>> &&> &&const remove_reference<basic_string<char, char_traits<char>, allocator<char>> &&>const remove_reference<basic_string<char, char_traits<char>, allocator<char>> &&> &__is_nothrow_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>> &&, true>__is_nothrow_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>> &&, true> &__is_nothrow_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>> &&, true> &&const __is_nothrow_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>> &&, true>const __is_nothrow_move_constructible_impl<basic_string<char, char_traits<char>, allocator<char>> &&, true> &_S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{})CAddress *constCAddress *const &const __normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>> *__normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>> *is_nothrow_constructible<CAddress>is_nothrow_constructible<CAddress> &is_nothrow_constructible<CAddress> &&const is_nothrow_constructible<CAddress>const is_nothrow_constructible<CAddress> &is_constructible<CAddress, CAddress &&>is_constructible<CAddress, CAddress &&> &is_constructible<CAddress, CAddress &&> &&const is_constructible<CAddress, CAddress &&>const is_constructible<CAddress, CAddress &&> &__is_move_constructible_impl<CAddress, true>__is_move_constructible_impl<CAddress, true> &__is_move_constructible_impl<CAddress, true> &&const __is_move_constructible_impl<CAddress, true>const __is_move_constructible_impl<CAddress, true> &is_move_constructible<CAddress>is_move_constructible<CAddress> &is_move_constructible<CAddress> &&const is_move_constructible<CAddress>const is_move_constructible<CAddress> &__is_move_insertable<allocator<CAddress>>__is_move_insertable__is_move_insertable<allocator<CAddress>> &__is_move_insertable<allocator<CAddress>> &&const __is_move_insertable<allocator<CAddress>>const __is_move_insertable<allocator<CAddress>> &__is_referenceable<basic_string<char, char_traits<char>, allocator<char>> &&>__is_referenceable<basic_string<char, char_traits<char>, allocator<char>> &&> &__is_referenceable<basic_string<char, char_traits<char>, allocator<char>> &&> &&const __is_referenceable<basic_string<char, char_traits<char>, allocator<char>> &&>const __is_referenceable<basic_string<char, char_traits<char>, allocator<char>> &&> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>> &&, basic_string<char, char_traits<char>, allocator<char>> &&>is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>> &&, basic_string<char, char_traits<char>, allocator<char>> &&> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>> &&, basic_string<char, char_traits<char>, allocator<char>> &&> &&const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>> &&, basic_string<char, char_traits<char>, allocator<char>> &&>const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>> &&, basic_string<char, char_traits<char>, allocator<char>> &&> &conditional<true, is_nothrow_move_assignable<..(*)(..)>, is_nothrow_move_constructible<..(*)(..)>>conditional<true, is_nothrow_move_assignable<..(*)(..)>, is_nothrow_move_constructible<..(*)(..)>> &conditional<true, is_nothrow_move_assignable<..(*)(..)>, is_nothrow_move_constructible<..(*)(..)>> &&const conditional<true, is_nothrow_move_assignable<..(*)(..)>, is_nothrow_move_constructible<..(*)(..)>>const conditional<true, is_nothrow_move_assignable<..(*)(..)>, is_nothrow_move_constructible<..(*)(..)>> &__is_nothrow_move_constructible_impl<..(*)(..), true>__is_nothrow_move_constructible_impl<..(*)(..), true> &__is_nothrow_move_constructible_impl<..(*)(..), true> &&const __is_nothrow_move_constructible_impl<..(*)(..), true>const __is_nothrow_move_constructible_impl<..(*)(..), true> &__is_nt_move_assignable_impl<..(*)(..), true>__is_nt_move_assignable_impl<..(*)(..), true> &__is_nt_move_assignable_impl<..(*)(..), true> &&const __is_nt_move_assignable_impl<..(*)(..), true>const __is_nt_move_assignable_impl<..(*)(..), true> &__uninitialized_move_if_noexcept_a__gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp)CAddress *&&noexcept(std::__relocate_a(std::declval<pointer>(),
					  std::declval<pointer>(),
					  std::declval<pointer>(),
					  std::declval<_Tp_alloc_type&>()))is_nothrow_assignable<..(*&)(..), ..(*&&)(..)>is_nothrow_assignable<..(*&)(..), ..(*&&)(..)> &is_nothrow_assignable<..(*&)(..), ..(*&&)(..)> &&const is_nothrow_assignable<..(*&)(..), ..(*&&)(..)>const is_nothrow_assignable<..(*&)(..), ..(*&&)(..)> &__is_referenceable<..(*)(..)>__is_referenceable<..(*)(..)> &__is_referenceable<..(*)(..)> &&const __is_referenceable<..(*)(..)>const __is_referenceable<..(*)(..)> &is_nothrow_constructible<..(*)(..), ..(*&&)(..)>is_nothrow_constructible<..(*)(..), ..(*&&)(..)> &is_nothrow_constructible<..(*)(..), ..(*&&)(..)> &&const is_nothrow_constructible<..(*)(..), ..(*&&)(..)>const is_nothrow_constructible<..(*)(..), ..(*&&)(..)> &__is_referenceable<CAddress>__is_referenceable<CAddress> &__is_referenceable<CAddress> &&const __is_referenceable<CAddress>const __is_referenceable<CAddress> &__relocate_ais_nothrow_destructible<CAddress>is_nothrow_destructible<CAddress> &is_nothrow_destructible<CAddress> &&const is_nothrow_destructible<CAddress>const is_nothrow_destructible<CAddress> &is_assignable<CAddress &, const CAddress &>is_assignable<CAddress &, const CAddress &> &is_assignable<CAddress &, const CAddress &> &&const is_assignable<CAddress &, const CAddress &>const is_assignable<CAddress &, const CAddress &> &__and_<is_assignable<..(*&)(..), ..(*&&)(..)>, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>>__and_<is_assignable<..(*&)(..), ..(*&&)(..)>, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>> &__and_<is_assignable<..(*&)(..), ..(*&&)(..)>, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>> &&const __and_<is_assignable<..(*&)(..), ..(*&&)(..)>, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>>const __and_<is_assignable<..(*&)(..), ..(*&&)(..)>, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>> &__is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>__is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)> &__is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)> &&const __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>const __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)> &is_assignable<..(*&)(..), ..(*&&)(..)>is_assignable<..(*&)(..), ..(*&&)(..)> &is_assignable<..(*&)(..), ..(*&&)(..)> &&const is_assignable<..(*&)(..), ..(*&&)(..)>const is_assignable<..(*&)(..), ..(*&&)(..)> &conditional<true, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>, is_assignable<..(*&)(..), ..(*&&)(..)>>conditional<true, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>, is_assignable<..(*&)(..), ..(*&&)(..)>> &conditional<true, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>, is_assignable<..(*&)(..), ..(*&&)(..)>> &&const conditional<true, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>, is_assignable<..(*&)(..), ..(*&&)(..)>>const conditional<true, __is_nt_assignable_impl<..(*&)(..), ..(*&&)(..)>, is_assignable<..(*&)(..), ..(*&&)(..)>> &__ds_type1__ds_type2__pair_type_T1 &&_T2 &&make_pairpair<_T1, _T2> &const pair<_T1, _T2>const pair<_T1, _T2> &pair<_T1, _T2> &&__pair_base<_U1, _U2> &const __pair_base<_U1, _U2>const __pair_base<_U1, _U2> &__pair_base~__pair_base__do_converts__converts__nonesuch_no_braces &const __nonesuch_no_bracesconst __nonesuch_no_braces &~__nonesuch_no_braces__nonesuch_no_bracesconst __nonesuchconst __nonesuch &__nonesuch &piecewise_construct_t &&piecewise_construct_tpiecewise_construct_t *__pair_base<_U1, _U2>_PCC<false, _T1, _T2>_PCC<<unnamed>, _T1, _T2>piecewise_construct_STL_PAIR_H/* _STL_PAIR_H */// NB: DR 706.// 181.  make_pair() unintended behavior/**
   *  @brief A convenience wrapper for creating a pair from two objects.
   *  @param  __x  The first object.
   *  @param  __y  The second object.
   *  @return   A newly-constructed pair<> object of the appropriate type.
   *
   *  The standard requires that the objects be passed by reference-to-const,
   *  but LWG issue #181 says they should be passed by const value.  We follow
   *  the LWG by default.
   */// __cplusplus >= 201103L//        implications, see, eg, libstdc++/38466.// Note:  no std::swap overloads in C++03 mode, this has performance/// See std::pair::swap()./// Uses @c operator< to find the result./// Uses @c operator== to find the result./// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>/// Two pairs of the same type are equal iff their members are equal.// DR 811.// Shortcut for constraining the templates that take pairs./** There is also a templated copy ctor for the @c pair class itself.  */// Shortcut for constraining the templates that don't take pairs./** Two objects may be passed to a @c pair constructor to be copied.  *//** The default constructor creates @c first and @c second using their
       *  respective default constructors.  */// 265.  std::pair::pair() effects overly restrictive/// @c second is a copy of the second object/// @c first is a copy of the first object/// @c second_type is the second bound type/// @c first_type is the first bound type/**
   *  @brief Struct holding two objects of arbitrary type.
   *
   *  @tparam _T1  Type of first object.
   *  @tparam _T2  Type of second object.
   */// operator from a pair of empty braces.// initialization of an argument of a disabled assignment// PR libstdc++/79141, a utility type for preventing// avoid querying those properties for incomplete types.// is_convertible if the types are the same to// See PR 70437, don't look at is_constructible or/// piecewise_construct/// piecewise_construct_t// for std::__decay_and_strip too// for std::move / std::forward, and std::swap/** @file bits/stl_pair.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */// Pair implementation -*- C++ -*-prevnext_InputIterator &__builtin_constant_p_RandomAccessIterator &_RandomAccessIteratorConcept< _RandomAccessIterator>__advance_BidirectionalIterator &distance_STL_ITERATOR_BASE_FUNCS_H__n >= 0/* _STL_ITERATOR_BASE_FUNCS_H */// concept requirements -- taken care of in __advance/**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __i  An input iterator.
   *  @param  __n  The @a delta by which to change @p __i.
   *  @return  Nothing.
   *
   *  This increments @p i by @p n.  For bidirectional and random access
   *  iterators, @p __n may be negative, in which case @p __i is decremented.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */// concept requirements -- taken care of in __distance/**
   *  @brief A generalization of pointer arithmetic.
   *  @param  __first  An input iterator.
   *  @param  __last  An input iterator.
   *  @return  The distance between them.
   *
   *  Returns @c n such that __first + n == __last.  This requires
   *  that @p __last must be reachable from @p __first.  Note that @c
   *  n may be negative.
   *
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */// Forward declaration because of the qualified call in distance.// Forward declaration for the overloads of __distance./** @file bits/stl_iterator_base_funcs.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file contains all of the general iterator-related utility
 *  functions, such as distance() and advance().
 */// Functions used by iterators -*- C++ -*-<backward/binders.h>mem_fun_refmem_funptr_fun_Arg1_Arg2not2const _Predicateconst _Predicate &_Predicate &not1const_mem_fun1_ref_tmem_fun1_ref_tconst_mem_fun1_tmem_fun1_tconst_mem_fun_ref_tmem_fun_ref_tconst_mem_fun_tmem_fun_tconst second_typeconst second_type &second_type &const _Pairconst _Pair &_Pair &const _Identity<_Tp>const _Identity<_Tp> *_Identity<_Tp> *pointer_to_binary_functionpointer_to_unary_functionconst first_argument_typeconst first_argument_type &first_argument_type &const second_argument_typeconst second_argument_type &second_argument_type &binary_negateconst argument_typeconst argument_type &argument_type &unary_negatebit_not<void> &bit_not<void> &&const bit_not<void>const bit_not<void> &bit_xor<void> &bit_xor<void> &&const bit_xor<void>const bit_xor<void> &bit_or<void> &bit_or<void> &&const bit_or<void>const bit_or<void> &bit_and<void> &bit_and<void> &&const bit_and<void>const bit_and<void> &logical_not<void> &logical_not<void> &&const logical_not<void>const logical_not<void> &logical_or<void> &logical_or<void> &&const logical_or<void>const logical_or<void> &logical_and<void> &logical_and<void> &&const logical_and<void>const logical_and<void> &less_equal<void> &less_equal<void> &&const less_equal<void>const less_equal<void> &_S_cmpgreater_equal<void> &greater_equal<void> &&const greater_equal<void>const greater_equal<void> &less<void> &less<void> &&const less<void>const less<void> &greater<void> &greater<void> &&const greater<void>const greater<void> &not_equal_to<void> &not_equal_to<void> &&const not_equal_to<void>const not_equal_to<void> &equal_to<void> &equal_to<void> &&const equal_to<void>const equal_to<void> &const less<_Tp *>const less<_Tp *> *less<_Tp *> *__builtin_is_constant_evaluatedconst less<_Tp>const less<_Tp> *less<_Tp> *const equal_to<_Tp>const equal_to<_Tp> *equal_to<_Tp> *negate<void> &negate<void> &&const negate<void>const negate<void> &modulus<void> &modulus<void> &&const modulus<void>const modulus<void> &divides<void> &divides<void> &&const divides<void>const divides<void> &multiplies<void> &multiplies<void> &&const multiplies<void>const multiplies<void> &minus<void> &minus<void> &&const minus<void>const minus<void> &plus<void> &plus<void> &&const plus<void>const plus<void> &const_mem_fun1_ref_t<_Ret, _Tp, _Arg>mem_fun1_ref_t<_Ret, _Tp, _Arg>const_mem_fun1_t<_Ret, _Tp, _Arg>mem_fun1_t<_Ret, _Tp, _Arg>const_mem_fun_ref_t<_Ret, _Tp>mem_fun_ref_t<_Ret, _Tp>const_mem_fun_t<_Ret, _Tp>mem_fun_t<_Ret, _Tp>_Select2nd<_Pair>_Select1st<_Pair>_Identity<const _Tp>_Identity<_Tp>pointer_to_binary_function<_Arg1, _Arg2, _Result>pointer_to_unary_function<_Arg, _Result>binary_negate<_Predicate>unary_negate<_Predicate>bit_not<void>bit_xor<void>bit_or<void>bit_and<void>bit_not<_Tp>bit_xor<_Tp>bit_or<_Tp>bit_and<_Tp>logical_not<void>logical_or<void>logical_and<void>logical_not<_Tp>logical_or<_Tp>logical_and<_Tp>less_equal<void>__not_overloaded<_Tp, _Up, __void_t<decltype((<expression>))>>__not_overloaded<_Tp, _Up, <unnamed>>__not_overloaded2<_Tp, _Up, __void_t<decltype((<expression>))>>__not_overloaded2<_Tp, _Up, <unnamed>>greater_equal<void>less<void>greater<void>not_equal_to<void>equal_to<void>less_equal<_Tp *>greater_equal<_Tp *>less<_Tp *>greater<_Tp *>less_equal<_Tp>greater_equal<_Tp>less<_Tp>greater<_Tp>not_equal_to<_Tp>equal_to<_Tp>negate<void>modulus<void>divides<void>multiplies<void>minus<void>plus<void>negate<_Tp>modulus<_Tp>divides<_Tp>multiplies<_Tp>minus<_Tp>plus<_Tp>__is_transparentbinary_function<_Arg1, _Arg2, _Result>unary_function<_Arg, _Result>_M_f_M_pred__cpp_lib_transparent_operators_STL_FUNCTION_H_GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED(__cplusplus < 201103L) || _GLIBCXX_USE_DEPRECATED__UINTPTR_TYPE__/* _STL_FUNCTION_H *//** @}  */// mem_fun and mem_fun_ref.// Mem_fun adaptor helper functions.  There are only two:/// pointers@endlink./// One of the @link memory_adaptors adaptors for member/** @defgroup memory_adaptors Adaptors for pointers to members
   * @ingroup functors
   *
   *  There are a total of 8 = 2^3 function objects in this family.
   *   (1) Member functions taking no arguments vs member functions taking
   *        one argument.
   *   (2) Call through pointer vs call through reference.
   *   (3) Const vs non-const member function.
   *
   *  All of this complexity is in the function objects themselves.  You can
   *   ignore it by using the helper function mem_fun and mem_fun_ref,
   *   which create whichever type of adaptor is appropriate.
   *
   *  @{
   */// 20.3.8 adaptors pointers members// Partial specialization, avoids confusing errors in e.g. std::set<const T>./// One of the @link pointer_adaptors adaptors for function pointers@endlink./** @defgroup pointer_adaptors Adaptors for pointers to functions
   * @ingroup functors
   *
   *  The advantage of function objects over pointers to functions is that
   *  the objects in the standard library declare nested typedefs describing
   *  their argument and result types with uniform names (e.g., @c result_type
   *  from the base classes @c unary_function and @c binary_function).
   *  Sometimes those typedefs are required, not just optional.
   *
   *  Adaptors are provided to turn pointers to unary (single-argument) and
   *  binary (double-argument) functions into function objects.  The
   *  long-winded functor @c pointer_to_unary_function is constructed with a
   *  function pointer @c f, and its @c operator() called with argument @c x
   *  returns @c f(x).  The functor @c pointer_to_binary_function does the same
   *  thing, but with a double-argument @c f and @c operator().
   *
   *  The function @c ptr_fun takes a pointer-to-function @c f and constructs
   *  an instance of the appropriate functor.
   *
   *  @{
   */// 20.3.7 adaptors pointers functions/// One of the @link negators negation functors@endlink./** @defgroup negators Negators
   * @ingroup functors
   *
   *  The functions @c not1 and @c not2 each take a predicate functor
   *  and return an instance of @c unary_negate or
   *  @c binary_negate, respectively.  These classes are functors whose
   *  @c operator() performs the stored predicate function and then returns
   *  the negation of the result.
   *
   *  For example, given a vector of integers and a trivial predicate,
   *  \code
   *  struct IntGreaterThanThree
   *    : public std::unary_function<int, bool>
   *  {
   *      bool operator() (int x) { return x > 3; }
   *  };
   *
   *  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));
   *  \endcode
   *  The call to @c find_if will locate the first index (i) of @c v for which
   *  <code>!(v[i] > 3)</code> is true.
   *
   *  The not1/unary_negate combination works on predicates taking a single
   *  argument.  The not2/binary_negate combination works on predicates which
   *  take two arguments.
   *
   *  @{
   */// 20.3.5 negators// DR 660. Missing Bitwise Operations./// One of the @link logical_functors Boolean operations functors@endlink./** @defgroup logical_functors Boolean Operations Classes
   * @ingroup functors
   *
   *  Here are wrapper functors for Boolean operations: @c &&, @c ||,
   *  and @c !.
   *
   *  @{
   */// 20.3.4 logical operations// False if we can call operator<=(T,U)// True if there is no overloaded operator<= for these operands.// False if we can call T.operator<=(U)// True if there is no viable operator<= member function./// One of the @link comparison_functors comparison functors@endlink.// False if we can call operator>=(T,U)// True if there is no overloaded operator>= for these operands.// False if we can call T.operator>=(U)// True if there is no viable operator>= member function.// False if we can call operator<(T,U)// True if there is no overloaded operator< for these operands.// False if we can call T.operator<(U)// True if there is no viable operator< member function.// False if we can call operator>(T,U)// True if there is no overloaded operator> for these operands.// False if we can call T.operator>(U)// True if there is no viable operator> member function.// Partial specialization of std::less_equal for pointers.// Partial specialization of std::greater_equal for pointers.// Partial specialization of std::less for pointers.// Partial specialization of std::greater for pointers./** @defgroup comparison_functors Comparison Classes
   * @ingroup functors
   *
   *  The library provides six wrapper functors for all the basic comparisons
   *  in C++, like @c <.
   *
   *  @{
   */// 20.3.3 comparisons/// One of the @link arithmetic_functors math functors@endlink.// undefined/** @defgroup arithmetic_functors Arithmetic Classes
   * @ingroup functors
   *
   *  Because basic math often needs to be done during an algorithm,
   *  the library provides functors for those operations.  See the
   *  documentation for @link functors the base classes@endlink
   *  for examples of their use.
   *
   *  @{
   */// 20.3.2 arithmetic/// @c result_type is the return type/// @c second_argument_type is the type of the second argument/// @c first_argument_type is the type of the first argument/**
   *  This is one of the @link functors functor base classes@endlink.
   *//// @c argument_type is the type of the argument/** @defgroup functors Function Objects
   * @ingroup utilities
   *
   *  Function objects, or @e functors, are objects with an @c operator()
   *  defined and accessible.  They can be passed as arguments to algorithm
   *  templates and used in place of a function pointer.  Not only is the
   *  resulting expressiveness of the library increased, but the generated
   *  code can be more efficient than what you might write by hand.  When we
   *  refer to @a functors, then, generally we include function pointers in
   *  the description as well.
   *
   *  Often, functors are only created as temporaries passed to algorithm
   *  calls, rather than being created as named variables.
   *
   *  Two examples taken from the standard itself follow.  To perform a
   *  by-element addition of two vectors @c a and @c b containing @c double,
   *  and put the result in @c a, use
   *  \code
   *  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
   *  \endcode
   *  To negate every element in @c a, use
   *  \code
   *  transform(a.begin(), a.end(), a.begin(), negate<double>());
   *  \endcode
   *  The addition and negation functions will be inlined directly.
   *
   *  The standard functors are derived from structs named @c unary_function
   *  and @c binary_function.  These two classes contain nothing but typedefs,
   *  to aid in generic (template) programming.  If you write your own
   *  functors, you might consider doing the same.
   *
   *  @{
   */// 20.3.1 base classes/** @file bits/stl_function.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Functor implementations -*- C++ -*-hash function must be invocable with an argument of key type_Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> *__hashtable *_Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> *_Hashtable<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> *_Node_const_iterator<_Value, __constant_iterators, __cache> *const _Node_const_iterator<_Value, __constant_iterators, __cache>const _Node_const_iterator<_Value, __constant_iterators, __cache> *const _Node_iterator<_Value, __constant_iterators, __cache> *_Node_iterator<_Value, __constant_iterators, __cache> *_Node_iterator_base<_Value, _Cache_hash_code> *const _AllocNode<_NodeAlloc>const _AllocNode<_NodeAlloc> *_AllocNode<_NodeAlloc> *const _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>const _Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> *_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> *key equality predicate must be invocable with two arguments of key typeconst _Identity *_Identity *const _Optional_payload_base<_Tp> *lambda [] type at line 81071, col. 9lambda [] type at line 81071, col. 9 &const lambda [] type at line 81071, col. 9const lambda [] type at line 81071, col. 9 &const lambda [] type at line 81071, col. 9 *lambda [] type at line 81071, col. 9 *lambda [] type at line 81017, col. 8lambda [] type at line 81017, col. 8 &const lambda [] type at line 81017, col. 8const lambda [] type at line 81017, col. 8 &const lambda [] type at line 81017, col. 8 *lambda [] type at line 81017, col. 8 *lambda [] type at line 81034, col. 2lambda [] type at line 81034, col. 2 &const lambda [] type at line 81034, col. 2const lambda [] type at line 81034, col. 2 &const lambda [] type at line 81034, col. 2 *lambda [] type at line 81034, col. 2 *lambda [] type at line 81229, col. 3lambda [] type at line 81229, col. 3 &const lambda [] type at line 81229, col. 3const lambda [] type at line 81229, col. 3 &const lambda [] type at line 81229, col. 3 *lambda [] type at line 81229, col. 3 *__new_buckets__bbegin_bkt__saved_state__do_rehash__before_n__prev_pconst unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &_Predconst unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &unordered_multimapconst unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>const unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &unordered_multimap<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &_Key1_Hash1_Pred1_Alloc1const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1> &_S_get_tableunordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc> &unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc> &unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> *const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> *unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &&unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc> &unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &&unordered_map<_Key, _Tp, _H2, _P2, _Alloc> &unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc> &&hasher &key_equal &__umapunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc> &&_Hash_merge_helper<unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2>_Hash2_Eq2_Hash_merge_helper<unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2>unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>_Eq1__cpp_lib_unordered_map_insertion__cpp_lib_unordered_map_try_emplace_UNORDERED_MAP_H/* _UNORDERED_MAP_H */// Allow std::unordered_multimap access to internals of compatible maps.// Allow std::unordered_map access to internals of compatible maps./**
       *  @brief  Prepare the %unordered_multimap for a specified number of
       *          elements.
       *  @param  __n Number of elements required.
       *
       *  Same as rehash(ceil(n / max_load_factor())).
       *//**
       *  @brief  May rehash the %unordered_multimap.
       *  @param  __n The new number of buckets.
       *
       *  Rehash will occur only if the new number of buckets respect the
       *  %unordered_multimap maximum load factor.
       *//**
       *  @brief  Change the %unordered_multimap maximum load factor.
       *  @param  __z The new maximum load factor.
       *//// the load factor less than or equal to./// Returns a positive number that the %unordered_multimap tries to keep/// Returns the average number of elements per bucket.// hash policy./**
       *  @brief  Returns a read-only (constant) iterator pointing to one past
       *         the last bucket elements.
       *  @param  __n The bucket index.
       *  @return  A read-only local iterator.
       *//**
       *  @brief  Returns a read/write iterator pointing to one past the last
       *         bucket elements.
       *  @param  __n The bucket index.
       *  @return  A read/write local iterator.
       *//**
       *  @brief  Returns a read-only (constant) iterator pointing to the first
       *         bucket element.
       *  @param  __n The bucket index.
       *  @return  A read-only local iterator.
       *//**
       *  @brief  Returns a read/write iterator pointing to the first bucket
       *         element.
       *  @param  __n The bucket index.
       *  @return  A read/write local iterator.
       *//*
       * @brief  Returns the bucket index of a given element.
       * @param  __key  A key instance.
       * @return  The key bucket index.
       *//*
       * @brief  Returns the number of elements in a given bucket.
       * @param  __n  A bucket index.
       * @return  The number of elements in the bucket.
       *//// Returns the maximum number of buckets of the %unordered_multimap./// Returns the number of buckets of the %unordered_multimap.// bucket interface./**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *//**
       *  @brief  Finds whether an element with the given key exists.
       *  @param  __x  Key of elements to be located.
       *  @return  True if there is any element with the specified key.
       *//**
       *  @brief  Finds the number of elements.
       *  @param  __x  Key to count.
       *  @return  Number of elements with specified key.
       *//**
       *  @brief Tries to locate an element in an %unordered_multimap.
       *  @param  __x  Key to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */// lookup.///  was constructed.///  Returns the key comparison object with which the %unordered_multimap///  Returns the hash functor object with which the %unordered_multimap// observers./**
       *  @brief  Swaps data with another %unordered_multimap.
       *  @param  __x  An %unordered_multimap of the same element and allocator
       *  types.
       *
       *  This exchanges the elements between two %unordered_multimap in
       *  constant time.
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(m1,m2) will feed to this function.
       *//**
       *  Erases all elements in an %unordered_multimap.
       *  Note that this function only erases the elements, and that if the
       *  elements themselves are pointers, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases a [__first,__last) range of elements from an
       *  %unordered_multimap.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                  erased.
       *  @param __last  Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from an
       *  %unordered_multimap.
       *  Note that this function only erases the elements, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of elements to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  an %unordered_multimap.
       *  Note that this function only erases the element, and that if the
       *  element is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from an %unordered_multimap.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a __position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from an %unordered_multimap.
       *  Note that this function only erases the element, and that if the
       *  element is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Attempts to insert a list of elements into the
       *  %unordered_multimap.
       *  @param  __l  A std::initializer_list<value_type> of elements
       *               to be inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief A template function that attempts to insert a range of
       *  elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Inserts a std::pair into the %unordered_multimap.
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                 pair should be inserted.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *               of pairs).
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Inserts a std::pair into the %unordered_multimap.
       *  @param __x Pair to be inserted (see std::make_pair for easy
       *	     creation of pairs).
       *
       *  @return  An iterator that points to the inserted pair.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the
       *  %unordered_multimap.
       *
       *  @param  __pos  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param  __args  Arguments used to generate a new pair instance (see
       *	         std::piecewise_contruct for passing arguments to each
       *	         part of the pair constructor).
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args.
       *
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the
       *  %unordered_multimap.
       *
       *  @param __args  Arguments used to generate a new pair instance (see
       *	        std::piecewise_contruct for passing arguments to each
       *	        part of the pair constructor).
       *
       *  @return  An iterator that points to the inserted pair.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %unordered_multimap.
       *
       *  Insertion requires amortized constant time.
       */// modifiers./**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %unordered_multimap.
       *//**
       *  Returns a read/write iterator that points one past the last element in
       *  the %unordered_multimap.
       *//**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %unordered_multimap.
       *//**
       *  Returns a read/write iterator that points to the first element in the
       *  %unordered_multimap.
       */// iterators.///  Returns the maximum size of the %unordered_multimap.///  Returns the size of the %unordered_multimap.///  Returns true if the %unordered_multimap is empty.// size and capacity:///  Returns the allocator object used by the %unordered_multimap./**
       *  @brief  %Unordered_multimap list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills an %unordered_multimap with copies of the
       *  elements in the initializer list @a __l.
       *
       *  Note that the assignment completely changes the %unordered_multimap
       *  and that the resulting %unordered_multimap's size is the same as the
       *  number of elements assigned.
       *//// Copy assignment operator./**
       *  @brief  Builds an %unordered_multimap from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param __n  Minimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param  __a  An allocator object.
       *
       *  Create an %unordered_multimap consisting of copies of the elements in
       *  the list. This is linear in N (where N is @a __l.size()).
       *//*
       *  @brief  Move constructor with allocator argument.
       *  @param  __uset Input %unordered_multimap to move.
       *  @param  __a    An allocator object.
       *//*
       *  @brief Copy constructor with allocator argument.
       * @param  __uset  Input %unordered_multimap to copy.
       * @param  __a  An allocator object.
       *//**
       *  @brief Creates an %unordered_multimap with no elements.
       *  @param __a An allocator object.
       *//// Copy constructor./**
       *  @brief  Builds an %unordered_multimap from a range.
       *  @param  __first An input iterator.
       *  @param  __last  An input iterator.
       *  @param __n      Minimal initial number of buckets.
       *  @param __hf     A hash functor.
       *  @param __eql    A key equality functor.
       *  @param __a      An allocator object.
       *
       *  Create an %unordered_multimap consisting of copies of the elements
       *  from [__first,__last).  This is linear in N (where N is
       *  distance(__first,__last)).
       *//**
       *  @brief  Default constructor creates no elements.
       *  @param __n  Mnimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param __a  An allocator object.
       *//// Default constructor.//construct/destroy/copy///  Iterator-related typedefs./// Public typedefs.// typedefs:/**
   *  @brief A standard container composed of equivalent keys
   *  (possibly containing multiple of each key value) that associates
   *  values of another type with the keys.
   *
   *  @ingroup unordered_associative_containers
   *
   *  @tparam  _Key    Type of key objects.
   *  @tparam  _Tp     Type of mapped objects.
   *  @tparam  _Hash   Hashing function object type, defaults to hash<_Value>.
   *  @tparam  _Pred   Predicate function object type, defaults
   *                   to equal_to<_Value>.
   *  @tparam  _Alloc  Allocator type, defaults to
   *                   std::allocator<std::pair<const _Key, _Tp>>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
   *  <a href="tables.html#xx">unordered associative container</a>
   *
   * The resulting value type of the container is std::pair<const _Key, _Tp>.
   *
   *  Base is _Hashtable, dispatched at compile time via template
   *  alias __ummap_hashtable.
   *//**
       *  @brief  Prepare the %unordered_map for a specified number of
       *          elements.
       *  @param  __n Number of elements required.
       *
       *  Same as rehash(ceil(n / max_load_factor())).
       *//**
       *  @brief  May rehash the %unordered_map.
       *  @param  __n The new number of buckets.
       *
       *  Rehash will occur only if the new number of buckets respect the
       *  %unordered_map maximum load factor.
       *//**
       *  @brief  Change the %unordered_map maximum load factor.
       *  @param  __z The new maximum load factor.
       *//// load factor less than or equal to./// Returns a positive number that the %unordered_map tries to keep the/// Returns the maximum number of buckets of the %unordered_map./// Returns the number of buckets of the %unordered_map./**
       *  @brief  Access to %unordered_map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data whose key is equal to @a __k, if
       *           such a data is present in the %unordered_map.
       *  @throw  std::out_of_range  If no such data is present.
       *//**
       *  @brief  Subscript ( @c [] ) access to %unordered_map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data of the (key,data) %pair.
       *
       *  Allows for easy lookup with the subscript ( @c [] )operator.  Returns
       *  data associated with the key specified in subscript.  If the key does
       *  not exist, a pair with that key is created using default values, which
       *  is then returned.
       *
       *  Lookup requires constant time.
       *//**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function probably only makes sense for %unordered_multimap.
       *//**
       *  @brief  Finds the number of elements.
       *  @param  __x  Key to count.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for %unordered_multimap; for
       *  %unordered_map the result will either be 0 (not present) or 1
       *  (present).
       *//**
       *  @brief Tries to locate an element in an %unordered_map.
       *  @param  __x  Key to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       *////  constructed.///  Returns the key comparison object with which the %unordered_map was///  Returns the hash functor object with which the %unordered_map was/**
       *  @brief  Swaps data with another %unordered_map.
       *  @param  __x  An %unordered_map of the same element and allocator
       *  types.
       *
       *  This exchanges the elements between two %unordered_map in constant
       *  time.
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(m1,m2) will feed to this function.
       *//**
       *  Erases all elements in an %unordered_map.
       *  Note that this function only erases the elements, and that if the
       *  elements themselves are pointers, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases a [__first,__last) range of elements from an
       *  %unordered_map.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                  erased.
       *  @param __last  Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from an %unordered_map.
       *  Note that this function only erases the elements, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  an %unordered_map. For an %unordered_map the result of this function
       *  can only be 0 (not present) or 1 (present).
       *  Note that this function only erases the element, and that if the
       *  element is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from an %unordered_map.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a __position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from an %unordered_map.
       *  Note that this function only erases the element, and that if the
       *  element is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Attempts to insert a std::pair into the %unordered_map.
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                  pair should be inserted.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the unordered_map.
       *  @param __obj  Argument used to generate the .second for a pair 
       *                instance.
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument insert()
       *  does.         
       *  If the %pair was already in the %unordered map, the .second of
       *  the %pair is assigned from __obj.
       *  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to insert a std::pair into the %unordered_map.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __obj  Argument used to generate the .second for a pair 
       *                instance.
       *
       *  @return  A pair, of which the first element is an iterator that 
       *           points to the possibly inserted pair, and the second is 
       *           a bool that is true if the pair was actually inserted.
       *
       *  This function attempts to insert a (key, value) %pair into the
       *  %unordered_map. An %unordered_map relies on unique keys and thus a
       *  %pair is only inserted if its first element (the key) is not already
       *  present in the %unordered_map.
       *  If the %pair was already in the %unordered_map, the .second of 
       *  the %pair is assigned from __obj.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to insert a list of elements into the %unordered_map.
       *  @param  __l  A std::initializer_list<value_type> of elements
       *               to be inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Attempts to insert a std::pair into the %unordered_map.
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                 pair should be inserted.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *               of pairs).
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument insert()
       *  does.  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to insert a std::pair into the %unordered_map.

       *  @param __x Pair to be inserted (see std::make_pair for easy
       *	     creation of pairs).
       *
       *  @return  A pair, of which the first element is an iterator that 
       *           points to the possibly inserted pair, and the second is 
       *           a bool that is true if the pair was actually inserted.
       *
       *  This function attempts to insert a (key, value) %pair into the
       *  %unordered_map. An %unordered_map relies on unique keys and thus a
       *  %pair is only inserted if its first element (the key) is not already
       *  present in the %unordered_map.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the
       *  %unordered_map.
       *
       *  @param  __hint  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the unordered_map.
       *  @param __args  Arguments used to generate the .second for a 
       *                new pair instance.
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args (may or may not be that
       *          std::pair).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does. However, if insertion did not take place,
       *  this function has no effect.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the
       *  %unordered_map.
       *
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the unordered_map.
       *  @param __args  Arguments used to generate the .second for a 
       *                new pair instance.
       *
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted pair, and the second is a bool that
       *           is true if the pair was actually inserted.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %unordered_map.
       *  An %unordered_map relies on unique keys and thus a %pair is only
       *  inserted if its first element (the key) is not already present in the
       *  %unordered_map.
       *  If a %pair is not inserted, this function has no effect.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the
       *  %unordered_map.
       *
       *  @param  __pos  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param  __args  Arguments used to generate a new pair instance (see
       *	         std::piecewise_contruct for passing arguments to each
       *	         part of the pair constructor).
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args (may or may not be that
       *          std::pair).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the
       *  %unordered_map.
       *
       *  @param __args  Arguments used to generate a new pair instance (see
       *	        std::piecewise_contruct for passing arguments to each
       *	        part of the pair constructor).
       *
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted pair, and the second is a bool that
       *           is true if the pair was actually inserted.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %unordered_map.
       *  An %unordered_map relies on unique keys and thus a %pair is only
       *  inserted if its first element (the key) is not already present in the
       *  %unordered_map.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %unordered_map.
       *//**
       *  Returns a read/write iterator that points one past the last element in
       *  the %unordered_map.
       *//**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %unordered_map.
       *//**
       *  Returns a read/write iterator that points to the first element in the
       *  %unordered_map.
       *////  Returns the maximum size of the %unordered_map.///  Returns the size of the %unordered_map.///  Returns true if the %unordered_map is empty.///  Returns the allocator object used by the %unordered_map./**
       *  @brief  %Unordered_map list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills an %unordered_map with copies of the elements in
       *  the initializer list @a __l.
       *
       *  Note that the assignment completely changes the %unordered_map and
       *  that the resulting %unordered_map's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  Builds an %unordered_map from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param __n  Minimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param  __a  An allocator object.
       *
       *  Create an %unordered_map consisting of copies of the elements in the
       *  list. This is linear in N (where N is @a __l.size()).
       *//*
       *  @brief  Move constructor with allocator argument.
       *  @param  __uset Input %unordered_map to move.
       *  @param  __a    An allocator object.
       *//*
       *  @brief Copy constructor with allocator argument.
       * @param  __uset  Input %unordered_map to copy.
       * @param  __a  An allocator object.
       *//**
       *  @brief Creates an %unordered_map with no elements.
       *  @param __a An allocator object.
       *//**
       *  @brief  Builds an %unordered_map from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param __n  Minimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param __a  An allocator object.
       *
       *  Create an %unordered_map consisting of copies of the elements from
       *  [__first,__last).  This is linear in N (where N is
       *  distance(__first,__last)).
       *//**
       *  @brief  Default constructor creates no elements.
       *  @param __n  Minimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param __a  An allocator object.
       *//**
   *  @brief A standard container composed of unique keys (containing
   *  at most one of each key value) that associates values of another type
   *  with the keys.
   *
   *  @ingroup unordered_associative_containers
   *
   *  @tparam  _Key    Type of key objects.
   *  @tparam  _Tp     Type of mapped objects.
   *  @tparam  _Hash   Hashing function object type, defaults to hash<_Value>.
   *  @tparam  _Pred   Predicate function object type, defaults
   *                   to equal_to<_Value>.
   *  @tparam  _Alloc  Allocator type, defaults to 
   *                   std::allocator<std::pair<const _Key, _Tp>>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
   *  <a href="tables.html#xx">unordered associative container</a>
   *
   * The resulting value type of the container is std::pair<const _Key, _Tp>.
   *
   *  Base is _Hashtable, dispatched at compile time via template
   *  alias __umap_hashtable.
   *//// Base types for unordered_multimap./// Base types for unordered_map./** @file bits/unordered_map.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{unordered_map}
 */// unordered_map implementation -*- C++ -*-__ummap_Rb_tree_iterator<int> &_Rb_tree_const_iterator<int> &const _Rb_tree<int, int, _Identity<int>, less<int>, allocator<int>>const _Rb_tree<int, int, _Identity<int>, less<int>, allocator<int>> &_Rb_tree<int, int, _Identity<int>, less<int>, allocator<int>> &set<_Key, _Compare, _Alloc> &const set<_Key, _Compare, _Alloc>const set<_Key, _Compare, _Alloc> &setconst set<_K1, _C1, _A1>const set<_K1, _C1, _A1> &set<_K1, _C1, _A1> &multiset<_Val, _Cmp2, _Alloc> &set<_Val, _Cmp2, _Alloc> &const set<_Key, _Compare, _Alloc> *set<_Key, _Compare, _Alloc> *multiset<_Key, _Compare1, _Alloc> &&_Compare1multiset<_Key, _Compare1, _Alloc> &set<_Key, _Compare1, _Alloc> &&set<_Key, _Compare1, _Alloc> &set<_Key, _Compare, _Alloc> &&~set_Rb_tree_merge_helper<set<_Val, _Cmp1, _Alloc>, _Cmp2>set<_Key, _Compare, _Alloc>_Key_alloc_typemultiset<_Key, _Compare, _Alloc>std::set must have the same value_type as its allocatorstd::set must have a non-const, non-volatile value_type_STL_SET_H/* _STL_SET_H *///namespace std// Allow std::set access to internals of compatible sets./// See std::set::swap().///  Returns !(x < y)///  Returns !(y < x)///  Returns y < x.///  Returns !(x == y)./**
   *  @brief  Set ordering relation.
   *  @param  __x  A %set.
   *  @param  __y  A %set of the same type as @a x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  sets.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  Set equality comparison.
   *  @param  __x  A %set.
   *  @param  __y  A %set of the same type as @a x.
   *  @return  True iff the size and elements of the sets are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the sets.
   *  Sets are considered equivalent if their sizes are equal, and if
   *  corresponding elements compare equal.
  *//**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multisets.
       *//**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return Iterator pointing to the first element
       *          greater than key, or end().
       *//**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Iterator pointing to first element equal to or greater
       *           than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       *//**
       *  @brief Tries to locate an element in a %set.
       *  @param  __x  Element to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */// 214.  set::find() missing const overload/**
       *  @brief  Finds whether an element with the given key exists.
       *  @param  __x  Key of elements to be located.
       *  @return  True if there is an element with the specified key.
       *//**
       *  @brief  Finds the number of elements.
       *  @param  __x  Element to located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for multisets; for set the result will
       *  either be 0 (not present) or 1 (present).
       */// set operations:/**
       *  Erases all elements in a %set.  Note that this function only erases
       *  the elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       *//**
       *  @brief Erases a [first,last) range of elements from a %set.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                 erased.
       *  @param __last Iterator pointing to the end of the range to
       *  be erased.
       *
       *  This function erases a sequence of elements from a %set.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases a [__first,__last) range of elements from a %set.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                 erased.

       *  @param __last Iterator pointing to the end of the range to
       *  be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from a %set.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  a %set.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from a %set.
       *  @param  position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %set.  Note that this function only erases the element, and
       *  that if the element is itself a pointer, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief Erases an element from a %set.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a __position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from a %set.  Note that this function only erases the element, and
       *  that if the element is itself a pointer, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief Attempts to insert a list of elements into the %set.
       *  @param  __l  A std::initializer_list<value_type> of elements
       *               to be inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief A template function that attempts to insert a range
       *  of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Attempts to insert an element into the %set.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                    element should be inserted.
       *  @param  __x  Element to be inserted.
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the element passed in).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument insert()
       *  does.  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *//**
       *  @brief Attempts to insert an element into the %set.
       *  @param  __x  Element to be inserted.
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted element, and the second is a bool
       *           that is true if the element was actually inserted.
       *
       *  This function attempts to insert an element into the %set.  A %set
       *  relies on unique keys and thus an element is only inserted if it is
       *  not already present in the %set.
       *
       *  Insertion requires logarithmic time.
       *//**
       *  @brief Attempts to insert an element into the %set.
       *  @param  __pos  An iterator that serves as a hint as to where the
       *                element should be inserted.
       *  @param  __args  Arguments used to generate the element to be
       *                 inserted.
       *  @return An iterator that points to the element with key equivalent to
       *          the one generated from @a __args (may or may not be the
       *          element itself).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does.  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *//**
       *  @brief Attempts to build and insert an element into the %set.
       *  @param __args  Arguments used to generate an element.
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted element, and the second is a bool
       *           that is true if the element was actually inserted.
       *
       *  This function attempts to build and insert an element into the %set.
       *  A %set relies on unique keys and thus an element is only inserted if
       *  it is not already present in the %set.
       *
       *  Insertion requires logarithmic time.
       */// insert/erase/**
       *  @brief  Swaps data with another %set.
       *  @param  __x  A %set of the same element and allocator types.
       *
       *  This exchanges the elements between two sets in constant
       *  time.  (It is only swapping a pointer, an integer, and an
       *  instance of the @c Compare type (which itself is often
       *  stateless and empty), so it should be quite fast.)  Note
       *  that the global std::swap() function is specialized such
       *  that std::swap(s1,s2) will feed to this function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *////  Returns the maximum size of the %set.///  Returns the size of the %set.///  Returns true if the %set is empty./**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %set.  Iteration is done in descending order
       *  according to the keys.
       *//**
       *  Returns a read-only (constant) iterator that points to the last
       *  element in the %set.  Iteration is done in descending order according
       *  to the keys.
       *//**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %set.  Iteration is done in ascending order according
       *  to the keys.
       *//**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %set.  Iteration is done in ascending order according
       *  to the keys.
       *////  Returns the allocator object with which the %set was constructed.///  Returns the comparison object with which the %set was constructed.// accessors:/**
       *  @brief  %Set list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %set with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %set and
       *  that the resulting %set's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  %Set assignment operator.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way. Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Builds a %set from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %set consisting of copies of the elements in the list.
       *  This is linear in N if the list is already sorted, and NlogN
       *  otherwise (where N is @a __l.size()).
       *//**
       *  @brief %Set move constructor
       *
       *  The newly-created %set contains the exact contents of the moved
       *  instance. The moved instance is a valid, but unspecified, %set.
       *//**
       *  @brief  %Set copy constructor.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  @brief  Builds a %set from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %set consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       *//**
       *  @brief  Builds a %set from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %set consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       *//**
       *  @brief  Creates a %set with no elements.
       *  @param  __comp  Comparator to use.
       *  @param  __a  An allocator object.
       */// but this allows modification of keys.// DR 103. set::iterator is required to be modifiable,// Red-black tree representing set./**
   *  @brief A standard container made up of unique keys, which can be
   *  retrieved in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using unique keys).
   *
   *  Sets support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for set and
   *  multiset; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  *//** @file bits/stl_set.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{set}
 */// Set implementation -*- C++ -*-__setprevector<16U, unsigned char, unsigned int, signed int> &&lambda [] type at line 139504, col. 13lambda [] type at line 139504, col. 13 &const lambda [] type at line 139504, col. 13const lambda [] type at line 139504, col. 13 &const lambda [] type at line 139504, col. 13 *lambda [] type at line 139504, col. 13 *lambda [] type at line 139502, col. 13lambda [] type at line 139502, col. 13 &const lambda [] type at line 139502, col. 13const lambda [] type at line 139502, col. 13 &const lambda [] type at line 139502, col. 13 *lambda [] type at line 139502, col. 13 *lambda [] type at line 149423, col. 52lambda [] type at line 149423, col. 52 &&lambda [] type at line 149423, col. 52 &const lambda [] type at line 149423, col. 52const lambda [] type at line 149423, col. 52 &const lambda [] type at line 149423, col. 52 *lambda [] type at line 149423, col. 52 *<thread><condition_variable>MutexTypeMutexType &MutexType *MaybeCheckNotHeldMutex *AnnotatedMixin<mutex> *Mutex &AnnotatedMixin<mutex> &AssertLockNotHeldInlineGlobalMutex *RecursiveMutex *AnnotatedMixin<recursive_mutex> *LockStackEmptyDeleteLockAssertLockNotHeldInternalAssertLockHeldInternalCheckLastCriticalLeaveCriticalEnterCriticalCSemaphoreGrant &const CSemaphoreGrantconst CSemaphoreGrant &CSemaphoreGrantconst CSemaphoreGrant *CSemaphoreGrant *~CSemaphoreGrantCSemaphore &CSemaphore *fHaveGrant(false)MoveToTryAcquireReleaseAcquire~UniqueLockUniqueLock<MutexType> *owns_lockconst defer_lock_tTryEntermutexEnterreverse_lock &const reverse_lockconst reverse_lock &reverse_lock~reverse_lockUniqueLock<MutexType> &GlobalMutex &const GlobalMutexconst GlobalMutex &~GlobalMutexGlobalMutex~AnnotatedMixinAnnotatedMixin<PARENT> *lambda [] type at line 150764, col. 30lambda [] type at line 150764, col. 30 &&lambda [] type at line 150764, col. 30 &const lambda [] type at line 150764, col. 30const lambda [] type at line 150764, col. 30 &const lambda [] type at line 150764, col. 30 *lambda [] type at line 150764, col. 30 *CSemaphore *constconst CSemaphoreconst CSemaphore &~CSemaphoreCSemaphorepostmutex &try_waitwaitunique_lock<mutex> &UniqueLock<MutexType>unique_lockBaseAnnotatedMixin<PARENT>PARENTfHaveGrantsemlinelocknametemplockconditionWITH_LOCK(cs,code)(MaybeCheckNotHeld(cs), [&]() -> decltype(auto) { LOCK(cs); code; }())LEAVE_CRITICAL_SECTION(cs){ std::string lockname; CheckLastCritical((void*)(&cs), lockname, #cs, __FILE__, __LINE__); (cs).unlock(); LeaveCritical(); }ENTER_CRITICAL_SECTION(cs){ EnterCritical(#cs, __FILE__, __LINE__, &cs); (cs).lock(); }WAIT_LOCK(cs,name)UniqueLock name(MaybeCheckNotHeld(cs), #cs, __FILE__, __LINE__)TRY_LOCK(cs,name)UniqueLock name(MaybeCheckNotHeld(cs), #cs, __FILE__, __LINE__, true)LOCK2(cs1,cs2)UniqueLock criticalblock1(MaybeCheckNotHeld(cs1), #cs1, __FILE__, __LINE__); UniqueLock criticalblock2(MaybeCheckNotHeld(cs2), #cs2, __FILE__, __LINE__)LOCK(cs)UniqueLock UNIQUE_NAME(criticalblock)(MaybeCheckNotHeld(cs), #cs, __FILE__, __LINE__)REVERSE_LOCK(g)typename std::decay<decltype(g)>::type::reverse_lock UNIQUE_NAME(revlock)(g, #g, __FILE__, __LINE__)AssertLockNotHeld(cs)AssertLockNotHeldInline(#cs, __FILE__, __LINE__, &cs)AssertLockHeld(cs)AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)BITCOIN_SYNC_HDEBUG_LOCKORDER__clang__cs!cspmutexInmutexIn// BITCOIN_SYNC_H/** RAII-style semaphore lock *///! gcc and the -Wreturn-stack-address flag in clang, both enabled by default.//! The above is detectable at compile-time with the -Wreturn-local-addr flag in//! is &int, a reference to a local variable//!   WITH_LOCK(cs, return {int j = 1; return (j);});//! is int, the deduced type of://!   WITH_LOCK(cs, return {int i = 1; return i;});//! deduced type of://! Since the return type deduction follows that of decltype(auto), while the//! Note://!   int val = WITH_LOCK(cs, return shared_val);//!   WITH_LOCK(cs, shared_val = shared_val + 1);//! Examples://! Run code while locking a mutex.// locked in the surrounding scope.// When locking a GlobalMutex or RecursiveMutex, just check it is not// is not already held// When locking a Mutex, require negative capability to ensure the lock/**
     * An RAII-style reverse lock. Unlocks on construction and locks on destruction.
     */// needed for reverse_lock/** Wrapper around std::unique_lock style lock for MutexType. *//** Different type to mark Mutex at global scope
 *
 * Thread safety analysis can't handle negative assertions about mutexes
 * with global scope well, so mark them with a separate type, and
 * eventually move all the mutexes into classes so they are not globally
 * visible.
 *
 * See: https://github.com/bitcoin/bitcoin/pull/20272#issuecomment-720755781
 *//** Wrapped mutex: supports waiting but not recursive locking *//**
 * Wrapped mutex: supports recursive locking, but no waiting
 * TODO: We should move away from using the recursive lock by default.
 */// __clang__//! with the ! operator, to indicate that a mutex should not be held.//! A negative requirement uses the EXCLUSIVE_LOCKS_REQUIRED attribute, in conjunction//! For negative capabilities in the Clang Thread Safety Analysis./**
 * Template mixin that adds -Wthread-safety locking annotations and lock order
 * checking to a subset of the mutex API.
 *//**
 * Call abort() if a potential lock order deadlock bug is detected, instead of
 * just logging information and throwing a logic_error. Defaults to true, and
 * set to false in DEBUG_LOCKORDER unit tests.
 *//////////////////////////////////                           //// THE ACTUAL IMPLEMENTATION ///*
RecursiveMutex mutex;
    std::recursive_mutex mutex;

LOCK(mutex);
    std::unique_lock<std::recursive_mutex> criticalblock(mutex);

LOCK2(mutex1, mutex2);
    std::unique_lock<std::recursive_mutex> criticalblock1(mutex1);
    std::unique_lock<std::recursive_mutex> criticalblock2(mutex2);

TRY_LOCK(mutex, name);
    std::unique_lock<std::recursive_mutex> name(mutex, std::try_to_lock_t);

ENTER_CRITICAL_SECTION(mutex); // no RAII
    mutex.lock();

LEAVE_CRITICAL_SECTION(mutex); // no RAII
    mutex.unlock();
 *///////////////////////////////////////////////////                                            //// THE SIMPLE DEFINITION, EXCLUDING DEBUG CODE //guardnamesemafTrygrantpszNamepszFilenLine_lock_guardname_file_line/home/tanteikg/QCVE/sources/bitcoin/src/timedata.hTestOnlyResetTimeDataAddTimeDataGetAdjustedTimeGetTimeOffsetsortedmedianCMedianFilterCMedianFilter<T>vSortedvValuesDEFAULT_MAX_TIME_ADJUSTMENT420070 * 60BITCOIN_TIMEDATA_HvSortedSize > 0// BITCOIN_TIMEDATA_H/**
 * Reset the internal state of GetTimeOffset(), GetAdjustedTime() and AddTimeData().
 *//** Functions to keep track of adjusted P2P time */// Even number of elements// Odd number of elements/**
 * Median filter over a stream of values.
 * Returns the median of the last N numbers
 */// Copyright (c) 2014-2022 The Bitcoin Core developersinitial_value/usr/include/c++/9/bits/unordered_set.hconst unordered_multiset<_Value, _Hash, _Pred, _Alloc>const unordered_multiset<_Value, _Hash, _Pred, _Alloc> &unordered_multiset<_Value, _Hash, _Pred, _Alloc> &const unordered_set<_Value, _Hash, _Pred, _Alloc>const unordered_set<_Value, _Hash, _Pred, _Alloc> &unordered_set<_Value, _Hash, _Pred, _Alloc> &unordered_multisetconst unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1>const unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1> &unordered_multiset<_Value1, _Hash1, _Pred1, _Alloc1> &_Value1unordered_setconst unordered_set<_Value1, _Hash1, _Pred1, _Alloc1>const unordered_set<_Value1, _Hash1, _Pred1, _Alloc1> &unordered_set<_Value1, _Hash1, _Pred1, _Alloc1> &unordered_multiset<_Val, _Hash2, _Eq2, _Alloc> &unordered_set<_Val, _Hash2, _Eq2, _Alloc> &const unordered_set<_Value, _Hash, _Pred, _Alloc> *unordered_set<_Value, _Hash, _Pred, _Alloc> *unordered_multiset<_Value, _H2, _P2, _Alloc> &&unordered_multiset<_Value, _H2, _P2, _Alloc> &unordered_set<_Value, _H2, _P2, _Alloc> &&unordered_set<_Value, _H2, _P2, _Alloc> &unordered_set<_Value, _Hash, _Pred, _Alloc> &&unordered_multiset<_Value, _Hash, _Pred, _Alloc> &&__uset__umset_Hash_merge_helper<unordered_multiset<_Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2>_Hash_merge_helper<unordered_set<_Val, _Hash1, _Eq1, _Alloc>, _Hash2, _Eq2>unordered_set<_Value, _Hash, _Pred, _Alloc>unordered_multiset<_Value, _Hash, _Pred, _Alloc>_UNORDERED_SET_H/* _UNORDERED_SET_H */// Allow std::unordered_multiset access to internals of compatible sets.// Allow std::unordered_set access to internals of compatible sets./**
       *  @brief  Prepare the %unordered_multiset for a specified number of
       *          elements.
       *  @param  __n Number of elements required.
       *
       *  Same as rehash(ceil(n / max_load_factor())).
       *//**
       *  @brief  May rehash the %unordered_multiset.
       *  @param  __n The new number of buckets.
       *
       *  Rehash will occur only if the new number of buckets respect the
       *  %unordered_multiset maximum load factor.
       *//**
       *  @brief  Change the %unordered_multiset maximum load factor.
       *  @param  __z The new maximum load factor.
       *//// Returns a positive number that the %unordered_multiset tries to keep the/// Returns the maximum number of buckets of the %unordered_multiset./// Returns the number of buckets of the %unordered_multiset./**
       *  @brief  Finds the number of elements.
       *  @param  __x  Element to located.
       *  @return  Number of elements with specified key.
       *//**
       *  @brief Tries to locate an element in an %unordered_multiset.
       *  @param  __x  Element to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       *////  Returns the key comparison object with which the %unordered_multiset///  Returns the hash functor object with which the %unordered_multiset/**
       *  @brief  Swaps data with another %unordered_multiset.
       *  @param  __x  An %unordered_multiset of the same element and allocator
       *  types.
       *
       *  This exchanges the elements between two sets in constant time.
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(s1,s2) will feed to this function.
       *//**
       *  Erases all elements in an %unordered_multiset.
       *
       *  Note that this function only erases the elements, and that if the
       *  elements themselves are pointers, the pointed-to memory is not touched
       *  in any way. Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases a [__first,__last) range of elements from an
       *  %unordered_multiset.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                  erased.
       *  @param __last  Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from an
       *  %unordered_multiset.
       *
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  an %unordered_multiset.
       *
       *  Note that this function only erases the element, and that if the
       *  element is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from an %unordered_multiset.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a __position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from an %unordered_multiset.
       *
       *  Note that this function only erases the element, and that if the
       *  element is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Inserts a list of elements into the %unordered_multiset.
       *  @param  __l  A std::initializer_list<value_type> of elements to be
       *              inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief A template function that inserts a range of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Inserts an element into the %unordered_multiset.
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                 element should be inserted.
       *  @param  __x  Element to be inserted.
       *  @return An iterator that points to the inserted element.
       *
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires amortized constant.
       *//**
       *  @brief Inserts an element into the %unordered_multiset.
       *  @param  __x  Element to be inserted.
       *  @return  An iterator that points to the inserted element.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Inserts an element into the %unordered_multiset.
       *  @param  __pos  An iterator that serves as a hint as to where the
       *                element should be inserted.
       *  @param  __args  Arguments used to generate the element to be
       *                 inserted.
       *  @return An iterator that points to the inserted element.
       *
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Builds and insert an element into the %unordered_multiset.
       *  @param __args  Arguments used to generate an element.
       *  @return  An iterator that points to the inserted element.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %unordered_multiset.
       *//**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %unordered_multiset.
       *////  Returns the maximum size of the %unordered_multiset.///  Returns the size of the %unordered_multiset.///  Returns true if the %unordered_multiset is empty.///  Returns the allocator object used by the %unordered_multiset./**
       *  @brief  %Unordered_multiset list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills an %unordered_multiset with copies of the elements
       *  in the initializer list @a __l.
       *
       *  Note that the assignment completely changes the %unordered_multiset
       *  and that the resulting %unordered_multiset's size is the same as the
       *  number of elements assigned.
       *//*
       *  @brief  Move constructor with allocator argument.
       *  @param  __umset  Input %unordered_multiset to move.
       *  @param  __a  An allocator object.
       *//*
       *  @brief Copy constructor with allocator argument.
       * @param  __uset  Input %unordered_multiset to copy.
       * @param  __a  An allocator object.
       *//**
       *  @brief Creates an %unordered_multiset with no elements.
       *  @param __a An allocator object.
       *//**
       *  @brief  Builds an %unordered_multiset from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param __n  Minimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param  __a  An allocator object.
       *
       *  Create an %unordered_multiset consisting of copies of the elements in
       *  the list. This is linear in N (where N is @a __l.size()).
       *//**
       *  @brief  Builds an %unordered_multiset from a range.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @param __n       Minimal initial number of buckets.
       *  @param __hf      A hash functor.
       *  @param __eql     A key equality functor.
       *  @param __a       An allocator object.
       *
       *  Create an %unordered_multiset consisting of copies of the elements
       *  from [__first,__last).  This is linear in N (where N is
       *  distance(__first,__last)).
       */// construct/destroy/copy/**
   *  @brief A standard container composed of equivalent keys
   *  (possibly containing multiple of each key value) in which the
   *  elements' keys are the elements themselves.
   *
   *  @ingroup unordered_associative_containers
   *
   *  @tparam  _Value  Type of key objects.
   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.
   *  @tparam  _Pred  Predicate function object type, defaults
   *                  to equal_to<_Value>.
   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
   *  <a href="tables.html#xx">unordered associative container</a>
   *
   *  Base is _Hashtable, dispatched at compile time via template
   *  alias __umset_hashtable.
   *//**
       *  @brief  Prepare the %unordered_set for a specified number of
       *          elements.
       *  @param  __n Number of elements required.
       *
       *  Same as rehash(ceil(n / max_load_factor())).
       *//**
       *  @brief  May rehash the %unordered_set.
       *  @param  __n The new number of buckets.
       *
       *  Rehash will occur only if the new number of buckets respect the
       *  %unordered_set maximum load factor.
       *//**
       *  @brief  Change the %unordered_set maximum load factor.
       *  @param  __z The new maximum load factor.
       *//// Returns a positive number that the %unordered_set tries to keep the/// Returns the maximum number of buckets of the %unordered_set./// Returns the number of buckets of the %unordered_set./**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function probably only makes sense for multisets.
       *//**
       *  @brief  Finds the number of elements.
       *  @param  __x  Element to located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for unordered_multisets; for
       *  unordered_set the result will either be 0 (not present) or 1
       *  (present).
       *//**
       *  @brief Tries to locate an element in an %unordered_set.
       *  @param  __x  Element to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after element.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       *////  Returns the key comparison object with which the %unordered_set was///  Returns the hash functor object with which the %unordered_set was/**
       *  @brief  Swaps data with another %unordered_set.
       *  @param  __x  An %unordered_set of the same element and allocator
       *  types.
       *
       *  This exchanges the elements between two sets in constant time.
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(s1,s2) will feed to this function.
       *//**
       *  Erases all elements in an %unordered_set. Note that this function only
       *  erases the elements, and that if the elements themselves are pointers,
       *  the pointed-to memory is not touched in any way. Managing the pointer
       *  is the user's responsibility.
       *//**
       *  @brief Erases a [__first,__last) range of elements from an
       *  %unordered_set.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                  erased.
       *  @param __last  Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from an %unordered_set.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  an %unordered_set. For an %unordered_set the result of this function
       *  can only be 0 (not present) or 1 (present).
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from an %unordered_set.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a __position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given iterator,
       *  from an %unordered_set.  Note that this function only erases the
       *  element, and that if the element is itself a pointer, the pointed-to
       *  memory is not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief Attempts to insert a list of elements into the %unordered_set.
       *  @param  __l  A std::initializer_list<value_type> of elements
       *               to be inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Attempts to insert an element into the %unordered_set.
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                 element should be inserted.
       *  @param  __x  Element to be inserted.
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the element passed in).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument insert()
       *  does.  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires amortized constant.
       *//**
       *  @brief Attempts to insert an element into the %unordered_set.
       *  @param  __x  Element to be inserted.
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted element, and the second is a bool
       *           that is true if the element was actually inserted.
       *
       *  This function attempts to insert an element into the %unordered_set.
       *  An %unordered_set relies on unique keys and thus an element is only
       *  inserted if it is not already present in the %unordered_set.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to insert an element into the %unordered_set.
       *  @param  __pos  An iterator that serves as a hint as to where the
       *                element should be inserted.
       *  @param  __args  Arguments used to generate the element to be
       *                 inserted.
       *  @return An iterator that points to the element with key equivalent to
       *          the one generated from @a __args (may or may not be the
       *          element itself).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does.  Note that the first parameter is only a hint and can
       *  potentially improve the performance of the insertion process.  A bad
       *  hint would cause no gains in efficiency.
       *
       *  For more on @a hinting, see:
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *
       *  Insertion requires amortized constant time.
       *//**
       *  @brief Attempts to build and insert an element into the
       *  %unordered_set.
       *  @param __args  Arguments used to generate an element.
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted element, and the second is a bool
       *           that is true if the element was actually inserted.
       *
       *  This function attempts to build and insert an element into the
       *  %unordered_set. An %unordered_set relies on unique keys and thus an
       *  element is only inserted if it is not already present in the
       *  %unordered_set.
       *
       *  Insertion requires amortized constant time.
       *//**
       *  Returns a read-only (constant) iterator that points one past the last
       *  element in the %unordered_set.
       *//**
       *  Returns a read-only (constant) iterator that points to the first
       *  element in the %unordered_set.
       *////  Returns the maximum size of the %unordered_set.///  Returns the size of the %unordered_set.///  Returns true if the %unordered_set is empty.///  Returns the allocator object used by the %unordered_set./**
       *  @brief  %Unordered_set list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills an %unordered_set with copies of the elements in
       *  the initializer list @a __l.
       *
       *  Note that the assignment completely changes the %unordered_set and
       *  that the resulting %unordered_set's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  Builds an %unordered_set from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param __n  Minimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param  __a  An allocator object.
       *
       *  Create an %unordered_set consisting of copies of the elements in the
       *  list. This is linear in N (where N is @a __l.size()).
       *//*
       *  @brief  Move constructor with allocator argument.
       *  @param  __uset Input %unordered_set to move.
       *  @param  __a    An allocator object.
       *//*
       *  @brief Copy constructor with allocator argument.
       * @param  __uset  Input %unordered_set to copy.
       * @param  __a  An allocator object.
       *//**
       *  @brief Creates an %unordered_set with no elements.
       *  @param __a An allocator object.
       *//**
       *  @brief  Builds an %unordered_set from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param __n  Minimal initial number of buckets.
       *  @param __hf  A hash functor.
       *  @param __eql  A key equality functor.
       *  @param __a  An allocator object.
       *
       *  Create an %unordered_set consisting of copies of the elements from
       *  [__first,__last).  This is linear in N (where N is
       *  distance(__first,__last)).
       *//**
   *  @brief A standard container composed of unique keys (containing
   *  at most one of each key value) in which the elements' keys are
   *  the elements themselves.
   *
   *  @ingroup unordered_associative_containers
   *
   *  @tparam  _Value  Type of key objects.
   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.

   *  @tparam _Pred Predicate function object type, defaults to
   *                equal_to<_Value>.
   *
   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
   *  <a href="tables.html#xx">unordered associative container</a>
   *
   *  Base is _Hashtable, dispatched at compile time via template
   *  alias __uset_hashtable.
   *//// Base types for unordered_multiset./// Base types for unordered_set./** @file bits/unordered_set.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{unordered_set}
 */// unordered_set implementation -*- C++ -*-/home/tanteikg/QCVE/sources/bitcoin/src/addrman_impl.h<unordered_set><timedata.h>AddrManImpl &const AddrManImplconst AddrManImpl &AddrInfo &AddrInfo &&AddrInfo *const AddrInfoconst AddrInfo &const AddrInfo *~AddrInfoAddrInfoGetNewBucketobj.source, Using<ChronoFormatter<int64_t>>(obj.m_last_success), obj.nAttemptsm_last_successnAttemptsNewTriedCount &NewTriedCount &&const NewTriedCountconst NewTriedCount &AddrManDeterministicFormatV0_HISTORICALV1_DETERMINISTICV2_ASMAPV3_BIP155V4_MULTIPORTNewTriedCountconst AddrManImpl *m_network_countsm_netgroupmanm_consistency_check_ratiom_tried_collisionsm_last_goodint[64]ADDRMAN_BUCKET_SIZEint[1024][64]ADDRMAN_NEW_BUCKET_COUNTvvNewnNewint[256][64]ADDRMAN_TRIED_BUCKET_COUNTvvTriednTriedvRandommapAddrmapInfonIdCountnKeyinsecure_randnRandomPosfInTriednRefCountm_last_count_attemptm_last_tryn_triedn_newADDRMAN_BUCKET_SIZE_LOG21 << ADDRMAN_BUCKET_SIZE_LOG2ADDRMAN_NEW_BUCKET_COUNT_LOG21 << ADDRMAN_NEW_BUCKET_COUNT_LOG2ADDRMAN_TRIED_BUCKET_COUNT_LOG21 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2INCOMPATIBILITY_BASEFILE_FORMATFormat::V4_MULTIPORTBITCOIN_ADDRMAN_IMPL_HCheckAddrmanCheckSize_FindAddressEntry_SelectTriedCollision_ResolveCollisions_SetServices_Connected_GetAddr_GetEntrySelect_Attempt_Add_Good_AddSingleMakeTriedClearNewDeleteSwapRandomCreateFind~AddrManImplGetChanceIsTerribleGetBucketPositionGetTriedBucket// BITCOIN_ADDRMAN_IMPL_H//! @returns an error code or zero.//! Perform consistency check, regardless of m_consistency_check_ratio.//! Will std::abort if an inconsistency is detected.//! Consistency check, taking into account m_consistency_check_ratio./** Helper to generalize looking up an addrman entry from either table.
     *
     *  @return  int The nid of the entry or -1 if the addrman position is empty.
     * *//** Attempt to add a single address to addrman's new table.
     *  @see AddrMan::Add() for parameters. *///! Move an entry from the "new" table(s) to the "tried" table//! Clear a position in a "new" table. This is the only place where entries are actually deleted.//! Delete an entry. It must not be in tried, and have refcount 0.//! Swap two elements in vRandom.//! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.//! Find an entry./** Number of entries in addrman per network and new/tried table. *//** Reference to the netgroup manager. netgroupman must be constructed before addrman and destructed after. *//** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). *///! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.//! last time Good was called (memory only). Initially set to 1 so that "never" is strictly worse.//! list of "new" buckets//! number of (unique) "new" entries//! list of "tried" buckets// number of "tried" entries//! changes to it (even in const methods) are also unobservable.//! This is mutable because it is unobservable outside the class, so any//! randomly-ordered vector of all nIds//! find an nId based on its network address and port.//! table with information about all nIds//! last used nId//! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.//! field which was 32 historically.//! understand the new file format). This is 32 because we overtook the "key size"//! change is made (such that old software versions would not be able to parse and//! The initial value of a field that is incremented every time an incompatible format//! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.//! still this software may be able to unserialize the file - if the second byte//! The format (first byte in the serialized stream) can be higher than this and//! in this format.//! The maximum format this software knows it can unserialize. Also, we always serialize//!< adds support for multiple ports per IP//!< same as V2_ASMAP plus addresses are in BIP155 format//!< for files including asmap version//!< for pre-asmap files//!< historic format, before commit e6b343d88//! Serialization versions.//! secret key to randomize bucket select with//! Source of random numbers for randomization in inner loops//! A mutex to protect the inner data structures.//! Calculate the relative chance this entry should be given when selecting nodes to connect to//! Determine whether the statistics about this entry are bad enough so that it can just be deleted//! Calculate in which position of a bucket to store this entry.//! Calculate in which "new" bucket this entry belongs, using its default source//! Calculate in which "new" bucket this entry belongs, given a certain source//! Calculate in which "tried" bucket this entry belongs//! position in vRandom//! in tried set? (memory only)//! reference count in new sets (memory only)//! connection attempts since last successful attempt//! last successful connection by us//! where knowledge about this address first came from//! last counted attempt (memory only)//! last try whatsoever by us (memory only)/**
 * Extended statistics about a CAddress
 *//** Maximum allowed number of entries in buckets for new and tried addresses *//** Total number of buckets for new addresses *//** Total number of buckets for tried addresses */// Copyright (c) 2021-2022 The Bitcoin Core developersaddrInaddrSourceuse_triedtest_before_evictinfonIdnUBucketnUBucketPosnRandomPos1nRandomPos2pnIdfNew__GLIBC_USE_IEC_60559_TYPES_EXT__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X__GLIBC_USE_IEC_60559_FUNCS_EXT__GLIBC_USE_IEC_60559_BFP_EXT_C2X__GLIBC_USE_IEC_60559_BFP_EXT__GLIBC_USE_LIB_EXT2__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATIONdefined __USE_GNU || defined __STDC_WANT_IEC_60559_BFP_EXT____GLIBC_USE (IEC_60559_BFP_EXT) || __GLIBC_USE (ISOC2X)defined __USE_GNU || defined __STDC_WANT_IEC_60559_FUNCS_EXT____GLIBC_USE (IEC_60559_FUNCS_EXT) || __GLIBC_USE (ISOC2X)defined __USE_GNU || defined __STDC_WANT_IEC_60559_TYPES_EXT__IEC_60559_FUNCS_EXTIEC_60559_BFP_EXT/* ISO/IEC TS 18661-3:2015 defines the
   __STDC_WANT_IEC_60559_TYPES_EXT__ macro.  *//* ISO/IEC TS 18661-4:2015 defines the
   __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
   functions, the symbols from this TS are enabled unconditionally in
   C2X.  *//* ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
   macro.  Most but not all symbols enabled by that macro in TS
   18661-1 are enabled unconditionally in C2X; the symbols in Annex F
   still require that macro in C2X.  *//* ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
   macro.  *//* This header is internal to glibc and should not be included outside
   of glibc headers.  Headers including it must define
   __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
   cannot have multiple include guards because ISO C feature test
   macros depend on the definition of the macro when an affected
   header is included, not when the first system header is
   included.  *//* Handle feature test macros at the start of a header.
   Copyright (C) 2016-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h__DECL_SIMD_powf128x__DECL_SIMD_powf64x__DECL_SIMD_powf32x__DECL_SIMD_powf128__DECL_SIMD_powf64__DECL_SIMD_powf32__DECL_SIMD_powf16__DECL_SIMD_powl__DECL_SIMD_powf__DECL_SIMD_pow__DECL_SIMD_expf128x__DECL_SIMD_expf64x__DECL_SIMD_expf32x__DECL_SIMD_expf128__DECL_SIMD_expf64__DECL_SIMD_expf32__DECL_SIMD_expf16__DECL_SIMD_expl__DECL_SIMD_expf__DECL_SIMD_exp__DECL_SIMD_logf128x__DECL_SIMD_logf64x__DECL_SIMD_logf32x__DECL_SIMD_logf128__DECL_SIMD_logf64__DECL_SIMD_logf32__DECL_SIMD_logf16__DECL_SIMD_logl__DECL_SIMD_logf__DECL_SIMD_log__DECL_SIMD_sincosf128x__DECL_SIMD_sincosf64x__DECL_SIMD_sincosf32x__DECL_SIMD_sincosf128__DECL_SIMD_sincosf64__DECL_SIMD_sincosf32__DECL_SIMD_sincosf16__DECL_SIMD_sincosl__DECL_SIMD_sincosf__DECL_SIMD_sincos__DECL_SIMD_sinf128x__DECL_SIMD_sinf64x__DECL_SIMD_sinf32x__DECL_SIMD_sinf128__DECL_SIMD_sinf64__DECL_SIMD_sinf32__DECL_SIMD_sinf16__DECL_SIMD_sinl__DECL_SIMD_sinf__DECL_SIMD_sin__DECL_SIMD_cosf128x__DECL_SIMD_cosf64x__DECL_SIMD_cosf32x__DECL_SIMD_cosf128__DECL_SIMD_cosf64__DECL_SIMD_cosf32__DECL_SIMD_cosf16__DECL_SIMD_cosl__DECL_SIMD_cosf__DECL_SIMD_cos_BITS_LIBM_SIMD_DECL_STUBS_H_MATH_H/* Needed definitions could be generated with:
   for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |\
		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
     echo "#define __DECL_SIMD_${func}";
     echo "#define __DECL_SIMD_${func}f";
     echo "#define __DECL_SIMD_${func}l";
   done
 *//* Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
   Copyright (C) 2014-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/math-vector.h<bits/libm-simd-decl-stubs.h>defined __x86_64__ && defined __FAST_MATH__defined _OPENMP && _OPENMP >= 201307__GNUC_PREREQ (6,0)__DECL_SIMD_x86_64/* W/o OpenMP use GCC 6.* __attribute__ ((__simd__)).  *//* OpenMP case.  *//* Get default empty definitions for simd declarations.  *//* Platform-specific SIMD declarations of math functions.
   Copyright (C) 2014-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/flt-eval-method.h__GLIBC_FLT_EVAL_METHOD__FLT_EVAL_METHOD____FLT_EVAL_METHOD__ == -1defined __x86_64__/* Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
   Copyright (C) 2016-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/fp-logb.h__FP_LOGBNAN_IS_MIN__FP_LOGB0_IS_MIN/* Define __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.  x86 version.
   Copyright (C) 2016-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/fp-fast.h__FP_FAST_FMA__FP_FAST_FMAF__FP_FAST_FMAL/* The GCC 4.6 compiler will define __FP_FAST_FMA{,F,L} if the fma{,f,l}
   builtins are supported.  *//* Define FP_FAST_* macros.
   Copyright (C) 2016-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h__issignaling__iseqsig__isnan__finite__isinf__signbit__fpclassify(_Mdouble_ __value)(double __value)(_Mdouble_ __x, _Mdouble_ __y)(double __x, double __y)/* Test for signaling NaN.  *//* Test equality.  *//* Return nonzero if VALUE is not a number.  *//* Return nonzero if VALUE is finite and not NaN.  Used by isfinite macro.  *//* Return 0 if VALUE is finite or NaN, +1 if it
   is +Infinity, -1 if it is -Infinity.  *//* Test for negative number.  *//* Classify given number.  *//* Prototype declarations for math classification macros helpers.
   Copyright (C) 2017-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/mathcalls.h__scalbscalbsetpayloadsigsetpayload__getpayloadgetpayloadtotalordermagtotalordercanonicalize__fminmagfminmag__fmaxmagfmaxmag__ufromfpxufromfpx__fromfpxfromfpx__ufromfpufromfp__fromfpfromfp__roundevenroundeven__fma__fmin__fmax__fdim__llround__lround__llrint__lrint__remquo__trunc__round__nearbyint__scalbln__llogbllogb__ilogb__scalbn__remainder__nextupnextup__nextdownnextdown__nexttoward__nextafter__rint__lgamma_rlgamma_r__gammagamma__tgamma__lgamma__erfc__erf__ynyn__y1y1__y0y0__jnjn__j1j1__j0j0__nan__copysign__significandsignificand__dremdremfinite__fmod__floor__fabs__ceil__cbrt__hypot__sqrt__pow__log2__exp2__logb__log1p__expm1__exp10exp10__modf__log10__log__ldexp__frexp__exp__atanh__asinh__acosh__sincossincos__tanh__sinh__cosh__tan__sin__cos__atan2__atan__asin__acostrunctgammascalbnscalblnrintremquoremaindernexttowardnextafternearbyintnanlroundlrintlogblog2log1pllroundllrintlgammailogbhypotfminfmaxfmafdimexpm1exp2erfcerfcopysigncbrtatanhasinhacoshtanhtansqrtsinhsinpowmodflog10logldexpfrexpfmodfabsexpcoshcosatan2atanasinacosdefined __USE_XOPEN_EXTENDED || defined __USE_ISOC99__GLIBC_USE (IEC_60559_FUNCS_EXT_C2X)defined __USE_XOPEN || defined __USE_ISOC99((!defined __cplusplus \!__MATH_DECLARING_FLOATNdefined __USE_MISC || (defined __USE_XOPEN && __MATH_DECLARING_DOUBLE)defined __USE_ISOC99 && !defined __LDBL_COMPAT && !__MATH_DECLARING_FLOATN__GLIBC_USE (IEC_60559_BFP_EXT_C2X) || __MATH_DECLARING_FLOATN__GLIBC_USE (IEC_60559_BFP_EXT) || __MATH_DECLARING_FLOATN(defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \(_Mdouble_ __x, _Mdouble_ __n)(double __x, double __n)_Mdouble_double__CONCAT(__,scalb)(_Mdouble_ *__x, _Mdouble_ __payload)(double *__x, double __payload)(const _Mdouble_ *__x)(const double *__x)__CONCAT(__,getpayload)(const _Mdouble_ *__x, const _Mdouble_ *__y)(const double *__x, const double *__y)(_Mdouble_ *__cx, const _Mdouble_ *__x)(double *__cx, const double *__x)(__const__)__CONCAT(__,fminmag)__CONCAT(__,fmaxmag)__uintmax_t(_Mdouble_ __x, int __round, unsigned int __width)(double __x, int __round, unsigned int __width)__CONCAT(__,ufromfpx)__intmax_t__CONCAT(__,fromfpx)__CONCAT(__,ufromfp)__CONCAT(__,fromfp)(_Mdouble_ __x)(double __x)__CONCAT(__,roundeven)(_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z)(double __x, double __y, double __z)__CONCAT(__,fma)__CONCAT(__,fmin)__CONCAT(__,fmax)__CONCAT(__,fdim)long long int__CONCAT(__,llround)__CONCAT(__,lround)__CONCAT(__,llrint)__CONCAT(__,lrint)(_Mdouble_ __x, _Mdouble_ __y, int *__quo)(double __x, double __y, int *__quo)__CONCAT(__,remquo)__CONCAT(__,trunc)__CONCAT(__,round)__CONCAT(__,nearbyint)(_Mdouble_ __x, long int __n)(double __x, long int __n)__CONCAT(__,scalbln)__CONCAT(__,llogb)__CONCAT(__,ilogb)(_Mdouble_ __x, int __n)(double __x, int __n)__CONCAT(__,scalbn)__CONCAT(__,remainder)__CONCAT(__,nextup)__CONCAT(__,nextdown)(_Mdouble_ __x, long double __y)(double __x, long double __y)__CONCAT(__,nexttoward)__CONCAT(__,nextafter)__CONCAT(__,rint)_r(_Mdouble_, int *__signgamp)(double, int *__signgamp)__CONCAT(__,lgamma)(_Mdouble_)(double)__CONCAT(__,gamma)__CONCAT(__,tgamma)__CONCAT(__,erfc)__CONCAT(__,erf)(int, _Mdouble_)(int, double)__CONCAT(__,yn)__CONCAT(__,y1)__CONCAT(__,y0)__CONCAT(__,jn)__CONCAT(__,j1)__CONCAT(__,j0)(const char *__tagb)__CONCAT(__,nan)__CONCAT(__,copysign)__CONCAT(__,significand)__CONCAT(__,drem)__CONCAT(__,fmod)__CONCAT(__,floor)__CONCAT(__,fabs)__CONCAT(__,ceil)__CONCAT(__,cbrt)__CONCAT(__,hypot)__CONCAT(__,sqrt)__CONCAT(__,pow)__CONCAT(__,log2)__CONCAT(__,exp2)__CONCAT(__,logb)__CONCAT(__,log1p)__CONCAT(__,expm1)__CONCAT(__,exp10)(_Mdouble_ __x, _Mdouble_ *__iptr)(double __x, double *__iptr)__CONCAT(__,modf)__CONCAT(__,log10)__CONCAT(__,log)(_Mdouble_ __x, int __exponent)(double __x, int __exponent)__CONCAT(__,ldexp)(_Mdouble_ __x, int *__exponent)(double __x, int *__exponent)__CONCAT(__,frexp)__CONCAT(__,exp)__CONCAT(__,atanh)__CONCAT(__,asinh)__CONCAT(__,acosh)void(_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx)(double __x, double *__sinx, double *__cosx)__CONCAT(__,sincos)__CONCAT(__,tanh)__CONCAT(__,sinh)__CONCAT(__,cosh)__CONCAT(__,tan)__CONCAT(__,sin)__CONCAT(__,cos)(_Mdouble_ __y, _Mdouble_ __x)(double __y, double __x)__CONCAT(__,atan2)__CONCAT(__,atan)__CONCAT(__,asin)__CONCAT(__,acos)____MATH_PRECNAME (exp, )__DECL_SIMD___MATH_PRECNAME (sincos, )IEC_60559_BFP_EXT_C2X__MATH_PRECNAME (pow, )IEC_60559_FUNCS_EXT_C2X__MATH_PRECNAME (log, )__MATH_PRECNAME (sin, )__MATH_PRECNAME (cos, )/* Return X times (2 to the Nth power).  *//* Set signaling NaN payload.  *//* Set quiet NaN payload.  *//* Get NaN payload.  *//* Total order operation on absolute values.  *//* Total order operation.  *//* Canonicalize floating-point representation.  *//* Return value with minimum magnitude.  *//* Return value with maximum magnitude.  *//* Round X to nearest unsigned integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  *//* Round X to nearest signed integer value, raising inexact for
   non-integers, with control of rounding direction and width of
   result.  *//* Round X to nearest unsigned integer value, not raising inexact,
   with control of rounding direction and width of result.  *//* Round X to nearest signed integer value, not raising inexact, with
   control of rounding direction and width of result.  *//* Round X to nearest integer value, rounding halfway cases to even.  *//* Use ISO C99.  *//* Multiply-add function computed as a ternary operation.  *//* Return minimum numeric value from X and Y.  *//* Return maximum numeric value from X and Y.  *//* Return positive difference between X and Y.  *//* Round X to nearest integral value, rounding halfway cases away from
   zero.  *//* Round X to nearest integral value according to current rounding
   direction.  *//* Conversion functions.  *//* Compute remainder of X and Y and put in *QUO a value with sign of x/y
   and magnitude congruent `mod 2^n' to the magnitude of the integral
   quotient x/y, with n >= 3.  *//* Round X to the integral value in floating-point format nearest but
   not larger in magnitude.  *//* Round X to integral value in floating-point format using current
   rounding direction, but do not raise inexact exception.  *//* Like ilogb, but returning long int.  *//* Return the binary exponent of X, which must be nonzero.  *//* Return the remainder of integer divison X / Y with infinite precision.  *//* Return X + epsilon.  *//* Return X - epsilon.  *//* Return X + epsilon if X < Y, X - epsilon if X > Y.  *//* Return the integer nearest X in the direction of the
   prevailing rounding mode.  *//* Reentrant version of lgamma.  This function uses the global variable
   `signgam'.  The reentrant version instead takes a pointer and stores
   the value through it.  *//* Obsolete alias for `lgamma'.  *//* True gamma function.  *//* Error and gamma functions.  *//* Bessel functions.  *//* isnanf or isnanl don't.  *//* isnan conflicts with C++11.  *//* Return representation of qNaN for double type.  *//* Return X with its signed changed to Y's.  *//* Return the fractional part of X after dividing out `ilogb (X)'.  *//* Return the remainder of X/Y.  *//* Return nonzero if VALUE is finite and not NaN.  *//* isinff or isinfl don't.  *//* isinf conflicts with C++11.  *//* Floating-point modulo remainder of X/Y.  *//* Largest integer not greater than X.  *//* Absolute value of X.  *//* Smallest integral value not less than X.  *//* Nearest integer, absolute value, and remainder functions.  *//* Return the cube root of X.  *//* Return `sqrt(X*X + Y*Y)'.  *//* Return the square root of X.  *//* Return X to the Y power.  *//* Power functions.  *//* Compute base-2 logarithm of X.  *//* Compute base-2 exponential of X.  *//* Return the base 2 signed integral exponent of X.  *//* Return log(1 + X).  *//* Return exp(X) - 1.  *//* Compute exponent to base ten.  *//* Break VALUE into integral and fractional parts.  *//* Base-ten logarithm of X.  *//* Natural logarithm of X.  *//* X times (two to the EXP power).  *//* Break VALUE into a normalized fraction and an integral power of 2.  *//* Exponential function of X.  *//* Exponential and logarithmic functions.  *//* Hyperbolic arc tangent of X.  *//* Hyperbolic arc sine of X.  *//* Hyperbolic arc cosine of X.  *//* Cosine and sine of X.  *//* Hyperbolic tangent of X.  *//* Hyperbolic sine of X.  *//* Hyperbolic cosine of X.  *//* Hyperbolic functions.  *//* Tangent of X.  *//* Sine of X.  *//* Cosine of X.  *//* Arc tangent of Y/X.  *//* Arc tangent of X.  *//* Arc sine of X.  *//* Arc cosine of X.  *//* Trigonometric functions.  *//* NOTE: Because of the special way this file is used by <math.h>, this
   file must NOT be protected from multiple inclusion as header files
   usually are.

   This file provides prototype declarations for the math functions.
   Most functions are declared using the macro:

   __MATHCALL (NAME,[_r], (ARGS...));

   This means there is a function `NAME' returning `double' and a function
   `NAMEf' returning `float'.  Each place `_Mdouble_' appears in the
   prototype, that is actually `double' in the prototype for `NAME' and
   `float' in the prototype for `NAMEf'.  Reentrant variant functions are
   called `NAME_r' and `NAMEf_r'.

   Functions returning other types like `int' are declared using the macro:

   __MATHDECL (TYPE, NAME,[_r], (ARGS...));

   This is just like __MATHCALL but for a function returning `TYPE'
   instead of `_Mdouble_'.  In all of these cases, there is still
   both a `NAME' and a `NAMEf' that takes `float' arguments.

   Note that there must be no whitespace before the argument passed for
   NAME, to make token pasting work with -traditional.  *//* Prototype declarations for math functions; helper file for <math.h>.
   Copyright (C) 1996-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__payload__cx__width__quo__signgamp__tagb__iptr__exponent__sinx__cosx__issignalingf__iseqsigf__isnanf__finitef__isinff__signbitf__fpclassifyf(float __value)(float __x, float __y)__scalbfscalbfsetpayloadsigffloat *setpayloadf__getpayloadfconst float *getpayloadftotalordermagftotalorderfcanonicalizef__fminmagffminmagf__fmaxmagffmaxmagf__ufromfpxfufromfpxf__fromfpxffromfpxf__ufromfpfufromfpf__fromfpffromfpf__roundevenfroundevenf__fmaf__fminf__fmaxf__fdimf__llroundf__lroundf__llrintf__lrintf__remquof__truncf__roundf__nearbyintf__scalblnf__llogbfllogbf__ilogbf__scalbnf__remainderf__nextupfnextupf__nextdownfnextdownf__nexttowardf__nextafterf__rintf__lgammaf_rlgammaf_r__gammafgammaf__tgammaf__lgammaf__erfcf__erff__ynfynf__y1fy1f__y0fy0f__jnfjnf__j1fj1f__j0fj0fisnanf__nanf__copysignf__significandfsignificandf__dremfdremffinitefisinff__fmodffmodf__floorffloorf__fabsffabsf__ceilfceilf__cbrtf__hypotf__sqrtfsqrtf__powfpowf__log2f__exp2f__logbf__log1pf__expm1f__exp10fexp10f__modffmodff__log10flog10f__logflogf__ldexpfldexpf__frexpffrexpf__expfexpf__atanhf__asinhf__acoshf__sincosfsincosf__tanhftanhf__sinhfsinhf__coshfcoshf__tanftanf__sinfsinf__cosfcosf__atan2fatan2f__atanfatanf__asinfasinf__acosfacosftruncftgammafscalbnfscalblnfroundfrintfremquofremainderfnexttowardfnextafterfnearbyintfnanflroundflrintflogbflog2flog1pfllroundfllrintflgammafilogbfhypotffminffmaxffmaffdimfexpm1fexp2ferfcferffcopysignfcbrtfatanhfasinhfacoshf(float __x, float __n)float(float *__x, float __payload)(const float *__x)(const float *__x, const float *__y)(float *__cx, const float *__x)(float __x, int __round, unsigned int __width)(float __x)(float __x, float __y, float __z)(float __x, float __y, int *__quo)(float __x, long int __n)(float __x, int __n)(float __x, long double __y)(float, int *__signgamp)(float)(int, float)isnanisinf(float __x, float *__iptr)(float __x, int __exponent)(float __x, int *__exponent)(float __x, float *__sinx, float *__cosx)(float __y, float __x)__issignalingl__iseqsigl__isnanl__finitel__isinfl__signbitl__fpclassifyl(long double __value)(long double __x, long double __y)__scalblscalblsetpayloadsigllong double *setpayloadl__getpayloadlconst long double *getpayloadltotalordermagltotalorderlcanonicalizel__fminmaglfminmagl__fmaxmaglfmaxmagl__ufromfpxlufromfpxl__fromfpxlfromfpxl__ufromfplufromfpl__fromfplfromfpl__roundevenlroundevenl__fmal__fminl__fmaxl__fdiml__llroundl__lroundl__llrintl__lrintl__remquol__truncl__roundl__nearbyintl__scalblnl__llogblllogbl__ilogbl__scalbnl__remainderl__nextuplnextupl__nextdownlnextdownl__nexttowardl__nextafterl__rintl__lgammal_rlgammal_r__gammalgammal__tgammal__lgammal__erfcl__erfl__ynlynl__y1ly1l__y0ly0l__jnljnl__j1lj1l__j0lj0lisnanl__nanl__copysignl__significandlsignificandl__dremldremlfinitelisinfl__fmodlfmodl__floorlfloorl__fabslfabsl__ceillceill__cbrtl__hypotl__sqrtlsqrtl__powlpowl__log2l__exp2l__logbl__log1pl__expm1l__exp10lexp10l__modflmodfl__log10llog10l__logllogl__ldexplldexpl__frexplfrexpl__explexpl__atanhl__asinhl__acoshl__sincoslsincosl__tanhltanhl__sinhlsinhl__coshlcoshl__tanltanl__sinlsinl__coslcosl__atan2latan2l__atanlatanl__asinlasinl__acoslacosltruncltgammalscalbnlscalblnlroundlrintlremquolremainderlnexttowardlnextafterlnearbyintlnanllroundllrintllogbllog2llog1plllroundlllrintllgammalilogblhypotlfminlfmaxlfmalfdimlexpm1lexp2lerfclerflcopysignlcbrtlatanhlasinhlacoshl(long double __x, long double __n)long double(long double *__x, long double __payload)(const long double *__x)(const long double *__x, const long double *__y)(long double *__cx, const long double *__x)(long double __x, int __round, unsigned int __width)(long double __x)(long double __x, long double __y, long double __z)(long double __x, long double __y, int *__quo)(long double __x, long int __n)(long double __x, int __n)(long double, int *__signgamp)(long double)(int, long double)(long double __x, long double *__iptr)(long double __x, int __exponent)(long double __x, int *__exponent)(long double __x, long double *__sinx, long double *__cosx)(long double __y, long double __x)setpayloadsigf32_Float32 *setpayloadf32__getpayloadf32const _Float32const _Float32 *getpayloadf32totalordermagf32totalorderf32canonicalizef32__fminmagf32fminmagf32__fmaxmagf32fmaxmagf32__ufromfpxf32ufromfpxf32__fromfpxf32fromfpxf32__ufromfpf32ufromfpf32__fromfpf32fromfpf32__roundevenf32roundevenf32__fmaf32fmaf32__fminf32fminf32__fmaxf32fmaxf32__fdimf32fdimf32__llroundf32llroundf32__lroundf32lroundf32__llrintf32llrintf32__lrintf32lrintf32__remquof32remquof32__truncf32truncf32__roundf32roundf32__nearbyintf32nearbyintf32__scalblnf32scalblnf32__llogbf32llogbf32__ilogbf32ilogbf32__scalbnf32scalbnf32__remainderf32remainderf32__nextupf32nextupf32__nextdownf32nextdownf32__nextafterf32nextafterf32__rintf32rintf32__lgammaf32_rlgammaf32_r__tgammaf32tgammaf32__lgammaf32lgammaf32__erfcf32erfcf32__erff32erff32__ynf32ynf32__y1f32y1f32__y0f32y0f32__jnf32jnf32__j1f32j1f32__j0f32j0f32__nanf32nanf32__copysignf32copysignf32__fmodf32fmodf32__floorf32floorf32__fabsf32fabsf32__ceilf32ceilf32__cbrtf32cbrtf32__hypotf32hypotf32__sqrtf32sqrtf32__powf32powf32__log2f32log2f32__exp2f32exp2f32__logbf32logbf32__log1pf32log1pf32__expm1f32expm1f32__exp10f32exp10f32__modff32modff32__log10f32log10f32__logf32logf32__ldexpf32ldexpf32__frexpf32frexpf32__expf32expf32__atanhf32atanhf32__asinhf32asinhf32__acoshf32acoshf32__sincosf32sincosf32__tanhf32tanhf32__sinhf32sinhf32__coshf32coshf32__tanf32tanf32__sinf32sinf32__cosf32cosf32__atan2f32atan2f32__atanf32atanf32__asinf32asinf32__acosf32acosf32(_Float32 *__x, _Float32 __payload)(const _Float32 *__x)_Float32(const _Float32 *__x, const _Float32 *__y)(_Float32 *__cx, const _Float32 *__x)(_Float32 __x, _Float32 __y)(_Float32 __x, int __round, unsigned int __width)(_Float32 __x)(_Float32 __x, _Float32 __y, _Float32 __z)(_Float32 __x, _Float32 __y, int *__quo)(_Float32 __x, long int __n)(_Float32 __x, int __n)(_Float32, int *__signgamp)(_Float32)(int, _Float32)(_Float32 __x, _Float32 *__iptr)(_Float32 __x, int __exponent)(_Float32 __x, int *__exponent)(_Float32 __x, _Float32 *__sinx, _Float32 *__cosx)(_Float32 __y, _Float32 __x)setpayloadsigf64_Float64 *setpayloadf64__getpayloadf64const _Float64const _Float64 *getpayloadf64totalordermagf64totalorderf64canonicalizef64__fminmagf64fminmagf64__fmaxmagf64fmaxmagf64__ufromfpxf64ufromfpxf64__fromfpxf64fromfpxf64__ufromfpf64ufromfpf64__fromfpf64fromfpf64__roundevenf64roundevenf64__fmaf64fmaf64__fminf64fminf64__fmaxf64fmaxf64__fdimf64fdimf64__llroundf64llroundf64__lroundf64lroundf64__llrintf64llrintf64__lrintf64lrintf64__remquof64remquof64__truncf64truncf64__roundf64roundf64__nearbyintf64nearbyintf64__scalblnf64scalblnf64__llogbf64llogbf64__ilogbf64ilogbf64__scalbnf64scalbnf64__remainderf64remainderf64__nextupf64nextupf64__nextdownf64nextdownf64__nextafterf64nextafterf64__rintf64rintf64__lgammaf64_rlgammaf64_r__tgammaf64tgammaf64__lgammaf64lgammaf64__erfcf64erfcf64__erff64erff64__ynf64ynf64__y1f64y1f64__y0f64y0f64__jnf64jnf64__j1f64j1f64__j0f64j0f64__nanf64nanf64__copysignf64copysignf64__fmodf64fmodf64__floorf64floorf64__fabsf64fabsf64__ceilf64ceilf64__cbrtf64cbrtf64__hypotf64hypotf64__sqrtf64sqrtf64__powf64powf64__log2f64log2f64__exp2f64exp2f64__logbf64logbf64__log1pf64log1pf64__expm1f64expm1f64__exp10f64exp10f64__modff64modff64__log10f64log10f64__logf64logf64__ldexpf64ldexpf64__frexpf64frexpf64__expf64expf64__atanhf64atanhf64__asinhf64asinhf64__acoshf64acoshf64__sincosf64sincosf64__tanhf64tanhf64__sinhf64sinhf64__coshf64coshf64__tanf64tanf64__sinf64sinf64__cosf64cosf64__atan2f64atan2f64__atanf64atanf64__asinf64asinf64__acosf64acosf64(_Float64 *__x, _Float64 __payload)(const _Float64 *__x)_Float64(const _Float64 *__x, const _Float64 *__y)(_Float64 *__cx, const _Float64 *__x)(_Float64 __x, _Float64 __y)(_Float64 __x, int __round, unsigned int __width)(_Float64 __x)(_Float64 __x, _Float64 __y, _Float64 __z)(_Float64 __x, _Float64 __y, int *__quo)(_Float64 __x, long int __n)(_Float64 __x, int __n)(_Float64, int *__signgamp)(_Float64)(int, _Float64)(_Float64 __x, _Float64 *__iptr)(_Float64 __x, int __exponent)(_Float64 __x, int *__exponent)(_Float64 __x, _Float64 *__sinx, _Float64 *__cosx)(_Float64 __y, _Float64 __x)__issignalingf128__iseqsigf128__isnanf128__finitef128__isinff128__signbitf128__fpclassifyf128(_Float128 __value)(_Float128 __x, _Float128 __y)setpayloadsigf128_Float128 *__float128 *setpayloadf128__getpayloadf128const _Float128const _Float128 *getpayloadf128totalordermagf128totalorderf128canonicalizef128__fminmagf128fminmagf128__fmaxmagf128fmaxmagf128__ufromfpxf128ufromfpxf128__fromfpxf128fromfpxf128__ufromfpf128ufromfpf128__fromfpf128fromfpf128__roundevenf128roundevenf128__fmaf128fmaf128__fminf128fminf128__fmaxf128fmaxf128__fdimf128fdimf128__llroundf128llroundf128__lroundf128lroundf128__llrintf128llrintf128__lrintf128lrintf128__remquof128remquof128__truncf128truncf128__roundf128roundf128__nearbyintf128nearbyintf128__scalblnf128scalblnf128__llogbf128llogbf128__ilogbf128ilogbf128__scalbnf128scalbnf128__remainderf128remainderf128__nextupf128nextupf128__nextdownf128nextdownf128__nextafterf128nextafterf128__rintf128rintf128__lgammaf128_rlgammaf128_r__tgammaf128tgammaf128__lgammaf128lgammaf128__erfcf128erfcf128__erff128erff128__ynf128ynf128__y1f128y1f128__y0f128y0f128__jnf128jnf128__j1f128j1f128__j0f128j0f128__nanf128nanf128__copysignf128copysignf128__fmodf128fmodf128__floorf128floorf128__fabsf128fabsf128__ceilf128ceilf128__cbrtf128cbrtf128__hypotf128hypotf128__sqrtf128sqrtf128__powf128powf128__log2f128log2f128__exp2f128exp2f128__logbf128logbf128__log1pf128log1pf128__expm1f128expm1f128__exp10f128exp10f128__modff128modff128__log10f128log10f128__logf128logf128__ldexpf128ldexpf128__frexpf128frexpf128__expf128expf128__atanhf128atanhf128__asinhf128asinhf128__acoshf128acoshf128__sincosf128sincosf128__tanhf128tanhf128__sinhf128sinhf128__coshf128coshf128__tanf128tanf128__sinf128sinf128__cosf128cosf128__atan2f128atan2f128__atanf128atanf128__asinf128asinf128__acosf128acosf128(_Float128 *__x, _Float128 __payload)(const _Float128 *__x)_Float128(const _Float128 *__x, const _Float128 *__y)(_Float128 *__cx, const _Float128 *__x)(_Float128 __x, int __round, unsigned int __width)(_Float128 __x)(_Float128 __x, _Float128 __y, _Float128 __z)(_Float128 __x, _Float128 __y, int *__quo)(_Float128 __x, long int __n)(_Float128 __x, int __n)(_Float128, int *__signgamp)(_Float128)(int, _Float128)(_Float128 __x, _Float128 *__iptr)(_Float128 __x, int __exponent)(_Float128 __x, int *__exponent)(_Float128 __x, _Float128 *__sinx, _Float128 *__cosx)(_Float128 __y, _Float128 __x)setpayloadsigf32x_Float32x *setpayloadf32x__getpayloadf32xconst _Float32xconst _Float32x *getpayloadf32xtotalordermagf32xtotalorderf32xcanonicalizef32x__fminmagf32xfminmagf32x__fmaxmagf32xfmaxmagf32x__ufromfpxf32xufromfpxf32x__fromfpxf32xfromfpxf32x__ufromfpf32xufromfpf32x__fromfpf32xfromfpf32x__roundevenf32xroundevenf32x__fmaf32xfmaf32x__fminf32xfminf32x__fmaxf32xfmaxf32x__fdimf32xfdimf32x__llroundf32xllroundf32x__lroundf32xlroundf32x__llrintf32xllrintf32x__lrintf32xlrintf32x__remquof32xremquof32x__truncf32xtruncf32x__roundf32xroundf32x__nearbyintf32xnearbyintf32x__scalblnf32xscalblnf32x__llogbf32xllogbf32x__ilogbf32xilogbf32x__scalbnf32xscalbnf32x__remainderf32xremainderf32x__nextupf32xnextupf32x__nextdownf32xnextdownf32x__nextafterf32xnextafterf32x__rintf32xrintf32x__lgammaf32x_rlgammaf32x_r__tgammaf32xtgammaf32x__lgammaf32xlgammaf32x__erfcf32xerfcf32x__erff32xerff32x__ynf32xynf32x__y1f32xy1f32x__y0f32xy0f32x__jnf32xjnf32x__j1f32xj1f32x__j0f32xj0f32x__nanf32xnanf32x__copysignf32xcopysignf32x__fmodf32xfmodf32x__floorf32xfloorf32x__fabsf32xfabsf32x__ceilf32xceilf32x__cbrtf32xcbrtf32x__hypotf32xhypotf32x__sqrtf32xsqrtf32x__powf32xpowf32x__log2f32xlog2f32x__exp2f32xexp2f32x__logbf32xlogbf32x__log1pf32xlog1pf32x__expm1f32xexpm1f32x__exp10f32xexp10f32x__modff32xmodff32x__log10f32xlog10f32x__logf32xlogf32x__ldexpf32xldexpf32x__frexpf32xfrexpf32x__expf32xexpf32x__atanhf32xatanhf32x__asinhf32xasinhf32x__acoshf32xacoshf32x__sincosf32xsincosf32x__tanhf32xtanhf32x__sinhf32xsinhf32x__coshf32xcoshf32x__tanf32xtanf32x__sinf32xsinf32x__cosf32xcosf32x__atan2f32xatan2f32x__atanf32xatanf32x__asinf32xasinf32x__acosf32xacosf32x(_Float32x *__x, _Float32x __payload)(const _Float32x *__x)_Float32x(const _Float32x *__x, const _Float32x *__y)(_Float32x *__cx, const _Float32x *__x)(_Float32x __x, _Float32x __y)(_Float32x __x, int __round, unsigned int __width)(_Float32x __x)(_Float32x __x, _Float32x __y, _Float32x __z)(_Float32x __x, _Float32x __y, int *__quo)(_Float32x __x, long int __n)(_Float32x __x, int __n)(_Float32x, int *__signgamp)(_Float32x)(int, _Float32x)(_Float32x __x, _Float32x *__iptr)(_Float32x __x, int __exponent)(_Float32x __x, int *__exponent)(_Float32x __x, _Float32x *__sinx, _Float32x *__cosx)(_Float32x __y, _Float32x __x)setpayloadsigf64x_Float64x *setpayloadf64x__getpayloadf64xconst _Float64xconst _Float64x *getpayloadf64xtotalordermagf64xtotalorderf64xcanonicalizef64x__fminmagf64xfminmagf64x__fmaxmagf64xfmaxmagf64x__ufromfpxf64xufromfpxf64x__fromfpxf64xfromfpxf64x__ufromfpf64xufromfpf64x__fromfpf64xfromfpf64x__roundevenf64xroundevenf64x__fmaf64xfmaf64x__fminf64xfminf64x__fmaxf64xfmaxf64x__fdimf64xfdimf64x__llroundf64xllroundf64x__lroundf64xlroundf64x__llrintf64xllrintf64x__lrintf64xlrintf64x__remquof64xremquof64x__truncf64xtruncf64x__roundf64xroundf64x__nearbyintf64xnearbyintf64x__scalblnf64xscalblnf64x__llogbf64xllogbf64x__ilogbf64xilogbf64x__scalbnf64xscalbnf64x__remainderf64xremainderf64x__nextupf64xnextupf64x__nextdownf64xnextdownf64x__nextafterf64xnextafterf64x__rintf64xrintf64x__lgammaf64x_rlgammaf64x_r__tgammaf64xtgammaf64x__lgammaf64xlgammaf64x__erfcf64xerfcf64x__erff64xerff64x__ynf64xynf64x__y1f64xy1f64x__y0f64xy0f64x__jnf64xjnf64x__j1f64xj1f64x__j0f64xj0f64x__nanf64xnanf64x__copysignf64xcopysignf64x__fmodf64xfmodf64x__floorf64xfloorf64x__fabsf64xfabsf64x__ceilf64xceilf64x__cbrtf64xcbrtf64x__hypotf64xhypotf64x__sqrtf64xsqrtf64x__powf64xpowf64x__log2f64xlog2f64x__exp2f64xexp2f64x__logbf64xlogbf64x__log1pf64xlog1pf64x__expm1f64xexpm1f64x__exp10f64xexp10f64x__modff64xmodff64x__log10f64xlog10f64x__logf64xlogf64x__ldexpf64xldexpf64x__frexpf64xfrexpf64x__expf64xexpf64x__atanhf64xatanhf64x__asinhf64xasinhf64x__acoshf64xacoshf64x__sincosf64xsincosf64x__tanhf64xtanhf64x__sinhf64xsinhf64x__coshf64xcoshf64x__tanf64xtanf64x__sinf64xsinf64x__cosf64xcosf64x__atan2f64xatan2f64x__atanf64xatanf64x__asinf64xasinf64x__acosf64xacosf64x(_Float64x *__x, _Float64x __payload)(const _Float64x *__x)_Float64x(const _Float64x *__x, const _Float64x *__y)(_Float64x *__cx, const _Float64x *__x)(_Float64x __x, _Float64x __y)(_Float64x __x, int __round, unsigned int __width)(_Float64x __x)(_Float64x __x, _Float64x __y, _Float64x __z)(_Float64x __x, _Float64x __y, int *__quo)(_Float64x __x, long int __n)(_Float64x __x, int __n)(_Float64x, int *__signgamp)(_Float64x)(int, _Float64x)(_Float64x __x, _Float64x *__iptr)(_Float64x __x, int __exponent)(_Float64x __x, int *__exponent)(_Float64x __x, _Float64x *__sinx, _Float64x *__cosx)(_Float64x __y, _Float64x __x)/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.hfsubfmulfdivfadd__MATHCALL_NAME (sub)__MATHCALL_REDIR_NAME (sub)sub__MATHCALL_NAME (mul)__MATHCALL_REDIR_NAME (mul)mul__MATHCALL_NAME (div)__MATHCALL_REDIR_NAME (div)div__MATHCALL_NAME (add)__MATHCALL_REDIR_NAME (add)add/* Subtract.  *//* Multiply.  *//* Divide.  *//* Add.  *//* Declare functions returning a narrower type.
   Copyright (C) 2018-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */fsublfmullfdivlfaddldsubldmullddivldaddlf32subf32xf32mulf32xf32divf32xf32addf32xf32subf64f32mulf64f32divf64f32addf64f32subf64xf32mulf64xf32divf64xf32addf64xf32subf128f32mulf128f32divf128f32addf128f32xsubf64f32xmulf64f32xdivf64f32xaddf64f32xsubf64xf32xmulf64xf32xdivf64xf32xaddf64xf32xsubf128f32xmulf128f32xdivf128f32xaddf128f64subf64xf64mulf64xf64divf64xf64addf64xf64subf128f64mulf128f64divf128f64addf128f64xsubf128f64xmulf128f64xdivf128f64xaddf128/usr/include/x86_64-linux-gnu/bits/iscanonical.hiscanonical__iscanonicall__iscanonicalf128(x)((void) (__typeof (x)) (x), 1)__iscanonical(x)__iscanonicalf(x)__HAVE_DISTINCT_FLOAT128/* __cplusplus *//* In C++ mode, __MATH_TG cannot be used, because it relies on
   __builtin_types_compatible_p, which is a C-only builtin.  On the
   other hand, overloading provides the means to distinguish between
   the floating-point types.  The overloading resolution will match
   the correct parameter (regardless of type qualifiers (i.e.: const
   and volatile)).  *//* Return nonzero value if X is canonical.  In IEEE interchange binary
   formats, all values are canonical, but the argument must still be
   converted to its semantic type for any exceptions arising from the
   conversion, before being discarded; in extended precision, there
   are encodings that are not consistently handled as corresponding to
   any particular value of the type, and we return 0 for those.  *//* Define iscanonical macro.  ldbl-96 version.
   Copyright (C) 2016-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/math.h<bits/iscanonical.h><bits/mathcalls-narrow.h><bits/mathcalls.h><bits/mathcalls-helper-functions.h><bits/fp-fast.h><bits/fp-logb.h><bits/flt-eval-method.h><bits/floatn.h><bits/math-vector.h><bits/libc-header-start.h>iseqsigiszero__Tissignaling__iseqsig_type<__float128> &__iseqsig_type<__float128> &&const __iseqsig_type<__float128>const __iseqsig_type<__float128> &__call__iseqsig_type<long double> &__iseqsig_type<long double> &&const __iseqsig_type<long double>const __iseqsig_type<long double> &__iseqsig_type<double> &__iseqsig_type<double> &&const __iseqsig_type<double>const __iseqsig_type<double> &__iseqsig_type<float> &__iseqsig_type<float> &&const __iseqsig_type<float>const __iseqsig_type<float> &__iseqsig_type<__float128>__iseqsig_type<long double>__iseqsig_type<double>__iseqsig_type<float>__iseqsig_type<<unnamed>>FP_NANFP_INFINITEFP_ZEROFP_SUBNORMALFP_NORMALFP_INT_UPWARDFP_INT_DOWNWARDFP_INT_TOWARDZEROFP_INT_TONEARESTFROMZEROFP_INT_TONEARESTfloat_tdouble_tsigngam__MATH_EVAL_FMT2(x,y)((x) + (y) + 0.0f)isunordered(x,y)__builtin_isunordered(x, y)islessgreater(x,y)__builtin_islessgreater(x, y)islessequal(x,y)__builtin_islessequal(x, y)isless(x,y)__builtin_isless(x, y)isgreaterequal(x,y)__builtin_isgreaterequal(x, y)isgreater(x,y)__builtin_isgreater(x, y)__NO_MATH_INLINESM_SQRT1_2f64x__f64x (0.707106781186547524400844362104849039)M_SQRT2f64x__f64x (1.414213562373095048801688724209698079)M_2_SQRTPIf64x__f64x (1.128379167095512573896158903121545172)M_2_PIf64x__f64x (0.636619772367581343075535053490057448)M_1_PIf64x__f64x (0.318309886183790671537767526745028724)M_PI_4f64x__f64x (0.785398163397448309615660845819875721)M_PI_2f64x__f64x (1.570796326794896619231321691639751442)M_PIf64x__f64x (3.141592653589793238462643383279502884)M_LN10f64x__f64x (2.302585092994045684017991454684364208)M_LN2f64x__f64x (0.693147180559945309417232121458176568)M_LOG10Ef64x__f64x (0.434294481903251827651128918916605082)M_LOG2Ef64x__f64x (1.442695040888963407359924681001892137)M_Ef64x__f64x (2.718281828459045235360287471352662498)M_SQRT1_2f32x__f32x (0.707106781186547524400844362104849039)M_SQRT2f32x__f32x (1.414213562373095048801688724209698079)M_2_SQRTPIf32x__f32x (1.128379167095512573896158903121545172)M_2_PIf32x__f32x (0.636619772367581343075535053490057448)M_1_PIf32x__f32x (0.318309886183790671537767526745028724)M_PI_4f32x__f32x (0.785398163397448309615660845819875721)M_PI_2f32x__f32x (1.570796326794896619231321691639751442)M_PIf32x__f32x (3.141592653589793238462643383279502884)M_LN10f32x__f32x (2.302585092994045684017991454684364208)M_LN2f32x__f32x (0.693147180559945309417232121458176568)M_LOG10Ef32x__f32x (0.434294481903251827651128918916605082)M_LOG2Ef32x__f32x (1.442695040888963407359924681001892137)M_Ef32x__f32x (2.718281828459045235360287471352662498)M_SQRT1_2f128__f128 (0.707106781186547524400844362104849039)M_SQRT2f128__f128 (1.414213562373095048801688724209698079)M_2_SQRTPIf128__f128 (1.128379167095512573896158903121545172)M_2_PIf128__f128 (0.636619772367581343075535053490057448)M_1_PIf128__f128 (0.318309886183790671537767526745028724)M_PI_4f128__f128 (0.785398163397448309615660845819875721)M_PI_2f128__f128 (1.570796326794896619231321691639751442)M_PIf128__f128 (3.141592653589793238462643383279502884)M_LN10f128__f128 (2.302585092994045684017991454684364208)M_LN2f128__f128 (0.693147180559945309417232121458176568)M_LOG10Ef128__f128 (0.434294481903251827651128918916605082)M_LOG2Ef128__f128 (1.442695040888963407359924681001892137)M_Ef128__f128 (2.718281828459045235360287471352662498)M_SQRT1_2f64__f64 (0.707106781186547524400844362104849039)M_SQRT2f64__f64 (1.414213562373095048801688724209698079)M_2_SQRTPIf64__f64 (1.128379167095512573896158903121545172)M_2_PIf64__f64 (0.636619772367581343075535053490057448)M_1_PIf64__f64 (0.318309886183790671537767526745028724)M_PI_4f64__f64 (0.785398163397448309615660845819875721)M_PI_2f64__f64 (1.570796326794896619231321691639751442)M_PIf64__f64 (3.141592653589793238462643383279502884)M_LN10f64__f64 (2.302585092994045684017991454684364208)M_LN2f64__f64 (0.693147180559945309417232121458176568)M_LOG10Ef64__f64 (0.434294481903251827651128918916605082)M_LOG2Ef64__f64 (1.442695040888963407359924681001892137)M_Ef64__f64 (2.718281828459045235360287471352662498)M_SQRT1_2f32__f32 (0.707106781186547524400844362104849039)M_SQRT2f32__f32 (1.414213562373095048801688724209698079)M_2_SQRTPIf32__f32 (1.128379167095512573896158903121545172)M_2_PIf32__f32 (0.636619772367581343075535053490057448)M_1_PIf32__f32 (0.318309886183790671537767526745028724)M_PI_4f32__f32 (0.785398163397448309615660845819875721)M_PI_2f32__f32 (1.570796326794896619231321691639751442)M_PIf32__f32 (3.141592653589793238462643383279502884)M_LN10f32__f32 (2.302585092994045684017991454684364208)M_LN2f32__f32 (0.693147180559945309417232121458176568)M_LOG10Ef32__f32 (0.434294481903251827651128918916605082)M_LOG2Ef32__f32 (1.442695040888963407359924681001892137)M_Ef32__f32 (2.718281828459045235360287471352662498)M_SQRT1_2l0.707106781186547524400844362104849039LM_SQRT2l1.414213562373095048801688724209698079LM_2_SQRTPIl1.128379167095512573896158903121545172LM_2_PIl0.636619772367581343075535053490057448LM_1_PIl0.318309886183790671537767526745028724LM_PI_4l0.785398163397448309615660845819875721LM_PI_2l1.570796326794896619231321691639751442LM_PIl3.141592653589793238462643383279502884LM_LN10l2.302585092994045684017991454684364208LM_LN2l0.693147180559945309417232121458176568LM_LOG10El0.434294481903251827651128918916605082LM_LOG2El1.442695040888963407359924681001892137LM_El2.718281828459045235360287471352662498LM_SQRT1_20.70710678118654752440M_SQRT21.41421356237309504880M_2_SQRTPI1.12837916709551257390M_2_PI0.63661977236758134308M_1_PI0.31830988618379067154M_PI_40.78539816339744830962M_PI_21.57079632679489661923M_PI3.14159265358979323846M_LN102.30258509299404568402M_LN20.69314718055994530942M_LOG10E0.43429448190325182765M_LOG2E1.4426950408889634074M_E2.7182818284590452354MAXFLOAT3.40282347e+38Fissubnormal(x)(fpclassify (x) == FP_SUBNORMAL)math_errhandling(MATH_ERRNO | MATH_ERREXCEPT)MATH_ERREXCEPTMATH_ERRNOisinf(x)__builtin_isinf_sign (x)isnan(x)__builtin_isnan (x)isnormal(x)__builtin_isnormal (x)isfinite(x)__builtin_isfinite (x)signbit(x)__builtin_signbit (x)fpclassify(x)__builtin_fpclassify (FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)__MATH_TG(TG_ARG,FUNC,ARGS)__builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), float), FUNC ## f ARGS, __builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), double), FUNC ARGS, __builtin_choose_expr (__builtin_types_compatible_p (__typeof (TG_ARG), long double), FUNC ## l ARGS, FUNC ## f128 ARGS)))__MATHCALL_NARROW__MATHCALL_NARROW_REDIR__MATHCALL_NARROW_NORMAL__MATHCALL_NARROW_ARGS_3__MATHCALL_NARROW_ARGS_2__MATHCALL_NARROW_ARGS_1__MATHCALL_NAME_Marg__Mret___MATHCALL_NAME(name)f64x ## name ## f128f64 ## name ## f128f64 ## name ## f64xf32x ## name ## f128f32x ## name ## f64xf32x ## name ## f64f32 ## name ## f128f32 ## name ## f64xf32 ## name ## f64f32 ## name ## f32xd ## name ## lf ## name ## lf ## name__MATHCALL_NARROW(func,redir,nargs)__MATHCALL_NARROW_NORMAL (func, nargs)__MATHCALL_NARROW_REDIR(func,redir,nargs)extern _Mret_ __REDIRECT_NTH (func, __MATHCALL_NARROW_ARGS_ ## nargs, redir)__MATHCALL_NARROW_NORMAL(func,nargs)extern _Mret_ func __MATHCALL_NARROW_ARGS_ ## nargs __THROW(_Marg_ __x, _Marg_ __y, _Marg_ __z)(_Marg_ __x, _Marg_ __y)(_Marg_ __x)__MATHCALL__MATHDECL__MATHDECL_1__MATH_DECLARING_FLOATN__MATH_DECLARING_DOUBLE__MATH_PRECNAME__MATH_PRECNAME(name,r)name ## f64x ## rname ## f32x ## rname ## f128 ## rname ## f64 ## rname ## f32 ## r__MATH_DECLARE_LDOUBLEname ## l ## rname ## f ## r__CONCAT(name,r)__MATHDECL_1(type,function,suffix,args)extern type __MATH_PRECNAME(function,suffix) args __THROW__MATHDECLX(type,function,suffix,args,attrib)__MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)__MATHCALLX(function,suffix,args,attrib)__MATHDECLX (_Mdouble_,function,suffix, args, attrib)__MATHDECL(type,function,suffix,args)__MATHDECL_1(type, function,suffix, args); __MATHDECL_1(type, __CONCAT(__,function),suffix, args)__MATHCALL(function,suffix,args)__MATHDECL (_Mdouble_,function,suffix, args)__MATHDECL_VEC(type,function,suffix,args)__SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHDECL(type, function,suffix, args)__MATHCALL_VEC(function,suffix,args)__SIMD_DECL (__MATH_PRECNAME (function, suffix)) __MATHCALL (function, suffix, args)__SIMD_DECL(function)__CONCAT (__DECL_SIMD_, function)FP_LLOGBNAN(-__FP_LONG_MAX - 1)FP_LLOGB0__FP_LONG_MAX0x7fffffffffffffffLFP_ILOGBNAN(-2147483647 - 1)FP_ILOGB0SNANF64X(__builtin_nansf64x (""))SNANF32X(__builtin_nansf32x (""))SNANF128(__builtin_nansf128 (""))SNANF64(__builtin_nansf64 (""))SNANF32(__builtin_nansf32 (""))SNANL(__builtin_nansl (""))SNAN(__builtin_nans (""))SNANF(__builtin_nansf (""))NAN(__builtin_nanf (""))INFINITY(__builtin_inff ())HUGE_VAL_F64X(__builtin_huge_valf64x ())HUGE_VAL_F32X(__builtin_huge_valf32x ())HUGE_VAL_F128(__builtin_huge_valf128 ())HUGE_VAL_F64(__builtin_huge_valf64 ())HUGE_VAL_F32(__builtin_huge_valf32 ())HUGE_VALL(__builtin_huge_vall ())HUGE_VALF(__builtin_huge_valf ())HUGE_VAL(__builtin_huge_val ())defined log && defined __GNUC____GNUC_PREREQ (3, 3)__HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)__GLIBC_USE (IEC_60559_BFP_EXT_C2X)__GLIBC_FLT_EVAL_METHOD == 0 || __GLIBC_FLT_EVAL_METHOD == 16__GLIBC_FLT_EVAL_METHOD == 1__GLIBC_FLT_EVAL_METHOD == 2__GLIBC_FLT_EVAL_METHOD == 32__GLIBC_FLT_EVAL_METHOD == 33__GLIBC_FLT_EVAL_METHOD == 64__GLIBC_FLT_EVAL_METHOD == 65__GLIBC_FLT_EVAL_METHOD == 128__GLIBC_FLT_EVAL_METHOD == 129__WORDSIZE == 32!(defined __NO_LONG_DOUBLE_MATH && defined _LIBC) \__LDBL_COMPAT__HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 && !defined _LIBC)__HAVE_DISTINCT_FLOAT16__GLIBC_USE (IEC_60559_TYPES_EXT)__HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 && !defined _LIBC)__HAVE_DISTINCT_FLOAT32__HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 && !defined _LIBC)__HAVE_DISTINCT_FLOAT64__HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 && !defined _LIBC)__HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X && !defined _LIBC)__HAVE_DISTINCT_FLOAT32X__HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X && !defined _LIBC)__HAVE_DISTINCT_FLOAT64X__HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X && !defined _LIBC)__HAVE_DISTINCT_FLOAT128X__HAVE_FLOAT16 && __HAVE_FLOAT32__HAVE_FLOAT16 && __HAVE_FLOAT32X__HAVE_FLOAT16 && __HAVE_FLOAT64__HAVE_FLOAT16 && __HAVE_FLOAT64X__HAVE_FLOAT16 && __HAVE_FLOAT128__HAVE_FLOAT16 && __HAVE_FLOAT128X__HAVE_FLOAT32 && __HAVE_FLOAT32X__HAVE_FLOAT32 && __HAVE_FLOAT64__HAVE_FLOAT32 && __HAVE_FLOAT64X__HAVE_FLOAT32 && __HAVE_FLOAT128__HAVE_FLOAT32 && __HAVE_FLOAT128X__HAVE_FLOAT32X && __HAVE_FLOAT64__HAVE_FLOAT32X && __HAVE_FLOAT64X__HAVE_FLOAT32X && __HAVE_FLOAT128__HAVE_FLOAT32X && __HAVE_FLOAT128X__HAVE_FLOAT64 && __HAVE_FLOAT64X__HAVE_FLOAT64 && __HAVE_FLOAT128__HAVE_FLOAT64 && __HAVE_FLOAT128X__HAVE_FLOAT64X && __HAVE_FLOAT128__HAVE_FLOAT64X && __HAVE_FLOAT128X__HAVE_FLOAT128 && __HAVE_FLOAT128X(__HAVE_DISTINCT_FLOAT16			\__NO_LONG_DOUBLE_MATH__HAVE_GENERIC_SELECTION__HAVE_FLOATN_NOT_TYPEDEF && __HAVE_FLOAT32__HAVE_FLOATN_NOT_TYPEDEF && __HAVE_FLOAT64X__HAVE_FLOAT64X_LONG_DOUBLE__HAVE_FLOATN_NOT_TYPEDEF((__GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__)		      \__GNUC_PREREQ (6,0) || __glibc_clang_prereq (3,3)defined __cplusplus__GNUC_PREREQ (4,0)(__GNUC_PREREQ (4,4) && !defined __SUPPORT_SNAN__) \__HAVE_DISTINCT_FLOAT128 && !__GNUC_PREREQ (7,0) \__FAST_MATH__defined __NO_MATH_ERRNO____HAVE_FLOAT128_UNLIKE_LDBL__SUPPORT_SNAN____HAVE_FLOAT16 && defined __USE_GNU__HAVE_FLOAT32 && defined __USE_GNU__HAVE_FLOAT64 && defined __USE_GNU__HAVE_FLOAT128 && defined __USE_GNU__HAVE_FLOAT32X && defined __USE_GNU__HAVE_FLOAT64X && defined __USE_GNU__HAVE_FLOAT128X && defined __USE_GNUdefined __STRICT_ANSI__ && !defined __NO_MATH_INLINES__GNUC_PREREQ (3, 1)__USE_EXTERN_INLINES__FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ > 64__FLT_EVAL_METHOD__ == 1 || __FLT_EVAL_METHOD__ > 32__FLT_EVAL_METHOD__ == 0 || __FLT_EVAL_METHOD__ == 32!defined __cplusplus || (__cplusplus < 201103L && !defined __GNUC__)IEC_60559_TYPES_EXT__LDBL_MANT_DIG__/* math.h  *//* extern "C++" *//* When using an IEEE 128-bit long double, _Float128 is defined as long double
     in C++.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
   __builtin_types_compatible_p, which is a C-only builtin.  Moreover,
   the comparison macros from ISO C take two floating-point arguments,
   which need not have the same type.  Choosing what underlying function
   to call requires evaluating the formats of the arguments, then
   selecting which is wider.  The macro __MATH_EVAL_FMT2 provides this
   information, however, only the type of the macro expansion is
   relevant (actually evaluating the expression would be incorrect).
   Thus, the type is used as a template parameter for __iseqsig_type,
   which calls the appropriate underlying function.  *//* Return X == Y but raising "invalid" and setting errno if X or Y is
   a NaN.  *//* An expression whose type has the widest of the evaluation formats
   of X and Y (which are of floating-point types).  *//* Get machine-dependent inline versions (if there are any).  *//* isunordered must always check both operands first for signaling NaNs.  *//* ISO C99 defines some macros to compare number while taking care for
   unordered numbers.  Many FPUs provide special instructions to support
   these operations.  Generic support in GCC for these as builtins went
   in 2.97, but not all cpus added their patterns until 3.1.  Therefore
   we enable the builtins from 3.1 onwards and use a generic implementation
   othwerwise.  *//* When compiling in strict ISO C compatible mode we must not use the
   inline functions since they, among other things, do not set the
   `errno' variable correctly.  *//* 1/sqrt(2) *//* sqrt(2) *//* 2/sqrt(pi) *//* 2/pi *//* 1/pi *//* pi/4 *//* pi/2 *//* pi *//* log_e 10 *//* log_e 2 *//* log_10 e *//* log_2 e *//* e *//* The above constants are not adequate for computation using `long double's.
   Therefore we provide as an extension constants with similar names as a
   GNU extension.  Provide enough digits for the 128-bit IEEE quad.  *//* Some useful constants.  *//* X/Open wants another strange constant.  *//* Use IEC_60559_BFP_EXT.  *//* extern C++ *//* Return nonzero value if X is zero.  *//* Return nonzero value if X is subnormal.  *//* When using an IEEE 128-bit long double, _Float128 is defined as long double
   in C++.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
      __builtin_types_compatible_p, which is a C-only builtin.  On the
      other hand, overloading provides the means to distinguish between
      the floating-point types.  The overloading resolution will match
      the correct parameter (regardless of type qualifiers (i.e.: const
      and volatile)).  *//* Return nonzero value if X is a signaling NaN.  *//* By default all math functions support both errno and exception handling
   (except for soft floating point implementations which may only support
   errno handling).  If errno handling is disabled, exceptions are still
   supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
   nonconforming but it is more useful than leaving it undefined).  *//* Exceptions raised by math functions.  *//* errno set by math functions.  *//* Bitmasks for the math_errhandling macro.  *//* Since __builtin_isinf_sign is broken for float128 before GCC 7.0,
      use the helper function, __isinff128, with older compilers.  This is
      only provided for C mode, because in C++ mode, GCC has no support
      for __builtin_types_compatible_p (and when in C++ mode, this macro is
      not used anyway, because libstdc++ headers undefine it).  *//* Return nonzero value if X is positive or negative infinity.  *//* Return nonzero value if X is a NaN.  We could use `fpclassify' but
   we already have this functions `__isnan' and it is faster.  *//* Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.  *//* Return nonzero value if X is not +-Inf or NaN.  *//* In C++ mode, __MATH_TG cannot be used, because it relies on
     __builtin_types_compatible_p, which is a C-only builtin.
     The check for __cplusplus allows the use of the builtin instead of
     __MATH_TG. This is provided for libstdc++, only to let its configure
     test work. No further use of this definition of signbit is expected
     in C++ mode, since libstdc++ provides its own version of signbit
     in cmath (which undefines signbit). *//* Return nonzero value if sign of X is negative.  *//* The check for __cplusplus allows the use of the builtin, even
	when optimization for size is on.  This is provided for
	libstdc++, only to let its configure test work when it is built
	with -Os.  No further use of this definition of fpclassify is
	expected in C++ mode, since libstdc++ provides its own version
	of fpclassify in cmath (which undefines fpclassify).  *//* Return number of classification appropriate for X.  *//* GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
   so disable builtins if this is enabled.  When fixed in a newer GCC,
   the __SUPPORT_SNAN__ check may be skipped for those versions.  *//* All floating-point numbers can be put in one of these categories.  *//* ISO C99 defines some generic macros which work on any data type.  *//* Depending on the type of TG_ARG, call an appropriately suffixed
   version of FUNC with arguments (including parentheses) ARGS.
   Suffixed functions may not exist for long double if it has the same
   format as double, or for other types with the same format as float,
   double or long double.  The behavior is undefined if the argument
   does not have a real floating type.  The definition may use a
   conditional expression, so all suffixed versions of FUNC must
   return the same type (FUNC may include a cast if necessary rather
   than being a single identifier).  *//* This variable is used by `gamma' and `lgamma'.  *//* Declare functions returning a narrower type.  *//* __HAVE_DISTINCT_FLOAT128X || (__HAVE_FLOAT128X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT64X || (__HAVE_FLOAT64X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT32X || (__HAVE_FLOAT32X && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT128 || (__HAVE_FLOAT128 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT64 || (__HAVE_FLOAT64 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT32 || (__HAVE_FLOAT32 && !_LIBC).  *//* __HAVE_DISTINCT_FLOAT16 || (__HAVE_FLOAT16 && !_LIBC).  *//* Include the file of declarations for _FloatN and _FloatNx
   types.  *//* !(__NO_LONG_DOUBLE_MATH && _LIBC) || __LDBL_COMPAT *//* Include the file of declarations again, this time using `long double'
   instead of `double' and appending l to each function name.  *//* Include the file of declarations again, this time using `float'
   instead of `double' and appending f to each function name.  *//* The file <bits/mathcalls.h> contains the prototypes for all the
   actual math functions.  These macros are used for those prototypes,
   so we can easily declare each function as both `name' and `__name',
   and can declare the float versions `namef' and `__namef'.  *//* Rounding direction macros for fromfp functions.  *//* Get the architecture specific values describing the floating-point
   evaluation.  The following symbols will get defined:

    FP_FAST_FMA
    FP_FAST_FMAF
    FP_FAST_FMAL
		If defined it indicates that the `fma' function
		generally executes about as fast as a multiply and an add.
		This macro is defined only iff the `fma' function is
		implemented directly with a hardware multiply-add instructions.
*//* Define macros for the return values of ilogb and llogb, based on
   __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.

    FP_ILOGB0	Expands to a value returned by `ilogb (0.0)'.
    FP_ILOGBNAN	Expands to a value returned by `ilogb (NAN)'.
    FP_LLOGB0	Expands to a value returned by `llogb (0.0)'.
    FP_LLOGBNAN	Expands to a value returned by `llogb (NAN)'.

*//* Define the following typedefs.

    float_t	floating-point type at least as wide as `float' used
		to evaluate `float' expressions
    double_t	floating-point type at least as wide as `double' used
		to evaluate `double' expressions
*//* Get __GLIBC_FLT_EVAL_METHOD.  *//* Signaling NaN macros, if supported.  *//* __USE_ISOC99 *//* This will raise an "invalid" exception outside static initializers,
   but is the best that can be done in ISO C while remaining a
   constant expression.  *//* IEEE Not A Number.  *//* IEEE positive infinity.  *//* This may provoke compiler warnings, and may not be rounded to
   +Infinity in all IEEE 754 rounding modes, but is the best that can
   be done in ISO C while remaining a constant expression.  10,000 is
   greater than the maximum (decimal) exponent for all supported
   floating-point formats and widths.  *//* Value returned on overflow.  With IEEE 754 floating point, this is
   +Infinity, otherwise the largest representable positive value.  *//* Gather machine dependent type support.  *//* Get machine-dependent vector math functions declarations.  *//* Get definitions of __intmax_t and __uintmax_t.  *//*
 *	ISO C99 Standard: 7.12 Mathematics	<math.h>
 *//* Declarations for math functions.
   Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/c++/9/tr1/special_function_util.h__euler__gamma_e0.577215664901532860620.5772156649015328606065120900824024L__lnpi1.14472988584940017421.1447298858494001741434273513530587L__sqrt1_2__sqrtpio21.25331413731550025121.2533141373155002512078826424055226L__sqrt3__sqrt2__2_sqrtpi__1_pi__pi_40.785398163397448309630.7853981633974483096156608458198757L__pi_3__pi_21.57079632679489661931.5707963267948966192313216916397514L3.14159265358979323853.1415926535897932384626433832795029L__numeric_constants<_Tp>__floating_point_constant<_Tp>_GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H_GLIBCXX_USE_STD_SPEC_FUNCSdefined(_GLIBCXX_TR1_CMATH)_GLIBCXX_USE_C99_MATH && !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC! _GLIBCXX_USE_STD_SPEC_FUNCS && defined(_GLIBCXX_TR1_CMATH)// _GLIBCXX_TR1_SPECIAL_FUNCTION_UTIL_H// namespace tr1/// std::isnan./// out of intrinsics, this will disappear completely in favor of/// all comparisons result in false. If/when we build a std::isnan/// This is a wrapper for the isnan function. Otherwise, for NaN,///  Constant Euler-Mascheroni @f$ e @f$///  Constant Euler's constant @f$ \gamma_E @f$.///  Constant @f$ \log(\pi) @f$.///  Constant @f$ 1 / sqrt(2) @f$.///  Constant @f$ \sqrt(\pi/2) @f$.///  Constant @f$ \sqrt(3) @f$.///  Constant @f$ \sqrt(2) @f$.///  Constant @f$ 2 / \sqrt(\pi) @f$.///  Constant @f$ 1 / \pi @f$.///  Constant @f$ \pi / 4 @f$.///  Constant @f$ \pi / 3 @f$.///  Constant @f$ \pi / 2 @f$.///  Constant @f$ \pi @f$./// A structure for numeric constants./// type logic./// constants.  Not everything will be able to be expressed as/// A class to encapsulate type dependent floating point// Written by Edward Smith-Rowland based on numerous mathematics books.// ISO C++ 14882 TR1: 5.2  Special functions/** @file tr1/special_function_util.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */// Copyright (C) 2006-2019 Free Software Foundation, Inc.// Special functions -*- C++ -*-/usr/include/c++/9/tr1/usr/include/c++/9/tr1/gamma.tcc<tr1/special_function_util.h>__psi__psi_asymp__psi_series__bincoef__log_bincoef__log_gamma_sign__log_gamma__log_gamma_lanczos__log_gamma_bernoulli__bernoulli__bernoulli_series_GLIBCXX_MATH_NS::std_GLIBCXX_TR1_GAMMA_TCC_GLIBCXX_USE_C99_MATH_TR1"Argument out of range " "in __psi""Argument is nonpositive integer " "in __log_gamma"// _GLIBCXX_TR1_GAMMA_TCC/**
     *   @brief  Return the polygamma function @f$ \psi^{(n)}(x) @f$.
     * 
     *   The polygamma function is related to the Hurwitz zeta function:
     *   @f[
     *     \psi^{(n)}(x) = (-1)^{n+1} m! \zeta(m+1,x)
     *   @f]
     *//**
     *   @brief  Return the digamma function.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *   For negative argument the reflection formula is used:
     *   @f[
     *     \psi(x) = \psi(1-x) - \pi \cot(\pi x)
     *   @f]
     *//**
     *   @brief  Return the digamma function for large argument.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *
     *   The asymptotic series is given by:
     *   @f[
     *     \psi(x) = \ln(x) - \frac{1}{2x}
     *             - \sum_{n=1}^{\infty} \frac{B_{2n}}{2 n x^{2n}}
     *   @f]
     *//**
     *   @brief  Return the digamma function by series expansion.
     *   The digamma or @f$ \psi(x) @f$ function is defined by
     *   @f[
     *     \psi(x) = \frac{\Gamma'(x)}{\Gamma(x)}
     *   @f]
     *
     *   The series is given by:
     *   @f[
     *     \psi(x) = -\gamma_E - \frac{1}{x}
     *              \sum_{k=1}^{\infty} \frac{x}{k(x + k)}
     *   @f]
     *//**
     *   @brief Return \f$ \Gamma(x) \f$.
     *
     *   @param __x The argument of the gamma function.
     *   @return  The gamma function.
     *///  Max e exponent before overflow./**
     *   @brief Return the binomial coefficient.
     *   The binomial coefficient is given by:
     *   @f[
     *   \left(  \right) = \frac{n!}{(n-k)! k!}
     *   @f]
     *
     *   @param __n The first argument of the binomial coefficient.
     *   @param __k The second argument of the binomial coefficient.
     *   @return  The binomial coefficient.
     *//**
     *   @brief Return the logarithm of the binomial coefficient.
     *   The binomial coefficient is given by:
     *   @f[
     *   \left(  \right) = \frac{n!}{(n-k)! k!}
     *   @f]
     *
     *   @param __n The first argument of the binomial coefficient.
     *   @param __k The second argument of the binomial coefficient.
     *   @return  The binomial coefficient.
     *//**
     *   @brief Return the sign of \f$ \Gamma(x) \f$.
     *          At nonpositive integers zero is returned.
     *
     *   @param __x The argument of the gamma function.
     *   @return  The sign of the gamma function.
     *//**
     *   @brief Return \f$ log(|\Gamma(x)|) \f$.
     *          This will return values even for \f$ x < 0 \f$.
     *          To recover the sign of \f$ \Gamma(x) \f$ for
     *          any argument use @a __log_gamma_sign.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief Return \f$log(\Gamma(x))\f$ by the Lanczos method.
     *          This method dominates all others on the positive axis I think.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief Return \f$log(\Gamma(x))\f$ by asymptotic expansion
     *          with Bernoulli number coefficients.  This is like
     *          Sterling's approximation.
     *
     *   @param __x The argument of the log of the gamma function.
     *   @return  The logarithm of the gamma function.
     *//**
     *   @brief This returns Bernoulli number \f$B_n\f$.
     *
     *   @param __n the order n of the Bernoulli number.
     *   @return  The Bernoulli number of order n.
     *///  Take care of some small evens that are painful for the series.//  Take care of the rest of the odd ones./**
     *   @brief This returns Bernoulli numbers from a table or by summation
     *          for larger values.
     *
     *   Recursion is unstable.
     *
     *   @param __n the order n of the Bernoulli number.
     *   @return  The Bernoulli number of order n.
     */// Implementation-space details.//       Princeton, 2003.//   (4) Gamma, Exploring Euler's Constant, Julian Havil,//       2nd ed, pp. 213-216//       W. T. Vetterling, B. P. Flannery, Cambridge University Press (1992),//   (3) Numerical Recipes in C, by W. H. Press, S. A. Teukolsky,//   (2) The Gnu Scientific Library, http://www.gnu.org/software/gsl//       Section 6, pp. 253-266//       Dover Publications,//       ed. Milton Abramowitz and Irene A. Stegun,//   (1) Handbook of Mathematical Functions,// Written by Edward Smith-Rowland based on:/** @file tr1/gamma.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/9/tr1/bessel_function.tcc"Bad argument " "in __sph_neumann."Bad argument in __sph_neumann.const char[31]char[31]__N("Bad argument "
                                      "in __sph_neumann.")quiet_NaNinfinity__j_n__n_n__jp_n__np_n__sph_neumann"Bad argument " "in __sph_bessel."Bad argument in __sph_bessel.__N("Bad argument "
                                      "in __sph_bessel.")__sph_bessel__nu0.50.5L__J_nu__N_nu__Jp_nu__Np_nu__factor__sph_bessel_jn"Bad argument " "in __cyl_neumann_n."Bad argument in __cyl_neumann_n.__N("Bad argument "
                                      "in __cyl_neumann_n.")__cyl_neumann_n"Bad argument " "in __cyl_bessel_j."Bad argument in __cyl_bessel_j.__N("Bad argument "
                                      "in __cyl_bessel_j.")__cyl_bessel_j__x2__fact__xx4__Jn__termepsilon__cyl_bessel_ij_series__mu__8x__P__Q__epsP__epsQ__eps2.02.__chi__coef__cyl_bessel_jn_asymp__fp_min__max_iter15000 15000__x_min__nl1.51.5L__mu2__xi__xi2__w__isign 1"Argument x too large in __bessel_jn; " "try asymptotic expansion."Argument x too large in __bessel_jn; try asymptotic expansion.const char[63]char[63]__N("Argument x too large in __bessel_jn; "
                                       "try asymptotic expansion.")__Jnul__Jpnul__Jnul1__Jpnu1__Jnutemp__Nmu__Nnu1__Npmu__Jmu"Bessel y series failed to converge " "in __bessel_jn.""Lentz's method failed " "in __bessel_jn."__pimu__fact2__gam1__gam2__gampl__gammi__ff__q__pimu2__fact3__sum__sum1__del1Bessel y series failed to converge in __bessel_jn.const char[51]char[51]__N("Bessel y series failed to converge "
                                           "in __bessel_jn.")0.250.25L__br__bi__ci__dr__di__dlr__dli__temp__gamLentz's method failed in __bessel_jn.__N("Lentz's method failed "
                                           "in __bessel_jn.")__Nnutemp__bessel_jn__gamma_temme_GLIBCXX_TR1_BESSEL_FUNCTION_TCC// _GLIBCXX_TR1_BESSEL_FUNCTION_TCC/**
     *   @brief  Return the spherical Neumann function
     *           @f$ n_n(x) @f$.
     *
     *   The spherical Neumann function is defined by:
     *   @f[
     *    n_n(x) = \left( \frac{\pi}{2x} \right) ^{1/2} N_{n+1/2}(x)
     *   @f]
     *
     *   @param  __n  The order of the spherical Neumann function.
     *   @param  __x  The argument of the spherical Neumann function.
     *   @return  The output spherical Neumann function.
     *//**
     *   @brief  Return the spherical Bessel function
     *           @f$ j_n(x) @f$ of order n.
     *
     *   The spherical Bessel function is defined by:
     *   @f[
     *    j_n(x) = \left( \frac{\pi}{2x} \right) ^{1/2} J_{n+1/2}(x)
     *   @f]
     *
     *   @param  __n  The order of the spherical Bessel function.
     *   @param  __x  The argument of the spherical Bessel function.
     *   @return  The output spherical Bessel function.
     *//**
     *   @brief  Compute the spherical Bessel @f$ j_n(x) @f$
     *           and Neumann @f$ n_n(x) @f$ functions and their first
     *           derivatives @f$ j'_n(x) @f$ and @f$ n'_n(x) @f$
     *           respectively.
     *
     *   @param  __n  The order of the spherical Bessel function.
     *   @param  __x  The argument of the spherical Bessel function.
     *   @param  __j_n  The output spherical Bessel function.
     *   @param  __n_n  The output spherical Neumann function.
     *   @param  __jp_n The output derivative of the spherical Bessel function.
     *   @param  __np_n The output derivative of the spherical Neumann function.
     *//**
     *   @brief  Return the Neumann function of order \f$ \nu \f$:
     *           \f$ N_{\nu}(x) \f$.
     *
     *   The Neumann function is defined by:
     *   @f[
     *      N_{\nu}(x) = \frac{J_{\nu}(x) \cos \nu\pi - J_{-\nu}(x)}
     *                        {\sin \nu\pi}
     *   @f]
     *   where for integral \f$ \nu = n \f$ a limit is taken:
     *   \f$ lim_{\nu \to n} \f$.
     *
     *   @param  __nu  The order of the Neumann function.
     *   @param  __x   The argument of the Neumann function.
     *   @return  The output Neumann function.
     *//**
     *   @brief  Return the Bessel function of order \f$ \nu \f$:
     *           \f$ J_{\nu}(x) \f$.
     *
     *   The cylindrical Bessel function is:
     *   @f[
     *    J_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{(-1)^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *
     *   @param  __nu  The order of the Bessel function.
     *   @param  __x   The argument of the Bessel function.
     *   @return  The output Bessel function.
     *//**
     *   @brief This routine returns the cylindrical Bessel functions
     *          of order \f$ \nu \f$: \f$ J_{\nu} \f$ or \f$ I_{\nu} \f$
     *          by series expansion.
     *
     *   The modified cylindrical Bessel function is:
     *   @f[
     *    Z_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{\sigma^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *   where \f$ \sigma = +1 \f$ or\f$  -1 \f$ for
     *   \f$ Z = I \f$ or \f$ J \f$ respectively.
     * 
     *   See Abramowitz & Stegun, 9.1.10
     *       Abramowitz & Stegun, 9.6.7
     *    (1) Handbook of Mathematical Functions,
     *        ed. Milton Abramowitz and Irene A. Stegun,
     *        Dover Publications,
     *        Equation 9.1.10 p. 360 and Equation 9.6.10 p. 375
     *
     *   @param  __nu  The order of the Bessel function.
     *   @param  __x   The argument of the Bessel function.
     *   @param  __sgn  The sign of the alternate terms
     *                  -1 for the Bessel function of the first kind.
     *                  +1 for the modified Bessel function of the first kind.
     *   @return  The output Bessel function.
     *//**
     *   @brief This routine computes the asymptotic cylindrical Bessel
     *          and Neumann functions of order nu: \f$ J_{\nu} \f$,
     *          \f$ N_{\nu} \f$.
     *
     *   References:
     *    (1) Handbook of Mathematical Functions,
     *        ed. Milton Abramowitz and Irene A. Stegun,
     *        Dover Publications,
     *        Section 9 p. 364, Equations 9.2.5-9.2.10
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Jnu  The output Bessel function of the first kind.
     *   @param  __Nnu  The output Neumann function (Bessel function of the second kind).
     *///const _Tp __fp_min = _Tp(20) * std::numeric_limits<_Tp>::min();//  Then J_0 and N_0 tank at x = 8 * N (J_0 = 0 and N_0 = nan)!//  fp_min = N * min()//  When the multiplier is N i.e./**
     *   @brief  Compute the Bessel @f$ J_\nu(x) @f$ and Neumann
     *           @f$ N_\nu(x) @f$ functions and their first derivatives
     *           @f$ J'_\nu(x) @f$ and @f$ N'_\nu(x) @f$ respectively.
     *           These four functions are computed together for numerical
     *           stability.
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Jnu  The output Bessel function of the first kind.
     *   @param  __Nnu  The output Neumann function (Bessel function of the second kind).
     *   @param  __Jpnu  The output derivative of the Bessel function of the first kind.
     *   @param  __Npnu  The output derivative of the Neumann function.
     *//**
     *   @brief Compute the gamma functions required by the Temme series
     *          expansions of @f$ N_\nu(x) @f$ and @f$ K_\nu(x) @f$.
     *   @f[
     *     \Gamma_1 = \frac{1}{2\mu}
     *                [\frac{1}{\Gamma(1 - \mu)} - \frac{1}{\Gamma(1 + \mu)}]
     *   @f]
     *   and
     *   @f[
     *     \Gamma_2 = \frac{1}{2}
     *                [\frac{1}{\Gamma(1 - \mu)} + \frac{1}{\Gamma(1 + \mu)}]
     *   @f]
     *   where @f$ -1/2 <= \mu <= 1/2 @f$ is @f$ \mu = \nu - N @f$ and @f$ N @f$.
     *   is the nearest integer to @f$ \nu @f$.
     *   The values of \f$ \Gamma(1 + \mu) \f$ and \f$ \Gamma(1 - \mu) \f$
     *   are returned as well.
     * 
     *   The accuracy requirements on this are exquisite.
     *
     *   @param __mu     The input parameter of the gamma functions.
     *   @param __gam1   The output function \f$ \Gamma_1(\mu) \f$
     *   @param __gam2   The output function \f$ \Gamma_2(\mu) \f$
     *   @param __gampl  The output function \f$ \Gamma(1 + \mu) \f$
     *   @param __gammi  The output function \f$ \Gamma(1 - \mu) \f$
     */// [5.2] Special functions//       2nd ed, pp. 240-245//       Section 9, pp. 355-434, Section 10 pp. 435-478// References:// Written by Edward Smith-Rowland./* __cyl_bessel_jn_asymp adapted from GNU GSL version 2.4 specfunc/bessel_j.c
 * Copyright (C) 1996-2003 Gerard Jungman
 *//** @file tr1/bessel_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__sgn__Jnu__Nnu__Jpnu__Npnu/usr/include/c++/9/tr1/beta_function.tcc__beta__beta_product__bet__beta_lgamma__beta_gamma_GLIBCXX_TR1_BETA_FUNCTION_TCC// _GLIBCXX_TR1_BETA_FUNCTION_TCC/**
     *   @brief  Return the beta function \f$ B(x,y) \f$.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function \f$B(x,y)\f$ using
     *           the product form.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function \f$B(x,y)\f$ using
     *           the log gamma functions.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//**
     *   @brief  Return the beta function: \f$B(x,y)\f$.
     * 
     *   The beta function is defined by
     *   @f[
     *     B(x,y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
     *   @f]
     *
     *   @param __x The first argument of the beta function.
     *   @param __y The second argument of the beta function.
     *   @return  The beta function.
     *//** @file tr1/beta_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/9/tr1/ell_integral.tcc"Bad argument in __ellint_3."Bad argument in __ellint_3.__N("Bad argument in __ellint_3.")__phi_red__kk__ss__sss__cc__Pi__ellint_3"Bad argument in __comp_ellint_3."Bad argument in __comp_ellint_3.__N("Bad argument in __comp_ellint_3.")__comp_ellint_3__min__max__lolim__uplim0.300000000000000000010.3L0.20.2L"Argument less than zero " "in __ellint_rj.""Argument too small " "in __ellint_rj"Argument less than zero in __ellint_rj.__N("Argument less than zero "
                                      "in __ellint_rj.")Argument too small in __ellint_rj__N("Argument too small "
                                      "in __ellint_rj")__c0__c1__c2__c3__c4__xn__zn__pn__sigma__power4__errtol__lambda__xndev__yndev__zndev__pndev__eaa__eb__ec__e2__e3__s1__s2__s3__epsilon__xnroot__ynroot__znroot__alpha1__alpha2__ellint_rj"Argument less than zero " "in __ellint_rc."Argument less than zero in __ellint_rc.__N("Argument less than zero "
                                      "in __ellint_rc.")__sn__ellint_rc"Bad argument in __ellint_2."Bad argument in __ellint_2.__N("Bad argument in __ellint_2.")__E__ellint_2"Bad argument in __comp_ellint_2."Bad argument in __comp_ellint_2.__N("Bad argument in __comp_ellint_2.")__comp_ellint_20.10.1L"Argument less than zero " "in __ellint_rd.""Argument too small " "in __ellint_rd."Argument less than zero in __ellint_rd.__N("Argument less than zero "
                                      "in __ellint_rd.")Argument too small in __ellint_rd.const char[35]char[35]__N("Argument too small "
                                      "in __ellint_rd.")__ed__ef__ellint_rd__comp_ellint_2_series"Bad argument in __ellint_1."Bad argument in __ellint_1.__N("Bad argument in __ellint_1.")__F__ellint_1__comp_ellint_1__comp_ellint_1_series"Argument less than zero " "in __ellint_rf.""Argument too small in __ellint_rf"Argument less than zero in __ellint_rf.__N("Argument less than zero "
                                      "in __ellint_rf.")Argument too small in __ellint_rf__N("Argument too small in __ellint_rf")__ellint_rf_GLIBCXX_TR1_ELL_INTEGRAL_TCC// _GLIBCXX_TR1_ELL_INTEGRAL_TCC//  Reduce phi to -pi/2 < phi < +pi/2./**
     *   @brief Return the incomplete elliptic integral of the third kind
     *          @f$ \Pi(k,\nu,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the third kind is defined as
     *   @f[
     *     \Pi(k,\nu,\phi) = \int_0^{\phi}
     *                       \frac{d\theta}
     *                            {(1 - \nu \sin^2\theta)
     *                             \sqrt{1 - k^2 \sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __nu  The second argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the third kind.
     *//**
     *   @brief Return the complete elliptic integral of the third kind
     *          @f$ \Pi(k,\nu) = \Pi(k,\nu,\pi/2) @f$ using the
     *          Carlson formulation.
     * 
     *   The complete elliptic integral of the third kind is defined as
     *   @f[
     *     \Pi(k,\nu) = \int_0^{\pi/2}
     *                   \frac{d\theta}
     *                 {(1 - \nu \sin^2\theta)\sqrt{1 - k^2 \sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __nu  The second argument of the elliptic function.
     *   @return  The complete elliptic function of the third kind.
     */// Note: __ea is an SPU badname./**
     *   @brief  Return the Carlson elliptic function @f$ R_J(x,y,z,p) @f$
     *           of the third kind.
     * 
     *   The Carlson elliptic function of the third kind is defined by:
     *   @f[
     *       R_J(x,y,z,p) = \frac{3}{2} \int_0^\infty
     *       \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}(t + p)}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first of three symmetric arguments.
     *   @param  __y  The second of three symmetric arguments.
     *   @param  __z  The third of three symmetric arguments.
     *   @param  __p  The fourth argument.
     *   @return  The Carlson elliptic function of the fourth kind.
     *//**
     *   @brief  Return the Carlson elliptic function
     *           @f$ R_C(x,y) = R_F(x,y,y) @f$ where @f$ R_F(x,y,z) @f$
     *           is the Carlson elliptic function of the first kind.
     * 
     *   The Carlson elliptic function is defined by:
     *   @f[
     *       R_C(x,y) = \frac{1}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first argument.
     *   @param  __y  The second argument.
     *   @return  The Carlson elliptic function.
     *//**
     *   @brief  Return the incomplete elliptic integral of the second kind
     *           @f$ E(k,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\phi) = \int_0^{\phi} \sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the second kind.
     *//**
     *   @brief  Return the complete elliptic integral of the second kind
     *           @f$ E(k) @f$ using the Carlson formulation.
     * 
     *   The complete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the second kind.
     *//**
     *   @brief  Return the Carlson elliptic function of the second kind
     *           @f$ R_D(x,y,z) = R_J(x,y,z,z) @f$ where
     *           @f$ R_J(x,y,z,p) @f$ is the Carlson elliptic function
     *           of the third kind.
     * 
     *   The Carlson elliptic function of the second kind is defined by:
     *   @f[
     *       R_D(x,y,z) = \frac{3}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{3/2}}
     *   @f]
     *
     *   Based on Carlson's algorithms:
     *   -  B. C. Carlson Numer. Math. 33, 1 (1979)
     *   -  B. C. Carlson, Special Functions of Applied Mathematics (1977)
     *   -  Numerical Recipes in C, 2nd ed, pp. 261-269,
     *      by Press, Teukolsky, Vetterling, Flannery (1992)
     *
     *   @param  __x  The first of two symmetric arguments.
     *   @param  __y  The second of two symmetric arguments.
     *   @param  __z  The third argument.
     *   @return  The Carlson elliptic function of the second kind.
     *//**
     *   @brief Return the complete elliptic integral of the second kind
     *          @f$ E(k) @f$ by series expansion.
     * 
     *   The complete elliptic integral of the second kind is defined as
     *   @f[
     *     E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
     *   @f]
     * 
     *   This routine is not bad as long as |k| is somewhat smaller than 1
     *   but is not is good as the Carlson elliptic integral formulation.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the second kind.
     *//**
     *   @brief  Return the incomplete elliptic integral of the first kind
     *           @f$ F(k,\phi) @f$ using the Carlson formulation.
     * 
     *   The incomplete elliptic integral of the first kind is defined as
     *   @f[
     *     F(k,\phi) = \int_0^{\phi}\frac{d\theta}
     *                                   {\sqrt{1 - k^2 sin^2\theta}}
     *   @f]
     * 
     *   @param  __k  The argument of the elliptic function.
     *   @param  __phi  The integral limit argument of the elliptic function.
     *   @return  The elliptic function of the first kind.
     *//**
     *   @brief  Return the complete elliptic integral of the first kind
     *           @f$ K(k) @f$ using the Carlson formulation.
     * 
     *   The complete elliptic integral of the first kind is defined as
     *   @f[
     *     K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
     *                                           {\sqrt{1 - k^2 sin^2\theta}}
     *   @f]
     *   where @f$ F(k,\phi) @f$ is the incomplete elliptic integral of the
     *   first kind.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the first kind.
     *//**
     *   @brief Return the complete elliptic integral of the first kind
     *          @f$ K(k) @f$ by series expansion.
     * 
     *   The complete elliptic integral of the first kind is defined as
     *   @f[
     *     K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
     *                              {\sqrt{1 - k^2sin^2\theta}}
     *   @f]
     * 
     *   This routine is not bad as long as |k| is somewhat smaller than 1
     *   but is not is good as the Carlson elliptic integral formulation.
     * 
     *   @param  __k  The argument of the complete elliptic function.
     *   @return  The complete elliptic function of the first kind.
     *//**
     *   @brief Return the Carlson elliptic function @f$ R_F(x,y,z) @f$
     *          of the first kind.
     * 
     *   The Carlson elliptic function of the first kind is defined by:
     *   @f[
     *       R_F(x,y,z) = \frac{1}{2} \int_0^\infty
     *                 \frac{dt}{(t + x)^{1/2}(t + y)^{1/2}(t + z)^{1/2}}
     *   @f]
     *
     *   @param  __x  The first of three symmetric arguments.
     *   @param  __y  The second of three symmetric arguments.
     *   @param  __z  The third of three symmetric arguments.
     *   @return  The Carlson elliptic function of the first kind.
     *///        (1992), pp. 261-269//        W. T. Vetterling, B. P. Flannery, Cambridge University Press//   (4)  Numerical Recipes in C, 2nd ed, by W. H. Press, S. A. Teukolsky,//   (3)  The Gnu Scientific Library, http://www.gnu.org/software/gsl//   (2)  B. C. Carlson, Special Functions of Applied Mathematics (1977)//   (1)  B. C. Carlson Numer. Math. 33, 1 (1979)/** @file tr1/ell_integral.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__phi/usr/include/c++/9/tr1/exp_integral.tcc__expint__expint_large_n__expint_asymp__expint_Ei__expint_Ei_asymp__expint_Ei_series__expint_En_recursion__nm1__ans"Continued fraction failed " "in __expint_En_cont_frac."Continued fraction failed in __expint_En_cont_frac.const char[52]char[52]__N("Continued fraction failed "
                                     "in __expint_En_cont_frac.")__expint_En_cont_frac__expint_En_series__esum__osum__expint_E1_asymp__expint_E1_series__expint_E1_GLIBCXX_TR1_EXP_INTEGRAL_TCC"Series summation failed " "in __expint_En_series."// _GLIBCXX_TR1_EXP_INTEGRAL_TCC/**
     *   @brief Return the exponential integral @f$ Ei(x) @f$.
     * 
     *   The exponential integral is given by
     *   \f[
     *     Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *   \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  Return NaN on NaN input./**
     *   @brief Return the exponential integral @f$ E_n(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          for large order.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     *        
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          for large argument.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   This is something of an extension.
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  TODO: Find a good asymptotic switch point./**
     *   @brief Return the exponential integral @f$ E_1(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^\infty \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$
     *          by asymptotic expansion.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ Ei(x) @f$
     *          by series summation.
     * 
     *   The exponential integral is given by
     *          \f[
     *            Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///  TODO: Check this starting number.//  Backward recursion is stable only for n >= x.//  Forward recursion is stable only for n < x./**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by recursion.  Use upward recursion for @f$ x < n @f$
     *          and downward recursion (Miller's algorithm) otherwise.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by continued fractions.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_n(x) @f$
     *          by series summation.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_n(x) = \int_{1}^\infty \frac{e^{-xt}}{t^n} dt
     *          \f]
     * 
     *   @param  __n  The order of the exponential integral function.
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_1(x) @f$
     *          by asymptotic expansion.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^\infty \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *//**
     *   @brief Return the exponential integral @f$ E_1(x) @f$
     *          by series summation.  This should be good
     *          for @f$ x < 1 @f$.
     * 
     *   The exponential integral is given by
     *          \f[
     *            E_1(x) = \int_{1}^{\infty} \frac{e^{-xt}}{t} dt
     *          \f]
     * 
     *   @param  __x  The argument of the exponential integral function.
     *   @return  The exponential integral.
     *///       2nd ed, pp. 222-225.//       Dover Publications, New-York, Section 5, pp. 228-251.//       Ed. by Milton Abramowitz and Irene A. Stegun,//  Written by Edward Smith-Rowland based on:/** @file tr1/exp_integral.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/9/tr1/hypergeometric.tcc__hyperg__hyperg_reflect__hyperg_luke__hyperg_series__conf_hyperg__conf_hyperg_luke__conf_hyperg_series_GLIBCXX_TR1_HYPERGEOMETRIC_TCC"Argument outside unit circle " "in __hyperg.""Underflow of gamma functions " "in __hyperg_reflect""Overflow of gamma functions " "in __hyperg_reflect""Sum F2 failed to converge " "in __hyperg_reflect""Overflow of gamma functions" " in __hyperg_luke.""Iteration failed to converge " "in __hyperg_luke.""Series failed to converge " "in __hyperg_series.""Iteration failed to converge " "in __conf_hyperg_luke.""Series failed to converge " "in __conf_hyperg_series."// _GLIBCXX_TR1_HYPERGEOMETRIC_TCC//  finite polynomial.//  For integer a and b the hypergeometric function is a/**
     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$.
     *
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     *
     *   @param  __a  The first @a numerator parameter.
     *   @param  __a  The second @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *///  catch their harmless domain errors and set the terms to zero.//  These gamma functions appear in the denominator, so we//  d = c - a - b not an integer.// end F2 evaluation// So the F2 term is zero.// Gamma functions in the denominator not ok.//  Abramowitz & Stegun 6.3.5//  Values for psi functions use recurrence;// Do F2 sum.//  Proceed with evaluation.//  Gamma functions in the denominator are ok.// Evaluate F2.// end F1 evaluation//  So the F1 term is zero.//  Gamma functions in the denominator were not ok./* Do F1 sum.
                   *//* Gamma functions in the denominator are ok.
                   * Proceed with evaluation.
                   *///  d = c - a - b = 0.//  Evaluate F1./**
     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$ 
     *  by the reflection formulae in Abramowitz & Stegun formula
     *  15.3.6 for d = c - a - b not integral and formula 15.3.11 for
     *  d = c - a - b integral.  This assumes a, b, c != negative
     *  integer.
     *
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     *
     *   The reflection formula for nonintegral @f$ d = c - a - b @f$ is:
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)\Gamma(d)}{\Gamma(c-a)\Gamma(c-b)}
     *                            _2F_1(a,b;1-d;1-x)
     *                    + \frac{\Gamma(c)\Gamma(-d)}{\Gamma(a)\Gamma(b)}
     *                            _2F_1(c-a,c-b;1+d;1-x)
     *   @f]
     *
     *   The reflection formula for integral @f$ m = c - a - b @f$ is:
     *   @f[
     *     _2F_1(a,b;a+b+m;x) = \frac{\Gamma(m)\Gamma(a+b+m)}{\Gamma(a+m)\Gamma(b+m)}
     *                        \sum_{k=0}^{m-1} \frac{(m+a)_k(m+b)_k}{k!(1-m)_k}
     *                      - 
     *   @f]
     *//**
     *   @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *           by an iterative procedure described in
     *           Luke, Algorithms for the Computation of Mathematical Functions.
     *//**
     *   @brief Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *   by series expansion.
     * 
     *   The hypogeometric function is defined by
     *   @f[
     *     _2F_1(a,b;c;x) = \frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     * 
     *   This works and it's pretty fast.
     *
     *   @param  __a  The first @a numerator parameter.
     *   @param  __a  The second @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *//**
     *   @brief  Return the confluent hypogeometric function
     *           @f$ _1F_1(a;c;x) @f$.
     * 
     *   @todo  Handle b == nonpositive integer blowup - return NaN.
     *
     *   @param  __a  The @a numerator parameter.
     *   @param  __c  The @a denominator parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *//**
     *  @brief  Return the hypogeometric function @f$ _2F_1(a,b;c;x) @f$
     *          by an iterative procedure described in
     *          Luke, Algorithms for the Computation of Mathematical Functions.
     *
     *  Like the case of the 2F1 rational approximations, these are 
     *  probably guaranteed to converge for x < 0, barring gross    
     *  numerical instability in the pre-asymptotic regime.         
     *//**
     *   @brief This routine returns the confluent hypergeometric function
     *          by series expansion.
     * 
     *   @f[
     *     _1F_1(a;c;x) = \frac{\Gamma(c)}{\Gamma(a)}
     *                      \sum_{n=0}^{\infty}
     *                      \frac{\Gamma(a+n)}{\Gamma(c+n)}
     *                      \frac{x^n}{n!}
     *   @f]
     * 
     *   If a and b are integers and a < 0 and either b > 0 or b < a
     *   then the series is a polynomial with a finite number of
     *   terms.  If b is an integer and b <= 0 the confluent
     *   hypergeometric function is undefined.
     *
     *   @param  __a  The "numerator" parameter.
     *   @param  __c  The "denominator" parameter.
     *   @param  __x  The argument of the confluent hypergeometric function.
     *   @return  The confluent hypergeometric function.
     *///       Section 6, pp. 555-566// Written by Edward Smith-Rowland based:/** @file tr1/hypergeometric.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__xin/usr/include/c++/9/tr1/legendre_function.tcc__y_mp1m_factor__lncirc__lnpoch__lnpre_val__sr__y_mm__y_mp1m__y_lm__ll__rat1__rat2__fact1__sph_legendre__p_mm__p_mp1m__p_lm2m__P_lm1m__p_lm__assoc_legendre_p__p_lm2__p_lm1__p_l__poly_legendre_p_GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC// _GLIBCXX_TR1_LEGENDRE_FUNCTION_TCC// Compute Y_l^m, l > m+1, upward recursion on l.//  Gamma(m+1/2) / Gamma(m)//             (-1)^m (1-x^2)^(m/2) / pi^(1/4)// Y_m^m(x) = sqrt( (2m+1)/(4pi m) gamma(m+1/2)/gamma(m) )// Starting value for recursion.// m > 0 and |x| < 1 here//  m > 0 here/**
     *   @brief  Return the spherical associated Legendre function.
     * 
     *   The spherical associated Legendre function of @f$ l @f$, @f$ m @f$,
     *   and @f$ \theta @f$ is defined as @f$ Y_l^m(\theta,0) @f$ where
     *   @f[
     *      Y_l^m(\theta,\phi) = (-1)^m[\frac{(2l+1)}{4\pi}
     *                                  \frac{(l-m)!}{(l+m)!}]
     *                     P_l^m(\cos\theta) \exp^{im\phi}
     *   @f]
     *   is the spherical harmonic function and @f$ P_l^m(x) @f$ is the
     *   associated Legendre function.
     * 
     *   This function differs from the associated Legendre function by
     *   argument (@f$x = \cos(\theta)@f$) and by a normalization factor
     *   but this factor is rather large for large @f$ l @f$ and @f$ m @f$
     *   and so this function is stable for larger differences of @f$ l @f$
     *   and @f$ m @f$.
     *   @note Unlike the case for __assoc_legendre_p the Condon-Shortley
     *         phase factor @f$ (-1)^m @f$ is present here.
     *   @note @f$ Y_l^m(\theta) = 0 @f$ if @f$ m > l @f$.
     * 
     *   @param  l  The degree of the spherical associated Legendre function.
     *              @f$ l >= 0 @f$.
     *   @param  m  The order of the spherical associated Legendre function.
     *   @param  theta  The radian angle argument of the spherical associated
     *                  Legendre function.
     *///  than just one.//  Two square roots seem more accurate more of the time/**
     *   @brief  Return the associated Legendre function by recursion
     *           on @f$ l @f$.
     * 
     *   The associated Legendre function is derived from the Legendre function
     *   @f$ P_l(x) @f$ by the Rodrigues formula:
     *   @f[
     *     P_l^m(x) = (1 - x^2)^{m/2}\frac{d^m}{dx^m}P_l(x)
     *   @f]
     *   @note @f$ P_l^m(x) = 0 @f$ if @f$ m > l @f$.
     * 
     *   @param  l  The degree of the associated Legendre function.
     *              @f$ l >= 0 @f$.
     *   @param  m  The order of the associated Legendre function.
     *   @param  x  The argument of the associated Legendre function.
     *              @f$ |x| <= 1 @f$.
     *   @param  phase  The phase of the associated Legendre function.
     *                  Use -1 for the Condon-Shortley phase convention.
     *///  protection, Arfken, 2nd Ed, Eq 12.17a.//  This arrangement is supposed to be better for roundoff/**
     *   @brief  Return the Legendre polynomial by recursion on degree
     *           @f$ l @f$.
     * 
     *   The Legendre function of @f$ l @f$ and @f$ x @f$,
     *   @f$ P_l(x) @f$, is defined by:
     *   @f[
     *     P_l(x) = \frac{1}{2^l l!}\frac{d^l}{dx^l}(x^2 - 1)^{l}
     *   @f]
     * 
     *   @param  l  The degree of the Legendre polynomial.  @f$l >= 0@f$.
     *   @param  x  The argument of the Legendre polynomial.  @f$|x| <= 1@f$.
     *///       2nd ed, pp. 252-254//       Section 8, pp. 331-341/** @file tr1/legendre_function.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__theta__phase/usr/include/c++/9/tr1/modified_bessel_func.tcc__airy__sph_bessel_ik"Bad argument " "in __cyl_bessel_k."Bad argument in __cyl_bessel_k.__N("Bad argument "
                                      "in __cyl_bessel_k.")__I_nu__K_nu__Ip_nu__Kp_nu__cyl_bessel_k"Bad argument " "in __cyl_bessel_i."Bad argument in __cyl_bessel_i.__N("Bad argument "
                                      "in __cyl_bessel_i.")__cyl_bessel_i"Argument x too large " "in __bessel_ik; " "try asymptotic expansion."Argument x too large in __bessel_ik; try asymptotic expansion.__N("Argument x too large "
                                       "in __bessel_ik; "
                                       "try asymptotic expansion.")__Inul__Ipnul__Inul1__Ipnu1__Inutemp__Kmu__Knu1"Bessel k series failed to converge " "in __bessel_ik.""Steed's method failed " "in __bessel_ik."Bessel k series failed to converge in __bessel_ik.__N("Bessel k series failed to converge "
                                           "in __bessel_ik.")__delh__q1__q2__qnew__delsSteed's method failed in __bessel_ik.__N("Steed's method failed "
                                           "in __bessel_ik.")__Kpmu__Inumu__Knutemp__bessel_ik_GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC// _GLIBCXX_TR1_MODIFIED_BESSEL_FUNC_TCC//  The number is Ai'(0) = -3^{-1/3}/\Gamma(1/3).//    Abramowitz & Stegun, page 446 section 10.4.5 on Airy functions.//  Reference://  The number is Ai(0) = 3^{-2/3}/\Gamma(2/3).//    Abramowitz & Stegun, page 446 section 10.4.4 on Airy functions./**
     *   @brief  Compute the Airy functions
     *           @f$ Ai(x) @f$ and @f$ Bi(x) @f$ and their first
     *           derivatives @f$ Ai'(x) @f$ and @f$ Bi(x) @f$
     *           respectively.
     *
     *   @param  __x  The argument of the Airy functions.
     *   @param  __Ai  The output Airy function of the first kind.
     *   @param  __Bi  The output Airy function of the second kind.
     *   @param  __Aip  The output derivative of the Airy function
     *                  of the first kind.
     *   @param  __Bip  The output derivative of the Airy function
     *                  of the second kind.
     *//**
     *   @brief  Compute the spherical modified Bessel functions
     *           @f$ i_n(x) @f$ and @f$ k_n(x) @f$ and their first
     *           derivatives @f$ i'_n(x) @f$ and @f$ k'_n(x) @f$
     *           respectively.
     *
     *   @param  __n  The order of the modified spherical Bessel function.
     *   @param  __x  The argument of the modified spherical Bessel function.
     *   @param  __i_n  The output regular modified spherical Bessel function.
     *   @param  __k_n  The output irregular modified spherical
     *                  Bessel function.
     *   @param  __ip_n  The output derivative of the regular modified
     *                   spherical Bessel function.
     *   @param  __kp_n  The output derivative of the irregular modified
     *                   spherical Bessel function.
     *//**
     *   @brief  Return the irregular modified Bessel function
     *           \f$ K_{\nu}(x) \f$ of order \f$ \nu \f$.
     *
     *   The irregular modified Bessel function is defined by:
     *   @f[
     *      K_{\nu}(x) = \frac{\pi}{2}
     *                   \frac{I_{-\nu}(x) - I_{\nu}(x)}{\sin \nu\pi}
     *   @f]
     *   where for integral \f$ \nu = n \f$ a limit is taken:
     *   \f$ lim_{\nu \to n} \f$.
     *
     *   @param  __nu  The order of the irregular modified Bessel function.
     *   @param  __x   The argument of the irregular modified Bessel function.
     *   @return  The output irregular modified Bessel function.
     *//**
     *   @brief  Return the regular modified Bessel function of order
     *           \f$ \nu \f$: \f$ I_{\nu}(x) \f$.
     *
     *   The regular modified cylindrical Bessel function is:
     *   @f[
     *    I_{\nu}(x) = \sum_{k=0}^{\infty}
     *              \frac{(x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
     *   @f]
     *
     *   @param  __nu  The order of the regular modified Bessel function.
     *   @param  __x   The argument of the regular modified Bessel function.
     *   @return  The output regular modified Bessel function.
     *//**
     *   @brief  Compute the modified Bessel functions @f$ I_\nu(x) @f$ and
     *           @f$ K_\nu(x) @f$ and their first derivatives
     *           @f$ I'_\nu(x) @f$ and @f$ K'_\nu(x) @f$ respectively.
     *           These four functions are computed together for numerical
     *           stability.
     *
     *   @param  __nu  The order of the Bessel functions.
     *   @param  __x   The argument of the Bessel functions.
     *   @param  __Inu  The output regular modified Bessel function.
     *   @param  __Knu  The output irregular modified Bessel function.
     *   @param  __Ipnu  The output derivative of the regular
     *                   modified Bessel function.
     *   @param  __Kpnu  The output derivative of the irregular
     *                   modified Bessel function.
     *///       2nd ed, pp. 246-249.//       Ed. Milton Abramowitz and Irene A. Stegun,/** @file tr1/modified_bessel_func.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 */__Ai__Bi__Aip__Bip__i_n__k_n__ip_n__kp_n__Inu__Knu__Ipnu__Kpnu/usr/include/c++/9/tr1/poly_hermite.tcc__poly_hermite__H_0__H_1__H_n__H_nm1__H_nm2__poly_hermite_recursion_GLIBCXX_TR1_POLY_HERMITE_TCC// _GLIBCXX_TR1_POLY_HERMITE_TCC/**
     *   @brief This routine returns the Hermite polynomial
     *          of order n: \f$ H_n(x) \f$.
     * 
     *   The Hermite polynomial is defined by:
     *   @f[
     *     H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
     *   @f]
     *
     *   @param __n The order of the Hermite polynomial.
     *   @param __x The argument of the Hermite polynomial.
     *   @return The value of the Hermite polynomial of order n
     *           and argument x.
     *///  Compute H_n.//  Compute H_1.//  Compute H_0./**
     *   @brief This routine returns the Hermite polynomial
     *          of order n: \f$ H_n(x) \f$ by recursion on n.
     * 
     *   The Hermite polynomial is defined by:
     *   @f[
     *     H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
     *   @f]
     *
     *   @param __n The order of the Hermite polynomial.
     *   @param __x The argument of the Hermite polynomial.
     *   @return The value of the Hermite polynomial of order n
     *           and argument x.
     *///       Dover Publications, Section 22 pp. 773-802/** @file tr1/poly_hermite.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/9/tr1/poly_laguerre.tcc__laguerre__assoc_laguerre"Negative argument " "in __poly_laguerre."Negative argument in __poly_laguerre.__N("Negative argument "
                                      "in __poly_laguerre.")_Tpa__prod10000000__poly_laguerre__l_0__l_1__l_n2__l_n1__l_n__nn__poly_laguerre_recursion__mx__tc_sgn__tc__ax__poly_laguerre_hyperg__eta__cos2th__sin2th__th__pre_h__lg_b__lnfact__pre_term1__pre_term2__lnpre__ser_term1__ser_term2__ser__poly_laguerre_large_n_GLIBCXX_TR1_POLY_LAGUERRE_TCC// _GLIBCXX_TR1_POLY_LAGUERRE_TCC/**
     *   @brief This routine returns the Laguerre polynomial
     *          of order n: @f$ L_n(x) @f$.
     *
     *   The Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre polynomial.
     *   @param __x The argument of the Laguerre polynomial.
     *   @return The value of the Laguerre polynomial of order n
     *           and argument x.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial
     *          of order n, degree m: @f$ L_n^m(x) @f$.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre polynomial.
     *   @param __m The degree of the Laguerre polynomial.
     *   @param __x The argument of the Laguerre polynomial.
     *   @return The value of the associated Laguerre polynomial of order n,
     *           degree m, and argument x.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial
     *          of order n, degree @f$ \alpha @f$: @f$ L_n^alpha(x) @f$.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *///  Compute l_n^alpha by recursion on n.//  Compute l_1^alpha.//   Compute l_0./**
     *   @brief This routine returns the associated Laguerre polynomial 
     *          of order @f$ n @f$, degree @f$ \alpha @f$: @f$ L_n^\alpha(x) @f$
     *          by recursion.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *   The associated Laguerre polynomial is defined for integral
     *   @f$ \alpha = m @f$ by:
     *   @f[
     *       L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
     *   @f]
     *   where the Laguerre polynomial is defined by:
     *   @f[
     *       L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
     *   @f]
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *///  Get |x|^n/n!/**
     *  @brief  Evaluate the polynomial based on the confluent hypergeometric
     *          function in a safe way, with no restriction on the arguments.
     *
     *   The associated Laguerre function is defined by
     *   @f[
     *       L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
     *                       _1F_1(-n; \alpha + 1; x)
     *   @f]
     *   where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
     *   @f$ _1F_1(a; c; x) @f$ is the confluent hypergeometric function.
     *
     *  This function assumes x != 0.
     *
     *  This is from the GNU Scientific Library.
     *//**
     *   @brief This routine returns the associated Laguerre polynomial 
     *          of order @f$ n @f$, degree @f$ \alpha @f$ for large n.
     *   Abramowitz & Stegun, 13.5.21
     *
     *   @param __n The order of the Laguerre function.
     *   @param __alpha The degree of the Laguerre function.
     *   @param __x The argument of the Laguerre function.
     *   @return The value of the Laguerre function of order n,
     *           degree @f$ \alpha @f$, and argument x.
     *
     *  This is from the GNU Scientific Library.
     *///       Section 13, pp. 509-510, Section 22 pp. 773-802/** @file tr1/poly_laguerre.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/9/tr1/riemann_zeta.tcc__hurwitz_zeta__hurwitz_zeta_glob__zeta__glob__riemann_zeta__prime__num_primesconst _Tp[29]_Tp[29]__riemann_zeta_product__max_bincoeffmax_exponent10__maxit__punt__bincoeff__riemann_zeta_glob__riemann_zeta_alt"Bad argument in zeta sum."Bad argument in zeta sum.__N("Bad argument in zeta sum.")max_iter__riemann_zeta_sum_GLIBCXX_TR1_RIEMANN_ZETA_TCC// _GLIBCXX_TR1_RIEMANN_ZETA_TCC/**
     *   @brief  Return the Hurwitz zeta function @f$ \zeta(x,s) @f$
     *           for all s != 1 and x > -1.
     * 
     *   The Hurwitz zeta function is defined by:
     *   @f[
     *     \zeta(x,s) = \sum_{n=0}^{\infty} \frac{1}{(n + x)^s}
     *   @f]
     *   The Riemann zeta function is a special case:
     *   @f[
     *     \zeta(s) = \zeta(1,s)
     *   @f]
     *///  This only gets hit for x << 0./**
     *   @brief  Return the Hurwitz zeta function @f$ \zeta(x,s) @f$
     *           for all s != 1 and x > -1.
     * 
     *   The Hurwitz zeta function is defined by:
     *   @f[
     *     \zeta(x,s) = \sum_{n=0}^{\infty} \frac{1}{(n + x)^s}
     *   @f]
     *   The Riemann zeta function is a special case:
     *   @f[
     *     \zeta(s) = \zeta(1,s)
     *   @f]
     * 
     *   This functions uses the double sum that converges for s != 1
     *   and x > -1:
     *   @f[
     *     \zeta(x,s) = \frac{1}{s-1}
     *                \sum_{n=0}^{\infty} \frac{1}{n + 1}
     *                \sum_{k=0}^{n} (-1)^k \frac{n!}{(n-k)!k!} (x+k)^{-s}
     *   @f]
     *///  Global double sum or McLaurin?/**
     *   @brief  Return the Riemann zeta function @f$ \zeta(s) @f$.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} k^{-s} for s > 1
     *                 \frac{(2\pi)^s}{pi} sin(\frac{\pi s}{2})
     *                 \Gamma (1 - s) \zeta (1 - s) for s < 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *//**
     *   @brief  Compute the Riemann zeta function @f$ \zeta(s) @f$
     *           using the product over prime factors.
     *    \f[
     *      \zeta(s) = \Pi_{i=1}^\infty \frac{1}{1 - p_i^{-s}}
     *    \f]
     *    where @f$ {p_i} @f$ are the prime numbers.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///  so use reflection.//  This series works until the binomial coefficient blows up/**
     *   @brief  Evaluate the Riemann zeta function by series for all s != 1.
     *           Convergence is great until largish negative numbers.
     *           Then the convergence of the > 0 sum gets better.
     *
     *   The series is:
     *    \f[
     *      \zeta(s) = \frac{1}{1-2^{1-s}}
     *                 \sum_{n=0}^{\infty} \frac{1}{2^{n+1}}
     *                 \sum_{k=0}^{n} (-1)^k \frac{n!}{(n-k)!k!} (k+1)^{-s}
     *    \f]
     *   Havil 2003, p. 206.
     *
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *//**
     *   @brief  Evaluate the Riemann zeta function @f$ \zeta(s) @f$
     *           by an alternate series for s > 0.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///  A user shouldn't get to this./**
     *   @brief  Compute the Riemann zeta function @f$ \zeta(s) @f$
     *           by summation for s > 1.
     * 
     *   The Riemann zeta function is defined by:
     *    \f[
     *      \zeta(s) = \sum_{k=1}^{\infty} \frac{1}{k^{s}} for s > 1
     *    \f]
     *   For s < 1 use the reflection formula:
     *    \f[
     *      \zeta(s) = 2^s \pi^{s-1} \Gamma(1-s) \zeta(1-s)
     *    \f]
     *///   (3) Gamma, Exploring Euler's Constant, Julian Havil,//       Dover Publications, New-York, Section 5, pp. 807-808./** @file tr1/riemann_zeta.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{tr1/cmath}
 *//usr/include/c++/9/bits/specfun.h<tr1/riemann_zeta.tcc><tr1/poly_laguerre.tcc><tr1/poly_hermite.tcc><tr1/modified_bessel_func.tcc><tr1/legendre_function.tcc><tr1/hypergeometric.tcc><tr1/exp_integral.tcc><tr1/ell_integral.tcc><tr1/beta_function.tcc><tr1/bessel_function.tcc><tr1/gamma.tcc>sph_neumannsph_neumannlsph_neumannfsph_legendresph_legendrelsph_legendrefsph_besselsph_bessellsph_besselfriemann_zetariemann_zetalriemann_zetaflegendrelegendrellegendreflaguerrelaguerrellaguerrefhermitehermitelhermitefexpintexpintlexpintfellint_3_Tpn_Tppellint_3lellint_3fellint_2ellint_2lellint_2fellint_1ellint_1lellint_1fcyl_neumann_Tpnucyl_neumannlcyl_neumannfcyl_bessel_kcyl_bessel_klcyl_bessel_kfcyl_bessel_jcyl_bessel_jlcyl_bessel_jfcyl_bessel_icyl_bessel_ilcyl_bessel_ifcomp_ellint_3comp_ellint_3lcomp_ellint_3fcomp_ellint_2comp_ellint_2lcomp_ellint_2fcomp_ellint_1comp_ellint_1lcomp_ellint_1fbeta_Tpbbetalbetafassoc_legendreassoc_legendrelassoc_legendrefassoc_laguerreassoc_laguerrelassoc_laguerref__cpp_lib_math_special_functions201603L__STDCPP_MATH_SPEC_FUNCS__201003L_GLIBCXX_BITS_SPECFUN_HGCC visibility push(default)__cplusplus <= 201403L && __STDCPP_WANT_MATH_SPEC_FUNCS__ == 0GCC visibility pop// _GLIBCXX_BITS_SPECFUN_H// __STRICT_ANSI__// namespace __gnu_cxx/**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of real numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * The hypergeometric function is defined by
   * @f[
   *    {}_2F_1(a;c;x) = \sum_{n=0}^{\infty} \frac{(a)_n (b)_n x^n}{(c)_n n!}
   * @f]
   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,
   * @f$ (x)_0 = 1 @f$
   *
   * @param __a The first numeratorial parameter
   * @param __b The second numeratorial parameter
   * @param __c The denominatorial parameter
   * @param __x The argument
   *//**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of <tt>long double</tt> numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see hyperg for details.
   *//**
   * Return the hypergeometric function @f$ {}_2F_1(a,b;c;x) @f$
   * of @ float numeratorial parameters @c a and @c b,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see hyperg for details.
   */// Hypergeometric functions/**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of real numeratorial parameter @c a, denominatorial parameter @c c,
   * and argument @c x.
   *
   * The confluent hypergeometric function is defined by
   * @f[
   *    {}_1F_1(a;c;x) = \sum_{n=0}^{\infty} \frac{(a)_n x^n}{(c)_n n!}
   * @f]
   * where the Pochhammer symbol is @f$ (x)_k = (x)(x+1)...(x+k-1) @f$,
   * @f$ (x)_0 = 1 @f$
   *
   * @param __a The numeratorial parameter
   * @param __c The denominatorial parameter
   * @param __x The argument
   *//**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of <tt>long double</tt> numeratorial parameter @c a,
   * denominatorial parameter @c c, and argument @c x.
   *
   * @see conf_hyperg for details.
   *//**
   * Return the confluent hypergeometric function @f$ {}_1F_1(a;c;x) @f$
   * of @c float numeratorial parameter @c a, denominatorial parameter @c c,
   * and argument @c x.
   *
   * @see conf_hyperg for details.
   */// Confluent hypergeometric functions/**
   * Return the Airy function @f$ Bi(x) @f$ of real argument x.
   *//**
   * Return the Airy function @f$ Bi(x) @f$ of <tt>long double</tt> argument x.
   *//**
   * Return the Airy function @f$ Bi(x) @f$ of @c float argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of real argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of <tt>long double</tt> argument x.
   *//**
   * Return the Airy function @f$ Ai(x) @f$ of @c float argument x.
   */// Airy functions/// @} group mathsf/**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and real argument @f$ x >= 0 @f$.
   *
   * The spherical Neumann function is defined by
   * @f[
   *    n_n(x) = \left(\frac{\pi}{2x} \right) ^{1/2} N_{n+1/2}(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __n  The integral order <tt> n >= 0 </tt>
   * @param  __x  The real argument <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and <tt>long double</tt> @f$ x >= 0 @f$.
   *
   * @see sph_neumann for details.
   *//**
   * Return the spherical Neumann function of integral order @f$ n >= 0 @f$
   * and @c float argument @f$ x >= 0 @f$.
   *
   * @see sph_neumann for details.
   */// Spherical Neumann functions/**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and real angle @f$ \theta @f$ in radians.
   *
   * The spherical Legendre function is defined by
   * @f[
   *  Y_l^m(\theta,\phi) = (-1)^m[\frac{(2l+1)}{4\pi}
   *                              \frac{(l-m)!}{(l+m)!}]
   *                   P_l^m(\cos\theta) \exp^{im\phi}
   * @f]
   *
   * @tparam _Tp The floating-point type of the angle @c __theta.
   * @param __l The order <tt> __l >= 0 </tt>
   * @param __m The degree <tt> __m >= 0 </tt> and <tt> __m <= __l </tt>
   * @param __theta The radian polar angle argument
   *//**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and <tt>long double</tt> angle @f$ \theta @f$
   * in radians.
   *
   * @see sph_legendre for details.
   *//**
   * Return the spherical Legendre function of nonnegative integral
   * degree @c l and order @c m and float angle @f$ \theta @f$ in radians.
   *
   * @see sph_legendre for details.
   */// Spherical associated Legendre functions/**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and real argument @f$ x >= 0 @f$.
   *
   * The spherical Bessel function is defined by:
   * @f[
   *  j_n(x) = \left(\frac{\pi}{2x} \right) ^{1/2} J_{n+1/2}(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __n  The integral order <tt> n >= 0 </tt>
   * @param  __x  The real argument <tt> x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and <tt>long double</tt> argument @f$ x >= 0 @f$.
   *
   * @see sph_bessel for more details.
   *//**
   * Return the spherical Bessel function @f$ j_n(x) @f$ of nonnegative order n
   * and @c float argument @f$ x >= 0 @f$.
   *
   * @see sph_bessel for more details.
   */// Spherical Bessel functions/**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for real argument @f$ s @f$.
   *
   * The Riemann zeta function is defined by:
   * @f[
   * 	\zeta(s) = \sum_{k=1}^{\infty} k^{-s} \hbox{ for } s > 1
   * @f]
   * and
   * @f[
   * 	\zeta(s) = \frac{1}{1-2^{1-s}}\sum_{k=1}^{\infty}(-1)^{k-1}k^{-s}
   *              \hbox{ for } 0 <= s <= 1
   * @f]
   * For s < 1 use the reflection formula:
   * @f[
   * 	\zeta(s) = 2^s \pi^{s-1} \sin(\frac{\pi s}{2}) \Gamma(1-s) \zeta(1-s)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __s.
   * @param __s The argument <tt> s != 1 </tt>
   *//**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for <tt>long double</tt> argument @f$ s @f$.
   *
   * @see riemann_zeta for more details.
   *//**
   * Return the Riemann zeta function @f$ \zeta(s) @f$
   * for @c float argument @f$ s @f$.
   *
   * @see riemann_zeta for more details.
   */// Riemann zeta functions/**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and real argument @f$ |x| <= 0 @f$.
   *
   * The Legendre function of order @f$ l @f$ and argument @f$ x @f$,
   * @f$ P_l(x) @f$, is defined by:
   * @f[
   *   P_l(x) = \frac{1}{2^l l!}\frac{d^l}{dx^l}(x^2 - 1)^{l}
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __l The degree @f$ l >= 0 @f$
   * @param __x The argument @c abs(__x) <= 1
   * @throw std::domain_error if @c abs(__x) > 1
   *//**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and <tt>long double</tt> argument @f$ |x| <= 0 @f$.
   *
   * @see legendre for more details.
   *//**
   * Return the Legendre polynomial @f$ P_l(x) @f$ of nonnegative
   * degree @f$ l @f$ and @c float argument @f$ |x| <= 0 @f$.
   *
   * @see legendre for more details.
   */// Legendre polynomials/**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$
   * of nonnegative degree @c n and real argument @f$ x >= 0 @f$.
   *
   * The Laguerre polynomial is defined by:
   * @f[
   * 	 L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The nonnegative order
   * @param __x The argument <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n
   * and <tt>long double</tt> argument @f$ x >= 0 @f$.
   *
   * @see laguerre for more details.
   *//**
   * Returns the Laguerre polynomial @f$ L_n(x) @f$ of nonnegative degree @c n
   * and @c float argument  @f$ x >= 0 @f$.
   *
   * @see laguerre for more details.
   */// Laguerre polynomials/**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of order n
   * and @c real argument @c x.
   *
   * The Hermite polynomial is defined by:
   * @f[
   *   H_n(x) = (-1)^n e^{x^2} \frac{d^n}{dx^n} e^{-x^2}
   * @f]
   *
   * The Hermite polynomial obeys a reflection formula:
   * @f[
   *   H_n(-x) = (-1)^n H_n(x)
   * @f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The order
   * @param __x The argument
   *//**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n
   * and <tt>long double</tt> argument @c x.
   *
   * @see hermite for details.
   *//**
   * Return the Hermite polynomial @f$ H_n(x) @f$ of nonnegative order n
   * and float argument @c x.
   *
   * @see hermite for details.
   */// Hermite polynomials/**
   * Return the exponential integral @f$ Ei(x) @f$ for @c real argument @c x.
   *
   * The exponential integral is given by
   * \f[
   *   Ei(x) = -\int_{-x}^\infty \frac{e^t}{t} dt
   * \f]
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __x  The argument of the exponential integral function.
   *//**
   * Return the exponential integral @f$ Ei(x) @f$
   * for <tt>long double</tt> argument @c x.
   *
   * @see expint for details.
   *//**
   * Return the exponential integral @f$ Ei(x) @f$ for @c float argument @c x.
   *
   * @see expint for details.
   */// Exponential integrals/**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$.
   *
   * The incomplete elliptic integral of the third kind is defined by:
   * @f[
   *   \Pi(k,\nu,\phi) = \int_0^{\phi}
   * 			 \frac{d\theta}
   * 			 {(1 - \nu \sin^2\theta)
   * 			  \sqrt{1 - k^2 \sin^2\theta}}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the third kind, @f$ \Pi(k,\nu) @f$.  @see comp_ellint_3.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpn The floating-point type of the argument @c __nu.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __nu  The second argument
   * @param  __phi  The integral limit argument in radians
   * @return  The elliptic function of the third kind.
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$.
   *
   * @see ellint_3 for details.
   *//**
   * @brief Return the incomplete elliptic integral of the third kind
   * @f$ \Pi(k,\nu,\phi) @f$ for @c float argument.
   *
   * @see ellint_3 for details.
   */// Incomplete elliptic integrals of the third kind/**
   * Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$.
   *
   * The incomplete elliptic integral of the second kind is defined as
   * @f[
   *   E(k,\phi) = \int_0^{\phi} \sqrt{1 - k^2 sin^2\theta}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the second kind, @f$ E(k) @f$.  @see comp_ellint_2.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __phi  The integral limit argument in radians
   * @return  The elliptic function of the second kind.
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * @brief Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$.
   *
   * @see ellint_2 for details.
   *//**
   * @brief Return the incomplete elliptic integral of the second kind
   * @f$ E(k,\phi) @f$ for @c float argument.
   *
   * @see ellint_2 for details.
   */// Incomplete elliptic integrals of the second kind/**
   * Return the incomplete elliptic integral of the first kind @f$ F(k,\phi) @f$
   * for @c real modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * The incomplete elliptic integral of the first kind is defined as
   * @f[
   *   F(k,\phi) = \int_0^{\phi}\frac{d\theta}
   * 				     {\sqrt{1 - k^2 sin^2\theta}}
   * @f]
   * For  @f$ \phi= \pi/2 @f$ this becomes the complete elliptic integral of
   * the first kind, @f$ K(k) @f$.  @see comp_ellint_1.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpp The floating-point type of the angle @c __phi.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @param  __phi  The integral limit argument in radians
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * Return the incomplete elliptic integral of the first kind @f$ E(k,\phi) @f$
   * for <tt>long double</tt> modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * @see ellint_1 for details.
   *//**
   * Return the incomplete elliptic integral of the first kind @f$ E(k,\phi) @f$
   * for @c float modulus @f$ k @f$ and angle @f$ \phi @f$.
   *
   * @see ellint_1 for details.
   */// Incomplete elliptic integrals of the first kind/**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of real order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * The Neumann function is defined by:
   * @f[
   *    N_{\nu}(x) = \frac{J_{\nu}(x) \cos \nu\pi - J_{-\nu}(x)}
   *                      {\sin \nu\pi}
   * @f]
   * where @f$ x >= 0 @f$ and for integral order @f$ \nu = n @f$
   * a limit is taken: @f$ lim_{\nu \to n} @f$.
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * @see cyl_neumann for setails.
   *//**
   * Return the Neumann function @f$ N_{\nu}(x) @f$
   * of @c float order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * @see cyl_neumann for setails.
   */// Cylindrical Neumann functions/**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * of real order @f$ \nu @f$ and argument @f$ x @f$.
   *
   * The irregular modified Bessel function is defined by:
   * @f[
   * 	K_{\nu}(x) = \frac{\pi}{2}
   * 		     \frac{I_{-\nu}(x) - I_{\nu}(x)}{\sin \nu\pi}
   * @f]
   * where for integral @f$ \nu = n @f$ a limit is taken:
   * @f$ lim_{\nu \to n} @f$.
   * For negative argument we have simply:
   * @f[
   * 	K_{-\nu}(x) = K_{\nu}(x)
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_k for setails.
   *//**
   * Return the irregular modified Bessel function @f$ K_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_k for setails.
   */// Irregular modified cylindrical Bessel functions/**
   * Return the Bessel function @f$ J_{\nu}(x) @f$ of real order @f$ \nu @f$
   * and argument @f$ x >= 0 @f$.
   *
   * The cylindrical Bessel function is:
   * @f[
   *    J_{\nu}(x) = \sum_{k=0}^{\infty}
   *              \frac{(-1)^k (x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the Bessel function of the first kind @f$ J_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_j for setails.
   *//**
   * Return the Bessel function of the first kind @f$ J_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_j for setails.
   */// Cylindrical Bessel functions (of the first kind)/**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for real order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * The regular modified cylindrical Bessel function is:
   * @f[
   *  I_{\nu}(x) = i^{-\nu}J_\nu(ix) = \sum_{k=0}^{\infty}
   * 		\frac{(x/2)^{\nu + 2k}}{k!\Gamma(\nu+k+1)}
   * @f]
   *
   * @tparam _Tpnu The floating-point type of the order @c __nu.
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __nu  The order
   * @param  __x   The argument, <tt> __x >= 0 </tt>
   * @throw std::domain_error if <tt> __x < 0 </tt>.
   *//**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for <tt>long double</tt> order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_i for setails.
   *//**
   * Return the regular modified Bessel function @f$ I_{\nu}(x) @f$
   * for @c float order @f$ \nu @f$ and argument @f$ x >= 0 @f$.
   *
   * @see cyl_bessel_i for setails.
   */// Regular modified cylindrical Bessel functions/**
   * Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) = \Pi(k,\nu,\pi/2) @f$ for real modulus @c k.
   *
   * The complete elliptic integral of the third kind is defined as
   * @f[
   *   \Pi(k,\nu) = \Pi(k,\nu,\pi/2) = \int_0^{\pi/2}
   * 		     \frac{d\theta}
   * 		   {(1 - \nu \sin^2\theta)\sqrt{1 - k^2 \sin^2\theta}}
   * @f]
   * where @f$ \Pi(k,\nu,\phi) @f$ is the incomplete elliptic integral of the
   * second kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_3 for details of the incomplete elliptic function
   * of the third kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @tparam _Tpn The floating-point type of the argument @c __nu.
   * @param  __k  The modulus, @c abs(__k) <= 1
   * @param  __nu  The argument
   * @throw std::domain_error if @c abs(__k) > 1.
   *//**
   * @brief Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) @f$ for <tt>long double</tt> modulus @c k.
   *
   * @see comp_ellint_3 for details.
   *//**
   * @brief Return the complete elliptic integral of the third kind
   * @f$ \Pi(k,\nu) @f$ for @c float modulus @c k.
   *
   * @see comp_ellint_3 for details.
   */// Complete elliptic integrals of the third kind/**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for real modulus @c k.
   *
   * The complete elliptic integral of the second kind is defined as
   * @f[
   *   E(k) = E(k,\pi/2) = \int_0^{\pi/2}\sqrt{1 - k^2 sin^2\theta}
   * @f]
   * where @f$ E(k,\phi) @f$ is the incomplete elliptic integral of the
   * second kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_2 for details of the incomplete elliptic function
   * of the second kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @param  __k  The modulus, @c abs(__k) <= 1
   * @throw std::domain_error if @c abs(__k) > 1.
   *//**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for long double modulus @c k.
   *
   * @see comp_ellint_2 for details.
   *//**
   * Return the complete elliptic integral of the second kind @f$ E(k) @f$
   * for @c float modulus @c k.
   *
   * @see comp_ellint_2 for details.
   */// Complete elliptic integrals of the second kind/**
   * Return the complete elliptic integral of the first kind
   * @f$ K(k) @f$ for real modulus @c k.
   *
   * The complete elliptic integral of the first kind is defined as
   * @f[
   *   K(k) = F(k,\pi/2) = \int_0^{\pi/2}\frac{d\theta}
   * 					     {\sqrt{1 - k^2 sin^2\theta}}
   * @f]
   * where @f$ F(k,\phi) @f$ is the incomplete elliptic integral of the
   * first kind and the modulus @f$ |k| <= 1 @f$.
   * @see ellint_1 for details of the incomplete elliptic function
   * of the first kind.
   *
   * @tparam _Tp The floating-point type of the modulus @c __k.
   * @param  __k  The modulus, <tt> abs(__k) <= 1 </tt>
   * @throw std::domain_error if <tt> abs(__k) > 1 </tt>.
   *//**
   * Return the complete elliptic integral of the first kind @f$ E(k) @f$
   * for long double modulus @c k.
   *
   * @see comp_ellint_1 for details.
   *//**
   * Return the complete elliptic integral of the first kind @f$ E(k) @f$
   * for @c float modulus @c k.
   *
   * @see comp_ellint_1 for details.
   */// Complete elliptic integrals of the first kind/**
   * Return the beta function, @f$B(a,b)@f$, for real parameters @c a, @c b.
   *
   * The beta function is defined by
   * @f[
   *   B(a,b) = \int_0^1 t^{a - 1} (1 - t)^{b - 1} dt
   *          = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}
   * @f]
   * where @f$ a > 0 @f$ and @f$ b > 0 @f$
   *
   * @tparam _Tpa The floating-point type of the parameter @c __a.
   * @tparam _Tpb The floating-point type of the parameter @c __b.
   * @param __a The first argument of the beta function, <tt> __a > 0 </tt>.
   * @param __b The second argument of the beta function, <tt> __b > 0 </tt>.
   * @throw std::domain_error if <tt> __a < 0 </tt> or <tt> __b < 0 </tt>.
   *//**
   * Return the beta function, @f$B(a,b)@f$, for long double
   * parameters @c a, @c b.
   *
   * @see beta for more details.
   *//**
   * Return the beta function, @f$ B(a,b) @f$, for @c float parameters @c a, @c b.
   *
   * @see beta for more details.
   */// Beta functions/**
   * Return the associated Legendre function of degree @c l and order @c m.
   *
   * The associated Legendre function is derived from the Legendre function
   * @f$ P_l(x) @f$ by the Rodrigues formula:
   * @f[
   *   P_l^m(x) = (1 - x^2)^{m/2}\frac{d^m}{dx^m}P_l(x)
   * @f]
   * @see legendre for details of the Legendre function of degree @c l
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param  __l  The degree <tt>__l >= 0</tt>.
   * @param  __m  The order <tt>__m <= l</tt>.
   * @param  __x  The argument, <tt>abs(__x) <= 1</tt>.
   * @throw std::domain_error if <tt>abs(__x) > 1</tt>.
   *//**
   * Return the associated Legendre function of degree @c l and order @c m.
   *
   * @see assoc_legendre for more details.
   *//**
   * Return the associated Legendre function of degree @c l and order @c m
   * for @c float argument.
   *
   * @see assoc_legendre for more details.
   */// Associated Legendre functions/**
   * Return the associated Laguerre polynomial of nonnegative order @c n,
   * nonnegative degree @c m and real argument @c x: @f$ L_n^m(x) @f$.
   *
   * The associated Laguerre function of real degree @f$ \alpha @f$,
   * @f$ L_n^\alpha(x) @f$, is defined by
   * @f[
   * 	 L_n^\alpha(x) = \frac{(\alpha + 1)_n}{n!}
   * 			 {}_1F_1(-n; \alpha + 1; x)
   * @f]
   * where @f$ (\alpha)_n @f$ is the Pochhammer symbol and
   * @f$ {}_1F_1(a; c; x) @f$ is the confluent hypergeometric function.
   *
   * The associated Laguerre polynomial is defined for integral
   * degree @f$ \alpha = m @f$ by:
   * @f[
   * 	 L_n^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n + m}(x)
   * @f]
   * where the Laguerre polynomial is defined by:
   * @f[
   * 	 L_n(x) = \frac{e^x}{n!} \frac{d^n}{dx^n} (x^ne^{-x})
   * @f]
   * and @f$ x >= 0 @f$.
   * @see laguerre for details of the Laguerre function of degree @c n
   *
   * @tparam _Tp The floating-point type of the argument @c __x.
   * @param __n The order of the Laguerre function, <tt>__n >= 0</tt>.
   * @param __m The degree of the Laguerre function, <tt>__m >= 0</tt>.
   * @param __x The argument of the Laguerre function, <tt>__x >= 0</tt>.
   * @throw std::domain_error if <tt>__x < 0</tt>.
   *//**
   * Return the associated Laguerre polynomial of order @c n,
   * degree @c m: @f$ L_n^m(x) @f$.
   *
   * @see assoc_laguerre for more details.
   *//**
   * Return the associated Laguerre polynomial of order @c n,
   * degree @c m: @f$ L_n^m(x) @f$ for @c float argument.
   *
   * @see assoc_laguerre for more details.
   */// Associated Laguerre polynomials/**
   * @mainpage Mathematical Special Functions
   *
   * @section intro Introduction and History
   * The first significant library upgrade on the road to C++2011,
   * <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1836.pdf">
   * TR1</a>, included a set of 23 mathematical functions that significantly
   * extended the standard transcendental functions inherited from C and declared
   * in @<cmath@>.
   *
   * Although most components from TR1 were eventually adopted for C++11 these
   * math functions were left behind out of concern for implementability.
   * The math functions were published as a separate international standard
   * <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3060.pdf">
   * IS 29124 - Extensions to the C++ Library to Support Mathematical Special
   * Functions</a>.
   *
   * For C++17 these functions were incorporated into the main standard.
   *
   * @section contents Contents
   * The following functions are implemented in namespace @c std:
   * - @ref assoc_laguerre "assoc_laguerre - Associated Laguerre functions"
   * - @ref assoc_legendre "assoc_legendre - Associated Legendre functions"
   * - @ref beta "beta - Beta functions"
   * - @ref comp_ellint_1 "comp_ellint_1 - Complete elliptic functions of the first kind"
   * - @ref comp_ellint_2 "comp_ellint_2 - Complete elliptic functions of the second kind"
   * - @ref comp_ellint_3 "comp_ellint_3 - Complete elliptic functions of the third kind"
   * - @ref cyl_bessel_i "cyl_bessel_i - Regular modified cylindrical Bessel functions"
   * - @ref cyl_bessel_j "cyl_bessel_j - Cylindrical Bessel functions of the first kind"
   * - @ref cyl_bessel_k "cyl_bessel_k - Irregular modified cylindrical Bessel functions"
   * - @ref cyl_neumann "cyl_neumann - Cylindrical Neumann functions or Cylindrical Bessel functions of the second kind"
   * - @ref ellint_1 "ellint_1 - Incomplete elliptic functions of the first kind"
   * - @ref ellint_2 "ellint_2 - Incomplete elliptic functions of the second kind"
   * - @ref ellint_3 "ellint_3 - Incomplete elliptic functions of the third kind"
   * - @ref expint "expint - The exponential integral"
   * - @ref hermite "hermite - Hermite polynomials"
   * - @ref laguerre "laguerre - Laguerre functions"
   * - @ref legendre "legendre - Legendre polynomials"
   * - @ref riemann_zeta "riemann_zeta - The Riemann zeta function"
   * - @ref sph_bessel "sph_bessel - Spherical Bessel functions"
   * - @ref sph_legendre "sph_legendre - Spherical Legendre functions"
   * - @ref sph_neumann "sph_neumann - Spherical Neumann functions"
   *
   * The hypergeometric functions were stricken from the TR29124 and C++17
   * versions of this math library because of implementation concerns.
   * However, since they were in the TR1 version and since they are popular
   * we kept them as an extension in namespace @c __gnu_cxx:
   * - @ref __gnu_cxx::conf_hyperg "conf_hyperg - Confluent hypergeometric functions"
   * - @ref __gnu_cxx::hyperg "hyperg - Hypergeometric functions"
   *
   * @section general General Features
   *
   * @subsection promotion Argument Promotion
   * The arguments suppled to the non-suffixed functions will be promoted
   * according to the following rules:
   * 1. If any argument intended to be floating point is given an integral value
   * That integral value is promoted to double.
   * 2. All floating point arguments are promoted up to the largest floating
   *    point precision among them.
   *
   * @subsection NaN NaN Arguments
   * If any of the floating point arguments supplied to these functions is
   * invalid or NaN (std::numeric_limits<Tp>::quiet_NaN),
   * the value NaN is returned.
   *
   * @section impl Implementation
   *
   * We strive to implement the underlying math with type generic algorithms
   * to the greatest extent possible.  In practice, the functions are thin
   * wrappers that dispatch to function templates. Type dependence is
   * controlled with std::numeric_limits and functions thereof.
   *
   * We don't promote @c float to @c double or @c double to <tt>long double</tt>
   * reflexively.  The goal is for @c float functions to operate more quickly,
   * at the cost of @c float accuracy and possibly a smaller domain of validity.
   * Similaryly, <tt>long double</tt> should give you more dynamic range
   * and slightly more pecision than @c double on many systems.
   *
   * @section testing Testing
   *
   * These functions have been tested against equivalent implementations
   * from the <a href="http://www.gnu.org/software/gsl">
   * Gnu Scientific Library, GSL</a> and
   * <a href="http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/index.html>Boost</a>
   * and the ratio
   * @f[
   *   \frac{|f - f_{test}|}{|f_{test}|}
   * @f]
   * is generally found to be within 10^-15 for 64-bit double on linux-x86_64 systems
   * over most of the ranges of validity.
   * 
   * @todo Provide accuracy comparisons on a per-function basis for a small
   *       number of targets.
   *
   * @section bibliography General Bibliography
   *
   * @see Abramowitz and Stegun: Handbook of Mathematical Functions,
   * with Formulas, Graphs, and Mathematical Tables
   * Edited by Milton Abramowitz and Irene A. Stegun,
   * National Bureau of Standards  Applied Mathematics Series - 55
   * Issued June 1964, Tenth Printing, December 1972, with corrections
   * Electronic versions of A&S abound including both pdf and navigable html.
   * @see for example  http://people.math.sfu.ca/~cbm/aands/
   *
   * @see The old A&S has been redone as the
   * NIST Digital Library of Mathematical Functions: http://dlmf.nist.gov/
   * This version is far more navigable and includes more recent work.
   *
   * @see An Atlas of Functions: with Equator, the Atlas Function Calculator
   * 2nd Edition, by Oldham, Keith B., Myland, Jan, Spanier, Jerome
   *
   * @see Asymptotics and Special Functions by Frank W. J. Olver,
   * Academic Press, 1974
   *
   * @see Numerical Recipes in C, The Art of Scientific Computing,
   * by William H. Press, Second Ed., Saul A. Teukolsky,
   * William T. Vetterling, and Brian P. Flannery,
   * Cambridge University Press, 1992
   *
   * @see The Special Functions and Their Approximations: Volumes 1 and 2,
   * by Yudell L. Luke, Academic Press, 1969
   *//**
   * @defgroup mathsf Mathematical Special Functions
   * @ingroup numerics
   *
   * A collection of advanced mathematical special functions,
   * defined by ISO/IEC IS 29124.
   * @{
   *//** @file bits/specfun.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{cmath}
 */// Mathematical Special Functions for -*- C++ -*-/usr/include/c++/9/cmath<bits/specfun.h><bits/std_abs.h><math.h>__hypot3__builtin_truncl__builtin_truncf__builtin_tgammal__builtin_tgammaf__builtin_scalbnl__builtin_scalbnf__builtin_scalblnl__builtin_scalblnf__builtin_roundl__builtin_roundf__builtin_rintl__builtin_rintf__builtin_remquol__builtin_remquof__builtin_remainderl__builtin_remainderf__builtin_nexttowardl__builtin_nexttowardf__builtin_nextafterl__builtin_nextafterf__builtin_nearbyintl__builtin_nearbyintf__builtin_lroundl__builtin_lroundf__builtin_lrintl__builtin_lrintf__builtin_logbl__builtin_logbf__builtin_log2l__builtin_log2f__builtin_log1pl__builtin_log1pf__builtin_llroundl__builtin_llroundf__builtin_llrintl__builtin_llrintf__builtin_lgammal__builtin_lgammaf__builtin_ilogbl__builtin_ilogbf__builtin_hypotl__builtin_hypotf__builtin_fminl__builtin_fminf__builtin_fmaxl__builtin_fmaxf__builtin_fmal__builtin_fmaf__builtin_fdiml__builtin_fdimf__builtin_expm1l__builtin_expm1f__builtin_exp2l__builtin_exp2f__builtin_erfcl__builtin_erfcf__builtin_erfl__builtin_erff__builtin_copysignl__builtin_copysignf__pquo__builtin_cbrtl__builtin_cbrtf__builtin_atanhl__builtin_atanhf__builtin_asinhl__builtin_asinhf__builtin_acoshl__builtin_acoshfisunordered__builtin_isunorderedislessgreater__builtin_islessgreaterislessequal__builtin_islessequalisless__builtin_islessisgreaterequal__builtin_isgreaterequalisgreater__builtin_isgreatersignbit__builtin_signbitisnormal__builtin_isnormal__builtin_isnan__builtin_isinfisfinite__builtin_isfinitefpclassify__builtin_fpclassify__builtin_tanhl__builtin_tanhf__builtin_tanl__builtin_tanf__builtin_sqrtl__builtin_sqrtf__builtin_sinhl__builtin_sinhf__builtin_sinl__builtin_sinf__builtin_powl__builtin_powf__builtin_modfl__builtin_modff__builtin_log10l__builtin_log10f__builtin_logl__builtin_logf__builtin_ldexpl__builtin_ldexpf__builtin_frexpl__builtin_frexpf__builtin_fmodl__builtin_fmodf__builtin_floorl__builtin_floorf__builtin_fabsl__builtin_fabsf__builtin_expl__builtin_expf__builtin_coshl__builtin_coshf__builtin_cosl__builtin_cosf__builtin_ceill__builtin_ceilf__builtin_atan2l__builtin_atan2f__builtin_atanl__builtin_atanf__builtin_asinl__builtin_asinf__builtin_acosl__builtin_acosf__cpp_lib_hypot_GLIBCXX_CMATH_GLIBCXX_INCLUDE_NEXT_C_HEADERS__CORRECT_ISO_CPP_MATH_H_PROTO_GLIBCXX_USE_C99_MATH!_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC__CORRECT_ISO_CPP11_MATH_H_PROTO_FP__CORRECT_ISO_CPP11_MATH_H_PROTO_INT_GLIBCXX_HAVE_OBSOLETE_ISINF \_GLIBCXX_HAVE_OBSOLETE_ISNAN \_GLIBCXX_NO_C99_ROUNDING_FUNCS// extern "C++"// monotonic near __t=1// bounded, determinate, and consistent:// Exact at __t=0, monotonic except near __t=1,// exact// linear interpolation// [c.math.hypot3], three-dimensional hypotenuse// _GLIBCXX_USE_C99_MATH_TR1// DR 568./// Additional overloads.// functions// types/* _GLIBCXX_USE_C99_MATH *//* _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC */// Note: middle-end/36757 is fixed, __builtin_signbit is type-generic.// These are possible macros imported from C99-land.// DR 550. What should the return type of pow(float,int) be?// Get rid of those macros defined in <math.h> in lieu of real functions.// ISO C++ 14882: 26.5  C library/** @file include/cmath
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c math.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */// -*- C++ -*- C forwarding header./usr/include/c++/9/unordered_set/home/tanteikg/QCVE/sources/bitcoin/src/util/check.h449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481/home/tanteikg/QCVE/sources/bitcoin/src/addrman.cpp<cmath><util/check.h><addrman_impl.h>addrman.cpp1038strprintf("new %i, tried %i, total %u", nNew, nTried, vRandom.size())tfm::format("new %i, tried %i, total %u", nNew, nTried, vRandom.size())BCLog::ADDRMANnew %i, tried %i, total %uconst vector<int, allocator<int>>setTriedmapNewlocal_counts-7const unordered_map<int, AddrInfo, hash<int>, equal_to<int>, allocator<pair<const int, AddrInfo>>>const unordered_map<int, AddrInfo, hash<int>, equal_to<int>, allocator<pair<const int, AddrInfo>>> &unordered_map<int, AddrInfo, hash<int>, equal_to<int>, allocator<pair<const int, AddrInfo>>> &const pair<const int, AddrInfo>const pair<const int, AddrInfo> &pair<const int, AddrInfo> &entryconst _Node_const_iterator<pair<const int, AddrInfo>, false, false>const _Node_iterator_base<pair<const int, AddrInfo>, false>const _Node_iterator_base<pair<const int, AddrInfo>, false> &_Node_iterator_base<pair<const int, AddrInfo>, false> &_Node_const_iterator<pair<const int, AddrInfo>, false, false> &-2ADDRMAN_NEW_BUCKETS_PER_ADDRESS-3-4const _Node_iterator_base<pair<const CService, int>, false>const _Node_iterator_base<pair<const CService, int>, false> &_Node_iterator_base<pair<const CService, int>, false> &-5-14-6-8const unordered_set<int, hash<int>, equal_to<int>, allocator<int>>-9const unordered_map<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>>-10const int[64]const int(*)[64]int(*)[64]const int *-11-17-18-12-19-13-15-16const unordered_map<Network, NewTriedCount, hash<Network>, equal_to<Network>, allocator<pair<const Network, NewTriedCount>>>-20const unordered_map<Network, NewTriedCount, hash<Network>, equal_to<Network>, allocator<pair<const Network, NewTriedCount>>> &unordered_map<Network, NewTriedCount, hash<Network>, equal_to<Network>, allocator<pair<const Network, NewTriedCount>>> &const pair<const Network, NewTriedCount>const pair<const Network, NewTriedCount> &pair<const Network, NewTriedCount> &const _Node_const_iterator<pair<const Network, NewTriedCount>, false, false>const _Node_iterator_base<pair<const Network, NewTriedCount>, false>const _Node_iterator_base<pair<const Network, NewTriedCount>, false> &_Node_iterator_base<pair<const Network, NewTriedCount>, false> &_Node_const_iterator<pair<const Network, NewTriedCount>, false, false> &-21~unordered_setunordered_set<int, hash<int>, equal_to<int>, allocator<int>> *unordered_map<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>> *unordered_map<Network, NewTriedCount, hash<Network>, equal_to<Network>, allocator<pair<const Network, NewTriedCount>>> *"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\n", err1031ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i
const char[44]char[44]1032void AddrManImpl::Check() const1001net_count978addr_info950const set<int, less<int>, allocator<int>>id_newconst _Rb_tree_const_iterator<int>newInfotried_buckettried_bucket_posinfo_old887"Replacing %s with %s in tried table\n", info_old.ToStringAddrPort(), info_new.ToStringAddrPort()"Unable to test; replacing %s with %s in tried table anyway\n", info_old.ToStringAddrPort(), info_new.ToStringAddrPort()erase_collisioninfo_newid_oldcurrent_timeconst duration<signed long, ratio<1L, 1L>> &const duration<signed long, ratio<3600L, 1L>>const duration<signed long, ratio<3600L, 1L>> &duration<signed long, ratio<3600L, 1L>> &const hoursconst hours &const char[19]char[19]920Replacing %s with %s in tried table
const char[37]char[37]const duration<signed long, ratio<60L, 1L>>const duration<signed long, ratio<60L, 1L>> &duration<signed long, ratio<60L, 1L>> &const minutesconst minutes &930Unable to test; replacing %s with %s in tried table anyway
++871pinfo852update_interval814nNodesaddressesit != mapInfo.end()nRndPosai834const char[130]char[130]std::vector<CAddress, std::allocator<CAddress>> AddrManImpl::GetAddr_(unsigned long, unsigned long, std::optional<Network>) const"GetAddr returned %d random addresses\n", addresses.size()846GetAddr returned %d random addresses
799position < ADDRMAN_BUCKET_SIZE801int AddrManImpl::GetEntry(bool, unsigned long, unsigned long) constbucket < ADDRMAN_TRIED_BUCKET_COUNTbucket < ADDRMAN_NEW_BUCKET_COUNT804807719new_counttried_countcountssearch_triedchance_factor 1.0it_found != mapInfo.end()"Selected %s from %s\n", info.ToStringAddrPort(), search_tried ? "tried" : "new"initial_positionit_foundnode_id767const char[169]char[169]std::pair<CAddress, std::chrono::time_point<NodeClock, std::chrono::duration<signed long, std::ratio<1L, 1L>>>> AddrManImpl::Select_(bool, std::optional<Network>) const7831073741824.0(1 << 30)788Selected %s from %s
new1.1999999999999999561.2699added"Added %i addresses (of %i) from %s: %i tried, %i new\n", added, vAddr.size(), source.ToStringAddr(), nTried, nNew692Added %i addresses (of %i) from %s: %i tried, %i new
const char[54]char[54]633info.nRefCount > 0657"Collision with %s while attempting to move %s to tried table. Collisions=%d\n", colliding_entry != mapInfo.end() ? colliding_entry->second.ToStringAddrPort() : "", addr.ToStringAddrPort(), m_tried_collisions.size()"Moved %s mapped to AS%i to tried[%i][%i]\n", addr.ToStringAddrPort(), m_netgroupman.GetMappedAS(addr), tried_bucket, tried_bucket_poscolliding_entryADDRMAN_SET_TRIED_COLLISION_SIZE674Collision with %s while attempting to move %s to tried table. Collisions=%d
const char[77]char[77]const _Node_iterator<pair<const int, AddrInfo>, false, false>const char[1]char[1]680Moved %s mapped to AS%i to tried[%i][%i]
557currently_onlineconst time_point<NodeClock, duration<signed long, ratio<1L, 1000000000L>>>const time_point<NodeClock, duration<signed long, ratio<1L, 1000000000L>>> &nFactorfInsert"Added %s mapped to AS%i to new[%i][%i]\n", addr.ToStringAddrPort(), m_netgroupman.GetMappedAS(addr), nUBucket, nUBucketPosinfoExisting621Added %s mapped to AS%i to new[%i][%i]
498start_bucketinfo.nRefCount == 0514void AddrManImpl::MakeTried(AddrInfo &, int)nKBucketnKBucketPosmapInfo.count(nIdEvict) == 1vvNew[nUBucket][nUBucketPos] == -1"Moved %s from tried[%i][%i] to new[%i][%i] to make space\n", infoOld.ToStringAddrPort(), nKBucket, nKBucketPos, nUBucket, nUBucketPosnIdEvictinfoOld537545Moved %s from tried[%i][%i] to new[%i][%i] to make space
const char[58]char[58]vvTried[nKBucket][nKBucketPos] == -1547infoDelete.nRefCount > 0"Removed %s from new[%i][%i]\n", infoDelete.ToStringAddrPort(), nUBucket, nUBucketPosnIdDeleteinfoDeleteconst char[25]char[25]486void AddrManImpl::ClearNew(int, int)489Removed %s from new[%i][%i]
mapInfo.count(nId) != 0void AddrManImpl::Delete(int)!info.fInTriednRndPos1 < vRandom.size() && nRndPos2 < vRandom.size()void AddrManImpl::SwapRandom(unsigned int, unsigned int) constnId1nId2it_1it_2it_1 != mapInfo.end()nRndPos1nRndPos2it_2 != mapInfo.end()mapped_type *it2criticalblock131229criticalblock121221criticalblock111213criticalblock101204criticalblock91195addrRetpair<CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &pair<CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> *criticalblock81186fChance0.010000000000000000210.010.66000000000000003110.66ADDRMAN_RETRIESADDRMAN_MAX_FAILUREShash1'N'uint8_t{'N'}'K'uint8_t{'K'}vchSourceGroupKeyhash2ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUPADDRMAN_TRIED_BUCKETS_PER_GROUPcriticalblock71178criticalblock61170criticalblock51161criticalblock41152criticalblock31143criticalblock1vRandom.empty()Format &stream_versionFormat::V3_BIP155compatCorrupted addrman database: The compat value (%u) is lower than the expected minimum value %u."Corrupted addrman database: The compat value (%u) "
            "is lower than the expected minimum value %u."const char[95]char[95]const uint8_tconst uint8_t &lowest_compatibleconst char(&)[13]char(&)[13]Unsupported format of addrman database: %u. It is compatible with formats >=%u, but the maximum supported by this version of %s is %u."Unsupported format of addrman database: %u. It is compatible with formats >=%u, "
            "but the maximum supported by this version of %s is %u."const char[135]char[135]Bitcoin CorePACKAGE_NAMEuint8_t{FILE_FORMAT}nUBucketsFormat::V1_DETERMINISTICADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZECorrupt AddrMan serialization: nNew=%d, should be in [0, %d]"Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]"ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZECorrupt AddrMan serialization: nTried=%d, should be in [0, %d]"Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]"nLostbucket_entriesnum_entriesentry_indexsupplied_asmap_checksumserialized_asmap_checksumFormat::V2_ASMAPrestore_bucketing"Bucketing method was updated, re-bucketing addrman entries from disk\n"Bucketing method was updated, re-bucketing addrman entries from disk
const char[70]char[70]vector<pair<int, int>, allocator<pair<int, int>>> &bucket_entryconst __normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>>const __normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>> &__normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>> &bucket_positionnLostUnkitCopy"addrman lost %i new and %i tried addresses due to collisions or invalid addresses\n", nLostUnk, nLostaddrman lost %i new and %i tried addresses due to collisions or invalid addresses
const char[83]char[83]check_codeCorrupt data. Consistency check failed with code %s"Corrupt data. Consistency check failed with code %s"static_cast<uint8_t>(FILE_FORMAT)static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible)1073742848ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30)mapUnkIdsnIdsnIds != nNewnIds != nTriednIndexunordered_map<CService, int, CServiceHash, equal_to<CService>, allocator<pair<const CService, int>>> *unordered_map<int, AddrInfo, hash<int>, equal_to<int>, allocator<pair<const int, AddrInfo>>> *int(&)[1024][64])int(&)[64]int(&)[256][64]AnnotatedMixinADDRMAN_TEST_WINDOWADDRMAN_REPLACEMENTADDRMAN_MIN_FAILADDRMAN_HORIZON// explicit instantiation/*test_before_evict=*/// doesn't have if addrs from a network were being added and then removed again in the past.// It's possible that m_network_counts may have all-zero entries that local_counts// Run consistency checks 1 in m_consistency_check_ratio times if enabled/*position_in=*//*bucket_in=*//*multiplicity_in=*//*tried_in=*/// which tried bucket to move the entry to// If id_new not found in mapInfo remove it from m_tried_collisions// Selects a random element from m_tried_collisions// Collision is not actually a collision anymore// connect to it for some reason.// just evict the old entry -- we must not be able to// If the collision hasn't resolved in some reasonable amount of time,// Replaces an existing address already in the tried table with the new address// Give address at least 60 seconds to successfully connect// attempted to connect and failed in last X hours// Has successfully connected in last X hours// Get the to-be-evicted address that is being tested// The position in the tried bucket is not empty// id_new may no longer map to a valid address// Which tried bucket to move the entry to.// update info// if not found, bail out// Filter for quality// Filter by network (optional)// gather a list of random nodes, skipping those of low quality// Otherwise start over with a (likely) different bucket, and increased chance factor.// With probability GetChance() * chance_factor, return the entry.// Find the entry to return.// If the bucket is entirely empty, start over with a (likely) different one.// and looping around.// Iterate over the positions of that bucket, starting at the initial one,// Pick a bucket, and an initial position in that bucket.// Loop through the addrman table until we find an appropriate entry// If either option is viable, use a 50% chance to choose// Decide if we are going to search the new or tried table// move nId to the tried tables// Output the entry we'd be colliding with, for debugging purposes// Will moving this address into tried evict another entry?// if it is not in new, something bad happened// if it is already in the tried set, don't do anything else// currently-connected peers.// nTime is not updated here, to avoid leaking information about// Overwrite the existing new table entry.// stochastic test: previous nRefCount == N: 2^N times harder to increase it// do not update if the max reference count is reached// do not update if the entry was already in the "tried" table// do not update if no new information is present// add services// periodically update nTime// Do not set a penalty for a source's self-announcement// Enter it into the new set again.// find which new bucket it belongs to// Remove the to-be-evicted item from the tried set.// find an item to evict// first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).// remove the entry from all new buckets// if there is an entry in the specified bucket, delete it.// Prune new entries with refcount 0 (as a result of collisions or invalid address).// try to give them a reference based on their primary source address.// In case the new table data cannot be used (bucket count wrong or new asmap),// Bucketing has not changed, using existing bucket positions for the new table// this bucket_entry.// ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip// The entry shouldn't appear in more than// Don't store the entry in the new bucket if it's not a valid address for our addrman// serialization.// to restore the entries to the buckets/positions they were in before// If the bucket count and asmap checksum haven't changed, then attempt// so we store all bucket-entry_index pairs to iterate through later.// An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,// Store positions in the new table buckets to apply later (if possible).// Deserialize entries from the tried table.// Deserialize entries from the new table.// unserialize methods know that an address in addrv2 format is coming.// Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress// can be ignored by older clients for backward compatibility.// Store asmap checksum after bucket entries so that it// this means nTried was wrong, oh ow// this means nNew was wrong, oh ow// the previous one.// Increment `lowest_compatible` iff a newly introduced format is incompatible with// Always serialize in the latest version (FILE_FORMAT)./**
     * Serialized format.
     * * format version byte (@see `Format`)
     * * lowest compatible format version byte. This is used to help old software decide
     *   whether to parse the file. For example:
     *   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is
     *     introduced in version N+1 that is compatible with format=3 and it is known that
     *     version N will be able to parse it, then version N+1 will write
     *     (format=4, lowest_compatible=3) in the first two bytes of the file, and so
     *     version N will still try to parse it.
     *   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write
     *     (format=5, lowest_compatible=5) and so any versions that do not know how to parse
     *     format=5 will not try to read the file.
     * * nKey
     * * nNew
     * * nTried
     * * number of "new" buckets XOR 2**30
     * * all new addresses (total count: nNew)
     * * all tried addresses (total count: nTried)
     * * for each new bucket:
     *   * number of elements
     *   * for each element: index in the serialized "all new addresses"
     * * asmap checksum
     *
     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it
     * as incompatible. This is necessary because it did not check the version number on
     * deserialization.
     *
     * vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;
     * they are instead reconstructed from the other information.
     *
     * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports
     * changes to the ADDRMAN_ parameters without breaking the on-disk structure.
     *
     * We don't use SERIALIZE_METHODS since the serialization and deserialization code has
     * very little in common.
     */// deprioritize 66% after each failed attempt, but at most 1/28th to avoid the search taking forever or overly penalizing outages.// deprioritize very recent attempts away// N successive failures in the last week// tried N times and never a success// not seen in recent history// came in a flying DeLorean// never remove things tried in the last minute/** The maximum time we'll spend trying to resolve a tried table collision *//** The maximum number of tried addr collisions to store *//** How recent a successful connection should be before we allow an address to be evicted from tried *//** ... in at least this duration *//** How many successive failures are allowed ... *//** After how many failed attempts we give up on a new node *//** How old addresses can maximally be *//** Maximum number of times an address can occur in the new table *//** Over how many buckets entries with new addresses originating from a single group are spread *//** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */__normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>>pair<int, int> *__normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>> &&__normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>> *pair<int, int> &pair<int, int>vector<pair<int, int>, allocator<pair<int, int>>>allocator<pair<int, int>> &Wrapper<CustomUintFormatter<1, false>, Format &>Wrapper<CustomUintFormatter<1, false>, Format &> &const Wrapper<CustomUintFormatter<1, false>, Format &>const Wrapper<CustomUintFormatter<1, false>, Format &> &Wrapper<CustomUintFormatter<1, false>, Format &> &&pair<const CService, int> &_Node_iterator<pair<const CService, int>, false, false>_Node_iterator<pair<const CService, int>, false, false> &_Node_iterator<pair<const CService, int>, false, false> &&const _Node_iterator<pair<const CService, int>, false, false>const _Node_iterator<pair<const CService, int>, false, false> &_Node_iterator<pair<const CService, int>, false, false> *_Node_iterator<pair<const int, AddrInfo>, false, false>_Node_iterator<pair<const int, AddrInfo>, false, false> &_Node_iterator<pair<const int, AddrInfo>, false, false> &&const _Node_iterator<pair<const int, AddrInfo>, false, false> &_Node_iterator<pair<const int, AddrInfo>, false, false> *pair<const int, AddrInfo> *pair<_Rb_tree_const_iterator<int>, bool>const _Rb_tree_const_iterator<int> &const pair<const Network, NewTriedCount> *pair<const Network, NewTriedCount> *_Node_iterator_base<pair<const Network, NewTriedCount>, false>_Node_iterator_base<pair<const Network, NewTriedCount>, false> &&_Hash_node<pair<const Network, NewTriedCount>, false> *_Node_const_iterator<pair<const Network, NewTriedCount>, false, false>_Node_const_iterator<pair<const Network, NewTriedCount>, false, false> &&const _Node_const_iterator<pair<const Network, NewTriedCount>, false, false> &_Node_const_iterator<pair<const Network, NewTriedCount>, false, false> *pair<const Network, NewTriedCount>const pair<const int, AddrInfo> *pair<const CService, int>const pair<const CService, int>const pair<const CService, int> &pair<const CService, int> *const pair<const CService, int> *_Node_iterator_base<pair<const CService, int>, false>_Node_iterator_base<pair<const CService, int>, false> &&_Hash_node<pair<const CService, int>, false> *pair<_Node_iterator<int, true, false>, bool>const _Node_iterator<int, true, false>const _Node_iterator<int, true, false> &_Node_iterator<int, true, false> &_Node_const_iterator<pair<const CService, int>, false, false>_Node_const_iterator<pair<const CService, int>, false, false> &_Node_const_iterator<pair<const CService, int>, false, false> &&const _Node_const_iterator<pair<const CService, int>, false, false>const _Node_const_iterator<pair<const CService, int>, false, false> &_Node_const_iterator<pair<const CService, int>, false, false> *_Node_iterator_base<pair<const int, AddrInfo>, false>_Node_iterator_base<pair<const int, AddrInfo>, false> &&_Hash_node<pair<const int, AddrInfo>, false> *_Node_const_iterator<pair<const int, AddrInfo>, false, false>_Node_const_iterator<pair<const int, AddrInfo>, false, false> &&const _Node_const_iterator<pair<const int, AddrInfo>, false, false> &_Node_const_iterator<pair<const int, AddrInfo>, false, false> *pair<const int, AddrInfo>Timer<duration<signed long, ratio<1L, 1000L>>>Timer<duration<signed long, ratio<1L, 1000L>>> &const Timer<duration<signed long, ratio<1L, 1000L>>>const Timer<duration<signed long, ratio<1L, 1000L>>> &__is_integer<_Tp>__enable_if<__value, double>__promote_2<_Tp, _Up, __type, __type>__enable_if<__value, int>__enable_if<__value, bool>__is_arithmetic<_Tp>__is_arithmetic<_Up>__enable_if<<expression>, bool>__promote_3<_Tp, _Up, _Vp, __type, __type, __type>__enable_if<__value, long long>__enable_if<__value, long>__promote<_Tp, __value>__promote_2<_Tpa, _Tpb, __type, __type>__promote_2<_Tp, _Tpn, __type, __type>__promote_2<_Tpnu, _Tp, __type, __type>__promote_2<_Tp, _Tpp, __type, __type>__promote_3<_Tp, _Tpn, _Tpp, __type, __type, __type>numeric_limits<_Tp>is_same<const AddrInfo &, const AddrInfo &>is_same<const AddrInfo &, const AddrInfo &> &is_same<const AddrInfo &, const AddrInfo &> &&const is_same<const AddrInfo &, const AddrInfo &>const is_same<const AddrInfo &, const AddrInfo &> &is_same<AddrInfo &, AddrInfo &>is_same<AddrInfo &, AddrInfo &> &is_same<AddrInfo &, AddrInfo &> &&const is_same<AddrInfo &, AddrInfo &>const is_same<AddrInfo &, AddrInfo &> &unordered_map<int, AddrInfo, hash<int>, equal_to<int>, allocator<pair<const int, AddrInfo>>>unordered_multimap<int, AddrInfo, _H2, _P2, allocator<pair<const int, AddrInfo>>> &&unordered_multimap<int, AddrInfo, _H2, _P2, allocator<pair<const int, AddrInfo>>> &unordered_map<int, AddrInfo, _H2, _P2, allocator<pair<const int, AddrInfo>>> &&unordered_map<int, AddrInfo, _H2, _P2, allocator<pair<const int, AddrInfo>>> &allocator<pair<const int, AddrInfo>> &equal_to<int> &unordered_map<CService, int, CServiceHash, equal_to<CService>, allocator<pair<const CService, int>>>unordered_multimap<CService, int, _H2, _P2, allocator<pair<const CService, int>>> &&unordered_multimap<CService, int, _H2, _P2, allocator<pair<const CService, int>>> &unordered_map<CService, int, _H2, _P2, allocator<pair<const CService, int>>> &&unordered_map<CService, int, _H2, _P2, allocator<pair<const CService, int>>> &allocator<pair<const CService, int>> &equal_to<CService> &vector<int, allocator<int>>allocator<int> &set<int, less<int>, allocator<int>>const set<int, less<int>, allocator<int>> *set<int, less<int>, allocator<int>> *multiset<int, _Compare1, allocator<int>> &&multiset<int, _Compare1, allocator<int>> &set<int, _Compare1, allocator<int>> &&set<int, _Compare1, allocator<int>> &const less<int>const less<int> &less<int> &unordered_map<Network, NewTriedCount, hash<Network>, equal_to<Network>, allocator<pair<const Network, NewTriedCount>>>unordered_multimap<Network, NewTriedCount, _H2, _P2, allocator<pair<const Network, NewTriedCount>>> &&unordered_multimap<Network, NewTriedCount, _H2, _P2, allocator<pair<const Network, NewTriedCount>>> &unordered_map<Network, NewTriedCount, _H2, _P2, allocator<pair<const Network, NewTriedCount>>> &&unordered_map<Network, NewTriedCount, _H2, _P2, allocator<pair<const Network, NewTriedCount>>> &hash<Network> &allocator<pair<const Network, NewTriedCount>> &equal_to<Network> &vector<T, allocator<T>>optional<AddressPosition> &const optional<AddressPosition>const optional<AddressPosition> &optional<AddressPosition> &&optional<AddressPosition> *time_point<NodeClock, duration<signed long, ratio<1L, 1000000000L>>>time_point<NodeClock, duration<signed long, ratio<1L, 1000000000L>>> &&shared_ptr<const CTransaction>optional<vector<unsigned char, allocator<unsigned char>>>pair<iterator, bool>_Rb_tree<int, int, _Identity<int>, less<int>, allocator<int>>_Rb_tree<int, int, _Identity<int>, _Compare2, allocator<int>> &_Rb_tree_const_iterator<int>_Rb_tree_const_iterator<int> &&_Rb_tree_const_iterator<int> *_Rb_tree_iterator<int>_Rb_tree_iterator<int> &&const _Rb_tree_iterator<int>const _Rb_tree_iterator<int> &_Rb_tree_iterator<int> *duration<type, _Period>_Vector_base<int, allocator<int>>_Vector_base<int, allocator<int>> &const _Vector_base<int, allocator<int>>const _Vector_base<int, allocator<int>> &_Vector_base<pair<int, int>, allocator<pair<int, int>>>_Vector_base<pair<int, int>, allocator<pair<int, int>>> &const _Vector_base<pair<int, int>, allocator<pair<int, int>>>const _Vector_base<pair<int, int>, allocator<pair<int, int>>> &_Node_handle<int, int, allocator<_Rb_tree_node<int>>>_Node_handle<int, int, allocator<_Rb_tree_node<int>>> &const _Node_handle<int, int, allocator<_Rb_tree_node<int>>>const _Node_handle<int, int, allocator<_Rb_tree_node<int>>> &_Node_handle_Node_handle<int, int, allocator<_Hash_node<int, false>>>_Node_handle<int, int, allocator<_Hash_node<int, false>>> &const _Node_handle<int, int, allocator<_Hash_node<int, false>>>const _Node_handle<int, int, allocator<_Hash_node<int, false>>> &_Optional_payload_base<AddressPosition>_Optional_payload_base<allocator<_Rb_tree_node<int>>>_Optional_payload<allocator<_Rb_tree_node<int>>, true, false, false>const _Optional_payload_base<allocator<_Rb_tree_node<int>>>const _Optional_payload_base<allocator<_Rb_tree_node<int>>> &_Optional_payload_base<allocator<_Rb_tree_node<int>>> &_Optional_payload_base<allocator<_Rb_tree_node<int>>> &&_Optional_payload_base<allocator<_Hash_node<int, false>>>_Optional_payload<allocator<_Hash_node<int, false>>, true, false, false>const _Optional_payload_base<allocator<_Hash_node<int, false>>>const _Optional_payload_base<allocator<_Hash_node<int, false>>> &_Optional_payload_base<allocator<_Hash_node<int, false>>> &_Optional_payload_base<allocator<_Hash_node<int, false>>> &&_Insert_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>_Insert_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &&const _Insert_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Insert_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>_Insert_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &&const _Insert_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Insert_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>_Insert_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &&const _Insert_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Insert_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &__is_invocable<const _Equal &, const _Key &, const _Key &>tuple<const key_type &>__is_invocable<const _H1 &, const _Key &>allocator<pair<const int, AddrInfo>>allocator<_Hash_node<pair<const int, AddrInfo>, false>>allocator<pair<const CService, int>>allocator<_Hash_node<pair<const CService, int>, false>>allocator<_Rb_tree_node<int>>allocator<pair<const Network, NewTriedCount>>allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>allocator<pair<int, int>>new_allocator<pair<const int, AddrInfo>>new_allocator<pair<const int, AddrInfo>> &const new_allocator<pair<const int, AddrInfo>>const new_allocator<pair<const int, AddrInfo>> &new_allocator<_Hash_node<pair<const int, AddrInfo>, false>>new_allocator<_Hash_node<pair<const int, AddrInfo>, false>> &const new_allocator<_Hash_node<pair<const int, AddrInfo>, false>>const new_allocator<_Hash_node<pair<const int, AddrInfo>, false>> &new_allocator<pair<const CService, int>>new_allocator<pair<const CService, int>> &const new_allocator<pair<const CService, int>>const new_allocator<pair<const CService, int>> &new_allocator<_Hash_node<pair<const CService, int>, false>>new_allocator<_Hash_node<pair<const CService, int>, false>> &const new_allocator<_Hash_node<pair<const CService, int>, false>>const new_allocator<_Hash_node<pair<const CService, int>, false>> &new_allocator<_Rb_tree_node<int>>new_allocator<_Rb_tree_node<int>> &const new_allocator<_Rb_tree_node<int>>const new_allocator<_Rb_tree_node<int>> &new_allocator<pair<const Network, NewTriedCount>>new_allocator<pair<const Network, NewTriedCount>> &const new_allocator<pair<const Network, NewTriedCount>>const new_allocator<pair<const Network, NewTriedCount>> &new_allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>new_allocator<_Hash_node<pair<const Network, NewTriedCount>, false>> &const new_allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>const new_allocator<_Hash_node<pair<const Network, NewTriedCount>, false>> &new_allocator<pair<int, int>>new_allocator<pair<int, int>> &const new_allocator<pair<int, int>>const new_allocator<pair<int, int>> &allocator_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>>allocator_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>> &allocator_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>> &&const allocator_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>>const allocator_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>> &allocator<_Hash_node<pair<const int, AddrInfo>, false>> &allocator_traits<allocator<_Hash_node<pair<const CService, int>, false>>>allocator_traits<allocator<_Hash_node<pair<const CService, int>, false>>> &allocator_traits<allocator<_Hash_node<pair<const CService, int>, false>>> &&const allocator_traits<allocator<_Hash_node<pair<const CService, int>, false>>>const allocator_traits<allocator<_Hash_node<pair<const CService, int>, false>>> &allocator<_Hash_node<pair<const CService, int>, false>> &allocator_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>allocator_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>> &allocator_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>> &&const allocator_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>const allocator_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>> &allocator<_Hash_node<pair<const Network, NewTriedCount>, false>> &allocator_traits<allocator<_Rb_tree_node<int>>>allocator_traits<allocator<_Rb_tree_node<int>>> &allocator_traits<allocator<_Rb_tree_node<int>>> &&const allocator_traits<allocator<_Rb_tree_node<int>>>const allocator_traits<allocator<_Rb_tree_node<int>>> &allocator<_Rb_tree_node<int>> &allocator_traits<allocator<pair<int, int>>>allocator_traits<allocator<pair<int, int>>> &allocator_traits<allocator<pair<int, int>>> &&const allocator_traits<allocator<pair<int, int>>>const allocator_traits<allocator<pair<int, int>>> &__rebind<allocator<_Hash_node<int, false>>, int, void>__rebind<allocator<_Hash_node<int, false>>, int, void> &__rebind<allocator<_Hash_node<int, false>>, int, void> &&const __rebind<allocator<_Hash_node<int, false>>, int, void>const __rebind<allocator<_Hash_node<int, false>>, int, void> &__rebind<allocator<_Rb_tree_node<int>>, int, void>__rebind<allocator<_Rb_tree_node<int>>, int, void> &__rebind<allocator<_Rb_tree_node<int>>, int, void> &&const __rebind<allocator<_Rb_tree_node<int>>, int, void>const __rebind<allocator<_Rb_tree_node<int>>, int, void> &__rebind<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node_base *, void>__rebind<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node_base *, void> &__rebind<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node_base *, void> &&const __rebind<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node_base *, void>const __rebind<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node_base *, void> &__rebind<allocator<pair<const Network, NewTriedCount>>, _Hash_node<pair<const Network, NewTriedCount>, false>, void>__rebind<allocator<pair<const Network, NewTriedCount>>, _Hash_node<pair<const Network, NewTriedCount>, false>, void> &__rebind<allocator<pair<const Network, NewTriedCount>>, _Hash_node<pair<const Network, NewTriedCount>, false>, void> &&const __rebind<allocator<pair<const Network, NewTriedCount>>, _Hash_node<pair<const Network, NewTriedCount>, false>, void>const __rebind<allocator<pair<const Network, NewTriedCount>>, _Hash_node<pair<const Network, NewTriedCount>, false>, void> &__rebind<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node_base *, void>__rebind<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node_base *, void> &__rebind<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node_base *, void> &&const __rebind<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node_base *, void>const __rebind<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node_base *, void> &__rebind<allocator<pair<const CService, int>>, _Hash_node<pair<const CService, int>, false>, void>__rebind<allocator<pair<const CService, int>>, _Hash_node<pair<const CService, int>, false>, void> &__rebind<allocator<pair<const CService, int>>, _Hash_node<pair<const CService, int>, false>, void> &&const __rebind<allocator<pair<const CService, int>>, _Hash_node<pair<const CService, int>, false>, void>const __rebind<allocator<pair<const CService, int>>, _Hash_node<pair<const CService, int>, false>, void> &__rebind<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node_base *, void>__rebind<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node_base *, void> &__rebind<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node_base *, void> &&const __rebind<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node_base *, void>const __rebind<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node_base *, void> &__rebind<allocator<pair<const int, AddrInfo>>, _Hash_node<pair<const int, AddrInfo>, false>, void>__rebind<allocator<pair<const int, AddrInfo>>, _Hash_node<pair<const int, AddrInfo>, false>, void> &__rebind<allocator<pair<const int, AddrInfo>>, _Hash_node<pair<const int, AddrInfo>, false>, void> &&const __rebind<allocator<pair<const int, AddrInfo>>, _Hash_node<pair<const int, AddrInfo>, false>, void>const __rebind<allocator<pair<const int, AddrInfo>>, _Hash_node<pair<const int, AddrInfo>, false>, void> &CTransactionRefvector<int, allocator<int>> *_Hashtable<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *_Hashtable_alloc<allocator<_Hash_node<pair<const int, AddrInfo>, false>>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, AddrInfo>, false>>, true> *_Hashtable<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *_Hashtable_alloc<allocator<_Hash_node<pair<const CService, int>, false>>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const CService, int>, false>>, true> *_Vector_base<int, allocator<int>> *_Node_iterator_base<pair<const int, AddrInfo>, false> *const unordered_map<int, AddrInfo, hash<int>, equal_to<int>, allocator<pair<const int, AddrInfo>>> *pair<int, int> *constpair<int, int> *const &pair<int, int> *&const __normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>> *vector<pair<int, int>, allocator<pair<int, int>>> *_Vector_base<pair<int, int>, allocator<pair<int, int>>> *pair<CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &&const _Node_iterator<pair<const int, AddrInfo>, false, false> *const _Node_iterator_base<pair<const int, AddrInfo>, false> *_Hash_node_value_base<pair<const int, AddrInfo>> *const _Node_iterator<pair<const CService, int>, false, false> *const _Node_iterator_base<pair<const CService, int>, false> *_Node_iterator_base<pair<const CService, int>, false> *_Hash_node_value_base<pair<const CService, int>> *const vector<int, allocator<int>> *const __normal_iterator<const int *, vector<int, allocator<int>>>const __normal_iterator<const int *, vector<int, allocator<int>>> &__normal_iterator<const int *, vector<int, allocator<int>>> &const _Rb_tree_const_iterator<int> *const _Rb_tree_node<int>const _Rb_tree_node<int> *_Rb_tree_node<int> *const _Node_const_iterator<pair<const Network, NewTriedCount>, false, false> *const _Node_iterator_base<pair<const Network, NewTriedCount>, false> *_Node_iterator_base<pair<const Network, NewTriedCount>, false> *_Hash_node_value_base<pair<const Network, NewTriedCount>> *_Optional_base_impl<Network, _Optional_base<Network, true, true>> *const unordered_map<Network, NewTriedCount, hash<Network>, equal_to<Network>, allocator<pair<const Network, NewTriedCount>>> *_Optional_base_impl<bool, _Optional_base<bool, true, true>> *const optional<bool> *const _Optional_base<bool, true, true>const _Optional_base<bool, true, true> *const _Optional_base_impl<bool, _Optional_base<bool, true, true>> *const optional<Network> *const _Optional_base<Network, true, true>const _Optional_base<Network, true, true> *const _Optional_base_impl<Network, _Optional_base<Network, true, true>> *_Hashtable<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *_Hashtable_alloc<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, true> *_Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *_Hashtable_alloc<allocator<_Hash_node<pair<const int, int>, false>>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, int>, false>>, true> *_Hashtable<int, int, allocator<int>, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, true, true>> *_Hashtable_alloc<allocator<_Hash_node<int, false>>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<int, false>>, true> *Timer<duration<signed long, ratio<1L, 1000L>>> *const unordered_map<int, int, hash<int>, equal_to<int>, allocator<pair<const int, int>>> *const _Node_const_iterator<pair<const int, AddrInfo>, false, false> *const unordered_set<int, hash<int>, equal_to<int>, allocator<int>> *const _Node_const_iterator<pair<const CService, int>, false, false> *const unordered_map<CService, int, CServiceHash, equal_to<CService>, allocator<pair<const CService, int>>>const unordered_map<CService, int, CServiceHash, equal_to<CService>, allocator<pair<const CService, int>>> *const _Vector_base<int, allocator<int>> *unique_ptr<AddrManImpl, default_delete<AddrManImpl>> *AddrManImpl *&&const unique_ptr<AddrManImpl, default_delete<AddrManImpl>> *{}_Tp(+1)_Tp(0)NaNstd::numeric_limits<_Tp>::quiet_NaN()_Tp(1)_Tp(2)3.0_Tp(3)+Infinitystd::numeric_limits<_Tp>::infinity()10.0_Tp(10)+_Tp(1)-1.0-_Tp(1)1000.0_Tp(1000)_Tp(0.5L)19.0_Tp(19)-19.0-_Tp(19)20.0_Tp(20)4.0_Tp(4)_Tp(0.25L)-0.25-_Tp(0.25L)const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &OverrideStream<CDataStream> &OverrideStream<CAutoFile> &Wrapper<ChronoFormatter<signed long, false>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &&Wrapper<ChronoFormatter<signed long, false>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &OverrideStream<CHashVerifier<CDataStream>> &const char[90]char[90]void AddrManImpl::Serialize(Stream &) const [with Stream = HashedSourceWriter<CAutoFile>]const char[72]char[72]void AddrManImpl::Serialize(Stream &) const [with Stream = CDataStream]const char[66]char[66]void AddrManImpl::Unserialize(Stream &) [with Stream = CAutoFile]void AddrManImpl::Unserialize(Stream &) [with Stream = CHashVerifier<CAutoFile>]void AddrManImpl::Unserialize(Stream &) [with Stream = CDataStream]void AddrManImpl::Unserialize(Stream &) [with Stream = CHashVerifier<CDataStream>]const char[186]char[186]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = OverrideStream<HashedSourceWriter<CAutoFile>>; Type = const CAddress; Operation = CSerActionSerialize]lambda [] type at line 139502, col. 13 &&lambda [] type at line 139504, col. 13 &&OverrideStream<OverrideStream<HashedSourceWriter<CAutoFile>>> &const OverrideStream<CDataStream>const char[168]char[168]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = OverrideStream<CDataStream>; Type = const CAddress; Operation = CSerActionSerialize]OverrideStream<CDataStream> *OverrideStream<OverrideStream<CDataStream>> &const OverrideStream<CAutoFile>const char[162]char[162]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = OverrideStream<CAutoFile>; Type = CAddress; Operation = CSerActionUnserialize]OverrideStream<CAutoFile> *OverrideStream<OverrideStream<CAutoFile>> &const char[177]char[177]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = OverrideStream<CHashVerifier<CAutoFile>>; Type = CAddress; Operation = CSerActionUnserialize]OverrideStream<OverrideStream<CHashVerifier<CAutoFile>>> &const char[164]char[164]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = OverrideStream<CDataStream>; Type = CAddress; Operation = CSerActionUnserialize]const OverrideStream<CHashVerifier<CDataStream>>const char[179]char[179]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = OverrideStream<CHashVerifier<CDataStream>>; Type = CAddress; Operation = CSerActionUnserialize]OverrideStream<CHashVerifier<CDataStream>> *OverrideStream<OverrideStream<CHashVerifier<CDataStream>>> &const OverrideStream<OverrideStream<HashedSourceWriter<CAutoFile>>>const OverrideStream<OverrideStream<CDataStream>>const OverrideStream<OverrideStream<CAutoFile>>const OverrideStream<OverrideStream<CHashVerifier<CAutoFile>>>const OverrideStream<OverrideStream<CHashVerifier<CDataStream>>>const unsigned int *const char(*)[13]char(*)[13]const allocator<int>const allocator<int> &const _Vector_base<pair<int, int>, allocator<pair<int, int>>> *const allocator<pair<int, int>>const allocator<pair<int, int>> &const _Hash_code_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>const _Hash_code_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> *_Hash_code_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> *const _Hash_node_value_base<pair<const int, AddrInfo>>const _Hash_node_value_base<pair<const int, AddrInfo>> *const _Hash_code_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false>const _Hash_code_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false> *_Hash_code_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false> *const _Hash_node_value_base<pair<const CService, int>>const _Hash_node_value_base<pair<const CService, int>> *const _Hash_code_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false>const _Hash_code_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false> *_Hash_code_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false> *const hash<Network>const hash<Network> &const __hash_enum<Network, true>const _Hash_node_value_base<pair<const Network, NewTriedCount>>const _Hash_node_value_base<pair<const Network, NewTriedCount>> *_Hash_node<pair<const int, int>, false> *const _Hash_code_base<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>const _Hash_code_base<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> *_Hash_code_base<int, pair<const int, int>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> *const pair<const int, int>const pair<const int, int> &pair<const int, int> &const _Hash_node_value_base<pair<const int, int>>const _Hash_node_value_base<pair<const int, int>> *_Hash_node_value_base<pair<const int, int>> *_Hash_node<int, false> *const _Hash_code_base<int, int, _Identity, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>const _Hash_code_base<int, int, _Identity, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> *_Hash_code_base<int, int, _Identity, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> *const _Hash_node_value_base<int>const _Hash_node_value_base<int> *_Hash_node_value_base<int> *_Insert_base<int, int, allocator<int>, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, true, true>> *_Hashtable<int, int, allocator<int>, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, true, true>> &_Hashtable_alloc<allocator<_Hash_node<int, false>>> &const _AllocNode<allocator<_Hash_node<int, false>>>const _AllocNode<allocator<_Hash_node<int, false>>> &_AllocNode<allocator<_Hash_node<int, false>>> &allocator<_Hash_node<pair<const int, int>, false>> &const new_allocator<int>allocator<_Hash_node<int, false>> &const equal_to<int>const equal_to<int> &const equal_to<CService>const equal_to<CService> &const equal_to<Network>const equal_to<Network> &_AllocNode<allocator<_Hash_node<int, false>>>_AllocNode<allocator<_Hash_node<int, false>>> &&initializer_list<int>initializer_list<int> &initializer_list<int> &&const initializer_list<int>const initializer_list<int> &initializer_list<pair<const Network, NewTriedCount>>initializer_list<pair<const CService, int>>initializer_list<pair<const int, AddrInfo>>__hash_enum<Network, true>__hash_enum<Network, true> &__hash_enum<Network, true> &&const __hash_enum<Network, true> &_Hash_code_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false>_Hash_code_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false> &_Hash_code_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false> &&const _Hash_code_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false> &_Hash_code_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false>_Hash_code_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false> &const _Hash_code_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false> &_Hash_code_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false> &&_Hash_code_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>_Hash_code_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> &_Hash_code_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> &&const _Hash_code_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false> &convertToInt<char[13], false>convertToInt<char[13], false> &convertToInt<char[13], false> &&const convertToInt<char[13], false>const convertToInt<char[13], false> &convertToInt<unsigned char, true>convertToInt<unsigned char, true> &convertToInt<unsigned char, true> &&const convertToInt<unsigned char, true>const convertToInt<unsigned char, true> &convertToInt<unsigned int, true>convertToInt<unsigned int, true> &convertToInt<unsigned int, true> &&const convertToInt<unsigned int, true>const convertToInt<unsigned int, true> &convertToInt<int, true>convertToInt<int, true> &convertToInt<int, true> &&const convertToInt<int, true>const convertToInt<int, true> &OverrideStream<OverrideStream<CHashVerifier<CDataStream>>>const OverrideStream<OverrideStream<CHashVerifier<CDataStream>>> &OverrideStream<OverrideStream<CHashVerifier<CDataStream>>> &&OverrideStream<OverrideStream<CHashVerifier<CAutoFile>>>const OverrideStream<OverrideStream<CHashVerifier<CAutoFile>>> &OverrideStream<OverrideStream<CHashVerifier<CAutoFile>>> &&OverrideStream<OverrideStream<CAutoFile>>const OverrideStream<OverrideStream<CAutoFile>> &OverrideStream<OverrideStream<CAutoFile>> &&OverrideStream<OverrideStream<CDataStream>>const OverrideStream<OverrideStream<CDataStream>> &OverrideStream<OverrideStream<CDataStream>> &&OverrideStream<OverrideStream<HashedSourceWriter<CAutoFile>>>const OverrideStream<OverrideStream<HashedSourceWriter<CAutoFile>>> &OverrideStream<OverrideStream<HashedSourceWriter<CAutoFile>>> &&OverrideStream<CHashVerifier<CDataStream>>const OverrideStream<CHashVerifier<CDataStream>> &OverrideStream<CHashVerifier<CDataStream>> &&Wrapper<ChronoFormatter<signed long, false>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>const Wrapper<ChronoFormatter<signed long, false>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>const Wrapper<ChronoFormatter<signed long, false>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &OverrideStream<CAutoFile>const OverrideStream<CAutoFile> &OverrideStream<CAutoFile> &&OverrideStream<CDataStream>const OverrideStream<CDataStream> &OverrideStream<CDataStream> &&Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &&__numeric_constants<long double>__numeric_constants<long double> &__numeric_constants<long double> &&const __numeric_constants<long double>const __numeric_constants<long double> &__numeric_constants<float>__numeric_constants<float> &__numeric_constants<float> &&const __numeric_constants<float>const __numeric_constants<float> &_Map_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Map_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Map_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Map_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Map_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, true>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, true> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, true> &&const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, true>const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, true> &_Hashtable_alloc<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>_Hashtable_alloc<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>> &const _Hashtable_alloc<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>const _Hashtable_alloc<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>> &_Hash_node_value_base<pair<const Network, NewTriedCount>>_Hash_node_value_base<pair<const Network, NewTriedCount>> &_Hash_node_value_base<pair<const Network, NewTriedCount>> &&const _Hash_node_value_base<pair<const Network, NewTriedCount>> &_Map_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Map_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Map_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Map_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Map_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &__normal_iterator<const int *, vector<int, allocator<int>>>__normal_iterator<const int *, vector<int, allocator<int>>> &&_Map_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Map_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Map_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Map_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Map_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Hash_node_value_base<pair<const CService, int>>_Hash_node_value_base<pair<const CService, int>> &_Hash_node_value_base<pair<const CService, int>> &&const _Hash_node_value_base<pair<const CService, int>> &_Hash_node_value_base<pair<const int, AddrInfo>>_Hash_node_value_base<pair<const int, AddrInfo>> &_Hash_node_value_base<pair<const int, AddrInfo>> &&const _Hash_node_value_base<pair<const int, AddrInfo>> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const CService, int>, false>>, true>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const CService, int>, false>>, true> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const CService, int>, false>>, true> &&const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const CService, int>, false>>, true>const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const CService, int>, false>>, true> &_Hashtable_alloc<allocator<_Hash_node<pair<const CService, int>, false>>>_Hashtable_alloc<allocator<_Hash_node<pair<const CService, int>, false>>> &const _Hashtable_alloc<allocator<_Hash_node<pair<const CService, int>, false>>>const _Hashtable_alloc<allocator<_Hash_node<pair<const CService, int>, false>>> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, AddrInfo>, false>>, true>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, AddrInfo>, false>>, true> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, AddrInfo>, false>>, true> &&const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, AddrInfo>, false>>, true>const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, AddrInfo>, false>>, true> &_Hashtable_alloc<allocator<_Hash_node<pair<const int, AddrInfo>, false>>>_Hashtable_alloc<allocator<_Hash_node<pair<const int, AddrInfo>, false>>> &const _Hashtable_alloc<allocator<_Hash_node<pair<const int, AddrInfo>, false>>>const _Hashtable_alloc<allocator<_Hash_node<pair<const int, AddrInfo>, false>>> &const pair<int, int>const pair<int, int> *const _Hash_node<pair<const Network, NewTriedCount>, false>const _Hash_node<pair<const Network, NewTriedCount>, false> *const _Hash_node<pair<const CService, int>, false>const _Hash_node<pair<const CService, int>, false> *const _Hash_node<pair<const int, AddrInfo>, false>const _Hash_node<pair<const int, AddrInfo>, false> *const pair<int, int> &const _Hash_node<pair<const Network, NewTriedCount>, false> &_Hash_node<pair<const Network, NewTriedCount>, false> &const _Rb_tree_node<int> &_Rb_tree_node<int> &const _Hash_node<pair<const CService, int>, false> &_Hash_node<pair<const CService, int>, false> &const _Hash_node<pair<const int, AddrInfo>, false> &_Hash_node<pair<const int, AddrInfo>, false> &rebind<_Hash_node<pair<const Network, NewTriedCount>, false>>rebind<_Hash_node<pair<const Network, NewTriedCount>, false>> &rebind<_Hash_node<pair<const Network, NewTriedCount>, false>> &&const rebind<_Hash_node<pair<const Network, NewTriedCount>, false>>const rebind<_Hash_node<pair<const Network, NewTriedCount>, false>> &_Rb_tree_node<int>_Rb_tree_node<int> &&rebind<int>rebind<int> &rebind<int> &&const rebind<int>const rebind<int> &rebind<_Hash_node<pair<const CService, int>, false>>rebind<_Hash_node<pair<const CService, int>, false>> &rebind<_Hash_node<pair<const CService, int>, false>> &&const rebind<_Hash_node<pair<const CService, int>, false>>const rebind<_Hash_node<pair<const CService, int>, false>> &rebind<_Hash_node<pair<const int, AddrInfo>, false>>rebind<_Hash_node<pair<const int, AddrInfo>, false>> &rebind<_Hash_node<pair<const int, AddrInfo>, false>> &&const rebind<_Hash_node<pair<const int, AddrInfo>, false>>const rebind<_Hash_node<pair<const int, AddrInfo>, false>> &_Storage<allocator<_Hash_node<int, false>>, false>_Storage<allocator<_Hash_node<int, false>>, false> &const _Storage<allocator<_Hash_node<int, false>>, false>const _Storage<allocator<_Hash_node<int, false>>, false> &_Storage<allocator<_Rb_tree_node<int>>, false>_Storage<allocator<_Rb_tree_node<int>>, false> &const _Storage<allocator<_Rb_tree_node<int>>, false>const _Storage<allocator<_Rb_tree_node<int>>, false> &_Storage<AddressPosition, true>_Storage<AddressPosition, true> &const _Storage<AddressPosition, true>const _Storage<AddressPosition, true> &_Storage<AddressPosition, true> &&_Node_handle_common<int, allocator<_Hash_node<int, false>>>_Node_handle_common<int, allocator<_Hash_node<int, false>>> &const _Node_handle_common<int, allocator<_Hash_node<int, false>>>const _Node_handle_common<int, allocator<_Hash_node<int, false>>> &_Node_handle_common_AllocTraits_Node_handle_common<int, allocator<_Rb_tree_node<int>>>_Node_handle_common<int, allocator<_Rb_tree_node<int>>> &const _Node_handle_common<int, allocator<_Rb_tree_node<int>>>const _Node_handle_common<int, allocator<_Rb_tree_node<int>>> &pair<_Node_iterator<pair<const int, int>, false, false>, bool>is_Span<const signed long>is_Span<const signed long> &is_Span<const signed long> &&const is_Span<const signed long>const is_Span<const signed long> &is_Span_int<signed long>is_Span_int<signed long> &is_Span_int<signed long> &&const is_Span_int<signed long>const is_Span_int<signed long> &is_Span<signed long>is_Span<signed long> &is_Span<signed long> &&const is_Span<signed long>const is_Span<signed long> &is_Span<const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>is_Span<const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &&const is_Span<const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>const is_Span<const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span_int<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>is_Span_int<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span_int<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &&const is_Span_int<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>const is_Span_int<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>is_Span<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &&const is_Span<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>const is_Span<Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<const AddrInfo>is_Span<const AddrInfo> &is_Span<const AddrInfo> &&const is_Span<const AddrInfo>const is_Span<const AddrInfo> &is_Span_int<AddrInfo>is_Span_int<AddrInfo> &is_Span_int<AddrInfo> &&const is_Span_int<AddrInfo>const is_Span_int<AddrInfo> &is_Span<AddrInfo>is_Span<AddrInfo> &is_Span<AddrInfo> &&const is_Span<AddrInfo>const is_Span<AddrInfo> &is_Span<const int>is_Span<const int> &is_Span<const int> &&const is_Span<const int>const is_Span<const int> &is_Span_int<int>is_Span_int<int> &is_Span_int<int> &&const is_Span_int<int>const is_Span_int<int> &is_Span<int>is_Span<int> &is_Span<int> &&const is_Span<int>const is_Span<int> &is_Span<const unsigned long>is_Span<const unsigned long> &is_Span<const unsigned long> &&const is_Span<const unsigned long>const is_Span<const unsigned long> &is_Span_int<unsigned long>is_Span_int<unsigned long> &is_Span_int<unsigned long> &&const is_Span_int<unsigned long>const is_Span_int<unsigned long> &is_Span<unsigned long>is_Span<unsigned long> &is_Span<unsigned long> &&const is_Span<unsigned long>const is_Span<unsigned long> &is_Span<const vector<unsigned char, allocator<unsigned char>>>is_Span<const vector<unsigned char, allocator<unsigned char>>> &is_Span<const vector<unsigned char, allocator<unsigned char>>> &&const is_Span<const vector<unsigned char, allocator<unsigned char>>>const is_Span<const vector<unsigned char, allocator<unsigned char>>> &is_Span_int<vector<unsigned char, allocator<unsigned char>>>is_Span_int<vector<unsigned char, allocator<unsigned char>>> &is_Span_int<vector<unsigned char, allocator<unsigned char>>> &&const is_Span_int<vector<unsigned char, allocator<unsigned char>>>const is_Span_int<vector<unsigned char, allocator<unsigned char>>> &is_Span<vector<unsigned char, allocator<unsigned char>>>is_Span<vector<unsigned char, allocator<unsigned char>>> &is_Span<vector<unsigned char, allocator<unsigned char>>> &&const is_Span<vector<unsigned char, allocator<unsigned char>>>const is_Span<vector<unsigned char, allocator<unsigned char>>> &pair<_Rb_tree_iterator<int>, bool>pair<_Rb_tree_iterator<int>, _Rb_tree_iterator<int>>_Rb_tree<int, int, _Identity<int>, _Compare2, allocator<int>>_Identity<int>_Identity<int> &_Identity<int> &&const _Identity<int>const _Identity<int> &_Rb_tree_impl<less<int>, true>_Rb_tree_impl<less<int>, true> &const _Rb_tree_impl<less<int>, true>const _Rb_tree_impl<less<int>, true> &_Rb_tree_impl<less<int>, true> *_Enable_copy_move<true, false, true, false, optional<AddressPosition>>_Optional_base<AddressPosition, true, true>__pair_base<CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>allocator<T>pair<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, bool>unordered_map<Network, NewTriedCount, _H2, _P2, allocator<pair<const Network, NewTriedCount>>>unordered_multimap<Network, NewTriedCount, _H2, _P2, allocator<pair<const Network, NewTriedCount>>>equal_to<Network>equal_to<Network> &&hash<Network>hash<Network> &&set<int, _Compare1, allocator<int>>multiset<int, _Compare1, allocator<int>>pair<_Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>>pair<_Node_iterator<pair<const CService, int>, false, false>, bool>unordered_map<CService, int, _H2, _P2, allocator<pair<const CService, int>>>unordered_multimap<CService, int, _H2, _P2, allocator<pair<const CService, int>>>equal_to<CService>equal_to<CService> &&pair<_Node_iterator<pair<const int, AddrInfo>, false, false>, bool>unordered_map<int, AddrInfo, _H2, _P2, allocator<pair<const int, AddrInfo>>>unordered_multimap<int, AddrInfo, _H2, _P2, allocator<pair<const int, AddrInfo>>>_MakeUniq<AddrManImpl>_MakeUniq<AddrManImpl> &_MakeUniq<AddrManImpl> &&const _MakeUniq<AddrManImpl>const _MakeUniq<AddrManImpl> &__pair_base<const int, AddrInfo>_Hash_node<pair<const int, AddrInfo>, false>_Hash_node<pair<const int, AddrInfo>, false> &&_Node_iterator<int, true, false>_Node_iterator<int, true, false> &&_Node_iterator<int, true, false> *__pair_base<_Node_iterator<int, true, false>, bool>_Hash_node<pair<const CService, int>, false>_Hash_node<pair<const CService, int>, false> &&__pair_base<const CService, int>__alloc_traits<allocator<int>, int>__alloc_traits<allocator<int>, int> &__alloc_traits<allocator<int>, int> &&const __alloc_traits<allocator<int>, int>const __alloc_traits<allocator<int>, int> &__pair_base<const Network, NewTriedCount>tuple_element<(unsigned long)0UL, const pair<const Network, NewTriedCount>>tuple_element<(unsigned long)0UL, const pair<const Network, NewTriedCount>> &tuple_element<(unsigned long)0UL, const pair<const Network, NewTriedCount>> &&const tuple_element<(unsigned long)0UL, const pair<const Network, NewTriedCount>>const tuple_element<(unsigned long)0UL, const pair<const Network, NewTriedCount>> &tuple_element<(unsigned long)0UL, pair<const Network, NewTriedCount>>tuple_element<(unsigned long)0UL, pair<const Network, NewTriedCount>> &tuple_element<(unsigned long)0UL, pair<const Network, NewTriedCount>> &&const tuple_element<(unsigned long)0UL, pair<const Network, NewTriedCount>>const tuple_element<(unsigned long)0UL, pair<const Network, NewTriedCount>> &tuple_element<1UL, const pair<const Network, NewTriedCount>>tuple_element<1UL, const pair<const Network, NewTriedCount>> &tuple_element<1UL, const pair<const Network, NewTriedCount>> &&const tuple_element<1UL, const pair<const Network, NewTriedCount>>const tuple_element<1UL, const pair<const Network, NewTriedCount>> &tuple_element<1UL, pair<const Network, NewTriedCount>>tuple_element<1UL, pair<const Network, NewTriedCount>> &tuple_element<1UL, pair<const Network, NewTriedCount>> &&const tuple_element<1UL, pair<const Network, NewTriedCount>>const tuple_element<1UL, pair<const Network, NewTriedCount>> &_Hash_node<pair<const Network, NewTriedCount>, false>_Hash_node<pair<const Network, NewTriedCount>, false> &&_Hashtable<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &__pair_base<_Rb_tree_const_iterator<int>, bool>CustomUintFormatter<1, false>CustomUintFormatter<1, false> &CustomUintFormatter<1, false> &&const CustomUintFormatter<1, false>const CustomUintFormatter<1, false> &__alloc_traits<allocator<pair<int, int>>, pair<int, int>>__alloc_traits<allocator<pair<int, int>>, pair<int, int>> &__alloc_traits<allocator<pair<int, int>>, pair<int, int>> &&const __alloc_traits<allocator<pair<int, int>>, pair<int, int>>const __alloc_traits<allocator<pair<int, int>>, pair<int, int>> &__pair_base<int, int>_Hashtable<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &allocator<_Rb_tree_node<int>> *allocator<int> *allocator<pair<int, int>> *const new_allocator<pair<int, int>> *new_allocator<pair<int, int>> *new_allocator<_Rb_tree_node<int>> *const new_allocator<_Rb_tree_node<int>> *new_allocator<_Hash_node<pair<const Network, NewTriedCount>, false>> *const new_allocator<_Hash_node<pair<const Network, NewTriedCount>, false>> *new_allocator<_Hash_node<pair<const CService, int>, false>> *const new_allocator<_Hash_node<pair<const CService, int>, false>> *new_allocator<_Hash_node<pair<const int, AddrInfo>, false>> *const new_allocator<_Hash_node<pair<const int, AddrInfo>, false>> *new_allocator<_Hash_node<int, false>> *const new_allocator<_Hash_node<int, false>>const new_allocator<_Hash_node<int, false>> *const new_allocator<int> *new_allocator<int> *2305843009213693951new_allocator<_Hash_node<pair<const int, int>, false>> *const new_allocator<_Hash_node<pair<const int, int>, false>>const new_allocator<_Hash_node<pair<const int, int>, false>> *_Hashtable_base<int, int, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, true, true>> *const _Hashtable<int, int, allocator<int>, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, true, true>>const _Hashtable<int, int, allocator<int>, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, true, true>> *_AllocNode<allocator<_Hash_node<int, false>>> *_Insert<int, int, allocator<int>, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, true, true>, true> *const _Hashtable_ebo_helper<0, _Identity, true>const _Hashtable_ebo_helper<0, _Identity, true> &_Hashtable_ebo_helper<0, _Identity, true> &const _Hashtable_ebo_helper<1, hash<int>, true>const _Hashtable_ebo_helper<1, hash<int>, true> &_Hashtable_ebo_helper<1, hash<int>, true> &const pair<const int, int> *pair<const int, int> *const _Hashtable_ebo_helper<1, hash<Network>, true>const _Hashtable_ebo_helper<1, hash<Network>, true> &_Hashtable_ebo_helper<1, hash<Network>, true> &const __hash_enum<Network, true> *__hash_enum<Network, true> *const _Hashtable_ebo_helper<1, CServiceHash, false>const _Hashtable_ebo_helper<1, CServiceHash, false> &_Hashtable_ebo_helper<1, CServiceHash, false> &direct_or_indirect &OverrideStream<OverrideStream<CHashVerifier<CDataStream>>> *const OverrideStream<OverrideStream<CHashVerifier<CDataStream>>> *OverrideStream<OverrideStream<CDataStream>> *OverrideStream<OverrideStream<CHashVerifier<CAutoFile>>> *const OverrideStream<OverrideStream<CHashVerifier<CAutoFile>>> *OverrideStream<OverrideStream<CAutoFile>> *const OverrideStream<OverrideStream<CAutoFile>> *const OverrideStream<OverrideStream<CDataStream>> *OverrideStream<OverrideStream<HashedSourceWriter<CAutoFile>>> *const OverrideStream<OverrideStream<HashedSourceWriter<CAutoFile>>> *const OverrideStream<CHashVerifier<CDataStream>> *const OverrideStream<CAutoFile> *const OverrideStream<CDataStream> *const duration<double, ratio<1L, 1000L>> *duration<double, ratio<1L, 1000L>> *static_cast<_Tp>(1.1447298858494001741434273513530587L)1.1447298531.084202172485504434e-19std::numeric_limits<_Tp>::epsilon()4932.0std::numeric_limits<_Tp>::max_exponent10_Tp(-1)static_cast<_Tp>(1.5707963267948966192313216916397514L)const long double[]long double[]const long double[29]long double[29]sizeof(__prime)sizeof(__prime) / sizeof(_Tp)5.0_Tp(5)7.0_Tp(7)11.0_Tp(11)13.0_Tp(13)17.0_Tp(17)23.0_Tp(23)29.0_Tp(29)31.0_Tp(31)37.0_Tp(37)41.0_Tp(41)43.0_Tp(43)47.0_Tp(47)53.0_Tp(53)59.0_Tp(59)61.0_Tp(61)67.0_Tp(67)71.0_Tp(71)73.0_Tp(73)79.0_Tp(79)83.0_Tp(83)89.0_Tp(89)97.0_Tp(97)101.0_Tp(101)103.0_Tp(103)107.0_Tp(107)109.0_Tp(109)1.192092896e-0738.01.570796371const float[]float[]const float[29]float[29]static_cast<_Tp>(3.1415926535897932384626433832795029L)3.1415927413.3621031431120935063e-4932std::numeric_limits<_Tp>::min()_Tp(1.5L)8.0_Tp(8)1.175494351e-381.084202172485504434e-18_Tp(10) * std::numeric_limits<_Tp>::epsilon()1.192092896e-061.189731495357231765e+4932std::numeric_limits<_Tp>::max()1.6810515715560467531e-4931_Tp(5) * __min0.33333333333333333334_Tp(1)/_Tp(3)_Tp(0.3L)_Tp(0.2L)2.37946299071446353e+4931_Tp(0.2L) * __max_Tp(1) / _Tp(4)14.0_Tp(14)0.21428571428571428572_Tp(3) / _Tp(14)_Tp(1) / _Tp(3)22.0_Tp(22)0.13636363636363636364_Tp(3) / _Tp(22)26.0_Tp(26)0.11538461538461538462_Tp(3) / _Tp(26)1.3552527156068805425e-20__eps / _Tp(8)6.0_Tp(6)0.16666666666666666667_Tp(1) / _Tp(6)-0.21428571428571428572-__c10.40909090909090909093_Tp(3) * __c30.34615384615384615384_Tp(3) * __c4__c2 / _Tp(2)-0.13636363636363636364-__c3-0.27272727272727272728-__c3 - __c33.402823466e+385.877471754e-380.33333334330.30000001190.2000000036.805646933e+370.21428571640.13636364040.1153846161.490116119e-080.1666666716-0.21428571640.40909093620.3461538553-0.1363636404-0.27272728090.66666666666666666668_Tp(2) / _Tp(3)_Tp(0.1L)9.0_Tp(9)0.40909090909090909091_Tp(9) / _Tp(22)-0.409090909090909090910.66666668650.10000000150.4090909064-0.4090909064__max / _Tp(5)24.0_Tp(24)0.041666666666666666668_Tp(1) / _Tp(24)_Tp(1) / _Tp(10)44.0_Tp(44)0.06818181818181818182_Tp(3) / _Tp(44)0.07142857142857142857_Tp(1) / _Tp(14)0.041666667910.068181820210.07142857462const default_delete<AddrManImpl> *default_delete<AddrManImpl> *__uniq_ptr_impl<AddrManImpl, default_delete<AddrManImpl>> *__tuple_element_t<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>> &const _Hashtable<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *const _Hashtable_base<CService, pair<const CService, int>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>const _Hashtable_base<CService, pair<const CService, int>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *_Hashtable_base<CService, pair<const CService, int>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *_Map_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> *_Hashtable_base<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *const _Hashtable<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *tuple<Network &&> &&tuple<Network &&> &const _Node_iterator<pair<const Network, NewTriedCount>, false, false>_Map_base<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> *_Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *const _Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<int, pair<const int, int>, allocator<pair<const int, int>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *tuple<const int &> &&tuple<const int &> &const _Node_iterator<pair<const int, int>, false, false>const _Hashtable<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *const _Hashtable_base<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>const _Hashtable_base<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *_Hashtable_base<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *const _Hashtable_base<int, int, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, true, true>>const _Hashtable_base<int, int, _Identity, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, true, true>> *const _Hash_node<int, false>const _Hash_node<int, false> *const _Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>const _Hashtable_base<int, pair<const int, int>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *const _Hash_node<pair<const int, int>, false>const _Hash_node<pair<const int, int>, false> *tuple<const Network &> &&tuple<const Network &> &allocator<_Hash_node<int, false>> *allocator<_Hash_node<pair<const int, int>, false>> *allocator<_Hash_node<pair<const Network, NewTriedCount>, false>> *const _Hashtable_base<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>const _Hashtable_base<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *_Optional_base<AddressPosition, true, true> *const _Rb_tree<int, int, _Identity<int>, less<int>, allocator<int>> *_Rb_tree<int, int, _Identity<int>, less<int>, allocator<int>> *time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> *__iterator_category_Map_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> *const unsigned long long_Val::valueconst int *constconst int *const &int *&const time_point<NodeClock, duration<signed long, ratio<1L, 1000000000L>>> *time_point<NodeClock, duration<signed long, ratio<1L, 1000000000L>>> *_Map_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> *tuple<const CService &> &&tuple<const CService &> &int *constint *const &const __normal_iterator<int *, vector<int, allocator<int>>>const __normal_iterator<int *, vector<int, allocator<int>>> &__normal_iterator<int *, vector<int, allocator<int>>> &Wrapper<CustomUintFormatter<1, false>, Format &> *const vector<pair<int, int>, allocator<pair<int, int>>>const vector<pair<int, int>, allocator<pair<int, int>>> *allocator<_Hash_node<pair<const CService, int>, false>> *allocator<_Hash_node<pair<const int, AddrInfo>, false>> *..(*)(..))[13]is_trivially_destructible<allocator<_Hash_node<int, false>>>is_trivially_destructible<allocator<_Hash_node<int, false>>> &is_trivially_destructible<allocator<_Hash_node<int, false>>> &&const is_trivially_destructible<allocator<_Hash_node<int, false>>>const is_trivially_destructible<allocator<_Hash_node<int, false>>> &is_trivially_destructible<allocator<_Rb_tree_node<int>>>is_trivially_destructible<allocator<_Rb_tree_node<int>>> &is_trivially_destructible<allocator<_Rb_tree_node<int>>> &&const is_trivially_destructible<allocator<_Rb_tree_node<int>>>const is_trivially_destructible<allocator<_Rb_tree_node<int>>> &is_trivially_destructible<AddressPosition>is_trivially_destructible<AddressPosition> &is_trivially_destructible<AddressPosition> &&const is_trivially_destructible<AddressPosition>const is_trivially_destructible<AddressPosition> &is_copy_assignable<AddressPosition>is_copy_assignable<AddressPosition> &is_copy_assignable<AddressPosition> &&const is_copy_assignable<AddressPosition>const is_copy_assignable<AddressPosition> &is_copy_constructible<AddressPosition>is_copy_constructible<AddressPosition> &is_copy_constructible<AddressPosition> &&const is_copy_constructible<AddressPosition>const is_copy_constructible<AddressPosition> &__and_<is_copy_constructible<AddressPosition>, is_copy_assignable<AddressPosition>>__and_<is_copy_constructible<AddressPosition>, is_copy_assignable<AddressPosition>> &__and_<is_copy_constructible<AddressPosition>, is_copy_assignable<AddressPosition>> &&const __and_<is_copy_constructible<AddressPosition>, is_copy_assignable<AddressPosition>>const __and_<is_copy_constructible<AddressPosition>, is_copy_assignable<AddressPosition>> &is_move_assignable<AddressPosition>is_move_assignable<AddressPosition> &is_move_assignable<AddressPosition> &&const is_move_assignable<AddressPosition>const is_move_assignable<AddressPosition> &is_move_constructible<AddressPosition>is_move_constructible<AddressPosition> &is_move_constructible<AddressPosition> &&const is_move_constructible<AddressPosition>const is_move_constructible<AddressPosition> &__and_<is_move_constructible<AddressPosition>, is_move_assignable<AddressPosition>>__and_<is_move_constructible<AddressPosition>, is_move_assignable<AddressPosition>> &__and_<is_move_constructible<AddressPosition>, is_move_assignable<AddressPosition>> &&const __and_<is_move_constructible<AddressPosition>, is_move_assignable<AddressPosition>>const __and_<is_move_constructible<AddressPosition>, is_move_assignable<AddressPosition>> &is_trivially_copy_constructible<AddressPosition>is_trivially_copy_constructible<AddressPosition> &is_trivially_copy_constructible<AddressPosition> &&const is_trivially_copy_constructible<AddressPosition>const is_trivially_copy_constructible<AddressPosition> &is_trivially_move_constructible<AddressPosition>is_trivially_move_constructible<AddressPosition> &is_trivially_move_constructible<AddressPosition> &&const is_trivially_move_constructible<AddressPosition>const is_trivially_move_constructible<AddressPosition> &integral_constant<unsigned long long, 60ULL>integral_constant<unsigned long long, 60ULL> &integral_constant<unsigned long long, 60ULL> &&const integral_constant<unsigned long long, 60ULL>const integral_constant<unsigned long long, 60ULL> &integral_constant<unsigned long long, 20ULL>integral_constant<unsigned long long, 20ULL> &integral_constant<unsigned long long, 20ULL> &&const integral_constant<unsigned long long, 20ULL>const integral_constant<unsigned long long, 20ULL> &integral_constant<unsigned long long, 24ULL>integral_constant<unsigned long long, 24ULL> &integral_constant<unsigned long long, 24ULL> &&const integral_constant<unsigned long long, 24ULL>const integral_constant<unsigned long long, 24ULL> &integral_constant<unsigned long long, 10ULL>integral_constant<unsigned long long, 10ULL> &integral_constant<unsigned long long, 10ULL> &&const integral_constant<unsigned long long, 10ULL>const integral_constant<unsigned long long, 10ULL> &integral_constant<unsigned long long, 40ULL>integral_constant<unsigned long long, 40ULL> &integral_constant<unsigned long long, 40ULL> &&const integral_constant<unsigned long long, 40ULL>const integral_constant<unsigned long long, 40ULL> &integral_constant<unsigned long long, 4ULL>integral_constant<unsigned long long, 4ULL> &integral_constant<unsigned long long, 4ULL> &&const integral_constant<unsigned long long, 4ULL>const integral_constant<unsigned long long, 4ULL> &_Parse_int<'4'>_Parse_int_Parse_int<'4'> &_Parse_int<'4'> &&const _Parse_int<'4'>const _Parse_int<'4'> &_Parse_int<'4', '0'>_Parse_int<'4', '0'> &_Parse_int<'4', '0'> &&const _Parse_int<'4', '0'>const _Parse_int<'4', '0'> &is_nothrow_constructible<pair<int, int>, int &, int &>is_nothrow_constructible<pair<int, int>, int &, int &> &is_nothrow_constructible<pair<int, int>, int &, int &> &&const is_nothrow_constructible<pair<int, int>, int &, int &>const is_nothrow_constructible<pair<int, int>, int &, int &> &FormatListN<4>FormatListN<4> &const FormatListN<4>const FormatListN<4> &FormatArg[4]_Parse_int<'1', '0'>_Parse_int<'1', '0'> &_Parse_int<'1', '0'> &&const _Parse_int<'1', '0'>const _Parse_int<'1', '0'> &is_nothrow_constructible<int, const int &>is_nothrow_constructible<int, const int &> &is_nothrow_constructible<int, const int &> &&const is_nothrow_constructible<int, const int &>const is_nothrow_constructible<int, const int &> &tuple<const CService &>const tuple<const CService &>const tuple<const CService &> &_Parse_int<'2', '4'>_Parse_int<'2', '4'> &_Parse_int<'2', '4'> &&const _Parse_int<'2', '4'>const _Parse_int<'2', '4'> &is_nothrow_constructible<CAddress, const CAddress &>is_nothrow_constructible<CAddress, const CAddress &> &is_nothrow_constructible<CAddress, const CAddress &> &&const is_nothrow_constructible<CAddress, const CAddress &>const is_nothrow_constructible<CAddress, const CAddress &> &_Parse_int<'2', '0'>_Parse_int<'2', '0'> &_Parse_int<'2', '0'> &&const _Parse_int<'2', '0'>const _Parse_int<'2', '0'> &_Parse_int<'6', '0'>_Parse_int<'6', '0'> &_Parse_int<'6', '0'> &&const _Parse_int<'6', '0'>const _Parse_int<'6', '0'> &tuple<const Network &>const tuple<const Network &>const tuple<const Network &> &const tuple<const int &>const tuple<const int &> &tuple<Network &&>const tuple<Network &&>const tuple<Network &&> &__duration_cast_impl<duration<double, ratio<1L, 1000L>>, ratio<1L, 1000000L>, double, true, false>__duration_cast_impl<duration<double, ratio<1L, 1000L>>, ratio<1L, 1000000L>, double, true, false> &__duration_cast_impl<duration<double, ratio<1L, 1000L>>, ratio<1L, 1000000L>, double, true, false> &&const __duration_cast_impl<duration<double, ratio<1L, 1000L>>, ratio<1L, 1000000L>, double, true, false>const __duration_cast_impl<duration<double, ratio<1L, 1000L>>, ratio<1L, 1000000L>, double, true, false> &formatValueAsType<int, const void *, false>formatValueAsType<int, const void *, false> &formatValueAsType<int, const void *, false> &&const formatValueAsType<int, const void *, false>const formatValueAsType<int, const void *, false> &formatValueAsType<int, char, true>formatValueAsType<int, char, true> &formatValueAsType<int, char, true> &&const formatValueAsType<int, char, true>const formatValueAsType<int, char, true> &is_convertible<int, const void *>is_convertible<int, const void *> &is_convertible<int, const void *> &&const is_convertible<int, const void *>const is_convertible<int, const void *> &is_convertible<int, char>is_convertible<int, char> &is_convertible<int, char> &&const is_convertible<int, char>const is_convertible<int, char> &formatValueAsType<unsigned int, const void *, false>formatValueAsType<unsigned int, const void *, false> &formatValueAsType<unsigned int, const void *, false> &&const formatValueAsType<unsigned int, const void *, false>const formatValueAsType<unsigned int, const void *, false> &formatValueAsType<unsigned int, char, true>formatValueAsType<unsigned int, char, true> &formatValueAsType<unsigned int, char, true> &&const formatValueAsType<unsigned int, char, true>const formatValueAsType<unsigned int, char, true> &is_convertible<unsigned int, const void *>is_convertible<unsigned int, const void *> &is_convertible<unsigned int, const void *> &&const is_convertible<unsigned int, const void *>const is_convertible<unsigned int, const void *> &is_convertible<unsigned int, char>is_convertible<unsigned int, char> &is_convertible<unsigned int, char> &&const is_convertible<unsigned int, char>const is_convertible<unsigned int, char> &formatValueAsType<char[13], const void *, true>formatValueAsType<char[13], const void *, true> &formatValueAsType<char[13], const void *, true> &&const formatValueAsType<char[13], const void *, true>const formatValueAsType<char[13], const void *, true> &formatValueAsType<char[13], char, false>formatValueAsType<char[13], char, false> &formatValueAsType<char[13], char, false> &&const formatValueAsType<char[13], char, false>const formatValueAsType<char[13], char, false> &is_convertible<char[13], const void *>is_convertible<char[13], const void *> &is_convertible<char[13], const void *> &&const is_convertible<char[13], const void *>const is_convertible<char[13], const void *> &is_convertible<char[13], char>is_convertible<char[13], char> &is_convertible<char[13], char> &&const is_convertible<char[13], char>const is_convertible<char[13], char> &_Equality<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Equality<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Equality<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Equality<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Equality<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Rehash_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>_Rehash_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Rehash_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &&const _Rehash_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>const _Rehash_base<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Equality<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Equality<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Equality<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Equality<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Equality<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Rehash_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>_Rehash_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Rehash_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &&const _Rehash_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>const _Rehash_base<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &iterator_traits<pair<int, int> *>iterator_traits<pair<int, int> *> &iterator_traits<pair<int, int> *> &&const iterator_traits<pair<int, int> *>const iterator_traits<pair<int, int> *> &_PCC<true, int, int>_PCC<true, int, int> &_PCC<true, int, int> &&const _PCC<true, int, int>const _PCC<true, int, int> &_PCC<<expression>, int, int>rebind<pair<int, int>>rebind<pair<int, int>> &rebind<pair<int, int>> &&const rebind<pair<int, int>>const rebind<pair<int, int>> &__normal_iterator<const pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>>reverse_iterator<__normal_iterator<const pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>>>reverse_iterator<__normal_iterator<pair<int, int> *, vector<pair<int, int>, allocator<pair<int, int>>>>>conditional<false, const pair<const int, AddrInfo> &, pair<const int, AddrInfo> &>conditional<false, const pair<const int, AddrInfo> &, pair<const int, AddrInfo> &> &conditional<false, const pair<const int, AddrInfo> &, pair<const int, AddrInfo> &> &&const conditional<false, const pair<const int, AddrInfo> &, pair<const int, AddrInfo> &>const conditional<false, const pair<const int, AddrInfo> &, pair<const int, AddrInfo> &> &conditional<false, const pair<const CService, int> &, pair<const CService, int> &>conditional<false, const pair<const CService, int> &, pair<const CService, int> &> &conditional<false, const pair<const CService, int> &, pair<const CService, int> &> &&const conditional<false, const pair<const CService, int> &, pair<const CService, int> &>const conditional<false, const pair<const CService, int> &, pair<const CService, int> &> &conditional<false, const pair<const int, AddrInfo> *, pair<const int, AddrInfo> *>conditional<false, const pair<const int, AddrInfo> *, pair<const int, AddrInfo> *> &conditional<false, const pair<const int, AddrInfo> *, pair<const int, AddrInfo> *> &&const conditional<false, const pair<const int, AddrInfo> *, pair<const int, AddrInfo> *>const conditional<false, const pair<const int, AddrInfo> *, pair<const int, AddrInfo> *> &_PCC<true, _Rb_tree_const_iterator<int>, bool>_PCC<true, _Rb_tree_const_iterator<int>, bool> &_PCC<true, _Rb_tree_const_iterator<int>, bool> &&const _PCC<true, _Rb_tree_const_iterator<int>, bool>const _PCC<true, _Rb_tree_const_iterator<int>, bool> &_PCC<<expression>, _Rb_tree_const_iterator<int>, bool>_Equality<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Equality<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Equality<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Equality<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Equality<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Rehash_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>_Rehash_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Rehash_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &&const _Rehash_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>const _Rehash_base<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &add_const<NewTriedCount>add_const<NewTriedCount> &add_const<NewTriedCount> &&const add_const<NewTriedCount>const add_const<NewTriedCount> &add_const<const Network>add_const<const Network> &add_const<const Network> &&const add_const<const Network>const add_const<const Network> &_PCC<true, const Network, NewTriedCount>_PCC<true, const Network, NewTriedCount> &_PCC<true, const Network, NewTriedCount> &&const _PCC<true, const Network, NewTriedCount>const _PCC<true, const Network, NewTriedCount> &_PCC<<expression>, const Network, NewTriedCount>rebind<_Rb_tree_node<int>>rebind<_Rb_tree_node<int>> &rebind<_Rb_tree_node<int>> &&const rebind<_Rb_tree_node<int>>const rebind<_Rb_tree_node<int>> &_PCC<true, const CService, int>_PCC<true, const CService, int> &_PCC<true, const CService, int> &&const _PCC<true, const CService, int>const _PCC<true, const CService, int> &_PCC<<expression>, const CService, int>_PCC<true, _Node_iterator<int, true, false>, bool>_PCC<true, _Node_iterator<int, true, false>, bool> &_PCC<true, _Node_iterator<int, true, false>, bool> &&const _PCC<true, _Node_iterator<int, true, false>, bool>const _PCC<true, _Node_iterator<int, true, false>, bool> &_PCC<<expression>, _Node_iterator<int, true, false>, bool>_Node_iterator_base<int, false>_Node_iterator_base<int, false> &_Node_iterator_base<int, false> &&const _Node_iterator_base<int, false>const _Node_iterator_base<int, false> &_PCC<true, const int, AddrInfo>_PCC<true, const int, AddrInfo> &_PCC<true, const int, AddrInfo> &&const _PCC<true, const int, AddrInfo>const _PCC<true, const int, AddrInfo> &_PCC<<expression>, const int, AddrInfo>_Local_iterator<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Local_const_iterator<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Node_handle<int, pair<const int, AddrInfo>, allocator<_Hash_node<pair<const int, AddrInfo>, false>>>_Node_insert_return<_Node_iterator<pair<const int, AddrInfo>, false, false>, _Node_handle<int, pair<const int, AddrInfo>, allocator<_Hash_node<pair<const int, AddrInfo>, false>>>>_Local_iterator<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false, false>_Local_const_iterator<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false, false>_Node_handle<CService, pair<const CService, int>, allocator<_Hash_node<pair<const CService, int>, false>>>_Node_insert_return<_Node_iterator<pair<const CService, int>, false, false>, _Node_handle<CService, pair<const CService, int>, allocator<_Hash_node<pair<const CService, int>, false>>>>binary_function<CService, CService, bool>binary_function<CService, CService, bool> &binary_function<CService, CService, bool> &&const binary_function<CService, CService, bool>const binary_function<CService, CService, bool> &__normal_iterator<int *, vector<int, allocator<int>>>__normal_iterator<int *, vector<int, allocator<int>>> &&reverse_iterator<__normal_iterator<const int *, vector<int, allocator<int>>>>reverse_iterator<__normal_iterator<int *, vector<int, allocator<int>>>>__pair_base<_Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>>_Local_iterator<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Local_const_iterator<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Node_handle<Network, pair<const Network, NewTriedCount>, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>_Node_insert_return<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, _Node_handle<Network, pair<const Network, NewTriedCount>, allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>>binary_function<Network, Network, bool>binary_function<Network, Network, bool> &binary_function<Network, Network, bool> &&const binary_function<Network, Network, bool>const binary_function<Network, Network, bool> &_Node_insert_return<_Node_iterator<int, true, false>, _Node_handle<int, int, allocator<_Hash_node<int, false>>>>unique_lock<recursive_mutex>_PCC<true, CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>_PCC<true, CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &_PCC<true, CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &&const _PCC<true, CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>const _PCC<true, CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &_PCC<<expression>, CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>__not_<is_same<optional<AddressPosition>, type>>_Optional_payload<AddressPosition, true, false, false>const _Optional_payload_base<AddressPosition>const _Optional_payload_base<AddressPosition> &_Optional_payload_base<AddressPosition> &_Optional_payload_base<AddressPosition> &&_Optional_base_impl<AddressPosition, _Optional_base<AddressPosition, true, true>>_Optional_base_impl<AddressPosition, _Optional_base<AddressPosition, true, true>> &_Optional_base_impl<AddressPosition, _Optional_base<AddressPosition, true, true>> &&const _Optional_base_impl<AddressPosition, _Optional_base<AddressPosition, true, true>>const _Optional_base_impl<AddressPosition, _Optional_base<AddressPosition, true, true>> &_Tuple_impl<0UL, const int &>_Tuple_impl<0UL, const int &> &&const _Tuple_impl<0UL, const int &>const _Tuple_impl<0UL, const int &> &_Tuple_impl<0UL, const int &> &_Tuple_impl<0UL, const CService &>_Tuple_impl<0UL, const CService &> &&const _Tuple_impl<0UL, const CService &>const _Tuple_impl<0UL, const CService &> &_Tuple_impl<0UL, const CService &> &_Tuple_impl<0UL, const Network &>_Tuple_impl<0UL, const Network &> &&const _Tuple_impl<0UL, const Network &>const _Tuple_impl<0UL, const Network &> &_Tuple_impl<0UL, const Network &> &_Tuple_impl<0UL, Network &&>_Tuple_impl<0UL, Network &&> &&const _Tuple_impl<0UL, Network &&>const _Tuple_impl<0UL, Network &&> &_Tuple_impl<0UL, Network &&> &__alloc_traits<allocator<_Rb_tree_node<int>>, _Rb_tree_node<int>>__alloc_traits<allocator<_Rb_tree_node<int>>, _Rb_tree_node<int>> &__alloc_traits<allocator<_Rb_tree_node<int>>, _Rb_tree_node<int>> &&const __alloc_traits<allocator<_Rb_tree_node<int>>, _Rb_tree_node<int>>const __alloc_traits<allocator<_Rb_tree_node<int>>, _Rb_tree_node<int>> &reverse_iterator<_Rb_tree_iterator<int>>reverse_iterator<_Rb_tree_const_iterator<int>>_Node_insert_return<_Rb_tree_const_iterator<int>, _Node_handle<int, int, allocator<_Rb_tree_node<int>>>>is_same<int, value_type>unary_function<int, int>unary_function<int, int> &unary_function<int, int> &&const unary_function<int, int>const unary_function<int, int> &__pair_base<_Rb_tree_iterator<int>, bool>_Node_insert_return<_Node_iterator<pair<const int, int>, false, false>, _Node_handle<int, pair<const int, int>, allocator<_Hash_node<pair<const int, int>, false>>>>optional<allocator<_Rb_tree_node<int>>>optional<allocator<_Rb_tree_node<int>>> &optional<allocator<_Rb_tree_node<int>>> &&const optional<allocator<_Rb_tree_node<int>>>const optional<allocator<_Rb_tree_node<int>>> &_Insert<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>_Insert<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &&const _Insert<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>const _Insert<int, pair<const int, AddrInfo>, allocator<pair<const int, AddrInfo>>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>_Insert<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &&const _Insert<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>const _Insert<CService, pair<const CService, int>, allocator<pair<const CService, int>>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>_Insert<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &&const _Insert<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>const _Insert<Network, pair<const Network, NewTriedCount>, allocator<pair<const Network, NewTriedCount>>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &optional<allocator<_Hash_node<int, false>>>optional<allocator<_Hash_node<int, false>>> &optional<allocator<_Hash_node<int, false>>> &&const optional<allocator<_Hash_node<int, false>>>const optional<allocator<_Hash_node<int, false>>> &_Hashtable_base<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>_Hashtable_base<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_Hashtable_base<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &&const _Hashtable_base<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, hash<int>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_AllocNode<allocator<_Hash_node<pair<const int, AddrInfo>, false>>>_Hashtable_base<CService, pair<const CService, int>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>_Hashtable_base<CService, pair<const CService, int>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &const _Hashtable_base<CService, pair<const CService, int>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_Hashtable_base<CService, pair<const CService, int>, _Select1st, equal_to<CService>, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &&_AllocNode<allocator<_Hash_node<pair<const CService, int>, false>>>_Hashtable_base<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>_Hashtable_base<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_Hashtable_base<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &&const _Hashtable_base<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_Node_iterator<pair<const Network, NewTriedCount>, false, false>_Node_iterator<pair<const Network, NewTriedCount>, false, false> &_Node_iterator<pair<const Network, NewTriedCount>, false, false> &&const _Node_iterator<pair<const Network, NewTriedCount>, false, false> &_AllocNode<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>_Node_const_iterator<pair<const int, int>, false, false>_Node_const_iterator<pair<const int, int>, false, false> &_Node_const_iterator<pair<const int, int>, false, false> &&const _Node_const_iterator<pair<const int, int>, false, false>const _Node_const_iterator<pair<const int, int>, false, false> &_Node_iterator<pair<const int, int>, false, false>_Node_iterator<pair<const int, int>, false, false> &_Node_iterator<pair<const int, int>, false, false> &&const _Node_iterator<pair<const int, int>, false, false> &_Node_iterator<pair<const int, int>, false, false> *_Node_const_iterator<int, true, false>_Node_const_iterator<int, true, false> &_Node_const_iterator<int, true, false> &&const _Node_const_iterator<int, true, false>const _Node_const_iterator<int, true, false> &pair<_Node_iterator<pair<const int, int>, false, false>, _Node_iterator<pair<const int, int>, false, false>>pair<_Node_const_iterator<pair<const int, int>, false, false>, _Node_const_iterator<pair<const int, int>, false, false>>pair<_Node_iterator<int, true, false>, _Node_iterator<int, true, false>>pair<_Node_const_iterator<int, true, false>, _Node_const_iterator<int, true, false>>pair<_Node_iterator<pair<const int, AddrInfo>, false, false>, _Node_iterator<pair<const int, AddrInfo>, false, false>>pair<_Node_const_iterator<pair<const int, AddrInfo>, false, false>, _Node_const_iterator<pair<const int, AddrInfo>, false, false>>pair<_Node_iterator<pair<const CService, int>, false, false>, _Node_iterator<pair<const CService, int>, false, false>>pair<_Node_const_iterator<pair<const CService, int>, false, false>, _Node_const_iterator<pair<const CService, int>, false, false>>pair<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, _Node_iterator<pair<const Network, NewTriedCount>, false, false>>pair<_Node_const_iterator<pair<const Network, NewTriedCount>, false, false>, _Node_const_iterator<pair<const Network, NewTriedCount>, false, false>>__aligned_membuf<int>__aligned_membuf<int> &__aligned_membuf<int> &&const __aligned_membuf<int>const __aligned_membuf<int> &allocator_traits<allocator<pair<const int, AddrInfo>>>allocator_traits<allocator<pair<const int, AddrInfo>>> &allocator_traits<allocator<pair<const int, AddrInfo>>> &&const allocator_traits<allocator<pair<const int, AddrInfo>>>const allocator_traits<allocator<pair<const int, AddrInfo>>> &allocator_traits<allocator<pair<const CService, int>>>allocator_traits<allocator<pair<const CService, int>>> &allocator_traits<allocator<pair<const CService, int>>> &&const allocator_traits<allocator<pair<const CService, int>>>const allocator_traits<allocator<pair<const CService, int>>> &allocator_traits<allocator<pair<const Network, NewTriedCount>>>allocator_traits<allocator<pair<const Network, NewTriedCount>>> &allocator_traits<allocator<pair<const Network, NewTriedCount>>> &&const allocator_traits<allocator<pair<const Network, NewTriedCount>>>const allocator_traits<allocator<pair<const Network, NewTriedCount>>> &remove_reference<int &>remove_reference<int &> &remove_reference<int &> &&const remove_reference<int &>const remove_reference<int &> &__aligned_buffer<pair<const int, AddrInfo>>__aligned_buffer<pair<const int, AddrInfo>> &__aligned_buffer<pair<const int, AddrInfo>> &&const __aligned_buffer<pair<const int, AddrInfo>>const __aligned_buffer<pair<const int, AddrInfo>> &__aligned_buffer<pair<const CService, int>>__aligned_buffer<pair<const CService, int>> &__aligned_buffer<pair<const CService, int>> &&const __aligned_buffer<pair<const CService, int>>const __aligned_buffer<pair<const CService, int>> &remove_reference<const AddrInfo &>remove_reference<const AddrInfo &> &remove_reference<const AddrInfo &> &&const remove_reference<const AddrInfo &>const remove_reference<const AddrInfo &> &__iterator_traits<_Rb_tree_const_iterator<int>, void>__iterator_traits<_Rb_tree_const_iterator<int>, void> &__iterator_traits<_Rb_tree_const_iterator<int>, void> &&const __iterator_traits<_Rb_tree_const_iterator<int>, void>const __iterator_traits<_Rb_tree_const_iterator<int>, void> &remove_reference<AddressPosition>remove_reference<AddressPosition> &remove_reference<AddressPosition> &&const remove_reference<AddressPosition>const remove_reference<AddressPosition> &__aligned_buffer<pair<const Network, NewTriedCount>>__aligned_buffer<pair<const Network, NewTriedCount>> &__aligned_buffer<pair<const Network, NewTriedCount>> &&const __aligned_buffer<pair<const Network, NewTriedCount>>const __aligned_buffer<pair<const Network, NewTriedCount>> &remove_reference<Network &>remove_reference<Network &> &remove_reference<Network &> &&const remove_reference<Network &>const remove_reference<Network &> &remove_reference<bool &>remove_reference<bool &> &remove_reference<bool &> &&const remove_reference<bool &>const remove_reference<bool &> &remove_reference<AddrManImpl *&>remove_reference<AddrManImpl *&> &remove_reference<AddrManImpl *&> &&const remove_reference<AddrManImpl *&>const remove_reference<AddrManImpl *&> &ChronoFormatter<signed long, false>ChronoFormatter<signed long, false> &ChronoFormatter<signed long, false> &&const ChronoFormatter<signed long, false>const ChronoFormatter<signed long, false> &enable_if<true, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>enable_if<true, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &enable_if<true, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &&const enable_if<true, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>const enable_if<true, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &is_convertible<int, int>is_convertible<int, int> &is_convertible<int, int> &&const is_convertible<int, int>const is_convertible<int, int> &is_convertible<unsigned int, int>is_convertible<unsigned int, int> &is_convertible<unsigned int, int> &&const is_convertible<unsigned int, int>const is_convertible<unsigned int, int> &is_convertible<unsigned char, int>is_convertible<unsigned char, int> &is_convertible<unsigned char, int> &&const is_convertible<unsigned char, int>const is_convertible<unsigned char, int> &is_convertible<char[13], int>is_convertible<char[13], int> &is_convertible<char[13], int> &&const is_convertible<char[13], int>const is_convertible<char[13], int> &_Local_iterator_base<int, pair<const int, AddrInfo>, _Select1st, hash<int>, _Mod_range_hashing, _Default_ranged_hash, false>tuple_element<0UL, pair<const int, AddrInfo>>tuple_element<0UL, pair<const int, AddrInfo>> &tuple_element<0UL, pair<const int, AddrInfo>> &&const tuple_element<0UL, pair<const int, AddrInfo>>const tuple_element<0UL, pair<const int, AddrInfo>> &remove_reference<const pair<const int, AddrInfo> &>remove_reference<const pair<const int, AddrInfo> &> &remove_reference<const pair<const int, AddrInfo> &> &&const remove_reference<const pair<const int, AddrInfo> &>const remove_reference<const pair<const int, AddrInfo> &> &_Local_iterator_base<CService, pair<const CService, int>, _Select1st, CServiceHash, _Mod_range_hashing, _Default_ranged_hash, false>_Hashtable_ebo_helper<1, CServiceHash, false>_Hashtable_ebo_helper<1, CServiceHash, false> &&tuple_element<0UL, pair<const CService, int>>tuple_element<0UL, pair<const CService, int>> &tuple_element<0UL, pair<const CService, int>> &&const tuple_element<0UL, pair<const CService, int>>const tuple_element<0UL, pair<const CService, int>> &remove_reference<const pair<const CService, int> &>remove_reference<const pair<const CService, int> &> &remove_reference<const pair<const CService, int> &> &&const remove_reference<const pair<const CService, int> &>const remove_reference<const pair<const CService, int> &> &_Local_iterator_base<Network, pair<const Network, NewTriedCount>, _Select1st, hash<Network>, _Mod_range_hashing, _Default_ranged_hash, false>_Hashtable_ebo_helper<1, hash<Network>, true>_Hashtable_ebo_helper<1, hash<Network>, true> &&is_enum<Network>is_enum<Network> &is_enum<Network> &&const is_enum<Network>const is_enum<Network> &__hash_base<unsigned long, Network>__hash_base<unsigned long, Network> &__hash_base<unsigned long, Network> &&const __hash_base<unsigned long, Network>const __hash_base<unsigned long, Network> &remove_reference<const pair<const Network, NewTriedCount> &>remove_reference<const pair<const Network, NewTriedCount> &> &remove_reference<const pair<const Network, NewTriedCount> &> &&const remove_reference<const pair<const Network, NewTriedCount> &>const remove_reference<const pair<const Network, NewTriedCount> &> &tuple_element<0UL, pair<const int, int>>tuple_element<0UL, pair<const int, int>> &tuple_element<0UL, pair<const int, int>> &&const tuple_element<0UL, pair<const int, int>>const tuple_element<0UL, pair<const int, int>> &remove_reference<const pair<const int, int> &>remove_reference<const pair<const int, int> &> &remove_reference<const pair<const int, int> &> &&const remove_reference<const pair<const int, int> &>const remove_reference<const pair<const int, int> &> &remove_reference<pair<const int, int> &>remove_reference<pair<const int, int> &> &remove_reference<pair<const int, int> &> &&const remove_reference<pair<const int, int> &>const remove_reference<pair<const int, int> &> &remove_reference<pair<const int, AddrInfo> &>remove_reference<pair<const int, AddrInfo> &> &remove_reference<pair<const int, AddrInfo> &> &&const remove_reference<pair<const int, AddrInfo> &>const remove_reference<pair<const int, AddrInfo> &> &remove_reference<pair<const CService, int> &>remove_reference<pair<const CService, int> &> &remove_reference<pair<const CService, int> &> &&const remove_reference<pair<const CService, int> &>const remove_reference<pair<const CService, int> &> &remove_reference<pair<const Network, NewTriedCount> &>remove_reference<pair<const Network, NewTriedCount> &> &remove_reference<pair<const Network, NewTriedCount> &> &&const remove_reference<pair<const Network, NewTriedCount> &>const remove_reference<pair<const Network, NewTriedCount> &> &remove_reference<const int &>remove_reference<const int &> &remove_reference<const int &> &&const remove_reference<const int &>const remove_reference<const int &> &const duration<signed long, ratio<3600L, 1L>> *duration<signed long, ratio<3600L, 1L>> *const __normal_iterator<int *, vector<int, allocator<int>>> *__normal_iterator<int *, vector<int, allocator<int>>> *__aligned_buffer<pair<const int, AddrInfo>> *const _Identity<int> *_Identity<int> *_Rb_tree_node<int> *&const __normal_iterator<const int *, vector<int, allocator<int>>> *__normal_iterator<const int *, vector<int, allocator<int>>> *const __aligned_membuf<int> *__aligned_membuf<int> *duration_values<rep>::zero()_Optional_payload<AddressPosition, true, false, false> *__aligned_buffer<pair<const Network, NewTriedCount>> *__aligned_buffer<pair<const CService, int>> *const _Node_iterator<pair<const int, int>, false, false> *const _Node_iterator_base<pair<const int, int>, false>const _Node_iterator_base<pair<const int, int>, false> *_Node_iterator_base<pair<const int, int>, false> *const _Node_iterator<pair<const Network, NewTriedCount>, false, false> *_Node_iterator<pair<const Network, NewTriedCount>, false, false> *__tuple_element_t<1UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>> &const __uniq_ptr_impl<AddrManImpl, default_delete<AddrManImpl>> *const __tuple_element_t<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>>const __tuple_element_t<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>> &0.1428571492_Tp(1) / _Tp(7)_Tp(3) / _Tp(10)0.375_Tp(3) / _Tp(8)30.0_Tp(30)3.973643192e-09__eps / _Tp(30)0.142857142857142857143.6140072416183481135e-21(_Tp(2))100.0_Tp(100)1.253314137static_cast<_Tp>(1.2533141373155002512078826424055226L)Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> *Wrapper<ChronoFormatter<signed long, false>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> *1000000.0direct_or_indirect &&const char[205]char[205]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = int; fmtT = const void *; bool convertible = false]const char[214]char[214]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = unsigned int; fmtT = const void *; bool convertible = false]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = char [13]; fmtT = char; bool convertible = false]const _AllocNode<allocator<_Hash_node<int, false>>> *64051194700380387288230376151711743230584300921369395is_trivially_copy_assignable<AddressPosition>is_trivially_copy_assignable<AddressPosition> &is_trivially_copy_assignable<AddressPosition> &&const is_trivially_copy_assignable<AddressPosition>const is_trivially_copy_assignable<AddressPosition> &is_trivially_move_assignable<AddressPosition>is_trivially_move_assignable<AddressPosition> &is_trivially_move_assignable<AddressPosition> &&const is_trivially_move_assignable<AddressPosition>const is_trivially_move_assignable<AddressPosition> &__and_<is_nothrow_move_constructible<direct_or_indirect>, is_nothrow_move_assignable<direct_or_indirect>>__and_<is_nothrow_move_constructible<direct_or_indirect>, is_nothrow_move_assignable<direct_or_indirect>> &__and_<is_nothrow_move_constructible<direct_or_indirect>, is_nothrow_move_assignable<direct_or_indirect>> &&const __and_<is_nothrow_move_constructible<direct_or_indirect>, is_nothrow_move_assignable<direct_or_indirect>>const __and_<is_nothrow_move_constructible<direct_or_indirect>, is_nothrow_move_assignable<direct_or_indirect>> &__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<1L, 1L>, signed long, true, true>__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<1L, 1L>, signed long, true, true> &__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<1L, 1L>, signed long, true, true> &&const __duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<1L, 1L>, signed long, true, true>const __duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<1L, 1L>, signed long, true, true> &__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<3600L, 1L>, signed long, false, true>__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<3600L, 1L>, signed long, false, true> &__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<3600L, 1L>, signed long, false, true> &&const __duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<3600L, 1L>, signed long, false, true>const __duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<3600L, 1L>, signed long, false, true> &__duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<3600000000000L, 1L>, signed long, false, true>__duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<3600000000000L, 1L>, signed long, false, true> &__duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<3600000000000L, 1L>, signed long, false, true> &&const __duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<3600000000000L, 1L>, signed long, false, true>const __duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<3600000000000L, 1L>, signed long, false, true> &ratio<3600000000000L, 1L>3600000000000ratio<3600000000000L, 1L> &ratio<3600000000000L, 1L> &&const ratio<3600000000000L, 1L>const ratio<3600000000000L, 1L> &FormatListN<5>FormatListN<5> &const FormatListN<5>const FormatListN<5> &FormatArg[5]is_nothrow_destructible<int>is_nothrow_destructible<int> &is_nothrow_destructible<int> &&const is_nothrow_destructible<int>const is_nothrow_destructible<int> &__is_move_insertable<allocator<int>>__is_move_insertable<allocator<int>> &__is_move_insertable<allocator<int>> &&const __is_move_insertable<allocator<int>>const __is_move_insertable<allocator<int>> &__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<60L, 1L>, signed long, false, true>__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<60L, 1L>, signed long, false, true> &__duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<60L, 1L>, signed long, false, true> &&const __duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<60L, 1L>, signed long, false, true>const __duration_cast_impl<duration<signed long, ratio<1L, 1L>>, ratio<60L, 1L>, signed long, false, true> &is_nothrow_default_constructible<allocator<pair<int, int>>>is_nothrow_default_constructible<allocator<pair<int, int>>> &is_nothrow_default_constructible<allocator<pair<int, int>>> &&const is_nothrow_default_constructible<allocator<pair<int, int>>>const is_nothrow_default_constructible<allocator<pair<int, int>>> &is_constructible<pair<int, int>, pair<int, int> &&>pair<int, int> &&is_constructible<pair<int, int>, pair<int, int> &&> &is_constructible<pair<int, int>, pair<int, int> &&> &&const is_constructible<pair<int, int>, pair<int, int> &&>const is_constructible<pair<int, int>, pair<int, int> &&> &__is_move_constructible_impl<pair<int, int>, true>__is_move_constructible_impl<pair<int, int>, true> &__is_move_constructible_impl<pair<int, int>, true> &&const __is_move_constructible_impl<pair<int, int>, true>const __is_move_constructible_impl<pair<int, int>, true> &is_move_constructible<pair<int, int>>is_move_constructible<pair<int, int>> &is_move_constructible<pair<int, int>> &&const is_move_constructible<pair<int, int>>const is_move_constructible<pair<int, int>> &__is_move_insertable<allocator<pair<int, int>>>__is_move_insertable<allocator<pair<int, int>>> &__is_move_insertable<allocator<pair<int, int>>> &&const __is_move_insertable<allocator<pair<int, int>>>const __is_move_insertable<allocator<pair<int, int>>> &is_nothrow_default_constructible<allocator<int>>is_nothrow_default_constructible<allocator<int>> &is_nothrow_default_constructible<allocator<int>> &&const is_nothrow_default_constructible<allocator<int>>const is_nothrow_default_constructible<allocator<int>> &enable_if<true, duration<double, ratio<1L, 1000L>>>enable_if<true, duration<double, ratio<1L, 1000L>>> &enable_if<true, duration<double, ratio<1L, 1000L>>> &&const enable_if<true, duration<double, ratio<1L, 1000L>>>const enable_if<true, duration<double, ratio<1L, 1000L>>> &unsigned char[24]_Lenaligned_storage<24UL, 8UL>aligned_storage<24UL, 8UL> &aligned_storage<24UL, 8UL> &&const aligned_storage<24UL, 8UL>const aligned_storage<24UL, 8UL> &iterator_traits<const int *>iterator_traits<const int *> &iterator_traits<const int *> &&const iterator_traits<const int *>const iterator_traits<const int *> &unsigned char[48]aligned_storage<48UL, 8UL>aligned_storage<48UL, 8UL> &aligned_storage<48UL, 8UL> &&const aligned_storage<48UL, 8UL>const aligned_storage<48UL, 8UL> &unsigned char[136]aligned_storage<136UL, 8UL>aligned_storage<136UL, 8UL> &aligned_storage<136UL, 8UL> &&const aligned_storage<136UL, 8UL>const aligned_storage<136UL, 8UL> &_Node_iterator_base<pair<const int, int>, false>_Node_iterator_base<pair<const int, int>, false> &_Node_iterator_base<pair<const int, int>, false> &&const _Node_iterator_base<pair<const int, int>, false> &_Hashtable_ebo_helper<0, equal_to<Network>, true>_Hashtable_ebo_helper<0, equal_to<Network>, true> &_Hashtable_ebo_helper<0, equal_to<Network>, true> &&const _Hashtable_ebo_helper<0, equal_to<Network>, true>const _Hashtable_ebo_helper<0, equal_to<Network>, true> &_Hashtable_ebo_helper<0, equal_to<CService>, true>_Hashtable_ebo_helper<0, equal_to<CService>, true> &_Hashtable_ebo_helper<0, equal_to<CService>, true> &&const _Hashtable_ebo_helper<0, equal_to<CService>, true>const _Hashtable_ebo_helper<0, equal_to<CService>, true> &_Enable_copy_move<true, true, true, true, optional<allocator<_Hash_node<int, false>>>>_Enable_copy_move<true, true, true, true, optional<allocator<_Hash_node<int, false>>>> &_Enable_copy_move<true, true, true, true, optional<allocator<_Hash_node<int, false>>>> &&const _Enable_copy_move<true, true, true, true, optional<allocator<_Hash_node<int, false>>>>const _Enable_copy_move<true, true, true, true, optional<allocator<_Hash_node<int, false>>>> &_Optional_base<allocator<_Hash_node<int, false>>, false, false>_Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<int>>>>_Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<int>>>> &_Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<int>>>> &&const _Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<int>>>>const _Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<int>>>> &_Optional_base<allocator<_Rb_tree_node<int>>, false, false>_PCC<true, _Rb_tree_iterator<int>, bool>_PCC<true, _Rb_tree_iterator<int>, bool> &_PCC<true, _Rb_tree_iterator<int>, bool> &&const _PCC<true, _Rb_tree_iterator<int>, bool>const _PCC<true, _Rb_tree_iterator<int>, bool> &_PCC<<expression>, _Rb_tree_iterator<int>, bool>_Head_base<0UL, Network &&, false>_Head_base<0UL, Network &&, false> &const _Head_base<0UL, Network &&, false>const _Head_base<0UL, Network &&, false> &_Head_base<0UL, const Network &, false>_Head_base<0UL, const Network &, false> &const _Head_base<0UL, const Network &, false>const _Head_base<0UL, const Network &, false> &_Head_base<0UL, const CService &, false>_Head_base<0UL, const CService &, false> &const _Head_base<0UL, const CService &, false>const _Head_base<0UL, const CService &, false> &_Head_base<0UL, const int &, false>_Head_base<0UL, const int &, false> &const _Head_base<0UL, const int &, false>const _Head_base<0UL, const int &, false> &is_same<optional<AddressPosition>, type>is_same<time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>, _U2>is_same<CAddress, _U1>_PCC<true, _Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>>_PCC<true, _Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>> &_PCC<true, _Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>> &&const _PCC<true, _Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>>const _PCC<true, _Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>> &_PCC<<expression>, _Rb_tree_const_iterator<int>, _Rb_tree_const_iterator<int>>is_same<AddrInfo, _U2>is_same<bool, _U2>is_same<_Node_iterator<int, true, false>, _U1>is_same<const CService, _U1>__and_<is_same<int *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<NewTriedCount, _U2>is_same<const Network, _U1>__alloc_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node<pair<const Network, NewTriedCount>, false>>__alloc_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node<pair<const Network, NewTriedCount>, false>> &__alloc_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node<pair<const Network, NewTriedCount>, false>> &&const __alloc_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node<pair<const Network, NewTriedCount>, false>>const __alloc_traits<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>, _Hash_node<pair<const Network, NewTriedCount>, false>> &_ReuseOrAllocNode<allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>>tuple_element<1UL, pair<const int, AddrInfo>>tuple_element<1UL, pair<const int, AddrInfo>> &tuple_element<1UL, pair<const int, AddrInfo>> &&const tuple_element<1UL, pair<const int, AddrInfo>>const tuple_element<1UL, pair<const int, AddrInfo>> &enable_if<true, bool>enable_if<true, bool> &enable_if<true, bool> &&const enable_if<true, bool>const enable_if<true, bool> &is_same<_Rb_tree_const_iterator<int>, _U1>tuple_element<1UL, pair<const CService, int>>tuple_element<1UL, pair<const CService, int>> &tuple_element<1UL, pair<const CService, int>> &&const tuple_element<1UL, pair<const CService, int>>const tuple_element<1UL, pair<const CService, int>> &conditional<false, const pair<const CService, int> *, pair<const CService, int> *>conditional<false, const pair<const CService, int> *, pair<const CService, int> *> &conditional<false, const pair<const CService, int> *, pair<const CService, int> *> &&const conditional<false, const pair<const CService, int> *, pair<const CService, int> *>const conditional<false, const pair<const CService, int> *, pair<const CService, int> *> &__and_<is_same<pair<int, int> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<int, _U1>__alloc_traits<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node<pair<const CService, int>, false>>__alloc_traits<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node<pair<const CService, int>, false>> &__alloc_traits<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node<pair<const CService, int>, false>> &&const __alloc_traits<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node<pair<const CService, int>, false>>const __alloc_traits<allocator<_Hash_node<pair<const CService, int>, false>>, _Hash_node<pair<const CService, int>, false>> &_ReuseOrAllocNode<allocator<_Hash_node<pair<const CService, int>, false>>>__alloc_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node<pair<const int, AddrInfo>, false>>__alloc_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node<pair<const int, AddrInfo>, false>> &__alloc_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node<pair<const int, AddrInfo>, false>> &&const __alloc_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node<pair<const int, AddrInfo>, false>>const __alloc_traits<allocator<_Hash_node<pair<const int, AddrInfo>, false>>, _Hash_node<pair<const int, AddrInfo>, false>> &_ReuseOrAllocNode<allocator<_Hash_node<pair<const int, AddrInfo>, false>>>__underlying_type_impl<Network, true>__underlying_type_impl<Network, true> &__underlying_type_impl<Network, true> &&const __underlying_type_impl<Network, true>const __underlying_type_impl<Network, true> &is_wchar<char[13]>is_wchar<char[13]> &is_wchar<char[13]> &&const is_wchar<char[13]>const is_wchar<char[13]> &is_wchar<unsigned int>is_wchar<unsigned int> &is_wchar<unsigned int> &&const is_wchar<unsigned int>const is_wchar<unsigned int> &is_wchar<int>is_wchar<int> &is_wchar<int> &&const is_wchar<int>const is_wchar<int> &remove_reference<_Rb_tree_iterator<int> &>remove_reference<_Rb_tree_iterator<int> &> &remove_reference<_Rb_tree_iterator<int> &> &&const remove_reference<_Rb_tree_iterator<int> &>const remove_reference<_Rb_tree_iterator<int> &> &__is_trivially_move_constructible_impl<AddressPosition, true>__is_trivially_move_constructible_impl<AddressPosition, true> &__is_trivially_move_constructible_impl<AddressPosition, true> &&const __is_trivially_move_constructible_impl<AddressPosition, true>const __is_trivially_move_constructible_impl<AddressPosition, true> &__is_trivially_copy_constructible_impl<AddressPosition, true>__is_trivially_copy_constructible_impl<AddressPosition, true> &__is_trivially_copy_constructible_impl<AddressPosition, true> &&const __is_trivially_copy_constructible_impl<AddressPosition, true>const __is_trivially_copy_constructible_impl<AddressPosition, true> &__is_move_constructible_impl<AddressPosition, true>__is_move_constructible_impl<AddressPosition, true> &__is_move_constructible_impl<AddressPosition, true> &&const __is_move_constructible_impl<AddressPosition, true>const __is_move_constructible_impl<AddressPosition, true> &__is_move_assignable_impl<AddressPosition, true>__is_move_assignable_impl<AddressPosition, true> &__is_move_assignable_impl<AddressPosition, true> &&const __is_move_assignable_impl<AddressPosition, true>const __is_move_assignable_impl<AddressPosition, true> &__is_copy_constructible_impl<AddressPosition, true>__is_copy_constructible_impl<AddressPosition, true> &__is_copy_constructible_impl<AddressPosition, true> &&const __is_copy_constructible_impl<AddressPosition, true>const __is_copy_constructible_impl<AddressPosition, true> &__is_copy_assignable_impl<AddressPosition, true>__is_copy_assignable_impl<AddressPosition, true> &__is_copy_assignable_impl<AddressPosition, true> &&const __is_copy_assignable_impl<AddressPosition, true>const __is_copy_assignable_impl<AddressPosition, true> &__and_<is_destructible<AddressPosition>, integral_constant<bool, true>>__and_<is_destructible<AddressPosition>, integral_constant<bool, true>> &__and_<is_destructible<AddressPosition>, integral_constant<bool, true>> &&const __and_<is_destructible<AddressPosition>, integral_constant<bool, true>>const __and_<is_destructible<AddressPosition>, integral_constant<bool, true>> &__and_<is_destructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>>__and_<is_destructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &__and_<is_destructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &&const __and_<is_destructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>>const __and_<is_destructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &__and_<is_destructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>>__and_<is_destructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &__and_<is_destructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &&const __and_<is_destructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>>const __and_<is_destructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &__and_<is_convertible<_U1&&, _T1>,
		      is_convertible<_U2&&, _T2>>::value__and_<is_constructible<_T1, _U1&&>,
		      is_constructible<_T2, _U2&&>>::value_Node_iterator_base<int, false> *const __aligned_buffer<int>const __aligned_buffer<int> *__aligned_buffer<int> *const __aligned_buffer<pair<const int, int>>const __aligned_buffer<pair<const int, int>> *__aligned_buffer<pair<const int, int>> *const __aligned_buffer<pair<const Network, NewTriedCount>> *const __aligned_buffer<pair<const CService, int>> *const __aligned_buffer<pair<const int, AddrInfo>> *2.9743287383930794127e+4931_Tp(1) / __fp_min8.507059173e+37static_cast<_Tp>(0.5772156649015328606065120900824024L)0.5772156715static_cast<_Tp>(0.7853981633974483096156608458198757L)0.7853981853_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const int, int>, false>>, true> &_Tuple_impl<0UL, const int &> *const _Hashtable_ebo_helper<0, equal_to<int>, true>const _Hashtable_ebo_helper<0, equal_to<int>, true> &_Hashtable_ebo_helper<0, equal_to<int>, true> &_Tuple_impl<0UL, const Network &> *const allocator<_Hash_node<int, false>>const allocator<_Hash_node<int, false>> &const allocator<_Hash_node<pair<const int, int>, false>>const allocator<_Hash_node<pair<const int, int>, false>> &const allocator<_Hash_node<pair<const Network, NewTriedCount>, false>>const allocator<_Hash_node<pair<const Network, NewTriedCount>, false>> &_Optional_payload_base<AddressPosition> *const unsigned char(*)[4]unsigned char(*)[4]3600static_cast<_CR>(_CF::num)const _Optional_payload_base<Network> *const less<int> *less<int> *_Tuple_impl<0UL, const CService &> *int *&&FormatListN<4> *pair<int, int> *&&const allocator<_Hash_node<pair<const CService, int>, false>>const allocator<_Hash_node<pair<const CService, int>, false>> &const allocator<_Hash_node<pair<const int, AddrInfo>, false>>const allocator<_Hash_node<pair<const int, AddrInfo>, false>> &_Pn_Qn_Pn * _Qn__static_sign<_Den>::value_Num * __static_sign<_Den>::value__static_gcd<_Num, _Den>::value_Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value__static_abs<_Den>::value__static_abs<_Den>::value / __static_gcd<_Num, _Den>::valueis_copy_assignable<allocator<_Hash_node<int, false>>>is_copy_assignable<allocator<_Hash_node<int, false>>> &is_copy_assignable<allocator<_Hash_node<int, false>>> &&const is_copy_assignable<allocator<_Hash_node<int, false>>>const is_copy_assignable<allocator<_Hash_node<int, false>>> &is_copy_constructible<allocator<_Hash_node<int, false>>>is_copy_constructible<allocator<_Hash_node<int, false>>> &is_copy_constructible<allocator<_Hash_node<int, false>>> &&const is_copy_constructible<allocator<_Hash_node<int, false>>>const is_copy_constructible<allocator<_Hash_node<int, false>>> &__and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, is_copy_assignable<allocator<_Hash_node<int, false>>>>__and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, is_copy_assignable<allocator<_Hash_node<int, false>>>> &__and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, is_copy_assignable<allocator<_Hash_node<int, false>>>> &&const __and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, is_copy_assignable<allocator<_Hash_node<int, false>>>>const __and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, is_copy_assignable<allocator<_Hash_node<int, false>>>> &is_move_assignable<allocator<_Hash_node<int, false>>>is_move_assignable<allocator<_Hash_node<int, false>>> &is_move_assignable<allocator<_Hash_node<int, false>>> &&const is_move_assignable<allocator<_Hash_node<int, false>>>const is_move_assignable<allocator<_Hash_node<int, false>>> &is_move_constructible<allocator<_Hash_node<int, false>>>is_move_constructible<allocator<_Hash_node<int, false>>> &is_move_constructible<allocator<_Hash_node<int, false>>> &&const is_move_constructible<allocator<_Hash_node<int, false>>>const is_move_constructible<allocator<_Hash_node<int, false>>> &__and_<is_move_constructible<allocator<_Hash_node<int, false>>>, is_move_assignable<allocator<_Hash_node<int, false>>>>__and_<is_move_constructible<allocator<_Hash_node<int, false>>>, is_move_assignable<allocator<_Hash_node<int, false>>>> &__and_<is_move_constructible<allocator<_Hash_node<int, false>>>, is_move_assignable<allocator<_Hash_node<int, false>>>> &&const __and_<is_move_constructible<allocator<_Hash_node<int, false>>>, is_move_assignable<allocator<_Hash_node<int, false>>>>const __and_<is_move_constructible<allocator<_Hash_node<int, false>>>, is_move_assignable<allocator<_Hash_node<int, false>>>> &is_trivially_copy_constructible<allocator<_Hash_node<int, false>>>is_trivially_copy_constructible<allocator<_Hash_node<int, false>>> &is_trivially_copy_constructible<allocator<_Hash_node<int, false>>> &&const is_trivially_copy_constructible<allocator<_Hash_node<int, false>>>const is_trivially_copy_constructible<allocator<_Hash_node<int, false>>> &is_trivially_move_constructible<allocator<_Hash_node<int, false>>>is_trivially_move_constructible<allocator<_Hash_node<int, false>>> &is_trivially_move_constructible<allocator<_Hash_node<int, false>>> &&const is_trivially_move_constructible<allocator<_Hash_node<int, false>>>const is_trivially_move_constructible<allocator<_Hash_node<int, false>>> &is_copy_assignable<allocator<_Rb_tree_node<int>>>is_copy_assignable<allocator<_Rb_tree_node<int>>> &is_copy_assignable<allocator<_Rb_tree_node<int>>> &&const is_copy_assignable<allocator<_Rb_tree_node<int>>>const is_copy_assignable<allocator<_Rb_tree_node<int>>> &is_copy_constructible<allocator<_Rb_tree_node<int>>>is_copy_constructible<allocator<_Rb_tree_node<int>>> &is_copy_constructible<allocator<_Rb_tree_node<int>>> &&const is_copy_constructible<allocator<_Rb_tree_node<int>>>const is_copy_constructible<allocator<_Rb_tree_node<int>>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, is_copy_assignable<allocator<_Rb_tree_node<int>>>>__and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, is_copy_assignable<allocator<_Rb_tree_node<int>>>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, is_copy_assignable<allocator<_Rb_tree_node<int>>>> &&const __and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, is_copy_assignable<allocator<_Rb_tree_node<int>>>>const __and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, is_copy_assignable<allocator<_Rb_tree_node<int>>>> &is_move_assignable<allocator<_Rb_tree_node<int>>>is_move_assignable<allocator<_Rb_tree_node<int>>> &is_move_assignable<allocator<_Rb_tree_node<int>>> &&const is_move_assignable<allocator<_Rb_tree_node<int>>>const is_move_assignable<allocator<_Rb_tree_node<int>>> &is_move_constructible<allocator<_Rb_tree_node<int>>>is_move_constructible<allocator<_Rb_tree_node<int>>> &is_move_constructible<allocator<_Rb_tree_node<int>>> &&const is_move_constructible<allocator<_Rb_tree_node<int>>>const is_move_constructible<allocator<_Rb_tree_node<int>>> &__and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, is_move_assignable<allocator<_Rb_tree_node<int>>>>__and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, is_move_assignable<allocator<_Rb_tree_node<int>>>> &__and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, is_move_assignable<allocator<_Rb_tree_node<int>>>> &&const __and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, is_move_assignable<allocator<_Rb_tree_node<int>>>>const __and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, is_move_assignable<allocator<_Rb_tree_node<int>>>> &is_trivially_copy_constructible<allocator<_Rb_tree_node<int>>>is_trivially_copy_constructible<allocator<_Rb_tree_node<int>>> &is_trivially_copy_constructible<allocator<_Rb_tree_node<int>>> &&const is_trivially_copy_constructible<allocator<_Rb_tree_node<int>>>const is_trivially_copy_constructible<allocator<_Rb_tree_node<int>>> &is_trivially_move_constructible<allocator<_Rb_tree_node<int>>>is_trivially_move_constructible<allocator<_Rb_tree_node<int>>> &is_trivially_move_constructible<allocator<_Rb_tree_node<int>>> &&const is_trivially_move_constructible<allocator<_Rb_tree_node<int>>>const is_trivially_move_constructible<allocator<_Rb_tree_node<int>>> &is_nothrow_destructible<pair<int, int>>is_nothrow_destructible<pair<int, int>> &is_nothrow_destructible<pair<int, int>> &&const is_nothrow_destructible<pair<int, int>>const is_nothrow_destructible<pair<int, int>> &is_nothrow_constructible<pair<const CService, int>, const piecewise_construct_t &, tuple<const CService &>, tuple<>>is_nothrow_constructible<pair<const CService, int>, const piecewise_construct_t &, tuple<const CService &>, tuple<>> &is_nothrow_constructible<pair<const CService, int>, const piecewise_construct_t &, tuple<const CService &>, tuple<>> &&const is_nothrow_constructible<pair<const CService, int>, const piecewise_construct_t &, tuple<const CService &>, tuple<>>const is_nothrow_constructible<pair<const CService, int>, const piecewise_construct_t &, tuple<const CService &>, tuple<>> &__is_invocable<less<int> &, const int &, const int &>__is_invocable__is_invocable<less<int> &, const int &, const int &> &__is_invocable<less<int> &, const int &, const int &> &&const __is_invocable<less<int> &, const int &, const int &>const __is_invocable<less<int> &, const int &, const int &> &is_nothrow_constructible<pair<const int, AddrInfo>, const piecewise_construct_t &, tuple<const int &>, tuple<>>is_nothrow_constructible<pair<const int, AddrInfo>, const piecewise_construct_t &, tuple<const int &>, tuple<>> &is_nothrow_constructible<pair<const int, AddrInfo>, const piecewise_construct_t &, tuple<const int &>, tuple<>> &&const is_nothrow_constructible<pair<const int, AddrInfo>, const piecewise_construct_t &, tuple<const int &>, tuple<>>const is_nothrow_constructible<pair<const int, AddrInfo>, const piecewise_construct_t &, tuple<const int &>, tuple<>> &is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<const Network &>, tuple<>>is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<const Network &>, tuple<>> &is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<const Network &>, tuple<>> &&const is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<const Network &>, tuple<>>const is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<const Network &>, tuple<>> &is_nothrow_constructible<pair<const int, int>, const piecewise_construct_t &, tuple<const int &>, tuple<>>is_nothrow_constructible<pair<const int, int>, const piecewise_construct_t &, tuple<const int &>, tuple<>> &is_nothrow_constructible<pair<const int, int>, const piecewise_construct_t &, tuple<const int &>, tuple<>> &&const is_nothrow_constructible<pair<const int, int>, const piecewise_construct_t &, tuple<const int &>, tuple<>>const is_nothrow_constructible<pair<const int, int>, const piecewise_construct_t &, tuple<const int &>, tuple<>> &is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<Network &&>, tuple<>>is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<Network &&>, tuple<>> &is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<Network &&>, tuple<>> &&const is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<Network &&>, tuple<>>const is_nothrow_constructible<pair<const Network, NewTriedCount>, const piecewise_construct_t &, tuple<Network &&>, tuple<>> &is_destructible<allocator<_Hash_node<int, false>>>is_destructible<allocator<_Hash_node<int, false>>> &is_destructible<allocator<_Hash_node<int, false>>> &&const is_destructible<allocator<_Hash_node<int, false>>>const is_destructible<allocator<_Hash_node<int, false>>> &is_destructible<allocator<_Rb_tree_node<int>>>is_destructible<allocator<_Rb_tree_node<int>>> &is_destructible<allocator<_Rb_tree_node<int>>> &&const is_destructible<allocator<_Rb_tree_node<int>>>const is_destructible<allocator<_Rb_tree_node<int>>> &is_destructible<AddressPosition>is_destructible<AddressPosition> &is_destructible<AddressPosition> &&const is_destructible<AddressPosition>const is_destructible<AddressPosition> &is_assignable<AddressPosition &, const AddressPosition &>is_assignable<AddressPosition &, const AddressPosition &> &is_assignable<AddressPosition &, const AddressPosition &> &&const is_assignable<AddressPosition &, const AddressPosition &>const is_assignable<AddressPosition &, const AddressPosition &> &is_constructible<AddressPosition, const AddressPosition &>is_constructible<AddressPosition, const AddressPosition &> &is_constructible<AddressPosition, const AddressPosition &> &&const is_constructible<AddressPosition, const AddressPosition &>const is_constructible<AddressPosition, const AddressPosition &> &conditional<true, is_copy_assignable<AddressPosition>, is_copy_constructible<AddressPosition>>conditional<true, is_copy_assignable<AddressPosition>, is_copy_constructible<AddressPosition>> &conditional<true, is_copy_assignable<AddressPosition>, is_copy_constructible<AddressPosition>> &&const conditional<true, is_copy_assignable<AddressPosition>, is_copy_constructible<AddressPosition>>const conditional<true, is_copy_assignable<AddressPosition>, is_copy_constructible<AddressPosition>> &is_assignable<AddressPosition &, AddressPosition &&>is_assignable<AddressPosition &, AddressPosition &&> &is_assignable<AddressPosition &, AddressPosition &&> &&const is_assignable<AddressPosition &, AddressPosition &&>const is_assignable<AddressPosition &, AddressPosition &&> &is_constructible<AddressPosition, AddressPosition &&>is_constructible<AddressPosition, AddressPosition &&> &is_constructible<AddressPosition, AddressPosition &&> &&const is_constructible<AddressPosition, AddressPosition &&>const is_constructible<AddressPosition, AddressPosition &&> &conditional<true, is_move_assignable<AddressPosition>, is_move_constructible<AddressPosition>>conditional<true, is_move_assignable<AddressPosition>, is_move_constructible<AddressPosition>> &conditional<true, is_move_assignable<AddressPosition>, is_move_constructible<AddressPosition>> &&const conditional<true, is_move_assignable<AddressPosition>, is_move_constructible<AddressPosition>>const conditional<true, is_move_assignable<AddressPosition>, is_move_constructible<AddressPosition>> &__and_<is_copy_constructible<AddressPosition>, integral_constant<bool, true>>__and_<is_copy_constructible<AddressPosition>, integral_constant<bool, true>> &__and_<is_copy_constructible<AddressPosition>, integral_constant<bool, true>> &&const __and_<is_copy_constructible<AddressPosition>, integral_constant<bool, true>>const __and_<is_copy_constructible<AddressPosition>, integral_constant<bool, true>> &__is_referenceable<AddressPosition>__is_referenceable<AddressPosition> &__is_referenceable<AddressPosition> &&const __is_referenceable<AddressPosition>const __is_referenceable<AddressPosition> &__and_<is_move_constructible<AddressPosition>, integral_constant<bool, true>>__and_<is_move_constructible<AddressPosition>, integral_constant<bool, true>> &__and_<is_move_constructible<AddressPosition>, integral_constant<bool, true>> &&const __and_<is_move_constructible<AddressPosition>, integral_constant<bool, true>>const __and_<is_move_constructible<AddressPosition>, integral_constant<bool, true>> &_TC<value, const CService &>_TC<<expression>, const CService &>_TC<value, const Network &>_TC<<expression>, const Network &>conditional<false, const pair<const int, int> *, pair<const int, int> *>conditional<false, const pair<const int, int> *, pair<const int, int> *> &conditional<false, const pair<const int, int> *, pair<const int, int> *> &&const conditional<false, const pair<const int, int> *, pair<const int, int> *>const conditional<false, const pair<const int, int> *, pair<const int, int> *> &_TC<value, const int &>_TC<<expression>, const int &>conditional<false, const pair<const Network, NewTriedCount> *, pair<const Network, NewTriedCount> *>conditional<false, const pair<const Network, NewTriedCount> *, pair<const Network, NewTriedCount> *> &conditional<false, const pair<const Network, NewTriedCount> *, pair<const Network, NewTriedCount> *> &&const conditional<false, const pair<const Network, NewTriedCount> *, pair<const Network, NewTriedCount> *>const conditional<false, const pair<const Network, NewTriedCount> *, pair<const Network, NewTriedCount> *> &_TC<value, Network &&>_TC<<expression>, Network &&>tuple_element<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>>tuple_element<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>> &tuple_element<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>> &&const tuple_element<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>>const tuple_element<0UL, tuple<AddrManImpl *, default_delete<AddrManImpl>>> &is_same<pair<int, int> *, _Ptr>is_same<int *, _Ptr>conditional<true, const int &, int &>conditional<true, const int &, int &> &conditional<true, const int &, int &> &&const conditional<true, const int &, int &>const conditional<true, const int &, int &> &conditional<true, const int *, int *>conditional<true, const int *, int *> &conditional<true, const int *, int *> &&const conditional<true, const int *, int *>const conditional<true, const int *, int *> &is_same<_Rb_tree_const_iterator<int>, _U2>__and_<is_same<_Rb_tree_node<int> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_iterator<int>, _U1>__not_<is_same<optional<allocator<_Rb_tree_node<int>>>, type>>_Optional_payload<allocator<_Rb_tree_node<int>>, false, false, false>_Optional_base_impl<allocator<_Rb_tree_node<int>>, _Optional_base<allocator<_Rb_tree_node<int>>, false, false>>_Optional_base_impl<allocator<_Rb_tree_node<int>>, _Optional_base<allocator<_Rb_tree_node<int>>, false, false>> &_Optional_base_impl<allocator<_Rb_tree_node<int>>, _Optional_base<allocator<_Rb_tree_node<int>>, false, false>> &&const _Optional_base_impl<allocator<_Rb_tree_node<int>>, _Optional_base<allocator<_Rb_tree_node<int>>, false, false>>const _Optional_base_impl<allocator<_Rb_tree_node<int>>, _Optional_base<allocator<_Rb_tree_node<int>>, false, false>> &is_constructible<pair<const int, AddrInfo>, _Pair &&>is_constructible<pair<const CService, int>, _Pair &&>is_constructible<pair<const Network, NewTriedCount>, _Pair &&>__not_<is_same<optional<allocator<_Hash_node<int, false>>>, type>>_Optional_payload<allocator<_Hash_node<int, false>>, false, false, false>_Optional_base_impl<allocator<_Hash_node<int, false>>, _Optional_base<allocator<_Hash_node<int, false>>, false, false>>_Optional_base_impl<allocator<_Hash_node<int, false>>, _Optional_base<allocator<_Hash_node<int, false>>, false, false>> &_Optional_base_impl<allocator<_Hash_node<int, false>>, _Optional_base<allocator<_Hash_node<int, false>>, false, false>> &&const _Optional_base_impl<allocator<_Hash_node<int, false>>, _Optional_base<allocator<_Hash_node<int, false>>, false, false>>const _Optional_base_impl<allocator<_Hash_node<int, false>>, _Optional_base<allocator<_Hash_node<int, false>>, false, false>> &remove_const<AddressPosition>remove_const<AddressPosition> &remove_const<AddressPosition> &&const remove_const<AddressPosition>const remove_const<AddressPosition> &remove_const<allocator<_Rb_tree_node<int>>>remove_const<allocator<_Rb_tree_node<int>>> &remove_const<allocator<_Rb_tree_node<int>>> &&const remove_const<allocator<_Rb_tree_node<int>>>const remove_const<allocator<_Rb_tree_node<int>>> &remove_const<allocator<_Hash_node<int, false>>>remove_const<allocator<_Hash_node<int, false>>> &remove_const<allocator<_Hash_node<int, false>>> &&const remove_const<allocator<_Hash_node<int, false>>>const remove_const<allocator<_Hash_node<int, false>>> &_Equal_helper<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, unsigned long, false>_Equal_helper<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, unsigned long, false> &_Equal_helper<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, unsigned long, false> &&const _Equal_helper<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, unsigned long, false>const _Equal_helper<int, pair<const int, AddrInfo>, _Select1st, equal_to<int>, unsigned long, false> &conditional<true, pair<_Node_iterator<pair<const int, AddrInfo>, false, false>, bool>, _Node_iterator<pair<const int, AddrInfo>, false, false>>conditional<true, pair<_Node_iterator<pair<const int, AddrInfo>, false, false>, bool>, _Node_iterator<pair<const int, AddrInfo>, false, false>> &conditional<true, pair<_Node_iterator<pair<const int, AddrInfo>, false, false>, bool>, _Node_iterator<pair<const int, AddrInfo>, false, false>> &&const conditional<true, pair<_Node_iterator<pair<const int, AddrInfo>, false, false>, bool>, _Node_iterator<pair<const int, AddrInfo>, false, false>>const conditional<true, pair<_Node_iterator<pair<const int, AddrInfo>, false, false>, bool>, _Node_iterator<pair<const int, AddrInfo>, false, false>> &_Equal_helper<CService, pair<const CService, int>, _Select1st, equal_to<CService>, unsigned long, false>_Equal_helper<CService, pair<const CService, int>, _Select1st, equal_to<CService>, unsigned long, false> &_Equal_helper<CService, pair<const CService, int>, _Select1st, equal_to<CService>, unsigned long, false> &&const _Equal_helper<CService, pair<const CService, int>, _Select1st, equal_to<CService>, unsigned long, false>const _Equal_helper<CService, pair<const CService, int>, _Select1st, equal_to<CService>, unsigned long, false> &conditional<true, pair<_Node_iterator<pair<const CService, int>, false, false>, bool>, _Node_iterator<pair<const CService, int>, false, false>>conditional<true, pair<_Node_iterator<pair<const CService, int>, false, false>, bool>, _Node_iterator<pair<const CService, int>, false, false>> &conditional<true, pair<_Node_iterator<pair<const CService, int>, false, false>, bool>, _Node_iterator<pair<const CService, int>, false, false>> &&const conditional<true, pair<_Node_iterator<pair<const CService, int>, false, false>, bool>, _Node_iterator<pair<const CService, int>, false, false>>const conditional<true, pair<_Node_iterator<pair<const CService, int>, false, false>, bool>, _Node_iterator<pair<const CService, int>, false, false>> &_Equal_helper<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, unsigned long, false>_Equal_helper<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, unsigned long, false> &_Equal_helper<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, unsigned long, false> &&const _Equal_helper<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, unsigned long, false>const _Equal_helper<Network, pair<const Network, NewTriedCount>, _Select1st, equal_to<Network>, unsigned long, false> &conditional<true, pair<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, bool>, _Node_iterator<pair<const Network, NewTriedCount>, false, false>>conditional<true, pair<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, bool>, _Node_iterator<pair<const Network, NewTriedCount>, false, false>> &conditional<true, pair<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, bool>, _Node_iterator<pair<const Network, NewTriedCount>, false, false>> &&const conditional<true, pair<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, bool>, _Node_iterator<pair<const Network, NewTriedCount>, false, false>>const conditional<true, pair<_Node_iterator<pair<const Network, NewTriedCount>, false, false>, bool>, _Node_iterator<pair<const Network, NewTriedCount>, false, false>> &conditional<true, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>>conditional<true, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>> &conditional<true, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>> &&const conditional<true, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>>const conditional<true, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>> &_Equal_helper<int, pair<const int, int>, _Select1st, equal_to<int>, unsigned long, false>_Equal_helper<int, pair<const int, int>, _Select1st, equal_to<int>, unsigned long, false> &_Equal_helper<int, pair<const int, int>, _Select1st, equal_to<int>, unsigned long, false> &&const _Equal_helper<int, pair<const int, int>, _Select1st, equal_to<int>, unsigned long, false>const _Equal_helper<int, pair<const int, int>, _Select1st, equal_to<int>, unsigned long, false> &conditional<false, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>>conditional<false, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>> &conditional<false, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>> &&const conditional<false, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>>const conditional<false, pair<_Node_iterator<pair<const int, int>, false, false>, bool>, _Node_iterator<pair<const int, int>, false, false>> &conditional<true, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>>conditional<true, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>> &conditional<true, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>> &&const conditional<true, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>>const conditional<true, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>> &_Equal_helper<int, int, _Identity, equal_to<int>, unsigned long, false>_Equal_helper<int, int, _Identity, equal_to<int>, unsigned long, false> &_Equal_helper<int, int, _Identity, equal_to<int>, unsigned long, false> &&const _Equal_helper<int, int, _Identity, equal_to<int>, unsigned long, false>const _Equal_helper<int, int, _Identity, equal_to<int>, unsigned long, false> &conditional<false, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>>conditional<false, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>> &conditional<false, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>> &&const conditional<false, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>>const conditional<false, pair<_Node_iterator<int, true, false>, bool>, _Node_iterator<int, true, false>> &iterator_traits<int *>iterator_traits<int *> &iterator_traits<int *> &&const iterator_traits<int *>const iterator_traits<int *> &__is_referenceable<pair<int, int>>__is_referenceable<pair<int, int>> &__is_referenceable<pair<int, int>> &&const __is_referenceable<pair<int, int>>const __is_referenceable<pair<int, int>> &remove_reference<tuple<const CService &>>remove_reference<tuple<const CService &>> &remove_reference<tuple<const CService &>> &&const remove_reference<tuple<const CService &>>const remove_reference<tuple<const CService &>> &__safe_multiply<3600L, 1000000000L>__safe_multiply<3600L, 1000000000L> &__safe_multiply<3600L, 1000000000L> &&const __safe_multiply<3600L, 1000000000L>const __safe_multiply<3600L, 1000000000L> &remove_reference<_Rb_tree_iterator<int>>remove_reference<_Rb_tree_iterator<int>> &remove_reference<_Rb_tree_iterator<int>> &&const remove_reference<_Rb_tree_iterator<int>>const remove_reference<_Rb_tree_iterator<int>> &remove_reference<tuple<const int &>>remove_reference<tuple<const int &>> &remove_reference<tuple<const int &>> &&const remove_reference<tuple<const int &>>const remove_reference<tuple<const int &>> &remove_reference<tuple<const Network &>>remove_reference<tuple<const Network &>> &remove_reference<tuple<const Network &>> &&const remove_reference<tuple<const Network &>>const remove_reference<tuple<const Network &>> &remove_reference<Network>remove_reference<Network> &remove_reference<Network> &&const remove_reference<Network>const remove_reference<Network> &remove_reference<tuple<Network &&>>remove_reference<tuple<Network &&>> &remove_reference<tuple<Network &&>> &&const remove_reference<tuple<Network &&>>const remove_reference<tuple<Network &&>> &is_nothrow_move_assignable<direct_or_indirect>is_nothrow_move_assignable<direct_or_indirect> &is_nothrow_move_assignable<direct_or_indirect> &&const is_nothrow_move_assignable<direct_or_indirect>const is_nothrow_move_assignable<direct_or_indirect> &is_nothrow_move_constructible<direct_or_indirect>is_nothrow_move_constructible<direct_or_indirect> &is_nothrow_move_constructible<direct_or_indirect> &&const is_nothrow_move_constructible<direct_or_indirect>const is_nothrow_move_constructible<direct_or_indirect> &remove_reference<direct_or_indirect &>remove_reference<direct_or_indirect &> &remove_reference<direct_or_indirect &> &&const remove_reference<direct_or_indirect &>const remove_reference<direct_or_indirect &> &remove_reference<_Node_iterator<int, true, false>>remove_reference<_Node_iterator<int, true, false>> &remove_reference<_Node_iterator<int, true, false>> &&const remove_reference<_Node_iterator<int, true, false>>const remove_reference<_Node_iterator<int, true, false>> &__decay_and_strip<_Node_iterator<int, true, false>>__decay_and_strip<_Node_iterator<int, true, false>> &__decay_and_strip<_Node_iterator<int, true, false>> &&const __decay_and_strip<_Node_iterator<int, true, false>>const __decay_and_strip<_Node_iterator<int, true, false>> &__is_trivially_move_assignable_impl<AddressPosition, true>__is_trivially_move_assignable_impl<AddressPosition, true> &__is_trivially_move_assignable_impl<AddressPosition, true> &&const __is_trivially_move_assignable_impl<AddressPosition, true>const __is_trivially_move_assignable_impl<AddressPosition, true> &__is_trivially_copy_assignable_impl<AddressPosition, true>__is_trivially_copy_assignable_impl<AddressPosition, true> &__is_trivially_copy_assignable_impl<AddressPosition, true> &&const __is_trivially_copy_assignable_impl<AddressPosition, true>const __is_trivially_copy_assignable_impl<AddressPosition, true> &_Hashtable_ebo_helper<1, CServiceHash, false> *__make_not_void<_Hash_node<pair<const int, AddrInfo>, false>> &__make_not_void<_Hash_node<pair<const CService, int>, false>> &noexcept(__relocate_a_1(std::__niter_base(__first),
				     std::__niter_base(__last),
				     std::__niter_base(__result), __alloc))const duration<signed long, ratio<60L, 1L>> *duration<signed long, ratio<60L, 1L>> *_Head_base<0UL, const CService &, false> *FormatListN<5> *_Storage<AddressPosition, true> *__make_not_void<_Hash_node<pair<const Network, NewTriedCount>, false>> &__make_not_void<_Hash_node<pair<const int, int>, false>> &_Hash_node<pair<const int, int>, false> &__make_not_void<_Hash_node<int, false>> &_Hash_node<int, false> &_Head_base<0UL, const Network &, false> *const equal_to<int> *equal_to<int> *_Head_base<0UL, const int &, false> *_Tuple_impl<0UL, AddrManImpl *, default_delete<AddrManImpl>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<int, false>>, true> &const uintmax_tuintmax_t(1)sizeof(intmax_t)sizeof(intmax_t) * 4(sizeof(intmax_t) * 4)uintmax_t(1) << (sizeof(intmax_t) * 4)__a0__static_abs<_Pn>::value__static_abs<_Pn>::value % __c__static_abs<_Pn>::value / __c__static_abs<_Qn>::value__static_abs<_Qn>::value % __c__static_abs<_Qn>::value / __cis_trivially_copy_assignable<allocator<_Rb_tree_node<int>>>is_trivially_copy_assignable<allocator<_Rb_tree_node<int>>> &is_trivially_copy_assignable<allocator<_Rb_tree_node<int>>> &&const is_trivially_copy_assignable<allocator<_Rb_tree_node<int>>>const is_trivially_copy_assignable<allocator<_Rb_tree_node<int>>> &is_trivially_move_assignable<allocator<_Rb_tree_node<int>>>is_trivially_move_assignable<allocator<_Rb_tree_node<int>>> &is_trivially_move_assignable<allocator<_Rb_tree_node<int>>> &&const is_trivially_move_assignable<allocator<_Rb_tree_node<int>>>const is_trivially_move_assignable<allocator<_Rb_tree_node<int>>> &is_trivially_copy_assignable<allocator<_Hash_node<int, false>>>is_trivially_copy_assignable<allocator<_Hash_node<int, false>>> &is_trivially_copy_assignable<allocator<_Hash_node<int, false>>> &&const is_trivially_copy_assignable<allocator<_Hash_node<int, false>>>const is_trivially_copy_assignable<allocator<_Hash_node<int, false>>> &is_trivially_move_assignable<allocator<_Hash_node<int, false>>>is_trivially_move_assignable<allocator<_Hash_node<int, false>>> &is_trivially_move_assignable<allocator<_Hash_node<int, false>>> &&const is_trivially_move_assignable<allocator<_Hash_node<int, false>>>const is_trivially_move_assignable<allocator<_Hash_node<int, false>>> &pointer_traits<_Hash_node<int, false> *>pointer_traits<_Hash_node<int, false> *> &pointer_traits<_Hash_node<int, false> *> &&const pointer_traits<_Hash_node<int, false> *>const pointer_traits<_Hash_node<int, false> *> &pointer_traits<_Hash_node<pair<const int, int>, false> *>pointer_traits<_Hash_node<pair<const int, int>, false> *> &pointer_traits<_Hash_node<pair<const int, int>, false> *> &&const pointer_traits<_Hash_node<pair<const int, int>, false> *>const pointer_traits<_Hash_node<pair<const int, int>, false> *> &pointer_traits<_Hash_node<pair<const Network, NewTriedCount>, false> *>pointer_traits<_Hash_node<pair<const Network, NewTriedCount>, false> *> &pointer_traits<_Hash_node<pair<const Network, NewTriedCount>, false> *> &&const pointer_traits<_Hash_node<pair<const Network, NewTriedCount>, false> *>const pointer_traits<_Hash_node<pair<const Network, NewTriedCount>, false> *> &pointer_traits<_Hash_node<pair<const CService, int>, false> *>pointer_traits<_Hash_node<pair<const CService, int>, false> *> &pointer_traits<_Hash_node<pair<const CService, int>, false> *> &&const pointer_traits<_Hash_node<pair<const CService, int>, false> *>const pointer_traits<_Hash_node<pair<const CService, int>, false> *> &pointer_traits<_Hash_node<pair<const int, AddrInfo>, false> *>pointer_traits<_Hash_node<pair<const int, AddrInfo>, false> *> &pointer_traits<_Hash_node<pair<const int, AddrInfo>, false> *> &&const pointer_traits<_Hash_node<pair<const int, AddrInfo>, false> *>const pointer_traits<_Hash_node<pair<const int, AddrInfo>, false> *> &__strip_reference_wrapper<_Node_iterator<int, true, false>>__strip_reference_wrapper<_Node_iterator<int, true, false>> &__strip_reference_wrapper<_Node_iterator<int, true, false>> &&const __strip_reference_wrapper<_Node_iterator<int, true, false>>const __strip_reference_wrapper<_Node_iterator<int, true, false>> &conditional<true, is_nothrow_move_assignable<direct_or_indirect>, is_nothrow_move_constructible<direct_or_indirect>>conditional<true, is_nothrow_move_assignable<direct_or_indirect>, is_nothrow_move_constructible<direct_or_indirect>> &conditional<true, is_nothrow_move_assignable<direct_or_indirect>, is_nothrow_move_constructible<direct_or_indirect>> &&const conditional<true, is_nothrow_move_assignable<direct_or_indirect>, is_nothrow_move_constructible<direct_or_indirect>>const conditional<true, is_nothrow_move_assignable<direct_or_indirect>, is_nothrow_move_constructible<direct_or_indirect>> &__is_nothrow_move_constructible_impl<direct_or_indirect, true>__is_nothrow_move_constructible_impl<direct_or_indirect, true> &__is_nothrow_move_constructible_impl<direct_or_indirect, true> &&const __is_nothrow_move_constructible_impl<direct_or_indirect, true>const __is_nothrow_move_constructible_impl<direct_or_indirect, true> &__is_nt_move_assignable_impl<direct_or_indirect, true>__is_nt_move_assignable_impl<direct_or_indirect, true> &__is_nt_move_assignable_impl<direct_or_indirect, true> &&const __is_nt_move_assignable_impl<direct_or_indirect, true>const __is_nt_move_assignable_impl<direct_or_indirect, true> &tuple_element<0UL, tuple<default_delete<AddrManImpl>>>tuple_element<0UL, tuple<default_delete<AddrManImpl>>> &tuple_element<0UL, tuple<default_delete<AddrManImpl>>> &&const tuple_element<0UL, tuple<default_delete<AddrManImpl>>>const tuple_element<0UL, tuple<default_delete<AddrManImpl>>> &__ratio_divide<ratio<1L, 1L>, ratio<1L, 1L>>__ratio_divide<ratio<1L, 1L>, ratio<1L, 1L>> &__ratio_divide<ratio<1L, 1L>, ratio<1L, 1L>> &&const __ratio_divide<ratio<1L, 1L>, ratio<1L, 1L>>const __ratio_divide<ratio<1L, 1L>, ratio<1L, 1L>> &__ratio_divide<ratio<3600L, 1L>, ratio<1L, 1L>>__ratio_divide<ratio<3600L, 1L>, ratio<1L, 1L>> &__ratio_divide<ratio<3600L, 1L>, ratio<1L, 1L>> &&const __ratio_divide<ratio<3600L, 1L>, ratio<1L, 1L>>const __ratio_divide<ratio<3600L, 1L>, ratio<1L, 1L>> &__ratio_divide<ratio<3600L, 1L>, ratio<1L, 1000000000L>>__ratio_divide<ratio<3600L, 1L>, ratio<1L, 1000000000L>> &__ratio_divide<ratio<3600L, 1L>, ratio<1L, 1000000000L>> &&const __ratio_divide<ratio<3600L, 1L>, ratio<1L, 1000000000L>>const __ratio_divide<ratio<3600L, 1L>, ratio<1L, 1000000000L>> &__ratio_divide<ratio<60L, 1L>, ratio<1L, 1L>>__ratio_divide<ratio<60L, 1L>, ratio<1L, 1L>> &__ratio_divide<ratio<60L, 1L>, ratio<1L, 1L>> &&const __ratio_divide<ratio<60L, 1L>, ratio<1L, 1L>>const __ratio_divide<ratio<60L, 1L>, ratio<1L, 1L>> &conditional<false, const pair<const int, int> &, pair<const int, int> &>conditional<false, const pair<const int, int> &, pair<const int, int> &> &conditional<false, const pair<const int, int> &, pair<const int, int> &> &&const conditional<false, const pair<const int, int> &, pair<const int, int> &>const conditional<false, const pair<const int, int> &, pair<const int, int> &> &conditional<false, const pair<const Network, NewTriedCount> &, pair<const Network, NewTriedCount> &>conditional<false, const pair<const Network, NewTriedCount> &, pair<const Network, NewTriedCount> &> &conditional<false, const pair<const Network, NewTriedCount> &, pair<const Network, NewTriedCount> &> &&const conditional<false, const pair<const Network, NewTriedCount> &, pair<const Network, NewTriedCount> &>const conditional<false, const pair<const Network, NewTriedCount> &, pair<const Network, NewTriedCount> &> &is_same<optional<allocator<_Hash_node<int, false>>>, type>is_same<optional<allocator<_Rb_tree_node<int>>>, type>is_same<_Rb_tree_node<int> *, _Ptr>__is_empty_non_tuple<Network &&>__is_empty_non_tuple<Network &&> &__is_empty_non_tuple<Network &&> &&const __is_empty_non_tuple<Network &&>const __is_empty_non_tuple<Network &&> &__is_empty_non_tuple<const Network &>__is_empty_non_tuple<const Network &> &__is_empty_non_tuple<const Network &> &&const __is_empty_non_tuple<const Network &>const __is_empty_non_tuple<const Network &> &__is_empty_non_tuple<const CService &>__is_empty_non_tuple<const CService &> &__is_empty_non_tuple<const CService &> &&const __is_empty_non_tuple<const CService &>const __is_empty_non_tuple<const CService &> &__and_<is_same<_Hash_node<pair<const Network, NewTriedCount>, false> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<_Hash_node<pair<const CService, int>, false> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<_Hash_node<pair<const int, AddrInfo>, false> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<tuple<Network &&>, tuple<_UElements...>>is_same<tuple<const int &>, tuple<_UElements...>>is_same<tuple<const Network &>, tuple<_UElements...>>is_same<tuple<const CService &>, tuple<_UElements...>>conditional<true, integral_constant<bool, true>, is_destructible<AddressPosition>>conditional<true, integral_constant<bool, true>, is_destructible<AddressPosition>> &conditional<true, integral_constant<bool, true>, is_destructible<AddressPosition>> &&const conditional<true, integral_constant<bool, true>, is_destructible<AddressPosition>>const conditional<true, integral_constant<bool, true>, is_destructible<AddressPosition>> &conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<int>>>>conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<int>>>> &conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<int>>>> &&const conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<int>>>>const conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<int>>>> &conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Hash_node<int, false>>>>conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Hash_node<int, false>>>> &conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Hash_node<int, false>>>> &&const conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Hash_node<int, false>>>>const conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Hash_node<int, false>>>> &__underlying_type_impl<Format, true>__underlying_type_impl<Format, true> &__underlying_type_impl<Format, true> &&const __underlying_type_impl<Format, true>const __underlying_type_impl<Format, true> &remove_reference<const vector<unsigned char, allocator<unsigned char>> &>remove_reference<const vector<unsigned char, allocator<unsigned char>> &> &remove_reference<const vector<unsigned char, allocator<unsigned char>> &> &&const remove_reference<const vector<unsigned char, allocator<unsigned char>> &>const remove_reference<const vector<unsigned char, allocator<unsigned char>> &> &remove_reference<_Rb_tree_node<int> *&>remove_reference<_Rb_tree_node<int> *&> &remove_reference<_Rb_tree_node<int> *&> &&const remove_reference<_Rb_tree_node<int> *&>const remove_reference<_Rb_tree_node<int> *&> &__is_trivially_move_constructible_impl<allocator<_Rb_tree_node<int>>, true>__is_trivially_move_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_trivially_move_constructible_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_trivially_move_constructible_impl<allocator<_Rb_tree_node<int>>, true>const __is_trivially_move_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true>__is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true>const __is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_move_constructible_impl<allocator<_Rb_tree_node<int>>, true>__is_move_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_move_constructible_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_move_constructible_impl<allocator<_Rb_tree_node<int>>, true>const __is_move_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_move_assignable_impl<allocator<_Rb_tree_node<int>>, true>__is_move_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__is_move_assignable_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_move_assignable_impl<allocator<_Rb_tree_node<int>>, true>const __is_move_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__is_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true>__is_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true>const __is_copy_constructible_impl<allocator<_Rb_tree_node<int>>, true> &__is_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true>__is_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__is_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true>const __is_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__is_trivially_move_constructible_impl<allocator<_Hash_node<int, false>>, true>__is_trivially_move_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_trivially_move_constructible_impl<allocator<_Hash_node<int, false>>, true> &&const __is_trivially_move_constructible_impl<allocator<_Hash_node<int, false>>, true>const __is_trivially_move_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_trivially_copy_constructible_impl<allocator<_Hash_node<int, false>>, true>__is_trivially_copy_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_trivially_copy_constructible_impl<allocator<_Hash_node<int, false>>, true> &&const __is_trivially_copy_constructible_impl<allocator<_Hash_node<int, false>>, true>const __is_trivially_copy_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_move_constructible_impl<allocator<_Hash_node<int, false>>, true>__is_move_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_move_constructible_impl<allocator<_Hash_node<int, false>>, true> &&const __is_move_constructible_impl<allocator<_Hash_node<int, false>>, true>const __is_move_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_move_assignable_impl<allocator<_Hash_node<int, false>>, true>__is_move_assignable_impl<allocator<_Hash_node<int, false>>, true> &__is_move_assignable_impl<allocator<_Hash_node<int, false>>, true> &&const __is_move_assignable_impl<allocator<_Hash_node<int, false>>, true>const __is_move_assignable_impl<allocator<_Hash_node<int, false>>, true> &__is_copy_constructible_impl<allocator<_Hash_node<int, false>>, true>__is_copy_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_copy_constructible_impl<allocator<_Hash_node<int, false>>, true> &&const __is_copy_constructible_impl<allocator<_Hash_node<int, false>>, true>const __is_copy_constructible_impl<allocator<_Hash_node<int, false>>, true> &__is_copy_assignable_impl<allocator<_Hash_node<int, false>>, true>__is_copy_assignable_impl<allocator<_Hash_node<int, false>>, true> &__is_copy_assignable_impl<allocator<_Hash_node<int, false>>, true> &&const __is_copy_assignable_impl<allocator<_Hash_node<int, false>>, true>const __is_copy_assignable_impl<allocator<_Hash_node<int, false>>, true> &const Wrapper<ChronoFormatter<signed long, false>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> *const vector<unsigned char, allocator<unsigned char>> *const _Vector_base<unsigned char, allocator<unsigned char>>const _Vector_base<unsigned char, allocator<unsigned char>> *_Vector_base<unsigned char, allocator<unsigned char>> *_Head_base<0UL, AddrManImpl *, false> *_Tuple_impl<1UL, default_delete<AddrManImpl>> *tuple<Network &&> *tuple<const Network &> *tuple<const int &> *tuple<const CService &> *__relocate_a_1noexcept(std::__relocate_object_a(std::addressof(*__result),
					       std::addressof(*__first),
					       __alloc))_ValueTypeintegral_constant<long, 3600L>integral_constant<long, 3600L> &integral_constant<long, 3600L> &&const integral_constant<long, 3600L>const integral_constant<long, 3600L> &is_nothrow_destructible<pair<const int, AddrInfo>>is_nothrow_destructible<pair<const int, AddrInfo>> &is_nothrow_destructible<pair<const int, AddrInfo>> &&const is_nothrow_destructible<pair<const int, AddrInfo>>const is_nothrow_destructible<pair<const int, AddrInfo>> &is_nothrow_destructible<pair<const CService, int>>is_nothrow_destructible<pair<const CService, int>> &is_nothrow_destructible<pair<const CService, int>> &&const is_nothrow_destructible<pair<const CService, int>>const is_nothrow_destructible<pair<const CService, int>> &is_nothrow_copy_constructible<pair<int, int> *>is_nothrow_copy_constructible<pair<int, int> *> &is_nothrow_copy_constructible<pair<int, int> *> &&const is_nothrow_copy_constructible<pair<int, int> *>const is_nothrow_copy_constructible<pair<int, int> *> &is_nothrow_copy_constructible<int *>is_nothrow_copy_constructible<int *> &is_nothrow_copy_constructible<int *> &&const is_nothrow_copy_constructible<int *>const is_nothrow_copy_constructible<int *> &is_nothrow_destructible<pair<const Network, NewTriedCount>>is_nothrow_destructible<pair<const Network, NewTriedCount>> &is_nothrow_destructible<pair<const Network, NewTriedCount>> &&const is_nothrow_destructible<pair<const Network, NewTriedCount>>const is_nothrow_destructible<pair<const Network, NewTriedCount>> &is_nothrow_destructible<pair<const int, int>>is_nothrow_destructible<pair<const int, int>> &is_nothrow_destructible<pair<const int, int>> &&const is_nothrow_destructible<pair<const int, int>>const is_nothrow_destructible<pair<const int, int>> &is_assignable<allocator<_Hash_node<int, false>> &, const allocator<_Hash_node<int, false>> &>is_assignable<allocator<_Hash_node<int, false>> &, const allocator<_Hash_node<int, false>> &> &is_assignable<allocator<_Hash_node<int, false>> &, const allocator<_Hash_node<int, false>> &> &&const is_assignable<allocator<_Hash_node<int, false>> &, const allocator<_Hash_node<int, false>> &>const is_assignable<allocator<_Hash_node<int, false>> &, const allocator<_Hash_node<int, false>> &> &is_constructible<allocator<_Hash_node<int, false>>, const allocator<_Hash_node<int, false>> &>is_constructible<allocator<_Hash_node<int, false>>, const allocator<_Hash_node<int, false>> &> &is_constructible<allocator<_Hash_node<int, false>>, const allocator<_Hash_node<int, false>> &> &&const is_constructible<allocator<_Hash_node<int, false>>, const allocator<_Hash_node<int, false>> &>const is_constructible<allocator<_Hash_node<int, false>>, const allocator<_Hash_node<int, false>> &> &conditional<true, is_copy_assignable<allocator<_Hash_node<int, false>>>, is_copy_constructible<allocator<_Hash_node<int, false>>>>_B1::valueconditional<true, is_copy_assignable<allocator<_Hash_node<int, false>>>, is_copy_constructible<allocator<_Hash_node<int, false>>>> &conditional<true, is_copy_assignable<allocator<_Hash_node<int, false>>>, is_copy_constructible<allocator<_Hash_node<int, false>>>> &&const conditional<true, is_copy_assignable<allocator<_Hash_node<int, false>>>, is_copy_constructible<allocator<_Hash_node<int, false>>>>const conditional<true, is_copy_assignable<allocator<_Hash_node<int, false>>>, is_copy_constructible<allocator<_Hash_node<int, false>>>> &is_assignable<allocator<_Hash_node<int, false>> &, allocator<_Hash_node<int, false>> &&>allocator<_Hash_node<int, false>> &&is_assignable<allocator<_Hash_node<int, false>> &, allocator<_Hash_node<int, false>> &&> &is_assignable<allocator<_Hash_node<int, false>> &, allocator<_Hash_node<int, false>> &&> &&const is_assignable<allocator<_Hash_node<int, false>> &, allocator<_Hash_node<int, false>> &&>const is_assignable<allocator<_Hash_node<int, false>> &, allocator<_Hash_node<int, false>> &&> &is_constructible<allocator<_Hash_node<int, false>>, allocator<_Hash_node<int, false>> &&>is_constructible<allocator<_Hash_node<int, false>>, allocator<_Hash_node<int, false>> &&> &is_constructible<allocator<_Hash_node<int, false>>, allocator<_Hash_node<int, false>> &&> &&const is_constructible<allocator<_Hash_node<int, false>>, allocator<_Hash_node<int, false>> &&>const is_constructible<allocator<_Hash_node<int, false>>, allocator<_Hash_node<int, false>> &&> &conditional<true, is_move_assignable<allocator<_Hash_node<int, false>>>, is_move_constructible<allocator<_Hash_node<int, false>>>>conditional<true, is_move_assignable<allocator<_Hash_node<int, false>>>, is_move_constructible<allocator<_Hash_node<int, false>>>> &conditional<true, is_move_assignable<allocator<_Hash_node<int, false>>>, is_move_constructible<allocator<_Hash_node<int, false>>>> &&const conditional<true, is_move_assignable<allocator<_Hash_node<int, false>>>, is_move_constructible<allocator<_Hash_node<int, false>>>>const conditional<true, is_move_assignable<allocator<_Hash_node<int, false>>>, is_move_constructible<allocator<_Hash_node<int, false>>>> &__and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>>__and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &__and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &&const __and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>>const __and_<is_copy_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &__is_referenceable<allocator<_Hash_node<int, false>>>__is_referenceable<allocator<_Hash_node<int, false>>> &__is_referenceable<allocator<_Hash_node<int, false>>> &&const __is_referenceable<allocator<_Hash_node<int, false>>>const __is_referenceable<allocator<_Hash_node<int, false>>> &__and_<is_move_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>>__and_<is_move_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &__and_<is_move_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &&const __and_<is_move_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>>const __and_<is_move_constructible<allocator<_Hash_node<int, false>>>, integral_constant<bool, false>> &is_assignable<allocator<_Rb_tree_node<int>> &, const allocator<_Rb_tree_node<int>> &>const allocator<_Rb_tree_node<int>>const allocator<_Rb_tree_node<int>> &is_assignable<allocator<_Rb_tree_node<int>> &, const allocator<_Rb_tree_node<int>> &> &is_assignable<allocator<_Rb_tree_node<int>> &, const allocator<_Rb_tree_node<int>> &> &&const is_assignable<allocator<_Rb_tree_node<int>> &, const allocator<_Rb_tree_node<int>> &>const is_assignable<allocator<_Rb_tree_node<int>> &, const allocator<_Rb_tree_node<int>> &> &is_constructible<allocator<_Rb_tree_node<int>>, const allocator<_Rb_tree_node<int>> &>is_constructible<allocator<_Rb_tree_node<int>>, const allocator<_Rb_tree_node<int>> &> &is_constructible<allocator<_Rb_tree_node<int>>, const allocator<_Rb_tree_node<int>> &> &&const is_constructible<allocator<_Rb_tree_node<int>>, const allocator<_Rb_tree_node<int>> &>const is_constructible<allocator<_Rb_tree_node<int>>, const allocator<_Rb_tree_node<int>> &> &conditional<true, is_copy_assignable<allocator<_Rb_tree_node<int>>>, is_copy_constructible<allocator<_Rb_tree_node<int>>>>conditional<true, is_copy_assignable<allocator<_Rb_tree_node<int>>>, is_copy_constructible<allocator<_Rb_tree_node<int>>>> &conditional<true, is_copy_assignable<allocator<_Rb_tree_node<int>>>, is_copy_constructible<allocator<_Rb_tree_node<int>>>> &&const conditional<true, is_copy_assignable<allocator<_Rb_tree_node<int>>>, is_copy_constructible<allocator<_Rb_tree_node<int>>>>const conditional<true, is_copy_assignable<allocator<_Rb_tree_node<int>>>, is_copy_constructible<allocator<_Rb_tree_node<int>>>> &is_assignable<allocator<_Rb_tree_node<int>> &, allocator<_Rb_tree_node<int>> &&>allocator<_Rb_tree_node<int>> &&is_assignable<allocator<_Rb_tree_node<int>> &, allocator<_Rb_tree_node<int>> &&> &is_assignable<allocator<_Rb_tree_node<int>> &, allocator<_Rb_tree_node<int>> &&> &&const is_assignable<allocator<_Rb_tree_node<int>> &, allocator<_Rb_tree_node<int>> &&>const is_assignable<allocator<_Rb_tree_node<int>> &, allocator<_Rb_tree_node<int>> &&> &is_constructible<allocator<_Rb_tree_node<int>>, allocator<_Rb_tree_node<int>> &&>is_constructible<allocator<_Rb_tree_node<int>>, allocator<_Rb_tree_node<int>> &&> &is_constructible<allocator<_Rb_tree_node<int>>, allocator<_Rb_tree_node<int>> &&> &&const is_constructible<allocator<_Rb_tree_node<int>>, allocator<_Rb_tree_node<int>> &&>const is_constructible<allocator<_Rb_tree_node<int>>, allocator<_Rb_tree_node<int>> &&> &conditional<true, is_move_assignable<allocator<_Rb_tree_node<int>>>, is_move_constructible<allocator<_Rb_tree_node<int>>>>conditional<true, is_move_assignable<allocator<_Rb_tree_node<int>>>, is_move_constructible<allocator<_Rb_tree_node<int>>>> &conditional<true, is_move_assignable<allocator<_Rb_tree_node<int>>>, is_move_constructible<allocator<_Rb_tree_node<int>>>> &&const conditional<true, is_move_assignable<allocator<_Rb_tree_node<int>>>, is_move_constructible<allocator<_Rb_tree_node<int>>>>const conditional<true, is_move_assignable<allocator<_Rb_tree_node<int>>>, is_move_constructible<allocator<_Rb_tree_node<int>>>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>>__and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &&const __and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>>const __and_<is_copy_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &__is_referenceable<allocator<_Rb_tree_node<int>>>__is_referenceable<allocator<_Rb_tree_node<int>>> &__is_referenceable<allocator<_Rb_tree_node<int>>> &&const __is_referenceable<allocator<_Rb_tree_node<int>>>const __is_referenceable<allocator<_Rb_tree_node<int>>> &__and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>>__and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &__and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &&const __and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>>const __and_<is_move_constructible<allocator<_Rb_tree_node<int>>>, integral_constant<bool, false>> &is_enum<Format>is_enum<Format> &is_enum<Format> &&const is_enum<Format>const is_enum<Format> &conditional<true, integral_constant<bool, true>, is_copy_constructible<AddressPosition>>conditional<true, integral_constant<bool, true>, is_copy_constructible<AddressPosition>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<AddressPosition>> &&const conditional<true, integral_constant<bool, true>, is_copy_constructible<AddressPosition>>const conditional<true, integral_constant<bool, true>, is_copy_constructible<AddressPosition>> &conditional<true, integral_constant<bool, true>, is_move_constructible<AddressPosition>>conditional<true, integral_constant<bool, true>, is_move_constructible<AddressPosition>> &conditional<true, integral_constant<bool, true>, is_move_constructible<AddressPosition>> &&const conditional<true, integral_constant<bool, true>, is_move_constructible<AddressPosition>>const conditional<true, integral_constant<bool, true>, is_move_constructible<AddressPosition>> &is_same<_Hash_node<pair<const int, AddrInfo>, false> *, _Ptr>is_same<_Hash_node<pair<const CService, int>, false> *, _Ptr>is_same<_Hash_node<pair<const Network, NewTriedCount>, false> *, _Ptr>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CService &>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CService &>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CService &>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CService &>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CService &>> &is_empty<const CService &>is_empty<const CService &> &is_empty<const CService &> &&const is_empty<const CService &>const is_empty<const CService &> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const Network &>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const Network &>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const Network &>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const Network &>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const Network &>> &is_empty<const Network &>is_empty<const Network &> &is_empty<const Network &> &&const is_empty<const Network &>const is_empty<const Network &> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Network &&>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Network &&>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Network &&>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Network &&>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Network &&>> &is_empty<Network &&>is_empty<Network &&> &is_empty<Network &&> &&const is_empty<Network &&>const is_empty<Network &&> &__ratio_multiply<ratio<60L, 1L>, ratio<1L, 1L>>__ratio_multiply<ratio<60L, 1L>, ratio<1L, 1L>> &__ratio_multiply<ratio<60L, 1L>, ratio<1L, 1L>> &&const __ratio_multiply<ratio<60L, 1L>, ratio<1L, 1L>>const __ratio_multiply<ratio<60L, 1L>, ratio<1L, 1L>> &__ratio_multiply<ratio<3600L, 1L>, ratio<1000000000L, 1L>>__ratio_multiply<ratio<3600L, 1L>, ratio<1000000000L, 1L>> &__ratio_multiply<ratio<3600L, 1L>, ratio<1000000000L, 1L>> &&const __ratio_multiply<ratio<3600L, 1L>, ratio<1000000000L, 1L>>const __ratio_multiply<ratio<3600L, 1L>, ratio<1000000000L, 1L>> &__ratio_multiply<ratio<3600L, 1L>, ratio<1L, 1L>>__ratio_multiply<ratio<3600L, 1L>, ratio<1L, 1L>> &__ratio_multiply<ratio<3600L, 1L>, ratio<1L, 1L>> &&const __ratio_multiply<ratio<3600L, 1L>, ratio<1L, 1L>>const __ratio_multiply<ratio<3600L, 1L>, ratio<1L, 1L>> &__ratio_multiply<ratio<1L, 1L>, ratio<1L, 1L>>__ratio_multiply<ratio<1L, 1L>, ratio<1L, 1L>> &__ratio_multiply<ratio<1L, 1L>, ratio<1L, 1L>> &&const __ratio_multiply<ratio<1L, 1L>, ratio<1L, 1L>>const __ratio_multiply<ratio<1L, 1L>, ratio<1L, 1L>> &tuple<default_delete<AddrManImpl>>is_nothrow_assignable<direct_or_indirect &, direct_or_indirect &&>is_nothrow_assignable<direct_or_indirect &, direct_or_indirect &&> &is_nothrow_assignable<direct_or_indirect &, direct_or_indirect &&> &&const is_nothrow_assignable<direct_or_indirect &, direct_or_indirect &&>const is_nothrow_assignable<direct_or_indirect &, direct_or_indirect &&> &__is_referenceable<direct_or_indirect>__is_referenceable<direct_or_indirect> &__is_referenceable<direct_or_indirect> &&const __is_referenceable<direct_or_indirect>const __is_referenceable<direct_or_indirect> &is_nothrow_constructible<direct_or_indirect, direct_or_indirect &&>is_nothrow_constructible<direct_or_indirect, direct_or_indirect &&> &is_nothrow_constructible<direct_or_indirect, direct_or_indirect &&> &&const is_nothrow_constructible<direct_or_indirect, direct_or_indirect &&>const is_nothrow_constructible<direct_or_indirect, direct_or_indirect &&> &__is_trivially_move_assignable_impl<allocator<_Hash_node<int, false>>, true>__is_trivially_move_assignable_impl<allocator<_Hash_node<int, false>>, true> &__is_trivially_move_assignable_impl<allocator<_Hash_node<int, false>>, true> &&const __is_trivially_move_assignable_impl<allocator<_Hash_node<int, false>>, true>const __is_trivially_move_assignable_impl<allocator<_Hash_node<int, false>>, true> &__is_trivially_copy_assignable_impl<allocator<_Hash_node<int, false>>, true>__is_trivially_copy_assignable_impl<allocator<_Hash_node<int, false>>, true> &__is_trivially_copy_assignable_impl<allocator<_Hash_node<int, false>>, true> &&const __is_trivially_copy_assignable_impl<allocator<_Hash_node<int, false>>, true>const __is_trivially_copy_assignable_impl<allocator<_Hash_node<int, false>>, true> &__is_trivially_move_assignable_impl<allocator<_Rb_tree_node<int>>, true>__is_trivially_move_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__is_trivially_move_assignable_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_trivially_move_assignable_impl<allocator<_Rb_tree_node<int>>, true>const __is_trivially_move_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true>__is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true> &&const __is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true>const __is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<int>>, true> &__relocate_object_anoexcept(std::allocator_traits<_Allocator>::construct(__alloc,
			 __dest, std::move(*__orig)))noexcept(std::allocator_traits<_Allocator>::destroy(
			    __alloc, std::__addressof(*__orig)))noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
			 __dest, std::move(*__orig)))
	     && noexcept(std::allocator_traits<_Allocator>::destroy(
			    __alloc, std::__addressof(*__orig)))__origconst equal_to<CService> *equal_to<CService> *_Tuple_impl<0UL, Network &&> *const equal_to<Network> *equal_to<Network> *_Head_base<1UL, default_delete<AddrManImpl>, true> *__static_gcd<60L, 1L>__static_gcd<60L, 1L> &__static_gcd<60L, 1L> &&const __static_gcd<60L, 1L>const __static_gcd<60L, 1L> &__static_gcd<3600L, 1L>__static_gcd<3600L, 1L> &__static_gcd<3600L, 1L> &&const __static_gcd<3600L, 1L>const __static_gcd<3600L, 1L> &is_nothrow_move_constructible<Network &&>is_nothrow_move_constructible<Network &&> &is_nothrow_move_constructible<Network &&> &&const is_nothrow_move_constructible<Network &&>const is_nothrow_move_constructible<Network &&> &is_nothrow_move_constructible<const Network &>is_nothrow_move_constructible<const Network &> &is_nothrow_move_constructible<const Network &> &&const is_nothrow_move_constructible<const Network &>const is_nothrow_move_constructible<const Network &> &is_nothrow_move_constructible<const int &>is_nothrow_move_constructible<const int &> &is_nothrow_move_constructible<const int &> &&const is_nothrow_move_constructible<const int &>const is_nothrow_move_constructible<const int &> &is_nothrow_move_constructible<const CService &>is_nothrow_move_constructible<const CService &> &is_nothrow_move_constructible<const CService &> &&const is_nothrow_move_constructible<const CService &>const is_nothrow_move_constructible<const CService &> &conditional<false, __undefined, _Hash_node<int, false>>conditional<false, __undefined, _Hash_node<int, false>> &conditional<false, __undefined, _Hash_node<int, false>> &&const conditional<false, __undefined, _Hash_node<int, false>>const conditional<false, __undefined, _Hash_node<int, false>> &conditional<false, __undefined, _Hash_node<pair<const int, int>, false>>conditional<false, __undefined, _Hash_node<pair<const int, int>, false>> &conditional<false, __undefined, _Hash_node<pair<const int, int>, false>> &&const conditional<false, __undefined, _Hash_node<pair<const int, int>, false>>const conditional<false, __undefined, _Hash_node<pair<const int, int>, false>> &conditional<false, __undefined, _Hash_node<pair<const Network, NewTriedCount>, false>>conditional<false, __undefined, _Hash_node<pair<const Network, NewTriedCount>, false>> &conditional<false, __undefined, _Hash_node<pair<const Network, NewTriedCount>, false>> &&const conditional<false, __undefined, _Hash_node<pair<const Network, NewTriedCount>, false>>const conditional<false, __undefined, _Hash_node<pair<const Network, NewTriedCount>, false>> &enable_if<true, int *>enable_if<true, int *> &enable_if<true, int *> &&const enable_if<true, int *>const enable_if<true, int *> &conditional<false, __undefined, _Hash_node<pair<const CService, int>, false>>conditional<false, __undefined, _Hash_node<pair<const CService, int>, false>> &conditional<false, __undefined, _Hash_node<pair<const CService, int>, false>> &&const conditional<false, __undefined, _Hash_node<pair<const CService, int>, false>>const conditional<false, __undefined, _Hash_node<pair<const CService, int>, false>> &conditional<false, __undefined, _Hash_node<pair<const int, AddrInfo>, false>>conditional<false, __undefined, _Hash_node<pair<const int, AddrInfo>, false>> &conditional<false, __undefined, _Hash_node<pair<const int, AddrInfo>, false>> &&const conditional<false, __undefined, _Hash_node<pair<const int, AddrInfo>, false>>const conditional<false, __undefined, _Hash_node<pair<const int, AddrInfo>, false>> &__and_<is_assignable<direct_or_indirect &, direct_or_indirect &&>, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>>__and_<is_assignable<direct_or_indirect &, direct_or_indirect &&>, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>> &__and_<is_assignable<direct_or_indirect &, direct_or_indirect &&>, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>> &&const __and_<is_assignable<direct_or_indirect &, direct_or_indirect &&>, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>>const __and_<is_assignable<direct_or_indirect &, direct_or_indirect &&>, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>> &__is_nothrow_copy_constructible_impl<int *, true>__is_nothrow_copy_constructible_impl<int *, true> &__is_nothrow_copy_constructible_impl<int *, true> &&const __is_nothrow_copy_constructible_impl<int *, true>const __is_nothrow_copy_constructible_impl<int *, true> &__is_nothrow_copy_constructible_impl<pair<int, int> *, true>__is_nothrow_copy_constructible_impl<pair<int, int> *, true> &__is_nothrow_copy_constructible_impl<pair<int, int> *, true> &&const __is_nothrow_copy_constructible_impl<pair<int, int> *, true>const __is_nothrow_copy_constructible_impl<pair<int, int> *, true> &is_nothrow_constructible<pair<int, int>, pair<int, int>>is_nothrow_constructible<pair<int, int>, pair<int, int>> &is_nothrow_constructible<pair<int, int>, pair<int, int>> &&const is_nothrow_constructible<pair<int, int>, pair<int, int>>const is_nothrow_constructible<pair<int, int>, pair<int, int>> &__is_referenceable<pair<int, int> *>__is_referenceable<pair<int, int> *> &__is_referenceable<pair<int, int> *> &&const __is_referenceable<pair<int, int> *>const __is_referenceable<pair<int, int> *> &is_nothrow_constructible<pair<int, int> *, pair<int, int> *const &>is_nothrow_constructible<pair<int, int> *, pair<int, int> *const &> &is_nothrow_constructible<pair<int, int> *, pair<int, int> *const &> &&const is_nothrow_constructible<pair<int, int> *, pair<int, int> *const &>const is_nothrow_constructible<pair<int, int> *, pair<int, int> *const &> &__is_referenceable<int *>__is_referenceable<int *> &__is_referenceable<int *> &&const __is_referenceable<int *>const __is_referenceable<int *> &is_nothrow_constructible<int *, int *const &>is_nothrow_constructible<int *, int *const &> &is_nothrow_constructible<int *, int *const &> &&const is_nothrow_constructible<int *, int *const &>const is_nothrow_constructible<int *, int *const &> &conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Hash_node<int, false>>>>conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Hash_node<int, false>>>> &conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Hash_node<int, false>>>> &&const conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Hash_node<int, false>>>>const conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Hash_node<int, false>>>> &conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Hash_node<int, false>>>>conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Hash_node<int, false>>>> &conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Hash_node<int, false>>>> &&const conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Hash_node<int, false>>>>const conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Hash_node<int, false>>>> &conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<int>>>>conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<int>>>> &conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<int>>>> &&const conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<int>>>>const conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<int>>>> &conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<int>>>>conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<int>>>> &conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<int>>>> &&const conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<int>>>>const conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<int>>>> &__is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>__is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&> &__is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&> &&const __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>const __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&> &is_assignable<direct_or_indirect &, direct_or_indirect &&>is_assignable<direct_or_indirect &, direct_or_indirect &&> &is_assignable<direct_or_indirect &, direct_or_indirect &&> &&const is_assignable<direct_or_indirect &, direct_or_indirect &&>const is_assignable<direct_or_indirect &, direct_or_indirect &&> &is_void<_Hash_node<pair<const int, AddrInfo>, false>>is_void<_Hash_node<pair<const int, AddrInfo>, false>> &is_void<_Hash_node<pair<const int, AddrInfo>, false>> &&const is_void<_Hash_node<pair<const int, AddrInfo>, false>>const is_void<_Hash_node<pair<const int, AddrInfo>, false>> &is_void<_Hash_node<pair<const CService, int>, false>>is_void<_Hash_node<pair<const CService, int>, false>> &is_void<_Hash_node<pair<const CService, int>, false>> &&const is_void<_Hash_node<pair<const CService, int>, false>>const is_void<_Hash_node<pair<const CService, int>, false>> &is_void<_Hash_node<pair<const Network, NewTriedCount>, false>>is_void<_Hash_node<pair<const Network, NewTriedCount>, false>> &is_void<_Hash_node<pair<const Network, NewTriedCount>, false>> &&const is_void<_Hash_node<pair<const Network, NewTriedCount>, false>>const is_void<_Hash_node<pair<const Network, NewTriedCount>, false>> &is_void<_Hash_node<pair<const int, int>, false>>is_void<_Hash_node<pair<const int, int>, false>> &is_void<_Hash_node<pair<const int, int>, false>> &&const is_void<_Hash_node<pair<const int, int>, false>>const is_void<_Hash_node<pair<const int, int>, false>> &is_void<_Hash_node<int, false>>is_void<_Hash_node<int, false>> &is_void<_Hash_node<int, false>> &&const is_void<_Hash_node<int, false>>const is_void<_Hash_node<int, false>> &remove_reference<pair<int, int> &>remove_reference<pair<int, int> &> &remove_reference<pair<int, int> &> &&const remove_reference<pair<int, int> &>const remove_reference<pair<int, int> &> &__is_nothrow_move_constructible_impl<const CService &, true>__is_nothrow_move_constructible_impl<const CService &, true> &__is_nothrow_move_constructible_impl<const CService &, true> &&const __is_nothrow_move_constructible_impl<const CService &, true>const __is_nothrow_move_constructible_impl<const CService &, true> &__is_nothrow_move_constructible_impl<const int &, true>__is_nothrow_move_constructible_impl<const int &, true> &__is_nothrow_move_constructible_impl<const int &, true> &&const __is_nothrow_move_constructible_impl<const int &, true>const __is_nothrow_move_constructible_impl<const int &, true> &remove_reference<const Network &>remove_reference<const Network &> &remove_reference<const Network &> &&const remove_reference<const Network &>const remove_reference<const Network &> &__is_nothrow_move_constructible_impl<const Network &, true>__is_nothrow_move_constructible_impl<const Network &, true> &__is_nothrow_move_constructible_impl<const Network &, true> &&const __is_nothrow_move_constructible_impl<const Network &, true>const __is_nothrow_move_constructible_impl<const Network &, true> &remove_reference<Network &&>remove_reference<Network &&> &remove_reference<Network &&> &&const remove_reference<Network &&>const remove_reference<Network &&> &__is_nothrow_move_constructible_impl<Network &&, true>__is_nothrow_move_constructible_impl<Network &&, true> &__is_nothrow_move_constructible_impl<Network &&, true> &&const __is_nothrow_move_constructible_impl<Network &&, true>const __is_nothrow_move_constructible_impl<Network &&, true> &__is_referenceable<Network &&>__is_referenceable<Network &&> &__is_referenceable<Network &&> &&const __is_referenceable<Network &&>const __is_referenceable<Network &&> &is_nothrow_constructible<Network &&, Network &&>is_nothrow_constructible<Network &&, Network &&> &is_nothrow_constructible<Network &&, Network &&> &&const is_nothrow_constructible<Network &&, Network &&>const is_nothrow_constructible<Network &&, Network &&> &__is_referenceable<const Network &>__is_referenceable<const Network &> &__is_referenceable<const Network &> &&const __is_referenceable<const Network &>const __is_referenceable<const Network &> &is_nothrow_constructible<const Network &, const Network &>is_nothrow_constructible<const Network &, const Network &> &is_nothrow_constructible<const Network &, const Network &> &&const is_nothrow_constructible<const Network &, const Network &>const is_nothrow_constructible<const Network &, const Network &> &tuple_element<0UL, tuple<const Network &>>tuple_element<0UL, tuple<const Network &>> &tuple_element<0UL, tuple<const Network &>> &&const tuple_element<0UL, tuple<const Network &>>const tuple_element<0UL, tuple<const Network &>> &__is_referenceable<const int &>__is_referenceable<const int &> &__is_referenceable<const int &> &&const __is_referenceable<const int &>const __is_referenceable<const int &> &is_nothrow_constructible<const int &, const int &>is_nothrow_constructible<const int &, const int &> &is_nothrow_constructible<const int &, const int &> &&const is_nothrow_constructible<const int &, const int &>const is_nothrow_constructible<const int &, const int &> &__is_referenceable<const CService &>__is_referenceable<const CService &> &__is_referenceable<const CService &> &&const __is_referenceable<const CService &>const __is_referenceable<const CService &> &is_nothrow_constructible<const CService &, const CService &>is_nothrow_constructible<const CService &, const CService &> &is_nothrow_constructible<const CService &, const CService &> &&const is_nothrow_constructible<const CService &, const CService &>const is_nothrow_constructible<const CService &, const CService &> &tuple_element<0UL, tuple<const CService &>>tuple_element<0UL, tuple<const CService &>> &tuple_element<0UL, tuple<const CService &>> &&const tuple_element<0UL, tuple<const CService &>>const tuple_element<0UL, tuple<const CService &>> &conditional<true, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>, is_assignable<direct_or_indirect &, direct_or_indirect &&>>conditional<true, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>, is_assignable<direct_or_indirect &, direct_or_indirect &&>> &conditional<true, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>, is_assignable<direct_or_indirect &, direct_or_indirect &&>> &&const conditional<true, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>, is_assignable<direct_or_indirect &, direct_or_indirect &&>>const conditional<true, __is_nt_assignable_impl<direct_or_indirect &, direct_or_indirect &&>, is_assignable<direct_or_indirect &, direct_or_indirect &&>> &remove_reference<pair<int, int>>remove_reference<pair<int, int>> &remove_reference<pair<int, int>> &&const remove_reference<pair<int, int>>const remove_reference<pair<int, int>> &/home/tanteikg/QCVE/sources/bitcoin/src/arith_uint256.hconst base_uint<256U>const base_uint<256U> &base_uint<256U> &operator^const base_uint<BITS>const base_uint<BITS> &base_uint<BITS> &uint32_t[]const uint32_t[]arith_uint256 &arith_uint256 &&arith_uint256 *base_uint<256U> *const arith_uint256const arith_uint256 &arith_uint256GetLow64const base_uint<BITS> *base_uint<BITS> *const uint32_t *Assertion WIDTH >= 2 failed (WIDTH = BITS / 32). BITS is a template parameter.carry 2operator~base_uintuint_error &uint_error &&const uint_errorconst uint_error &~uint_erroruint_error *uint_errorbase_uint<BITS>pnTemplate parameter BITS must be a positive multiple of 32.BITCOIN_ARITH_UINT256_HUintToArith256ArithToUint256GetCompactconst arith_uint256 *SetCompactEqualToCompareTooperator>>=operator<<=getdouble// BITCOIN_ARITH_UINT256_H/**
     * The "compact" format is a representation of a whole
     * number N using an unsigned 32bit number similar to a
     * floating point format.
     * The most significant 8 bits are the unsigned exponent of base 256.
     * This exponent can be thought of as "number of bytes of N".
     * The lower 23 bits are the mantissa.
     * Bit number 24 (0x800000) represents the sign of N.
     * N = (-1^sign) * mantissa * 256^(exponent-3)
     *
     * Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn().
     * MPI uses the most significant bit of the first byte as sign.
     * Thus 0x1234560000 is compact (0x05123456)
     * and  0xc0de000000 is compact (0x0600c0de)
     *
     * Bitcoin only uses this "compact" format for encoding difficulty
     * targets, which are unsigned 256bit quantities.  Thus, all the
     * complexities of the sign bit and using base 256 are probably an
     * implementation accident.
     *//** 256-bit unsigned big integer. *//**
     * Returns the position of the highest bit set plus one, or zero if the
     * value is zero.
     */// postfix operator// prefix operator/** Template base class for unsigned big integers. */shiftb64fNegativenCompactpfNegativepfOverflowb32/home/tanteikg/QCVE/sources/bitcoin/src/arith_uint256.cpp<arith_uint256.h>b.WIDTHuint32_t[8]unsigned int[8]a.WIDTHconst base_uint<256U> *bn0x00800000(nCompact & ~0x007fffffU) == 083886074286578688arith_uint256.cppunsigned int arith_uint256::GetCompact(bool) constnSize < 2560x007fffffnWord 310xffffffffulnum_bitsdiv_bitsDivision by zero"Division by zero"k 0.0fact4294967296.0// Thus, if it is already set, divide the mantissa by 256 and increase the exponent.// The 0x00800000 bit denotes the sign.// through an intermediate MPI representation.// This implementation directly uses shifts instead of going// Explicit instantiations for base_uint<256>// num now contains the remainder of the division.// shift back.// set a bit of the result.// shift so that div and num align.// the result is certainly 0.// the quotient.// make a copy, so we can subtract.// make a copy, so we can shift.WIDTH - 1this->WIDTH__negate__iter_comp_iter__iter_comp_val__pred_iter__iter_equals_val__val_comp_iter__iter_equal_to_val__iter_equal_to_iter__val_less_iter__iter_less_val__iter_less_iter_Iter_negate_Iterator2_Iter_comp_to_iter_Iterator1_Iter_comp_to_val_Iter_pred_Iter_equals_iter_Iter_equals_val_Val_comp_iter_Iter_comp_iter<_Compare> &&const _Iter_comp_iter<_Compare>const _Iter_comp_iter<_Compare> &_Iter_comp_iter<_Compare> &_Iter_comp_val_Iter_comp_iter_Iter_equal_to_val &_Iter_equal_to_val &&const _Iter_equal_to_valconst _Iter_equal_to_val &_Iter_equal_to_iter &_Iter_equal_to_iter &&const _Iter_equal_to_iterconst _Iter_equal_to_iter &_Val_less_iter &_Val_less_iter &&const _Val_less_iterconst _Val_less_iter &_Val_less_iter_Val_less_iter *_Iter_less_val &_Iter_less_val &&const _Iter_less_valconst _Iter_less_val &_Iter_less_val_Iter_less_val *_Iter_less_iter &_Iter_less_iter &&const _Iter_less_iterconst _Iter_less_iter &_Iter_negate<_Predicate>_Iter_comp_to_iter<_Compare, _Iterator1>_Iter_comp_to_val<_Compare, _Value>_Iter_pred<_Predicate>_Iter_equals_iter<_Iterator1>_Iter_equals_val<_Value>_Val_comp_iter<_Compare>_Iter_comp_val<_Compare>_Iter_comp_iter<_Compare>_Iter_equal_to_val_Iter_equal_to_iter_Iter_less_iter_M_it1_M_comp_GLIBCXX_PREDEFINED_OPS_H__ops__pred._M_pred__comp._M_comp// namespace __ops/** @file predefined_ops.h
 *  This is an internal header file, included by other library headers.
 *  You should not attempt to use it directly. @headername{algorithm}
 */// Default predicates for internal use -*- C++ -*-__it1__it2<bits/memoryfwd.h><bits/c++allocator.h>const allocator<_Hash_node_base *>const allocator<_Hash_node_base *> &const allocator<_Sp_counted_ptr_inplace<mutex, allocator<mutex>, _S_atomic>>const allocator<_Sp_counted_ptr_inplace<mutex, allocator<mutex>, _S_atomic>> &allocator<_Sp_counted_ptr_inplace<mutex, allocator<mutex>, _S_atomic>> &const allocator<mutex>const allocator<mutex> &allocator<mutex> &const allocator<LogCategory>const allocator<LogCategory> &const allocator<_List_node<function<..(..)>>>const allocator<_List_node<function<..(..)>>> &const allocator<function<..(..)>>const allocator<function<..(..)>> &const allocator<pair<const LogFlags, Level>>const allocator<pair<const LogFlags, Level>> &const allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>const allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>> &const allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>const allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> &allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> &const allocator<pair<const CSubNet, CBanEntry>>const allocator<pair<const CSubNet, CBanEntry>> &const allocator<unsigned long>const allocator<unsigned long> &allocator<unsigned long> &const allocator<unsigned char>const allocator<unsigned char> &allocator<unsigned char> &const allocator<pair<const int, int>>const allocator<pair<const int, int>> &allocator<pair<const int, int>> &const allocator<char32_t>const allocator<char32_t> &allocator<char32_t> &const allocator<char16_t>const allocator<char16_t> &allocator<char16_t> &const allocator<wchar_t>const allocator<wchar_t> &allocator<wchar_t> &const allocator<char>const allocator<char> &allocator<char> &const allocator<_T1>const allocator<_T1> &allocator<_T1> &const allocator<_T2>const allocator<_T2> &allocator<_T2> &const allocator<_Tp>const allocator<_Tp> &const allocator<_Up>const allocator<_Up> &allocator<_Up> &allocator<void> &allocator<void> &&const allocator<void>const allocator<void> &allocator<_Tp> *__shrink_to_fit_aux<_Tp, true>__shrink_to_fit_aux<_Tp, <unnamed>>__alloc_neq<_Alloc, false>__alloc_neq<_Alloc, <unnamed>>__alloc_swap<_Alloc, false>__alloc_swap<_Alloc, <unnamed>>allocator<const volatile _Tp>allocator<volatile _Tp>allocator<const _Tp>allocator<void>allocator<_Tp>__cpp_lib_allocator_is_always_equal__cpp_lib_incomplete_container_elements201505_ALLOCATOR_H_GLIBCXX_EXTERN_TEMPLATE// Optimize for stateless allocators.// Precondition: swappable allocators.// To implement Option 3 of DR 431.// Undefine.// which are defined via explicit instantiations elsewhere.// Inhibit implicit instantiations for required instantiations,/// @} group allocator// allocator_traits::rebind_alloc can be used to form a valid allocator type.// Invalid allocator<cv T> partial specializations.// Inherit everything else.// Avoid implicit deprecation.// 3035. std::allocator's constructors should be constexpr// 2103. std::allocator propagate_on_container_move_assignment/**
   * @brief  The @a standard allocator, as per [20.4].
   *
   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
   *  for further details.
   *
   *  @tparam  _Tp  Type of allocated object.
   *//// allocator<void> specialization./**
   *  @addtogroup allocators
   *  @{
   */// Define the base class to std::allocator./** @file bits/allocator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 *//*
 * Copyright (c) 1996-1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// Allocators -*- C++ -*-__alloc_on_swap__do_alloc_on_swap__pocma__alloc_on_move__do_alloc_on_move_Alloc2_S_select_Alloc2 &_S_destroy_S_construct_S_allocate__allocator_traits_base &__allocator_traits_base &&const __allocator_traits_baseconst __allocator_traits_base &_RequireNotAllocator_RequireAllocator__is_allocator<_Alloc, __void_t<value_type, decltype((<expression>))>>__is_allocator<_Alloc, <unnamed>>__is_move_insertable<allocator<_Tp>>__is_move_insertable<_Alloc>__is_copy_insertable<allocator<_Tp>>__is_copy_insertable<_Alloc>__is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, __void_t<decltype((<expression>))>>__is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, <unnamed>>allocator_traits<allocator<_Tp>>allocator_traits<_Alloc>__has_construct__construct_helper<_Tp, _Args...>_Size<_A2, _DiffT, __void_t<size_type>>_A2_DiffT_Size<_A2, _DiffT, <unnamed>>_Diff<_A2, _PtrT, __void_t<difference_type>>_PtrT_Diff<_A2, _PtrT, <unnamed>>_Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>_Ptr<_Func, _Tp, <unnamed>>__allocator_traits_base__equal__pocs__cv_pointer__v_pointer__c_pointer__rebind<_Tp, _Up, __void_t<other>>__rebind<_Tp, _Up, <unnamed>>__cpp_lib_allocator_traits_is_always_equal_ALLOC_TRAITS_H// _ALLOC_TRAITS_H// Trait to detect Allocator-like types.// std::allocator<_Tp> just requires MoveConstructible// i.e. actually trying to use it would still be invalid. Use with caution.)// (might be wrong if _Alloc::construct exists but is not constrained,// true if _Alloc::value_type is MoveInsertable into containers using _Alloc// std::allocator<_Tp> just requires CopyConstructible// true if _Alloc::value_type is CopyInsertable into containers using _Alloc/**
       *  @brief  Obtain an allocator to use when copying a container.
       *  @param  __rhs  An allocator.
       *  @return @c __rhs
      *//**
       *  @brief  The maximum supported allocation size
       *  @param  __a  An allocator.
       *  @return @c __a.max_size()
      *//**
       *  @brief  Destroy an object of type @a _Up
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the object to destroy
       *
       *  Calls @c __a.destroy(__p).
      *//**
       *  @brief  Construct an object of type @a _Up
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
       *  @param  __args Constructor arguments.
       *
       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
      *//**
       *  @brief  Deallocate memory.
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the memory to deallocate.
       *  @param  __n  The number of objects space was allocated for.
       *
       *  Calls <tt> a.deallocate(p, n) </tt>
      *//**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *  @param  __hint Aid to locality.
       *  @return Memory of suitable size and alignment for @a n objects
       *          of type @c value_type
       *
       *  Returns <tt> a.allocate(n, hint) </tt>
      *//**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *
       *  Calls @c a.allocate(n)
      *//// Whether all instances of the allocator type compare equal./// How the allocator is propagated on swap/// How the allocator is propagated on move assignment/// How the allocator is propagated on copy assignment/// The allocator's size type/// The allocator's difference type/// The allocator's const void pointer type./// The allocator's void pointer type./// The allocator's const pointer type./// The allocator's pointer type./// The allocated type/// The allocator type/// Partial specialization for std::allocator./**
       *  @brief  Obtain an allocator to use when copying a container.
       *  @param  __rhs  An allocator.
       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
       *
       *  Returns @c __rhs.select_on_container_copy_construction() if that
       *  expression is well-formed, otherwise returns @a __rhs
      *//**
       *  @brief  The maximum supported allocation size
       *  @param  __a  An allocator.
       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
       *
       *  Returns @c __a.max_size() if that expression is well-formed,
       *  otherwise returns @c numeric_limits<size_type>::max()
      *//**
       *  @brief  Destroy an object of type @a _Tp
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to the object to destroy
       *
       *  Calls @c __a.destroy(__p) if that expression is well-formed,
       *  otherwise calls @c __p->~_Tp()
      *//**
       *  @brief  Construct an object of type `_Tp`
       *  @param  __a  An allocator.
       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
       *  @param  __args Constructor arguments.
       *
       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
       *  if that expression is well-formed, otherwise uses placement-new
       *  to construct an object of type @a _Tp at location @a __p from the
       *  arguments @a __args...
      *//**
       *  @brief  Allocate memory.
       *  @param  __a  An allocator.
       *  @param  __n  The number of objects to allocate space for.
       *  @param  __hint Aid to locality.
       *  @return Memory of suitable size and alignment for @a n objects
       *          of type @c value_type
       *
       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is
       *  well-formed, otherwise returns @c a.allocate(n)
      */// 2466. allocator_traits::max_size() default behavior is incorrect/**
       * @brief   Whether all instances of the allocator type compare equal.
       *
       * @c Alloc::is_always_equal if that type exists,
       * otherwise @c is_empty<Alloc>::type
      *//**
       * @brief   How the allocator is propagated on swap
       *
       * @c Alloc::propagate_on_container_swap if that type exists,
       * otherwise @c false_type
      *//**
       * @brief   How the allocator is propagated on move assignment
       *
       * @c Alloc::propagate_on_container_move_assignment if that type exists,
       * otherwise @c false_type
      *//**
       * @brief   How the allocator is propagated on copy assignment
       *
       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
       * otherwise @c false_type
      *//**
       * @brief   The allocator's size type
       *
       * @c Alloc::size_type if that type exists, otherwise
       * <tt> make_unsigned<difference_type>::type </tt>
      *//**
       * @brief   The allocator's difference type
       *
       * @c Alloc::difference_type if that type exists, otherwise
       * <tt> pointer_traits<pointer>::difference_type </tt>
      *//**
       * @brief   The allocator's const void pointer type.
       *
       * @c Alloc::const_void_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
      *//**
       * @brief   The allocator's void pointer type.
       *
       * @c Alloc::void_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<void> </tt>
      *//**
       * @brief   The allocator's const pointer type.
       *
       * @c Alloc::const_pointer if that type exists, otherwise
       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
      */// Select _A2::size_type or make_unsigned<_DiffT>::type// Select _A2::difference_type or pointer_traits<_Ptr>::difference_type// Select _Func<_Alloc> or pointer_traits<pointer>::rebind<_Tp>/**
       * @brief   The allocator's pointer type.
       *
       * @c Alloc::pointer if that type exists, otherwise @c value_type*
      *//**
   * @brief  Uniform interface to all allocator types.
   * @ingroup allocators
  *//** @file bits/alloc_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Copyright (C) 2011-2019 Free Software Foundation, Inc.// Allocator traits -*- C++ -*-<bits/alloc_traits.h>_S_propagate_on_swap__alloc_traits<_Alloc, <unnamed>>_EXT_ALLOC_TRAITS_H// 431. Swapping containers with unequal allocators.// overload destroy for non-standard pointer types// overload construct for non-standard pointer types// C++11 allocators do not define reference or const_reference/**
 * @brief  Uniform interface to C++98 and C++11 allocators.
 * @ingroup allocators
*/// for __alloc_swap/** @file ext/alloc_traits.h
 *  This file is a GNU extension to the Standard C++ Library.
 */const initializer_list<_E>const initializer_list<_E> *initializer_list<_E> *initializer_list<_E>_Econst _Econst _E *_E *const _E &_E &_INITIALIZER_LIST// _INITIALIZER_LIST/**
   *  @brief  Return an iterator pointing to one past the last element
   *          of the initializer_list.
   *  @param  __ils  Initializer list.
   *//**
   *  @brief  Return an iterator pointing to the first element of
   *          the initializer_list.
   *  @param  __ils  Initializer list.
   */// One past the last element.// First element.// Number of elements.// The compiler can call a private constructor./// initializer_list// C++0x/** @file initializer_list
 *  This is a Standard C++ Library header.
 */// GCC is distributed in the hope that it will be useful,// the Free Software Foundation; either version 3, or (at your option)// it under the terms of the GNU General Public License as published by// GCC is free software; you can redistribute it and/or modify// This file is part of GCC.// std::initializer_list support -*- C++ -*-__ils__xu__yu__top_Reuse_or_alloc_node *relocation is only possible for values of the same typeuninitialized_move_nuninitialized_moveuninitialized_value_construct_nuninitialized_value_constructuninitialized_default_construct_nuninitialized_default_construct__uninitialized_copy_n_pairuninitialized_copy_n__uninitialized_copy_n__uninitialized_default_novalue_n__uninitialized_default_novalue__uninitialized_default_n_a__uninitialized_default_a__uninitialized_default_n__uninitialized_default__uninitialized_move_fill__uninitialized_fill_move__uninitialized_move_copy__uninitialized_copy_move__uninitialized_fill_n_aallocator<_Tp2> &__uninitialized_fill_a__uninitialized_move_auninitialized_fill_nuninitialized_fill__uninitialized_default_novalue_n_1<true> &__uninitialized_default_novalue_n_1<true> &&const __uninitialized_default_novalue_n_1<true>const __uninitialized_default_novalue_n_1<true> &__uninit_default_novalue_n__uninitialized_default_novalue_1<true> &__uninitialized_default_novalue_1<true> &&const __uninitialized_default_novalue_1<true>const __uninitialized_default_novalue_1<true> &__uninit_default_novalue__uninitialized_default_n_1<true> &__uninitialized_default_n_1<true> &&const __uninitialized_default_n_1<true>const __uninitialized_default_n_1<true> &__uninit_default_n__uninitialized_default_1<true> &__uninitialized_default_1<true> &&const __uninitialized_default_1<true>const __uninitialized_default_1<true> &__uninit_default__uninitialized_fill_n<true> &__uninitialized_fill_n<true> &&const __uninitialized_fill_n<true>const __uninitialized_fill_n<true> &__uninit_fill_n__uninitialized_fill<true> &__uninitialized_fill<true> &&const __uninitialized_fill<true>const __uninitialized_fill<true> &__uninit_fill__uninitialized_copy<true> &__uninitialized_copy<true> &&const __uninitialized_copy<true>const __uninitialized_copy<true> &__is_bitwise_relocatable<_Tp, <unnamed>>__uninitialized_default_novalue_n_1<true>__uninitialized_default_novalue_n_1<_TrivialValueType>_TrivialValueType__uninitialized_default_novalue_1<true>__uninitialized_default_novalue_1<_TrivialValueType>__uninitialized_default_n_1<true>__uninitialized_default_n_1<_TrivialValueType>__uninitialized_default_1<true>__uninitialized_default_1<_TrivialValueType>__uninitialized_fill_n<true>__uninitialized_fill_n<_TrivialValueType>__uninitialized_fill<true>__uninitialized_fill<_TrivialValueType>__uninitialized_copy<true>__uninitialized_copy<_TrivialValueTypes>_TrivialValueTypes__cpp_lib_raw_memory_algorithms_STL_UNINITIALIZED_H/* _STL_UNINITIALIZED_H */// Also known as is_trivially_relocatable.// This class may be specialized for specific types./**
   *  @brief Copies the range [first,first+n) into result.
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  __result + __n
   *
   *  Like copy_n(), but does not require an initialized output range.
  */// Fills [first, first + n) with n default-initialized value_type(s).// __uninitialized_default_n// value_types(s).// Fills [first, last) with std::distance(first, last) default-initialized// __uninitialized_default_novalue// constructed with the allocator alloc.// Fills [first, first + n) with n default constructed value_types(s),// __uninitialized_default_n_a// constructed value_types(s), constructed with the allocator alloc.// Fills [first, last) with std::distance(first, last) default// __uninitialized_default_a// Fills [first, first + n) with n default constructed value_type(s).// constructed value_types(s).// __uninitialized_default// __uninitialized_default_a, __uninitialized_default_n_a.// Extensions: __uninitialized_default, __uninitialized_default_n,//  fills [first2 + (last1 - first1), last2) with x.// Moves [first1, last1) into [first2, first2 + (last1 - first1)), and// __uninitialized_move_fill//  [mid, mid + (last - first)).// Fills [result, mid) with x, and moves [first, last) into// __uninitialized_fill_move//  [result, result + (last1 - first1) + (last2 - first2)).//  copies [first2, last2) into// Moves [first1, last1) into [result, result + (last1 - first1)), and// __uninitialized_move_copy//  move [first2, last2) into// Copies [first1, last1) into [result, result + (last1 - first1)), and// __uninitialized_copy_move// for construction and destruction.// All of these algorithms take a user-supplied allocator, which is used// __uninitialized_fill_move, __uninitialized_move_fill.// Extensions: __uninitialized_copy_move, __uninitialized_move_copy,//  any of the POD optimizations.//  default allocator.  For nondefault allocators we do not use //  We dispatch back to the standard versions when we're given the//  and uninitialized_fill_n that take an allocator parameter.// Extensions: versions of uninitialized_copy, uninitialized_fill,// would be ill-formed. Require assignability before using std::fill:// Trivial types can have deleted assignment, so using std::fill// optimization that uses memmove would happily "copy" them anyway.// Trivial types can have deleted copy constructor, but the std::fill/**
   *  @brief Copies the value x into the range [first,first+n).
   *  @param  __first  An input iterator.
   *  @param  __n      The number of copies to make.
   *  @param  __x      The source value.
   *  @return   Nothing.
   *
   *  Like fill_n(), but does not require an initialized output range.
  */// DR 1339. uninitialized_fill_n should return the end of its range/**
   *  @brief Copies the value x into the range [first,last).
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __x      The source value.
   *  @return   Nothing.
   *
   *  Like fill(), but does not require an initialized output range.
  */// would be ill-formed. Require assignability before using std::copy:// Trivial types can have deleted assignment, so using std::copy// Trivial types can have deleted copy constructor, but the std::copy/**
   *  @brief Copies the range [first,last) into result.
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   __result + (__first - __last)
   *
   *  Like copy(), but does not require an initialized output range.
  *//** @file bits/stl_uninitialized.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// Raw memory manipulators -*- C++ -*-<bits/stl_vector.h>_Bit_type *__first_p_S_word_bit~0sizeof(_Bit_type)__fill_bvectorconst _Bit_type__fmask0ul~0ul__lmask__maskconst _Bit_const_iteratorconst _Bit_const_iterator &_Bit_const_iterator &const _Bit_iteratorconst _Bit_iterator &_Bit_iterator &const _Bit_iterator_baseconst _Bit_iterator_base &_Bit_iterator_base &int(_S_word_bit)const _Bit_reference_Bit_reference &const _Bit_reference &_M_initialize_range_M_initialize_value_M_initialize_M_copy_alignedflipvector<bool, _Alloc> &&_S_nword_Bvector_base<_Alloc> &&~_Bvector_base_Bvector_baseconst _Bit_alloc_typeconst _Bit_alloc_type &_M_get_Bit_allocator_Bit_alloc_type &_M_end_addr_Bvector_impl_Bvector_impl &&is_nothrow_default_constructible<_Bit_alloc_type>::value_Bvector_impl_data &&_Bvector_impl_data_Bit_const_iterator &&_Bit_const_iterator_Bit_const_iterator *const _Bit_const_iterator *_Bit_iterator_base *const _Bit_iterator_base *1UL_Bit_iterator &&_Bit_iterator_Bit_iterator *const _Bit_iterator *_Bit_iterator_base &&_Bit_iterator_base_M_bump_downint(_S_word_bit) - 1_M_bump_up_Bit_reference *const _Bit_reference *_Bit_referencehash<vector<bool, _Alloc>>vector<bool, _Alloc>const bool *_Bit_alloc_traits_Bit_pointer_Bvector_base<_Alloc>_Bit_alloc_typeint(__CHAR_BIT__ * sizeof(_Bit_type))_Bit_type_M_offset_M_mask_STL_BVECTOR_H"vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"/// std::hash specialization for vector<bool>.// Precondition: __first._M_offset == 0 && __result._M_offset == 0.// [23.2.5]/1, third-to-last entry in synopsis listing// vector class.// here due to the way we are implementing DR 464 in the debug-mode// N.B. DR 464 says nothing about vector<bool> but we need something// or not the type is an integer.// The range version is a member template, so we dispatch on whether// versions: one that takes a count, and one that takes a range.// assign(), a generalized assignment member function.  Two/**
   *  @brief  A specialization of vector for booleans which offers fixed time
   *  access to individual elements in any order.
   *
   *  @ingroup sequences
   *
   *  @tparam _Alloc  Allocator type.
   *
   *  Note that vector<bool> does not actually meet the requirements for being
   *  a container.  This is because the reference and pointer types are not
   *  really references and pointers to bool.  See DR96 for details.  @see
   *  vector for function documentation.
   *
   *  In some terminology a %vector can be described as a dynamic
   *  C-style array, it offers fast and efficient access to individual
   *  elements in any order and saves the user from worrying about
   *  memory and size allocation.  Subscripting ( @c [] ) access is
   *  also provided as with C-style arrays.
  */// Declare a partial specialization of vector<T, Alloc>./** @file bits/stl_bvector.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1999
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// vector<bool> specialization -*- C++ -*-lambda [] type at line 80164, col. 9lambda [] type at line 80164, col. 9 &const lambda [] type at line 80164, col. 9const lambda [] type at line 80164, col. 9 &const lambda [] type at line 80164, col. 9 *lambda [] type at line 80164, col. 9 *lambda [] type at line 80110, col. 8lambda [] type at line 80110, col. 8 &const lambda [] type at line 80110, col. 8const lambda [] type at line 80110, col. 8 &const lambda [] type at line 80110, col. 8 *lambda [] type at line 80110, col. 8 *lambda [] type at line 80127, col. 2lambda [] type at line 80127, col. 2 &const lambda [] type at line 80127, col. 2const lambda [] type at line 80127, col. 2 &const lambda [] type at line 80127, col. 2 *lambda [] type at line 80127, col. 2 *lambda [] type at line 80322, col. 3lambda [] type at line 80322, col. 3 &const lambda [] type at line 80322, col. 3const lambda [] type at line 80322, col. 3 &const lambda [] type at line 80322, col. 3 *lambda [] type at line 80322, col. 3 *<bits/error_constants.h>const error_categoryconst error_category &error_category &generic_categorysystem_categoryconst error_conditionconst error_condition &error_condition &const error_codeconst error_code &error_code &make_error_conditionmake_error_codehash<error_condition> &hash<error_condition> &&const hash<error_condition>const hash<error_condition> &const hash<error_condition> *hash<error_condition> *hash<error_code> &hash<error_code> &&const hash<error_code>const hash<error_code> &const hash<error_code> *hash<error_code> *const error_category *error_category *const error_category *constconst error_category *const &error_category *&is_error_condition_enumis_error_condition_enum<errc> &is_error_condition_enum<errc> &&const is_error_condition_enum<errc>const is_error_condition_enum<errc> &codeconst system_errorconst system_error *system_error *~system_errorsystem_error &const system_error &system_error: ": "error_code &&error_codeconst error_code *error_code *default_error_condition_ErrorCodeEnum_M_value(0)const less<const error_category *>equivalenterror_condition &&error_conditionconst error_condition *error_condition *_ErrorConditionEnum_M_messageerror_category~error_categoryhash<error_condition>hash<error_code>is_error_condition_enum<errc>is_error_condition_enum<_Tp>is_error_code_enum<_Tp>is_error_condition_enum_vis_error_code_enum_v_M_code_M_cat_GLIBCXX_SYSTEM_ERROR// _GLIBCXX_SYSTEM_ERROR/// std::hash specialization for error_condition.// DR 2686.// _GLIBCXX_COMPATIBILITY_CXX0X/// std::hash specialization for error_code./**
   *  @brief Thrown to indicate error code of underlying system.
   *
   *  @ingroup exceptions
   */// 19.4.4 Comparison operators// 19.4.3.6 non-member functions// DR 804.// 19.4.3.4 observers// Portable error identification/// error_condition// 19.4.2.6 non-member functions// Implementation-specific error identification/// error_code// end inline namespace// DR 890.// the name "message()" finds depends on which ABI the caller is using.// vtable must be consistent for dynamic dispatch to work, but which one// COW string and one returning an SSO string. Their positions in the// We need two different virtual functions here, one returning a/// error_category/// is_error_condition_enum/// is_error_code_enum/** @file include/system_error
 *  This is a Standard C++ Library header.
 */// <system_error> -*- C++ -*-__ecat__what__cat/home/tanteikg/QCVE/sources/bitcoin/src/common/bloom.hCRollingBloomFilter &CRollingBloomFilter &&const CRollingBloomFilterconst CRollingBloomFilter &~CRollingBloomFilterCRollingBloomFilter *CRollingBloomFiltercontainsCBloomFilter &CBloomFilter &&const CBloomFilterconst CBloomFilter &~CBloomFilterCBloomFilterIsRelevantAndUpdateIsWithinSizeConstraintsCBloomFilter *bloomflagsBLOOM_UPDATE_NONEBLOOM_UPDATE_ALLBLOOM_UPDATE_P2PUBKEY_ONLYBLOOM_UPDATE_MASKnHashFuncsnTweaknGenerationnEntriesThisGenerationnEntriesPerGenerationnFlagsvDataMAX_HASH_FUNCSMAX_BLOOM_FILTER_SIZE36000BITCOIN_COMMON_BLOOM_Hobj.vData, obj.nHashFuncs, obj.nTweak, obj.nFlags// BITCOIN_COMMON_BLOOM_H/**
 * RollingBloomFilter is a probabilistic "keep track of most recently inserted" set.
 * Construct it with the number of items to keep track of, and a false-positive
 * rate. Unlike CBloomFilter, by default nTweak is set to a cryptographically
 * secure random value for you. Similarly rather than clear() the method
 * reset() is provided, which also changes nTweak to decrease the impact of
 * false-positives.
 *
 * contains(item) will always return true if item was one of the last N to 1.5*N
 * insert()'ed ... but may also return true for items that were not inserted.
 *
 * It needs around 1.8 bytes per element per factor 0.1 of false positive rate.
 * For example, if we want 1000 elements, we'd need:
 * - ~1800 bytes for a false positive rate of 0.1
 * - ~3600 bytes for a false positive rate of 0.01
 * - ~5400 bytes for a false positive rate of 0.001
 *
 * If we make these simplifying assumptions:
 * - logFpRate / log(0.5) doesn't get rounded or clamped in the nHashFuncs calculation
 * - nElements is even, so that nEntriesPerGeneration == nElements / 2
 *
 * Then we get a more accurate estimate for filter bytes:
 *
 *     3/(log(256)*log(2)) * log(1/fpRate) * nElements
 *///! Also adds any outputs which match the filter to the filter (to match their spending txes)//! (catch a filter which was just deserialized which was too big)//! True if the size is <= MAX_BLOOM_FILTER_SIZE and the number of hash functions is <= MAX_HASH_FUNCS/**
     * Creates a new bloom filter which will provide the given fp rate when filled with the given number of elements
     * Note that if the given parameters will result in a filter outside the bounds of the protocol limits,
     * the filter created will be as close to the given parameters as possible within the protocol limits.
     * This will apply if nFPRate is very low or nElements is unreasonably high.
     * nTweak is a constant which is added to the seed value passed to the hash function
     * It should generally always be a random value (and is largely only exposed for unit testing)
     * nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)
     *//**
 * BloomFilter is a probabilistic filter which SPV clients provide
 * so that we can filter the transactions we send them.
 *
 * This allows for significantly more efficient transaction and block downloads.
 *
 * Because bloom filters are probabilistic, a SPV node can increase the false-
 * positive rate, making us send it transactions which aren't actually its,
 * allowing clients to trade more bandwidth for more privacy by obfuscating which
 * keys are controlled by them.
 */// Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script/**
 * First two bits of nFlags control how much IsRelevantAndUpdate actually updates
 * The remaining bits are reserved
 */// bytes//! 20,000 items with fp rate < 0.1% or 10,000 items and <0.0001%// Copyright (c) 2012-2021 The Bitcoin Core developersvKeynElementsnFPRateoutpointnFlagsInnHashNumlambda [] type at line 127016, col. 30lambda [] type at line 127016, col. 30 &&lambda [] type at line 127016, col. 30 &const lambda [] type at line 127016, col. 30const lambda [] type at line 127016, col. 30 &const lambda [] type at line 127016, col. 30 *lambda [] type at line 127016, col. 30 */home/tanteikg/QCVE/sources/bitcoin/src/banman.h<common/bloom.h>BanMan &const BanManconst BanMan &BanManm_discouraged500009.999999999999999547e-070.000001m_default_ban_timem_ban_dbCClientUIInterface *m_client_interfacem_is_dirtym_bannedm_cs_bannedDUMP_BANS_INTERVALDEFAULT_MISBEHAVING_BANTIME60 * 608640060 * 60 * 24BITCOIN_BANMAN_HSweepBannedBanMan *SetBannedSetDirtyBannedSetIsDirtyLoadBanlistDumpBanlistGetBannedUnbanIsDiscouragedIsBannedClearBannedDiscourageBan~BanManCClientUIInterface!m_cs_banned// BITCOIN_BANMAN_H//!clean unused entries (if bantime has expired)//!set the "dirty" flag for the banlist//! Return whether net_addr is discouraged.//! Return whether sub_net is exactly banned//! Return whether net_addr is banned// cause the network to split between old nodes and new nodes.// policy check so the transaction is accepted, then that transaction could// transaction that fails a policy check and a future version changes the// risk of splitting the network. For example, if we banned/disconnected for a// Attempting to automatically disconnect or ban any class of peer carries the// reconnect from another IP address.// disconnect from them and ban that address, it's trivial for them to// attacks, since if an attacker has a way to waste our resources and we// Neither banning nor discouragement are protections against denial-of-service// or broken peers.// can prevent our limited connection slots being used up by incompatible// list all discouraged addresses or unmark them as discouraged. Discouragement// a bloom filter. We can (probabilistically) test for membership, but can't// them, and do not gossip their address to other peers. This is implemented as// we receive new incoming connections. We never make outgoing connections to// incoming connections from them, but they're preferred for eviction when// net_processing.cpp), we'll mark that address as discouraged. We still allow// 2. Discouragement. If a peer misbehaves enough (see Misbehaving() in// prevent connections with spy nodes or other griefers.// disk on shutdown and reloaded on startup. Banning can be used to// to other peers in addr messages. Banned addresses and subnets are stored to// it and never create outgoing connections to it. We won't gossip its address// If an address or subnet is banned, we never accept incoming connections from// 1. Banning. This is configured manually by the user, through the setban RPC.// Banman manages two related but distinct concepts:/// How often to dump banned addresses/subnets to disk.// Default 24-hour ban// NOTE: When adjusting this, update rpcnet:setban's help ("24h")dirtybanmapsub_netnet_addrban_time_offsetsince_unix_epochban_fileclient_interfacedefault_ban_timeCSubNet */home/tanteikg/QCVE/sources/bitcoin/src/node/interface_ui.hInitErrorInitWarningCClientUIInterface &CClientUIInterface &&const CClientUIInterfaceconst CClientUIInterface &BannedListChanged_connectBannedListChangedNotifyHeaderTip_connectNotifyHeaderTipNotifyBlockTip_connectNotifyBlockTipconst CBlockIndexconst CBlockIndex *CBlockIndex *ShowProgress_connectShowProgressNotifyAlertChanged_connectNotifyAlertChangedNotifyNetworkActiveChanged_connectNotifyNetworkActiveChangedNotifyNumConnectionsChanged_connectNotifyNumConnectionsChangedInitWallet_connectInitWalletInitMessage_connectInitMessageThreadSafeQuestion_connectThreadSafeQuestionThreadSafeMessageBox_connectThreadSafeMessageBoxconnectionBannedListChangedSigNotifyHeaderTipSigSynchronizationState, int64_t height, int64_t timestamp, bool presyncNotifyBlockTipSigSynchronizationState, const CBlockIndex*ShowProgressSigconst std::string& title, int nProgress, bool resume_possibleNotifyAlertChangedSigNotifyNetworkActiveChangedSigbool networkActiveNotifyNumConnectionsChangedSigint newNumConnectionsInitWalletSigInitMessageSigconst std::string& messageThreadSafeQuestionSigconst bilingual_str& message, const std::string& noninteractive_message, const std::string& caption, unsigned int styleThreadSafeMessageBoxSigconst bilingual_str& message, const std::string& caption, unsigned int styleMessageBoxFlagsICON_INFORMATIONICON_WARNINGICON_ERRORICON_MASKICON_INFORMATION | ICON_WARNINGICON_INFORMATION | ICON_WARNING | ICON_ERROR(ICON_INFORMATION | ICON_WARNING | ICON_ERROR)BTN_OK0x00000400UBTN_YES0x00004000UBTN_NO0x00010000UBTN_ABORT0x00040000UBTN_RETRY0x00080000UBTN_IGNORE0x00100000UBTN_CLOSE0x00200000UBTN_CANCEL0x00400000UBTN_DISCARD0x00800000UBTN_HELP167772160x01000000UBTN_APPLY0x02000000UBTN_RESET0x04000000UBTN_MASK17408BTN_OK | BTN_YES82944BTN_OK | BTN_YES | BTN_NO345088BTN_OK | BTN_YES | BTN_NO | BTN_ABORT869376BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY1917952BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE4015104BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE |
                    BTN_CLOSE8209408BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE |
                    BTN_CLOSE | BTN_CANCEL16598016BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE |
                    BTN_CLOSE | BTN_CANCEL | BTN_DISCARD33375232BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE |
                    BTN_CLOSE | BTN_CANCEL | BTN_DISCARD | BTN_HELP66929664BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE |
                    BTN_CLOSE | BTN_CANCEL | BTN_DISCARD | BTN_HELP | BTN_APPLY134038528BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE |
                    BTN_CLOSE | BTN_CANCEL | BTN_DISCARD | BTN_HELP | BTN_APPLY | BTN_RESET(BTN_OK | BTN_YES | BTN_NO | BTN_ABORT | BTN_RETRY | BTN_IGNORE |
                    BTN_CLOSE | BTN_CANCEL | BTN_DISCARD | BTN_HELP | BTN_APPLY | BTN_RESET)MODAL0x10000000USECURE0x40000000UMSG_INFORMATIONMSG_WARNING1025ICON_WARNING | BTN_OK268436481ICON_WARNING | BTN_OK | MODAL(ICON_WARNING | BTN_OK | MODAL)MSG_ERROR1026ICON_ERROR | BTN_OK268436482ICON_ERROR | BTN_OK | MODAL(ICON_ERROR | BTN_OK | MODAL)CBlockIndexSynchronizationStateuiInterfaceADD_SIGNALS_DECL_WRAPPER(signal_name,rtype,__VA_ARGS__...)rtype signal_name(__VA_ARGS__); using signal_name ## Sig = rtype(__VA_ARGS__); boost::signals2::connection signal_name ## _connect(std::function<signal_name ## Sig> fn);BITCOIN_NODE_INTERFACE_UI_Hboostsignals2// BITCOIN_NODE_INTERFACE_UI_H/** Show error message **//** Show warning message **//** Banlist did change. *//** Best header has changed *//** New block has been accepted *//**
     * Show progress e.g. for verifychain.
     * resume_possible indicates shutting down now will result in the current progress action resuming upon restart.
     *//**
     * Status bar alerts changed.
     *//** Network activity state changed. *//** Number of network connections changed. *//** Wallet loader created. *//** Progress message during initialization. *//** If possible, ask the user a question. If not, falls back to ThreadSafeMessageBox(noninteractive_message, caption, style) and returns false. *//** Show message box. *//** Predefined combinations for certain default usage cases *//** Do not print contents of message to debug log *//** Force blocking, modal message box dialog (not just OS notification) *//**
         * Mask of all available buttons in CClientUIInterface::MessageBoxFlags
         * This needs to be updated, when buttons are changed there!
         */// QMessageBox::Reset// QMessageBox::Apply// QMessageBox::Help// QMessageBox::Discard// QMessageBox::Cancel// QMessageBox::Close// QMessageBox::Ignore// QMessageBox::Retry// QMessageBox::Abort// QMessageBox::No// QMessageBox::Yes// QMessageBox::Ok/** These values are taken from qmessagebox.h "enum StandardButton" to be directly usable *//**
         * Mask of all available icons in CClientUIInterface::MessageBoxFlags
         * This needs to be updated, when icons are changed there!
         *//** Flags for CClientUIInterface::ThreadSafeMessageBox *//** Signals for UI communication. */// namespace boost// Copyright (c) 2010 Satoshi Nakamoto/home/tanteikg/QCVE/sources/bitcoin/src/nodedetailsheighttimestamppresynctitlenProgressresume_possiblenetworkActivenewNumConnectionsnoninteractive_messagecaptionstyle/usr/include/c++/9/any_Never_valueless_alt_Never_valueless_alt<any> &_Never_valueless_alt<any> &&const _Never_valueless_alt<any>const _Never_valueless_alt<any> &_ValueType *any_castany *const _ValueTypeconst _ValueType *const anyconst any *any &&any &const any &make_any__any_caster__throw_bad_any_castbad_any_castbad_any_cast *bad_any_cast &bad_any_cast &&const bad_any_castconst bad_any_cast &~bad_any_castconst bad_any_cast *bad any_cast"bad any_cast"__is_valid_cast_Arg *_Op_get_type_info_Op_xfer__empty__full_Op_destroy_ValueType &&~anyany_Mgr_Op_clone__do_emplace_S_create_Storage &_S_manage_Arg &const _Argconst _Arg &const _Storageconst _Storage &_Storage *_Never_valueless_alt<any>_Op_Op_access__any_constructible_t_Decay_Manager_Manager_external<_Tp>_Manager_internal<_Tp>_Safe_Decayed_M_any_M_typeinfo_M_obj_M_buffer__cpp_lib_any_GLIBCXX_ANY// _GLIBCXX_ANY// any into a variant.// Provide the strong exception-safety guarantee when emplacing an// The contained object is *_M_storage._M_ptr// The contained object is in _M_storage._M_buffer/**
   * @brief Access the contained object.
   *
   * @tparam  _ValueType  The type of the contained object.
   * @param   __any       A pointer to the object to access.
   * @return  The address of the contained object if <code>
   *          __any != nullptr && __any.type() == typeid(_ValueType)
   *          </code>, otherwise a null pointer.
   *
   * @{
   *//// @endcond// First try comparing function addresses, which works without RTTI// Only copy constructible types can be used for contained values:// then it's not possible to have a contained value of type U:// The contained value has a decayed type, so if decay_t<U> is not U,// typeid(T) ignores cv-qualifiers so remove them:// any_cast<T> returns non-null if __any->type() == typeid(T) and/// @cond undocumented/**
   * @brief Access the contained object.
   *
   * @tparam  _ValueType  A reference or CopyConstructible type.
   * @param   __any       The object to access.
   * @return  The contained object.
   * @throw   bad_any_cast If <code>
   *          __any.type() != typeid(remove_reference_t<_ValueType>)
   *          </code>
   *
   * @{
   *//**
   * @brief Access the contained object.
   *
   * @tparam  _ValueType  A const-reference or CopyConstructible type.
   * @param   __any       The object to access.
   * @return  The contained object.
   * @throw   bad_any_cast If <code>
   *          __any.type() != typeid(remove_reference_t<_ValueType>)
   *          </code>
   *//// Create an any holding a @c _Tp constructed from @c __il and @c __args./// Create an any holding a @c _Tp constructed from @c __args./// Exchange the states of two @c any objects.// Manage external contained object.// Manage in-place contained object./// The @c typeid of the contained object, or @c typeid(void) if empty./// Reports whether there is a contained object or not./// Exchange state with another object./// If not empty, destroy the contained object./// the contained object./// Emplace with an object created from @p __il and @p __args as/// Emplace with an object created from @p __args as the contained object./// Store a copy of @p __rhs as the contained object./**
     * @brief Move assignment operator
     *
     * @post @c !__rhs.has_value() (not guaranteed for other implementations)
     *//// Copy the state of another object.// assignments/// Destructor, calls @c reset()/// Construct with an object created from @p __il and @p __args as/// Construct with an object created from @p __args as the contained object./// Construct with a copy of @p __value as the contained object./**
     * @brief Move constructor, transfer the state from @p __other
     *
     * @post @c !__other.has_value() (this postcondition is a GNU extension)
     *//// Copy constructor, copies the state of @p __other/// Default constructor, creates an empty object.// construct/destruct// creates contained object on the heap// uses small-object optimization// Prevent trivial copies of this type, buffer might hold a non-POD.// Holds either pointer to a heap object or the contained object itself./**
   *  @brief A type-safe container of any type.
   *
   *  An @c any object's state is either empty or it stores a contained object
   *  of CopyConstructible type.
   *//**
   *  @brief Exception class thrown by a failed @c any_cast
   *  @ingroup exceptions
   *//** @file include/any
 *  This is a Standard C++ Library header.
 */// Copyright (C) 2014-2019 Free Software Foundation, Inc.// <any> -*- C++ -*-__which__any__storage__anyp/home/tanteikg/QCVE/sources/bitcoin/src/util/system.h<any><compat/assumptions.h>AnyPtrset<TsetT, less<TsetT>, allocator<TsetT>> &Tsrcconst Tsrcconst Tsrc &Tsrc &TsetTTdstTdst &ScheduleBatchPriorityGetNumCoresrunCommandShellEscapeSetupNetworkingSetupEnvironmentGetStartupTimeBITCOIN_UTIL_SYSTEM_HHAVE_SYSTEM// BITCOIN_UTIL_SYSTEM_H/**
 * Helper function to access the contained object of a std::any instance.
 * Returns a pointer to the object if passed instance has a value and the type
 * matches, nullptr otherwise.
 *///! Simplification of std insertion/**
 * On platforms that support it, tell the kernel the calling thread is
 * CPU-intensive and non-interactive. See SCHED_BATCH in sched(7) for details.
 *
 *//**
 * Return the number of cores available on the current system.
 * @note This does count virtual cores, such as those provided by HyperThreading.
 */// Application startup time (used for uptime calculation)strCommand/home/tanteikg/QCVE/sources/bitcoin/src/compat/assumptions.h/home/tanteikg/QCVE/sources/bitcoin/src/banman.cpp<util/system.h><node/interface_ui.h><banman.h>banman.cppnotify_uiBCLog::NET"Removed banned node address/subnet: %s\n", sub_net.ToString()ban_entryRemoved banned node address/subnet: %s
Loading banlist"Loading banlist"Loaded %d banned node addresses/subnets  %dms\n", m_banned.size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start)"Recreating the banlist database\n"Loaded %d banned node addresses/subnets  %dms
Recreating the banlist database
dump_mutexcriticalblock2const map<CSubNet, CBanEntry, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> &"Flushed %d banned node addresses/subnets to disk  %dms\n", banmap.size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start)Flushed %d banned node addresses/subnets to disk  %dms
normalized_ban_time_offsetnormalized_since_unix_epochpath &&//reuse m_banned lock for the m_is_dirty flag// update UI//create a thread safe copy// Sweep the banlist so expired bans are not returned//store banlist to disk immediately//store banlist to disk// sweep out unused entriesinitializer_list<pair<const CSubNet, CBanEntry>>initializer_list<pair<const CSubNet, CBanEntry>> &initializer_list<pair<const CSubNet, CBanEntry>> &&const initializer_list<pair<const CSubNet, CBanEntry>>const initializer_list<pair<const CSubNet, CBanEntry>> &time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>optional<unsigned long>Span<unsigned char>Span<byte>vector<CAddress, allocator<CAddress>>allocator_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>>allocator_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>>const allocator_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>> &NodeSecondstuple<const CSubNet &> &&tuple<const CSubNet &> &_Rep_type *_Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> *const _Rep_typeconst _Rep_type &initializer_list<pair<const CSubNet, CBanEntry>> *_Rb_tree_iterator<pair<const CSubNet, CBanEntry>> *const _Rb_tree_iterator<pair<const CSubNet, CBanEntry>> *vector<unsigned long, allocator<unsigned long>> *_Vector_base<unsigned long, allocator<unsigned long>> *signed long &&tuple<const CSubNet &>const tuple<const CSubNet &>const tuple<const CSubNet &> &_Rb_tree_node<pair<const CSubNet, CBanEntry>> &&_Select1st<pair<const CSubNet, CBanEntry>> &_Select1st<pair<const CSubNet, CBanEntry>> &&const _Select1st<pair<const CSubNet, CBanEntry>>const _Select1st<pair<const CSubNet, CBanEntry>> &_Rb_tree_impl<less<CSubNet>, true> *less<basic_string<char, char_traits<char>, allocator<char>>>allocator<CAddress>allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> *new_allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> *const new_allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> *const _Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> *const initializer_list<pair<const CSubNet, CBanEntry>> *_Alloc_traits::_S_propagate_on_copy_assign()_Alloc_traits::_S_always_equal()!_Alloc_traits::_S_always_equal()!_Alloc_traits::_S_always_equal()
		  && __this_alloc != __that_alloc_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>> *const less<CSubNet> *less<CSubNet> *__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>reverse_iterator<__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>>reverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>>__alloc_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>, _Rb_tree_node<pair<const CSubNet, CBanEntry>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>, _Rb_tree_node<pair<const CSubNet, CBanEntry>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>, _Rb_tree_node<pair<const CSubNet, CBanEntry>>>const __alloc_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>, _Rb_tree_node<pair<const CSubNet, CBanEntry>>> &unary_function<pair<const CSubNet, CBanEntry>, const CSubNet>unary_function<pair<const CSubNet, CBanEntry>, const CSubNet> &unary_function<pair<const CSubNet, CBanEntry>, const CSubNet> &&const unary_function<pair<const CSubNet, CBanEntry>, const CSubNet>const unary_function<pair<const CSubNet, CBanEntry>, const CSubNet> &__aligned_membuf<pair<const CSubNet, CBanEntry>>__aligned_membuf<pair<const CSubNet, CBanEntry>> &__aligned_membuf<pair<const CSubNet, CBanEntry>> &&const __aligned_membuf<pair<const CSubNet, CBanEntry>>const __aligned_membuf<pair<const CSubNet, CBanEntry>> &unsigned char[80]_Tuple_impl<0UL, const CSubNet &>_Tuple_impl<0UL, const CSubNet &> &&const _Tuple_impl<0UL, const CSubNet &>const _Tuple_impl<0UL, const CSubNet &> &_Tuple_impl<0UL, const CSubNet &> &_Tuple_impl<0UL, const CSubNet &> *__aligned_membuf<pair<const CSubNet, CBanEntry>> *82351536043346212__is_invocable<less<CSubNet> &, const CSubNet &, const CSubNet &>__is_invocable<less<CSubNet> &, const CSubNet &, const CSubNet &> &__is_invocable<less<CSubNet> &, const CSubNet &, const CSubNet &> &&const __is_invocable<less<CSubNet> &, const CSubNet &, const CSubNet &>const __is_invocable<less<CSubNet> &, const CSubNet &, const CSubNet &> &_TC<value, const CSubNet &>_TC<<expression>, const CSubNet &>_Head_base<0UL, const CSubNet &, false>_Head_base<0UL, const CSubNet &, false> &const _Head_base<0UL, const CSubNet &, false>const _Head_base<0UL, const CSubNet &, false> &remove_reference<tuple<const CSubNet &>>remove_reference<tuple<const CSubNet &>> &remove_reference<tuple<const CSubNet &>> &&const remove_reference<tuple<const CSubNet &>>const remove_reference<tuple<const CSubNet &>> &unsigned char(*)[80]_Rb_tree_key_compare<less<CSubNet>> *_Head_base<0UL, const CSubNet &, false> *_Rb_tree_node<pair<const CSubNet, CBanEntry>> *&const _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>> *const _Select1st<pair<const CSubNet, CBanEntry>> *_Select1st<pair<const CSubNet, CBanEntry>> *is_nothrow_default_constructible<less<CSubNet>>is_nothrow_default_constructible<less<CSubNet>> &is_nothrow_default_constructible<less<CSubNet>> &&const is_nothrow_default_constructible<less<CSubNet>>const is_nothrow_default_constructible<less<CSubNet>> &__and_<is_same<_Rb_tree_node<pair<const CSubNet, CBanEntry>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<tuple<const CSubNet &>, tuple<_UElements...>>remove_reference<const pair<const CSubNet, CBanEntry> &>remove_reference<const pair<const CSubNet, CBanEntry> &> &remove_reference<const pair<const CSubNet, CBanEntry> &> &&const remove_reference<const pair<const CSubNet, CBanEntry> &>const remove_reference<const pair<const CSubNet, CBanEntry> &> &iterator_traits<unsigned long *>iterator_traits<unsigned long *> &iterator_traits<unsigned long *> &&const iterator_traits<unsigned long *>const iterator_traits<unsigned long *> &const __aligned_membuf<pair<const CSubNet, CBanEntry>> *conditional<false, is_move_assignable<unsigned char>, is_copy_assignable<unsigned char>>conditional<false, is_move_assignable<unsigned char>, is_copy_assignable<unsigned char>> &conditional<false, is_move_assignable<unsigned char>, is_copy_assignable<unsigned char>> &&const conditional<false, is_move_assignable<unsigned char>, is_copy_assignable<unsigned char>>const conditional<false, is_move_assignable<unsigned char>, is_copy_assignable<unsigned char>> &is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const piecewise_construct_t &, tuple<const CSubNet &>, tuple<>>is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const piecewise_construct_t &, tuple<const CSubNet &>, tuple<>> &is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const piecewise_construct_t &, tuple<const CSubNet &>, tuple<>> &&const is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const piecewise_construct_t &, tuple<const CSubNet &>, tuple<>>const is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const piecewise_construct_t &, tuple<const CSubNet &>, tuple<>> &__is_empty_non_tuple<const CSubNet &>__is_empty_non_tuple<const CSubNet &> &__is_empty_non_tuple<const CSubNet &> &&const __is_empty_non_tuple<const CSubNet &>const __is_empty_non_tuple<const CSubNet &> &is_same<_Rb_tree_node<pair<const CSubNet, CBanEntry>> *, _Ptr>remove_reference<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>remove_reference<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>> &remove_reference<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>> &&const remove_reference<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>const remove_reference<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>> &const unsigned char[80]const unsigned char(*)[80]is_nothrow_destructible<pair<const CSubNet, CBanEntry>>is_nothrow_destructible<pair<const CSubNet, CBanEntry>> &is_nothrow_destructible<pair<const CSubNet, CBanEntry>> &&const is_nothrow_destructible<pair<const CSubNet, CBanEntry>>const is_nothrow_destructible<pair<const CSubNet, CBanEntry>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CSubNet &>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CSubNet &>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CSubNet &>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CSubNet &>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const CSubNet &>> &is_empty<const CSubNet &>is_empty<const CSubNet &> &is_empty<const CSubNet &> &&const is_empty<const CSubNet &>const is_empty<const CSubNet &> &remove_reference<_Rb_tree_node<pair<const CSubNet, CBanEntry>> *&>remove_reference<_Rb_tree_node<pair<const CSubNet, CBanEntry>> *&> &remove_reference<_Rb_tree_node<pair<const CSubNet, CBanEntry>> *&> &&const remove_reference<_Rb_tree_node<pair<const CSubNet, CBanEntry>> *&>const remove_reference<_Rb_tree_node<pair<const CSubNet, CBanEntry>> *&> &is_move_assignable<unsigned char>tuple<const CSubNet &> *is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const pair<const CSubNet, CBanEntry> &>is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const pair<const CSubNet, CBanEntry> &> &is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const pair<const CSubNet, CBanEntry> &> &&const is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const pair<const CSubNet, CBanEntry> &>const is_nothrow_constructible<pair<const CSubNet, CBanEntry>, const pair<const CSubNet, CBanEntry> &> &is_nothrow_move_constructible<const CSubNet &>is_nothrow_move_constructible<const CSubNet &> &is_nothrow_move_constructible<const CSubNet &> &&const is_nothrow_move_constructible<const CSubNet &>const is_nothrow_move_constructible<const CSubNet &> &remove_reference<const CSubNet &>remove_reference<const CSubNet &> &remove_reference<const CSubNet &> &&const remove_reference<const CSubNet &>const remove_reference<const CSubNet &> &__is_nothrow_move_constructible_impl<const CSubNet &, true>__is_nothrow_move_constructible_impl<const CSubNet &, true> &__is_nothrow_move_constructible_impl<const CSubNet &, true> &&const __is_nothrow_move_constructible_impl<const CSubNet &, true>const __is_nothrow_move_constructible_impl<const CSubNet &, true> &__is_referenceable<const CSubNet &>__is_referenceable<const CSubNet &> &__is_referenceable<const CSubNet &> &&const __is_referenceable<const CSubNet &>const __is_referenceable<const CSubNet &> &is_nothrow_constructible<const CSubNet &, const CSubNet &>is_nothrow_constructible<const CSubNet &, const CSubNet &> &is_nothrow_constructible<const CSubNet &, const CSubNet &> &&const is_nothrow_constructible<const CSubNet &, const CSubNet &>const is_nothrow_constructible<const CSubNet &, const CSubNet &> &tuple_element<0UL, tuple<const CSubNet &>>tuple_element<0UL, tuple<const CSubNet &>> &tuple_element<0UL, tuple<const CSubNet &>> &&const tuple_element<0UL, tuple<const CSubNet &>>const tuple_element<0UL, tuple<const CSubNet &>> &result type must be constructible from input typeresult type must be constructible from value type of input range/home/tanteikg/QCVE/sources/bitcoin/src/base58.h/home/tanteikg/QCVE/sources/bitcoin/src/base58.cpp<base58.h>DecodeBase58Check2147483643std::numeric_limits<int>::max() - 4EncodeBase58CheckDecodeBase58EncodeBase58zeroesb58carry == 0const reverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>>const reverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>> &reverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>> &base58.cppconst char[119]char[119]std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> EncodeBase58(Span<const unsigned char>)'1'733b256const int8_tconst int8_t[256]signed char[256]const int8_t *const char[98]char[98]bool DecodeBase58(const char *, std::vector<unsigned char, std::allocator<unsigned char>> &, int)const signed char[256]const signed char(&)[256]signed char(&)[256]const int8_t(&)[256]std::size(mapBase58) == 256mapBase58.size() should be 256mapBase58pszBase58123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"const char[59]char[59]// re-calculate the checksum, ensure it matches the included 4-byte checksum// add 4-byte hash check to the end// Translate the result into a string.// Skip leading zeroes in base58 result.// Apply "b58 = b58 * 256 + ch".// Process the bytes.// log(256) / log(58), rounded up.// Allocate enough space in big-endian base58 representation.// Skip & count leading zeroes.// Copy result into output vector.// Skip leading zeroes in b256.// Skip trailing spaces.// Invalid b58 character// Decode base58 character// guarantee not out of range// Process the characters.// log(58) / log(256), rounded up.// Allocate enough space in big-endian base256 representation.// Skip and count leading '1's.// Skip leading spaces./** All alphanumeric characters except for "0", "I", "O", and "l" */max_retmax_ret_lenreverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>> *__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> *unsigned char *constunsigned char *const &unsigned char *&const reverse_iterator<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>> *const Span<const unsigned char> *Span<const unsigned char> *const __normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>>const __normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>> &__normal_iterator<const unsigned char *, vector<unsigned char, allocator<unsigned char>>> &iterator<random_access_iterator_tag, unsigned char, long, unsigned char *, unsigned char &>iterator<random_access_iterator_tag, unsigned char, long, unsigned char *, unsigned char &> &iterator<random_access_iterator_tag, unsigned char, long, unsigned char *, unsigned char &> &&const iterator<random_access_iterator_tag, unsigned char, long, unsigned char *, unsigned char &>const iterator<random_access_iterator_tag, unsigned char, long, unsigned char *, unsigned char &> &iterator_traits<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>>iterator_traitsiterator_traits<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>> &iterator_traits<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>> &&const iterator_traits<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>>const iterator_traits<__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>> &remove_reference<const Span<unsigned char> &>remove_reference<const Span<unsigned char> &> &remove_reference<const Span<unsigned char> &> &&const remove_reference<const Span<unsigned char> &>const remove_reference<const Span<unsigned char> &> &__is_move_iterator<_II>::__value__is_byte<byte> &__is_byte<byte> &&const __is_byte<byte>const __is_byte<byte> &__is_byte<unsigned char> &__is_byte<unsigned char> &&const __is_byte<unsigned char>const __is_byte<unsigned char> &__is_byte<signed char> &__is_byte<signed char> &&const __is_byte<signed char>const __is_byte<signed char> &__is_byte<char> &__is_byte<char> &&const __is_byte<char>const __is_byte<char> &__is_char<wchar_t> &__is_char<wchar_t> &&const __is_char<wchar_t>const __is_char<wchar_t> &__is_char<char> &__is_char<char> &&const __is_char<char>const __is_char<char> &__is_floating<long double> &__is_floating<long double> &&const __is_floating<long double>const __is_floating<long double> &__is_floating<double> &__is_floating<double> &&const __is_floating<double>const __is_floating<double> &__is_floating<float> &__is_floating<float> &&const __is_floating<float>const __is_floating<float> &__is_integer<unsigned long long> &__is_integer<unsigned long long> &&const __is_integer<unsigned long long>const __is_integer<unsigned long long> &__is_integer<long long> &__is_integer<long long> &&const __is_integer<long long>const __is_integer<long long> &__is_integer<unsigned long> &__is_integer<unsigned long> &&const __is_integer<unsigned long>const __is_integer<unsigned long> &__is_integer<long> &__is_integer<long> &&const __is_integer<long>const __is_integer<long> &__is_integer<unsigned int> &__is_integer<unsigned int> &&const __is_integer<unsigned int>const __is_integer<unsigned int> &__is_integer<int> &__is_integer<int> &&const __is_integer<int>const __is_integer<int> &__is_integer<unsigned short> &__is_integer<unsigned short> &&const __is_integer<unsigned short>const __is_integer<unsigned short> &__is_integer<short> &__is_integer<short> &&const __is_integer<short>const __is_integer<short> &__is_integer<char32_t> &__is_integer<char32_t> &&const __is_integer<char32_t>const __is_integer<char32_t> &__is_integer<char16_t> &__is_integer<char16_t> &&const __is_integer<char16_t>const __is_integer<char16_t> &__is_integer<wchar_t> &__is_integer<wchar_t> &&const __is_integer<wchar_t>const __is_integer<wchar_t> &__is_integer<unsigned char> &__is_integer<unsigned char> &&const __is_integer<unsigned char>const __is_integer<unsigned char> &__is_integer<signed char> &__is_integer<signed char> &&const __is_integer<signed char>const __is_integer<signed char> &__is_integer<char> &__is_integer<char> &&const __is_integer<char>const __is_integer<char> &__is_integer<bool> &__is_integer<bool> &&const __is_integer<bool>const __is_integer<bool> &__is_void<void> &__is_void<void> &&const __is_void<void>const __is_void<void> &__truth_type<true> &__truth_type<true> &&const __truth_type<true>const __truth_type<true> &__true_type &__true_type &&const __true_typeconst __true_type &__false_type &__false_type &&const __false_typeconst __false_type &__is_move_iterator<_Tp>__is_byte<byte>byte__is_byte<unsigned char>__is_byte<signed char>__is_byte<char>__is_byte<_Tp>__is_char<wchar_t>__is_char<char>__is_char<_Tp>__is_scalar<_Tp>__is_pointer<_Tp *>__is_pointer<_Tp>__is_floating<long double>__is_floating<double>__is_floating<float>__is_floating<_Tp>__is_integer<unsigned long long>__is_integer<long long>__is_integer<unsigned long>__is_integer<long>__is_integer<unsigned int>__is_integer<int>__is_integer<unsigned short>__is_integer<short>__is_integer<char32_t>__is_integer<char16_t>__is_integer<wchar_t>__is_integer<unsigned char>__is_integer<signed char>__is_integer<char>__is_integer<bool>__is_void<void>__is_void<_Tp>__are_same<_Tp, _Tp>__are_same<<unnamed>, <unnamed>>__traitor<_Sp, _Tp>_Sp__truth_type<true>__truth_type<<unnamed>>__true_type__false_type__INT_N__INT_N(TYPE)template<> struct __is_integer<TYPE> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned TYPE> { enum { __value = 1 }; typedef __true_type __type; };_CPP_TYPE_TRAITS_H//_CPP_TYPE_TRAITS_H// remove the move_iterator wrapper.// Move iterator type// For use in std::copy and std::find overloads for streambuf iterators.// // A scalar type is an arithmetic type or a pointer type// An arithmetic type is an integer type or a floating point type// Pointer types// three specializations (float, double and 'long double')// Floating point types// types are supported as well.// supported as extensions).  Up to four target-specific __int<N>// types; <em>long long</em> and <em>unsigned long long</em> are// Thirteen specializations (yes there are eleven standard integer// Integer types// Holds if the template-argument is a void type.// Compare for equality of types.// explained in c++/19404.// N.B. The conversions to bool are needed due to the issue// removed.// Update 2005: types are also provided and <bits/type_traits.h> has been// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.// See valarray_array.h for a case use.// keep these resource consumption as least as possible.// is highly costly in terms of compiler-resource.  It is a Good Thing to// Thirdly, partial ordering and overload resolution (of function templates)// glance.// one. As a net effect, the overall structure isn't very clear at first// overloaded functions and to hope that the compiler will select the right// information is -not- *that* convenient.  One has to write lots of// Secondly, from the point of view of ease of use, type-based compile-time// We're left with types and constant  integral expressions.// so function return values won't work:  We need compile-time entities.// Firstly, these compile-time entities are used as template-arguments// Why integral expressions, and not functions nor types?// the obvious thing.// can be used in control structures and the optimizer hopefully will do// and not types as found in <bits/type_traits.h>.  In particular, they// These representations were designed, on purpose, to be constant-expressions// This file provides some compile-time information about various types.// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>/** @file bits/cpp_type_traits.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ext/type_traits}
 */// Copyright (C) 2000-2019 Free Software Foundation, Inc.// The  -*- C++ -*- type traits classes for internal use in libstdc++__niter__string_type__size_type__move_storage/home/tanteikg/QCVE/sources/bitcoin/src/bech32.hDecodeResult &DecodeResult &&const DecodeResultconst DecodeResult &~DecodeResultDecodeResultstring &&vector<unsigned char, allocator<unsigned char>> &&DecodeResult *Encoding::INVALIDEncodingINVALIDBECH32BECH32MhrpencodingBITCOIN_BECH32_Hbech32LocateErrorsDecodeEncodeconst dataconst data &// BITCOIN_BECH32_H// namespace bech32/** Return the positions of errors in a Bech32 string. *//** Decode a Bech32 or Bech32m string. *///!< The payload (excluding checksum)//!< The human readable part//!< What encoding was detected in the result; Encoding::INVALID if failed./** Encode a Bech32 or Bech32m string. If hrp contains uppercase characters, this will cause an
 *  assertion error. Encoding must be one of BECH32 or BECH32M. *///!< Bech32m encoding as defined in BIP350//!< Bech32 encoding as defined in BIP173//!< Failed decoding// For more information, see BIP 173 and BIP 350.// module is namespaced under bech32 for historical reasons.// section, the last 6 characters of which are a checksum. The// (alphanumeric), a separator character (1), and a base32 data// address types. The outputs consist of a human-readable part// Bech32 and Bech32m are string encoding formats used in newer// Copyright (c) 2017, 2021 Pieter Wuilleench/home/tanteikg/QCVE/sources/bitcoin/src/util/vector.hCatVectorBITCOIN_UTIL_VECTOR_H// BITCOIN_UTIL_VECTOR_H/** Concatenate two vectors. *//** Concatenate two vectors, moving elements. */// The line below uses the trick from https://www.experts-exchange.com/articles/32502/None-recursive-variadic-templates-with-std-initializer-list.html/** Construct a vector with the specified elements.
 *
 * This is preferable over the list initializing constructor of std::vector:
 * - It automatically infers the element type from its arguments.
 * - If any arguments are rvalue references, they will be moved into the vector
 *   (list initialization always copies).
 */v2array::at: __n (which is %zu) >= _Nm (which is %zu)__N("array::at: __n (which is %zu) "
					       ">= _Nm (which is %zu)")__N("array::at: __n (which is %zu) "
					    ">= _Nm (which is %zu)")/home/tanteikg/QCVE/sources/bitcoin/src/bech32.cpp<util/vector.h><bech32.h>CreateChecksummoddata &VerifyChecksumcheckEncoding::BECH32Encoding::BECH32MExpandHRP0x1fCheckCharactersvector<int, allocator<int>> &lowerupper'Z'LowerCaseSyndromelowconst array<unsigned int, 25UL>GenerateSyndromeConstantsSYNDROME_CONSTSconst array<signed short, 1024UL>const array<signed short, 1024UL> &array<signed short, 1024UL> &size_t{1}c0const array<signed short, 1023UL>const array<signed short, 1023UL> &array<signed short, 1023UL> &997c1998c2indPolyModv_i335544310x1ffffff9968250100x3b6a57b26428135490x26508e6d5138744260x1ea119fa10277488290x3d4233dd7059790590x2a1462b3EncodingConstantencoding == Encoding::BECH32 || encoding == Encoding::BECH32Mbech32.cppunsigned int bech32::<unnamed>::EncodingConstant(bech32::Encoding)7345399390x2bc830a3GenerateGFTablesGF32_EXPGF32_LOG 41GF1024_EXPGF1024_LOGv0v0nv1nresidueerror_locationsconst char(&)[23]char(&)[23]vector<int, allocator<int>> &&Bech32 string too long"Bech32 string too long"pair<const char *, vector<int, allocator<int>>> &const char(&)[32]char(&)[32]Invalid character or mixed case"Invalid character or mixed case"str.nposconst char(&)[18]char(&)[18]Missing separator"Missing separator"const char(&)[27]char(&)[27]Invalid separator position"Invalid separator position"revconst int8_t[128]signed char[128]const char(&)[26]char(&)[26]Invalid Base 32 character"Invalid Base 32 character"error_encodinginitializer_list<Encoding> &&const Encodingconst Encoding[2]Encoding[2]const Encoding *Encoding *initializer_list<Encoding> &const initializer_list<Encoding>possible_errorssyns00x3FFs1s2l_s0l_s1l_s22046p1l_e11023 - 997(1023 - 997)s2_s1p1l_s2_s1p1s1_s0p1l_s1_s0p1p2s1_s0p2l_s1_s0p2inv_p1_p2l_e2const char(&)[1]char(&)[1]""const optional<Encoding>Encoding &error_messageconst optional<Encoding> &optional<Encoding> &const Encoding &Invalid Bech32m checksum"Invalid Bech32m checksum"Invalid Bech32 checksum"Invalid Bech32 checksum"Invalid checksum"Invalid checksum"c < 'A' || c > 'Z'const char[267]char[267]std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> bech32::Encode(bech32::Encoding, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, const std::vector<unsigned char, std::allocator<unsigned char>> &)checksumcombinedconst pair<array<signed short, 1023UL>, array<signed short, 1024UL>>tablesCHARSET_REVCHARSETqpzry9x8gf2tvdw0s3jn54khce6mua7l"qpzry9x8gf2tvdw0s3jn54khce6mua7l"(unnamed namespace)// No errors// Order the error positions from the left of the string and return them// Again, we do not return e1 or e2 for safety.// Check that e1 is in GF(32)// So recover e1 by dividing by (e)^(997*p1)//         = e1*(e)^(997*p1)// In the same way, (s1 + s0*(e)^p2) * (1/((e)^p1 + (e)^p2)))// Check that e2 is in GF(32)// Then recover e2 by dividing by (e)^(997*p2)//         = e2*(e)^(997*p2)// Then (s1 + s0*(e)^p1) * (1/((e)^p1 + (e)^p2)))// And compute (the log of) 1/((e)^p1 + (e)^p2))//          = e1*(e)^(997*p1) ((e)^p1 + (e)^p2)// Similar to above, we compute s1 + s0*(e)^p2// Now we want to compute the error values e1 and e2.// Sanity checks that p2 is a valid position and not the same as p1// p2 = log((e)^p2)// (e)^p2 = (s2 + s1^p1)/(s1 + s0^p1)// So, putting these together, we can compute the second error position as//          = e2*(e)^(997*p2) ((e)^p2 + (e)^p1)// Similarly, s1 + s0*(e)^p1//          = e2*(e)^(998*p2) ((e)^p2 + (e)^p1)//    (Because we are working in characteristic 2.)//          = e2*(e)^(999*p2) + e2*(e)^(998*p2)*(e)^p1//          = 2e1*(e)^(999^p1) + e2*(e)^(999*p2) + e2*(e)^(998*p2)*(e)^p1// Consider s2 + s1*(e)^p1// s0 = E((e)^997) = e1*(e)^(997^p1) + e2*(e)^(997*p2), and similar for s1 and s2.// We have guessed p1, and want to solve for p2. Recall that E(x) = e1*x^p1 + e2*x^p2, so// For all possible first error positions p1// Otherwise, suppose there are two errors. Then E(x) = e1*x^p1 + e2*x^p2.// the user should check the address themselves.// We don't return e1 because it is dangerous to suggest corrections to the user,// Polynomials run from highest power to lowest, so the index p1 is from the right.// of GF(32) form an index 33 subgroup of the 1023 non-zero elements of GF(1024)).// - e1 should be in GF(32), which implies that e1 = (e)^(33k) for some k (the 31 non-zero elements// - The error position should be within the length of the data// Finally, some sanity checks on the result:// so 1/((e)^997) = (e)^(1023-997).// Now because s0 = e1*(e)^(997*p1), we get e1 = s0/((e)^(997*p1)). Remember that (e)^1023 = 1,// the +1023 ensures it is positive// Compute the error position p1 as l_s1 - l_s0 = p1 (mod 1023)// Hence, s1^2 == s0*s2, which is exactly the condition we check first:// Therefore s1/s0 = (e)^p1, and by the same logic, s2/s1 = (e)^p1 too.// Then s0 = E((e)^997) = e1*(e)^(997*p1) and s1 = E((e)^998) = e1*(e)^(998*p1)// First, suppose there is only a single error. Then E(x) = e1*x^p1 for some position p1// Get the discrete logs of these values in GF1024 for more efficient computation// Unpack the three 10-bit syndrome values// codeword (a multiple of G(x)), and E encodes the errors.// If errors are present, our polynomial must be of the form C(x) + E(x) where C is the valid// constant) should be 0 - hence 0 indicates there are no errors present.// All valid codewords should be multiples of G(x), so this remainder (after XORing with the encoding// over GF(32). PolyMod computes the "remainder" of this polynomial modulo the generator G(x).// Recall that (ExpandHRP(hrp) ++ values) is interpreted as a list of coefficients of a polynomial// We can't simply use the segwit version, because that may be one of the errors// We attempt error detection with both bech32 and bech32m, and choose the one with the fewest errors// length of data part/** Find index of an incorrect character in a Bech32 string. */// result will always be invalid.// to return a lowercase Bech32/Bech32m string, but if given an uppercase HRP, the// First ensure that the HRP is all lowercase. BIP-173 and BIP350 require an encoder/** Encode a Bech32 or Bech32m string. */// Convert the 5-bit groups in mod to checksum values.// Determine what to XOR into those 6 zeroes.// Append 6 zeroes/** Create a checksum. */// https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e for details.// resulting checksum to be 1 instead. In Bech32m, this constant was amended. See// list of values would result in a new valid list. For that reason, Bech32 requires the// if we required that the checksum was 0, it would be the case that appending a 0 to a valid// PolyMod computes what value to xor into the final values to make the checksum 0. However,/** Verify a checksum. *//** Expand a HRP for use in checksum computation. *//** Return indices of invalid characters in a Bech32 string. *//** Convert to lower case. */// simultaneously. Recall that XOR corresponds to addition in a characteristic 2 field.// GF1024_EXP above). In this way, we compute all three values of s_j for j in (997, 998, 999)// bits, corresponding exactly to a^999 || a^998 || a^997 (matching the corresponding values in// For example, 0x31edd3c4 is 1100011110 1101110100 1111000100 when unpacked in groups of 10// Then for each following bit, we add the corresponding precomputed constant if the bit is 1.// We begin by setting s_j = low = r6 for all three values of j, because these are unconditional.// (the constant term of the polynomial).// low is the first 5 bits, corresponding to the r6 in the residue/**
 * Syndrome returns the three values s_997, s_998, and s_999 described above,
 * packed into a 30-bit integer, where each group of 10 bits encodes one value.
 *//** Syndrome computes the values s_j = R(e^j) for j in [997, 998, 999]. As described above, the
 * generator polynomial G is the LCM of the minimal polynomials of (e)^997, (e)^998, and (e)^999.
 *
 * Consider a codeword with errors, of the form R(x) = C(x) + E(x). The residue is the bit-packed
 * result of computing R(x) mod G(X), where G is the generator of the code. Because C(x) is a valid
 * codeword, it is a multiple of G(X), so the residue is in fact just E(x) mod G(x). Note that all
 * of the (e)^j are roots of G(x) by definition, so R((e)^j) = E((e)^j).
 *
 * Let R(x) = r1*x^5 + r2*x^4 + r3*x^3 + r4*x^2 + r5*x + r6
 *
 * To compute R((e)^j), we are really computing:
 * r1*(e)^(j*5) + r2*(e)^(j*4) + r3*(e)^(j*3) + r4*(e)^(j*2) + r5*(e)^j + r6
 *
 * Now note that all of the (e)^(j*i) for i in [5..0] are constants and can be precomputed.
 * But even more than that, we can consider each coefficient as a bit-string.
 * For example, take r5 = (b_5, b_4, b_3, b_2, b_1) written out as 5 bits. Then:
 * r5*(e)^j = b_1*(e)^j + b_2*(2*(e)^j) + b_3*(4*(e)^j) + b_4*(8*(e)^j) + b_5*(16*(e)^j)
 * where all the (2^i*(e)^j) are constants and can be precomputed.
 *
 * Then we just add each of these corresponding constants to our final value based on the
 * bit values b_i. This is exactly what is done in the Syndrome function below.
 */// {16}k(x) = {21}x^5 +     x^4 +  {8}x^3 + {24}x^2 + {21}x + {19}//  {8}k(x) = {30}x^5 + {20}x^4 +  {4}x^3 + {12}x^2 + {30}x + {29}//  {4}k(x) = {15}x^5 + {10}x^4 +  {2}x^3 +  {6}x^2 + {15}x + {26}//  {2}k(x) = {19}x^5 +  {5}x^4 +     x^3 +  {3}x^2 + {19}x + {13}//     k(x) = {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}//     print("0x%x" % v)//         v = v*32 + coef.integer_representation()//     for coef in reversed((F.fetch_int(i)*(G % x**6)).coefficients(sparse=True))://     v = 0// for i in [1,2,4,8,16]: # Print out {1,2,4,8,16}*(g(x) mod x^6), packed in hex integers.// computed using the following Sage code (continuing the code above):// Finally, for each set bit n in c0, conditionally add {2^n}k(x). These constants can be// Then compute c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i:// First, determine the value of c0:// c'(x) = (c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i) + c0*k(x)// If we call (x^6 mod g(x)) = k(x), this can be written as//       = c0*(x^6 mod g(x)) + c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i//       = c0*x^6 + c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i mod g(x)// c'(x) = (c0*x^5 + c1*x^4 + c2*x^3 + c3*x^2 + c4*x + c5) * x + v_i mod g(x)// If c(x) = c0*x^5 + c1*x^4 + c2*x^3 + c3*x^2 + c4*x + c5, we want to compute//         (c(x) * x + v_i) mod g(x)//         ((f(x) mod g(x)) * x + v_i) mod g(x)// c'(x) = (f(x) * x + v_i) mod g(x)// process. Simplifying:// correspond to c'(x) = (f(x) * x + v_i) mod g(x), where v_i is the next input to// value of `c` consists of the coefficients of c(x) = f(x) mod g(x), we modify it to// We want to update `c` to correspond to a polynomial with one extra term. If the initial// length 1023 and distance 4. See https://en.wikipedia.org/wiki/BCH_code for more details.// That guarantees it is, in fact, the generator of a primitive BCH code with cycle// of 3 consecutive powers (997,998,999) of a primitive element (e) of GF(1024).// It demonstrates that g(x) is the least common multiple of the minimal polynomials// print(G) # Print out the generator// G = lcm([(e**i).minpoly() for i in range(997,1000)])//    assert((e**p == 1) == (p % 1023 == 0))// for p in divisors(E.order() - 1): # Verify e has order 1023.// E.<e> = F.extension(E_mod) # GF(1024) extension field definition// E_mod = x**2 + F.fetch_int(9)*x + F.fetch_int(23)// FP.<x> = F[] # Polynomials over GF(32)// F.<f> = GF(32, modulus=F_mod, repr='int') # GF(32) definition// F_mod = b**5 + b**3 + 1// BP.<b> = B[] # Polynomials over the binary field// B = GF(2) # Binary field// The following Sage code constructs the generator used:// for `c`.// v, it corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the starting value// the above example, `c` initially corresponds to 1 mod g(x), and after processing 2 inputs of// polynomial constructed from just the values of v that were processed so far, mod g(x). In// During the course of the loop below, `c` contains the bitpacked coefficients of the// = a^3 + 1 (mod a^5 + a^3 + 1) = {9}.// (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 + a^3 + a) = a^6 + a^5 + a^4 + a// GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example, {5} * {26} =// treating the bits of values themselves as coefficients of a polynomial over a smaller field,// example, {27} + {13} = {27 ^ 13} = {22}. Multiplication is more complicated, and requires// between {}. In this finite field, addition is just XOR of the corresponding numbers. For// Note that the coefficients are elements of GF(32), here represented as decimal numbers// fact guarantee detection of up to 4 errors within a window of 89 characters.// window of 1023 characters. Among the various possible BCH codes, one was selected to in// that the resulting code is a BCH code, guaranteeing detection of up to 3 errors within a// x^6 + {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}. g(x) is chosen in such a way// v(x) mod g(x), where g(x) is the Bech32 generator,// The output is a 30-bit integer whose 5-bit groups are the coefficients of the remainder of// [v0,v1,v2,...] has a distinct checksum from [0,v0,v1,v2,...].// 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4. The implicit 1 guarantees that// implicit 1 in front. If the input is [v0,v1,v2,v3,v4], that polynomial is v(x) =// The input is interpreted as a list of coefficients of a polynomial over F = GF(32), with an/** This function will compute what 6 5-bit values to XOR into the last 6 input values, in order to
 *  make the checksum 0. These 6 values are packed together in a single 30-bit integer. The higher
 *  bits correspond to earlier values. *//* Determine the final constant to use for the specified encoding. */// for non-zero a and b.// e^x * e^y = e^(x + y) so a * b = EXP[ LOG[a] + LOG [b] ]// is done using the log/exp tables:// Where 23, 9 are GF(32) elements encoded as described above. Multiplication in GF(32)// e*v = v1' || v0'// v1' = 9*v1 + v0// v0' = 23*v1// we compute (e)*(v) by multiplying in the following way:// a*(e) + b is represented as a || b (a and b are both GF(32) elements). Given (v),// The element (e) is encoded as 1 || 0, to represent 1*(e) + 0. Every other element// v = v1 || v0 where v0, v1 are 5-bit integers (elements of GF(32)).// Each element v of GF(1024) is encoded as a 10 bit integer in the following way:// Build table for GF(1024)// 2 fields.// to remain working modulo fmod. Subtraction is the same as XOR in characteristic// If the polynomial now has an x^5 term, we subtract fmod from it// every coefficient of the polynomial is moved up one place.// Multiplication by x is the same as shifting left by 1, as// For example, 00001 = 1 is the multiplicative identity.// b_4*x^4 + b_3*x^3 + b_2*x^2 + b_1*x^1 + b_0 (modulo fmod).// 5 binary digits. Each element (b_4, b_3, b_2, b_1, b_0) encodes a polynomial// Elements of GF(32) are encoded as vectors of length 5 over GF(2), that is,// Because coefficients in GF(2) are binary digits, the coefficients are packed as 101001.// fmod encodes the defining polynomial of GF(32) over GF(2), x^5 + x^3 + 1.// tables for GF(1024).// We use these tables to perform arithmetic in GF(32) below, when constructing the// Build table for GF(32)./** We work with the finite field GF(1024) defined as a degree 2 extension of the base field GF(32)
 * The defining polynomial of the extension is x^2 + 9x + 23.
 * Let (e) be a root of this defining polynomial. Then (e) is a primitive element of GF(1024),
 * that is, a generator of the field. Every non-zero element of the field can then be represented
 * as (e)^k for some power k.
 * The array GF1024_EXP contains all these powers of (e) - GF1024_EXP[k] = (e)^k in GF(1024).
 * Conversely, GF1024_LOG contains the discrete logarithms of these powers, so
 * GF1024_LOG[GF1024_EXP[k]] == k.
 * The following function generates the two tables GF1024_EXP and GF1024_LOG as constexprs. *//** The Bech32 and Bech32m character set for decoding. *//** The Bech32 and Bech32m character set for encoding. */initializer_list<Encoding>const initializer_list<Encoding> &pair<const char *, vector<int, allocator<int>>>pair<const char *, vector<int, allocator<int>>> *const vector<int, allocator<int>> &pair<array<signed short, 1023UL>, array<signed short, 1024UL>>array<signed char, 31UL>array<signed char, 31UL> &array<signed char, 31UL> &&const array<signed char, 31UL>const array<signed char, 31UL> &array<signed char, 32UL>array<signed char, 32UL> &array<signed char, 32UL> &&const array<signed char, 32UL>const array<signed char, 32UL> &array<signed short, 1023UL>array<signed short, 1023UL> &&array<signed short, 1024UL>array<signed short, 1024UL> &&array<unsigned int, 25UL>array<unsigned int, 25UL> &array<unsigned int, 25UL> &&const array<unsigned int, 25UL> &optional<Encoding>optional<Encoding> &&_Optional_payload_base<Encoding>pair<basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>>_Alloc_traits::_S_nothrow_move()_Alloc_traits::_S_propagate_on_move_assign()_Alloc_traits::_S_propagate_on_move_assign()
	  || _Alloc_traits::_S_always_equal()..(*)(..))[1]const initializer_list<Encoding> *initializer_list<Encoding> *optional<Encoding> *..(*)(..))[26]..(*)(..))[27]..(*)(..))[18]..(*)(..))[32]..(*)(..))[23]pair<const char *, vector<int, allocator<int>>> &&const char *&&char *&&array<signed char, 32UL> *signed char[32]signed char(&)[32]array<signed char, 31UL> *signed char[31]signed char(&)[31]array<signed short, 1024UL> *const signed shortsigned short[1024]signed short(&)[1024]array<signed short, 1023UL> *signed short[1023]signed short(&)[1023]array<unsigned int, 25UL> *unsigned int[25]unsigned int(&)[25]const array<signed short, 1023UL> *const array<signed short, 1024UL> *const array<unsigned int, 25UL> *__pair_base<basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>>_Storage<Encoding, true>_Storage<Encoding, true> &_Storage<Encoding, true> &&const _Storage<Encoding, true>const _Storage<Encoding, true> &_Enable_copy_move<true, true, true, true, optional<Encoding>>_Enable_copy_move<true, true, true, true, optional<Encoding>> &_Enable_copy_move<true, true, true, true, optional<Encoding>> &&const _Enable_copy_move<true, true, true, true, optional<Encoding>>const _Enable_copy_move<true, true, true, true, optional<Encoding>> &_Optional_base<Encoding, true, true>_AT_Typesigned short *__pair_base<array<signed short, 1023UL>, array<signed short, 1024UL>>__pair_base<const char *, vector<int, allocator<int>>>const signed short *_Optional_base<Encoding, true, true> *_Base_type::propagate_on_container_move_assignment::value_S_propagate_on_move_assign()_S_propagate_on_move_assign() || _S_always_equal()const optional<Encoding> *const _Optional_base<Encoding, true, true>const _Optional_base<Encoding, true, true> *const _Optional_base_impl<Encoding, _Optional_base<Encoding, true, true>>const _Optional_base_impl<Encoding, _Optional_base<Encoding, true, true>> *_Optional_base_impl<Encoding, _Optional_base<Encoding, true, true>> *is_trivially_destructible<Encoding>is_trivially_destructible<Encoding> &is_trivially_destructible<Encoding> &&const is_trivially_destructible<Encoding>const is_trivially_destructible<Encoding> &is_copy_assignable<Encoding>is_copy_assignable<Encoding> &is_copy_assignable<Encoding> &&const is_copy_assignable<Encoding>const is_copy_assignable<Encoding> &is_copy_constructible<Encoding>is_copy_constructible<Encoding> &is_copy_constructible<Encoding> &&const is_copy_constructible<Encoding>const is_copy_constructible<Encoding> &__and_<is_copy_constructible<Encoding>, is_copy_assignable<Encoding>>__and_<is_copy_constructible<Encoding>, is_copy_assignable<Encoding>> &__and_<is_copy_constructible<Encoding>, is_copy_assignable<Encoding>> &&const __and_<is_copy_constructible<Encoding>, is_copy_assignable<Encoding>>const __and_<is_copy_constructible<Encoding>, is_copy_assignable<Encoding>> &is_move_assignable<Encoding>is_move_assignable<Encoding> &is_move_assignable<Encoding> &&const is_move_assignable<Encoding>const is_move_assignable<Encoding> &is_move_constructible<Encoding>is_move_constructible<Encoding> &is_move_constructible<Encoding> &&const is_move_constructible<Encoding>const is_move_constructible<Encoding> &__and_<is_move_constructible<Encoding>, is_move_assignable<Encoding>>__and_<is_move_constructible<Encoding>, is_move_assignable<Encoding>> &__and_<is_move_constructible<Encoding>, is_move_assignable<Encoding>> &&const __and_<is_move_constructible<Encoding>, is_move_assignable<Encoding>>const __and_<is_move_constructible<Encoding>, is_move_assignable<Encoding>> &is_trivially_copy_constructible<Encoding>is_trivially_copy_constructible<Encoding> &is_trivially_copy_constructible<Encoding> &&const is_trivially_copy_constructible<Encoding>const is_trivially_copy_constructible<Encoding> &is_trivially_move_constructible<Encoding>is_trivially_move_constructible<Encoding> &is_trivially_move_constructible<Encoding> &&const is_trivially_move_constructible<Encoding>const is_trivially_move_constructible<Encoding> &_PCC<true, const char *, vector<int, allocator<int>>>_PCC<true, const char *, vector<int, allocator<int>>> &_PCC<true, const char *, vector<int, allocator<int>>> &&const _PCC<true, const char *, vector<int, allocator<int>>>const _PCC<true, const char *, vector<int, allocator<int>>> &_PCC<<expression>, const char *, vector<int, allocator<int>>>_PCC<true, array<signed short, 1023UL>, array<signed short, 1024UL>>_PCC<true, array<signed short, 1023UL>, array<signed short, 1024UL>> &_PCC<true, array<signed short, 1023UL>, array<signed short, 1024UL>> &&const _PCC<true, array<signed short, 1023UL>, array<signed short, 1024UL>>const _PCC<true, array<signed short, 1023UL>, array<signed short, 1024UL>> &_PCC<<expression>, array<signed short, 1023UL>, array<signed short, 1024UL>>__array_traits<signed char, 31UL>__array_traits<signed char, 31UL> &__array_traits<signed char, 31UL> &&const __array_traits<signed char, 31UL>const __array_traits<signed char, 31UL> &reverse_iterator<signed char *>reverse_iterator<const signed char *>__array_traits<signed char, 32UL>__array_traits<signed char, 32UL> &__array_traits<signed char, 32UL> &&const __array_traits<signed char, 32UL>const __array_traits<signed char, 32UL> &__array_traits<signed short, 1023UL>__array_traits<signed short, 1023UL> &__array_traits<signed short, 1023UL> &&const __array_traits<signed short, 1023UL>const __array_traits<signed short, 1023UL> &reverse_iterator<signed short *>reverse_iterator<const signed short *>__array_traits<signed short, 1024UL>__array_traits<signed short, 1024UL> &__array_traits<signed short, 1024UL> &&const __array_traits<signed short, 1024UL>const __array_traits<signed short, 1024UL> &__array_traits<unsigned int, 25UL>__array_traits<unsigned int, 25UL> &__array_traits<unsigned int, 25UL> &&const __array_traits<unsigned int, 25UL>const __array_traits<unsigned int, 25UL> &__not_<is_same<optional<Encoding>, type>>_Optional_payload<Encoding, true, true, true>const _Optional_payload_base<Encoding>const _Optional_payload_base<Encoding> &_Optional_payload_base<Encoding> &_Optional_payload_base<Encoding> &&_Optional_payload<Encoding, true, true, true> &_Optional_payload<Encoding, true, true, true> &&const _Optional_payload<Encoding, true, true, true>const _Optional_payload<Encoding, true, true, true> &_Optional_base_impl<Encoding, _Optional_base<Encoding, true, true>>_Optional_base_impl<Encoding, _Optional_base<Encoding, true, true>> &_Optional_base_impl<Encoding, _Optional_base<Encoding, true, true>> &&const _Optional_base_impl<Encoding, _Optional_base<Encoding, true, true>> &_PCC<true, basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>>_PCC<true, basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>> &_PCC<true, basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>> &&const _PCC<true, basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>>const _PCC<true, basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>> &_PCC<<expression>, basic_string<char, char_traits<char>, allocator<char>>, vector<int, allocator<int>>>__decay_and_strip<vector<int, allocator<int>>>__decay_and_strip<vector<int, allocator<int>>> &__decay_and_strip<vector<int, allocator<int>>> &&const __decay_and_strip<vector<int, allocator<int>>>const __decay_and_strip<vector<int, allocator<int>>> &remove_reference<Encoding &>remove_reference<Encoding &> &remove_reference<Encoding &> &&const remove_reference<Encoding &>const remove_reference<Encoding &> &__decay_and_strip<const char(&)[26]>__decay_and_strip<const char(&)[26]> &__decay_and_strip<const char(&)[26]> &&const __decay_and_strip<const char(&)[26]>const __decay_and_strip<const char(&)[26]> &__decay_and_strip<const char(&)[27]>__decay_and_strip<const char(&)[27]> &__decay_and_strip<const char(&)[27]> &&const __decay_and_strip<const char(&)[27]>const __decay_and_strip<const char(&)[27]> &__decay_and_strip<const char(&)[18]>__decay_and_strip<const char(&)[18]> &__decay_and_strip<const char(&)[18]> &&const __decay_and_strip<const char(&)[18]>const __decay_and_strip<const char(&)[18]> &__decay_and_strip<const char(&)[32]>__decay_and_strip<const char(&)[32]> &__decay_and_strip<const char(&)[32]> &&const __decay_and_strip<const char(&)[32]>const __decay_and_strip<const char(&)[32]> &remove_reference<const char(&)[32]>remove_reference<const char(&)[32]> &remove_reference<const char(&)[32]> &&const remove_reference<const char(&)[32]>const remove_reference<const char(&)[32]> &__decay_and_strip<const char(&)[23]>__decay_and_strip<const char(&)[23]> &__decay_and_strip<const char(&)[23]> &&const __decay_and_strip<const char(&)[23]>const __decay_and_strip<const char(&)[23]> &__decay_and_strip<array<signed short, 1023UL> &>__decay_and_strip<array<signed short, 1023UL> &> &__decay_and_strip<array<signed short, 1023UL> &> &&const __decay_and_strip<array<signed short, 1023UL> &>const __decay_and_strip<array<signed short, 1023UL> &> &__decay_and_strip<array<signed short, 1024UL> &>__decay_and_strip<array<signed short, 1024UL> &> &__decay_and_strip<array<signed short, 1024UL> &> &&const __decay_and_strip<array<signed short, 1024UL> &>const __decay_and_strip<array<signed short, 1024UL> &> &remove_reference<array<signed short, 1023UL> &>remove_reference<array<signed short, 1023UL> &> &remove_reference<array<signed short, 1023UL> &> &&const remove_reference<array<signed short, 1023UL> &>const remove_reference<array<signed short, 1023UL> &> &remove_reference<array<signed short, 1024UL> &>remove_reference<array<signed short, 1024UL> &> &remove_reference<array<signed short, 1024UL> &> &&const remove_reference<array<signed short, 1024UL> &>const remove_reference<array<signed short, 1024UL> &> &_Optional_payload<Encoding, true, true, true> *is_trivially_copy_assignable<Encoding>is_trivially_copy_assignable<Encoding> &is_trivially_copy_assignable<Encoding> &&const is_trivially_copy_assignable<Encoding>const is_trivially_copy_assignable<Encoding> &is_trivially_move_assignable<Encoding>is_trivially_move_assignable<Encoding> &is_trivially_move_assignable<Encoding> &&const is_trivially_move_assignable<Encoding>const is_trivially_move_assignable<Encoding> &__strip_reference_wrapper<array<signed short, 1024UL>>__strip_reference_wrapper<array<signed short, 1024UL>> &__strip_reference_wrapper<array<signed short, 1024UL>> &&const __strip_reference_wrapper<array<signed short, 1024UL>>const __strip_reference_wrapper<array<signed short, 1024UL>> &__strip_reference_wrapper<array<signed short, 1023UL>>__strip_reference_wrapper<array<signed short, 1023UL>> &__strip_reference_wrapper<array<signed short, 1023UL>> &&const __strip_reference_wrapper<array<signed short, 1023UL>>const __strip_reference_wrapper<array<signed short, 1023UL>> &__strip_reference_wrapper<vector<int, allocator<int>>>__strip_reference_wrapper<vector<int, allocator<int>>> &__strip_reference_wrapper<vector<int, allocator<int>>> &&const __strip_reference_wrapper<vector<int, allocator<int>>>const __strip_reference_wrapper<vector<int, allocator<int>>> &is_same<vector<int, allocator<int>>, _U2>is_same<optional<Encoding>, type>_Is_swappableis_same<array<signed short, 1024UL>, _U2>is_same<array<signed short, 1023UL>, _U1>__is_trivially_move_constructible_impl<Encoding, true>__is_trivially_move_constructible_impl<Encoding, true> &__is_trivially_move_constructible_impl<Encoding, true> &&const __is_trivially_move_constructible_impl<Encoding, true>const __is_trivially_move_constructible_impl<Encoding, true> &__is_trivially_copy_constructible_impl<Encoding, true>__is_trivially_copy_constructible_impl<Encoding, true> &__is_trivially_copy_constructible_impl<Encoding, true> &&const __is_trivially_copy_constructible_impl<Encoding, true>const __is_trivially_copy_constructible_impl<Encoding, true> &__is_move_constructible_impl<Encoding, true>__is_move_constructible_impl<Encoding, true> &__is_move_constructible_impl<Encoding, true> &&const __is_move_constructible_impl<Encoding, true>const __is_move_constructible_impl<Encoding, true> &__is_move_assignable_impl<Encoding, true>__is_move_assignable_impl<Encoding, true> &__is_move_assignable_impl<Encoding, true> &&const __is_move_assignable_impl<Encoding, true>const __is_move_assignable_impl<Encoding, true> &__is_copy_constructible_impl<Encoding, true>__is_copy_constructible_impl<Encoding, true> &__is_copy_constructible_impl<Encoding, true> &&const __is_copy_constructible_impl<Encoding, true>const __is_copy_constructible_impl<Encoding, true> &__is_copy_assignable_impl<Encoding, true>__is_copy_assignable_impl<Encoding, true> &__is_copy_assignable_impl<Encoding, true> &&const __is_copy_assignable_impl<Encoding, true>const __is_copy_assignable_impl<Encoding, true> &__and_<is_destructible<Encoding>, integral_constant<bool, true>>__and_<is_destructible<Encoding>, integral_constant<bool, true>> &__and_<is_destructible<Encoding>, integral_constant<bool, true>> &&const __and_<is_destructible<Encoding>, integral_constant<bool, true>>const __and_<is_destructible<Encoding>, integral_constant<bool, true>> &_Optional_payload_base<Encoding> *allocator<int> &&const _Optional_payload_base<Encoding> *is_destructible<Encoding>is_destructible<Encoding> &is_destructible<Encoding> &&const is_destructible<Encoding>const is_destructible<Encoding> &is_assignable<Encoding &, const Encoding &>is_assignable<Encoding &, const Encoding &> &is_assignable<Encoding &, const Encoding &> &&const is_assignable<Encoding &, const Encoding &>const is_assignable<Encoding &, const Encoding &> &is_constructible<Encoding, const Encoding &>is_constructible<Encoding, const Encoding &> &is_constructible<Encoding, const Encoding &> &&const is_constructible<Encoding, const Encoding &>const is_constructible<Encoding, const Encoding &> &conditional<true, is_copy_assignable<Encoding>, is_copy_constructible<Encoding>>conditional<true, is_copy_assignable<Encoding>, is_copy_constructible<Encoding>> &conditional<true, is_copy_assignable<Encoding>, is_copy_constructible<Encoding>> &&const conditional<true, is_copy_assignable<Encoding>, is_copy_constructible<Encoding>>const conditional<true, is_copy_assignable<Encoding>, is_copy_constructible<Encoding>> &is_assignable<Encoding &, Encoding &&>Encoding &&is_assignable<Encoding &, Encoding &&> &is_assignable<Encoding &, Encoding &&> &&const is_assignable<Encoding &, Encoding &&>const is_assignable<Encoding &, Encoding &&> &is_constructible<Encoding, Encoding &&>is_constructible<Encoding, Encoding &&> &is_constructible<Encoding, Encoding &&> &&const is_constructible<Encoding, Encoding &&>const is_constructible<Encoding, Encoding &&> &conditional<true, is_move_assignable<Encoding>, is_move_constructible<Encoding>>conditional<true, is_move_assignable<Encoding>, is_move_constructible<Encoding>> &conditional<true, is_move_assignable<Encoding>, is_move_constructible<Encoding>> &&const conditional<true, is_move_assignable<Encoding>, is_move_constructible<Encoding>>const conditional<true, is_move_assignable<Encoding>, is_move_constructible<Encoding>> &__and_<is_copy_constructible<Encoding>, integral_constant<bool, true>>__and_<is_copy_constructible<Encoding>, integral_constant<bool, true>> &__and_<is_copy_constructible<Encoding>, integral_constant<bool, true>> &&const __and_<is_copy_constructible<Encoding>, integral_constant<bool, true>>const __and_<is_copy_constructible<Encoding>, integral_constant<bool, true>> &__is_referenceable<Encoding>__is_referenceable<Encoding> &__is_referenceable<Encoding> &&const __is_referenceable<Encoding>const __is_referenceable<Encoding> &__and_<is_move_constructible<Encoding>, integral_constant<bool, true>>__and_<is_move_constructible<Encoding>, integral_constant<bool, true>> &__and_<is_move_constructible<Encoding>, integral_constant<bool, true>> &&const __and_<is_move_constructible<Encoding>, integral_constant<bool, true>>const __and_<is_move_constructible<Encoding>, integral_constant<bool, true>> &__is_swappable<signed char>__is_nothrow_swappable<signed char>__is_swappable<signed short>__is_nothrow_swappable<signed short>remove_const<Encoding>remove_const<Encoding> &remove_const<Encoding> &&const remove_const<Encoding>const remove_const<Encoding> &__is_trivially_move_assignable_impl<Encoding, true>__is_trivially_move_assignable_impl<Encoding, true> &__is_trivially_move_assignable_impl<Encoding, true> &&const __is_trivially_move_assignable_impl<Encoding, true>const __is_trivially_move_assignable_impl<Encoding, true> &__is_trivially_copy_assignable_impl<Encoding, true>__is_trivially_copy_assignable_impl<Encoding, true> &__is_trivially_copy_assignable_impl<Encoding, true> &&const __is_trivially_copy_assignable_impl<Encoding, true>const __is_trivially_copy_assignable_impl<Encoding, true> &_Storage<Encoding, true> *conditional<true, integral_constant<bool, true>, is_destructible<Encoding>>conditional<true, integral_constant<bool, true>, is_destructible<Encoding>> &conditional<true, integral_constant<bool, true>, is_destructible<Encoding>> &&const conditional<true, integral_constant<bool, true>, is_destructible<Encoding>>const conditional<true, integral_constant<bool, true>, is_destructible<Encoding>> &remove_reference<allocator<int> &>remove_reference<allocator<int> &> &remove_reference<allocator<int> &> &&const remove_reference<allocator<int> &>const remove_reference<allocator<int> &> &conditional<true, integral_constant<bool, true>, is_copy_constructible<Encoding>>conditional<true, integral_constant<bool, true>, is_copy_constructible<Encoding>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<Encoding>> &&const conditional<true, integral_constant<bool, true>, is_copy_constructible<Encoding>>const conditional<true, integral_constant<bool, true>, is_copy_constructible<Encoding>> &conditional<true, integral_constant<bool, true>, is_move_constructible<Encoding>>conditional<true, integral_constant<bool, true>, is_move_constructible<Encoding>> &conditional<true, integral_constant<bool, true>, is_move_constructible<Encoding>> &&const conditional<true, integral_constant<bool, true>, is_move_constructible<Encoding>>const conditional<true, integral_constant<bool, true>, is_move_constructible<Encoding>> &_My_handlerconst type_info *&type_info *&const _Functor &const _Hash_node<_Value, true>const _Hash_node<_Value, true> */home/tanteikg/QCVE/sources/bitcoin/src/bench/nanobench.h<linux/version.h>PerformanceCounters &performanceCountersdoNotOptimizeAwaymoveResultTovector<Result, allocator<Result>> &const PerformanceCountersconst PerformanceCounters &numIters~IterationLogicIterationLogic &const IterationLogicconst IterationLogic &IterationLogicIterationLogic &&const Benchconst Bench &Bench &pyperfhtmlBoxplotcsvconst vector<BigO, allocator<BigO>>const vector<BigO, allocator<BigO>> &vector<BigO, allocator<BigO>> &const BigOconst BigO &BigO &renderconst vector<Result, allocator<Result>>const vector<Result, allocator<Result>> &rotl64UstateContainerContainer &uniform01Rng *0x3ff52U4607182418800017408(UINT64_C(0x3ff) << 52U)12U}sizeof(double)boundedr32multiresult32U15241094284759029579Rngconst vector<unsigned long, allocator<unsigned long>>const vector<unsigned long, allocator<unsigned long>> &vector<unsigned long, allocator<unsigned long>> &~RngRng &Rng &&const Rngconst Rng &(std::numeric_limits<uint64_t>::max)()const Configconst Config &Config &configcomplexityBigOOpcomplexityNresultsrelativewarmupepochIterationsminEpochIterationsminEpochTimemaxEpochTimeepochsclockResolutionMultipleostream *timeUnittimeUnitNameunitbatchclearContextcontextiterationLogicBench *beforeafterOp &&run~BenchBenchBench &&ConfigConfig &&~ConfigBigO &&~BigOBigOnormalizedRootMeanSquareconstantconst RangeMeasureconst RangeMeasure &vector<pair<double, double>, allocator<pair<double, double>>> &collectRangeMeasuremapRangeMeasurefromStringhasmaximumminimumsumProductsumaveragemedianAbsolutePercentErrorconst PerfCountSet<bool>const PerfCountSet<bool> &PerfCountSet<bool> &const PerfCountSet<unsigned long>const PerfCountSet<unsigned long> &PerfCountSet<unsigned long> &updateResultsendMeasurebeginMeasure~PerformanceCountersPerformanceCountersPerformanceCounters &&ResultResult &&const Resultconst Result &Result &~ResultImplPerfCountSet<T>LinuxPerformanceCountersMeasureelapsediterationspagefaultscpucyclescontextswitchesinstructionsbranchinstructionsbranchmissesClockImpl *mPimplbranchMissesbranchInstructionscontextSwitchescpuCyclespageFaultsmYmXmResultsmConfigmContextmIsRelativemShowPerformanceCountersmTimeUnitNamens"ns"mTimeUnitmOutmWarmupmEpochIterationsmMinEpochIterationsmMinEpochTimeconst duration<signed long, ratio<1L, 1000L>> &duration<signed long, ratio<1L, 1000L>> &mMaxEpochTimemClockResolutionMultiplestatic_cast<size_t>(1000)mNumEpochsmComplexityNmBatch 1.0;                                                     // NOLINT(misc-non-private-member-variables-in-classes)
    double mComplexityN = -1.0;                                              // NOLINT(misc-non-private-member-variables-in-classes)
    size_t mNumEpochs = 11;                                                  // NOLINT(misc-non-private-member-variables-in-classes)
    size_t mClockResolutionMultiple = static_cast<size_t>(1000);             // NOLINT(misc-non-private-member-variables-in-classes)
    std::chrono::nanoseconds mMaxEpochTime = std::chrono::milliseconds(100); // NOLINT(misc-non-private-member-variables-in-classes)
    std::chrono::nanoseconds mMinEpochTime = std::chrono::milliseconds(1);   // NOLINT(misc-non-private-member-variables-in-classes)
    uint64_t mMinEpochIterations{1};                                         // NOLINT(misc-non-private-member-variables-in-classes)
    // If not 0, run *exactly* these number of iterations per epoch.
    uint64_t mEpochIterations{0};                                          // NOLINT(misc-non-private-member-variables-in-classes)
    uint64_t mWarmup = 0;                                                  // NOLINT(misc-non-private-member-variables-in-classes)
    std::ostream* mOut = nullptr;                                          // NOLINT(misc-non-private-member-variables-in-classes)
    std::chrono::duration<double> mTimeUnit = std::chrono::nanoseconds{1}; // NOLINT(misc-non-private-member-variables-in-classes)
    std::string mTimeUnitName = "ns";                                      // NOLINT(misc-non-private-member-variables-in-classes)
    bool mShowPerformanceCounters = true;                                  // NOLINT(misc-non-private-member-variables-in-classes)
    bool mIsRelative = false;                                              // NOLINT(misc-non-private-member-variables-in-classes)
    std::unordered_map<std::string, std::string> mContext{};               // NOLINT(misc-non-private-member-variables-in-classes)

    Config();
    ~Config();
    Config& operator=(Config const& other);
    Config& operator=(Config&& other) noexcept;
    Config(Config const& other);
    Config(Config&& other)mUnitop"op"mBenchmarkNamenoname"noname"mBenchmarkTitlebenchmark"benchmark"mNormalizedRootMeanSquaremConstantmNamemHasmValLinuxPerformanceCounters *mPcmNameToMeasurementsANKERL_NANOBENCH_IS_TRIVIALLY_COPYABLE(__VA_ARGS__...)std::is_trivially_copyable<__VA_ARGS__>::valueANKERL_NANOBENCH_PRIVATE_NOINLINE()__attribute__((noinline))ANKERL_NANOBENCH_NO_SANITIZE(__VA_ARGS__...)ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERS()ANKERL_NANOBENCH_PRIVATE_PERF_COUNTERSANKERL_NANOBENCH_LOG(x)do { } while (0)ANKERL_NANOBENCH_PRIVATE_IGNORE_EFFCPP_POP()_Pragma("GCC diagnostic pop")ANKERL_NANOBENCH_PRIVATE_IGNORE_EFFCPP_PUSH()_Pragma("GCC diagnostic push") _Pragma("GCC diagnostic ignored \"-Weffc++\"")ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_POP()ANKERL_NANOBENCH_PRIVATE_IGNORE_PADDED_PUSH()ANKERL_NANOBENCH_PRIVATE_NODISCARD()[[nodiscard]]ANKERL_NANOBENCH_PRIVATE_CXX17()ANKERL_NANOBENCH_PRIVATE_CXX14()ANKERL_NANOBENCH_PRIVATE_CXX11()201103LANKERL_NANOBENCH_PRIVATE_CXX98()199711LANKERL_NANOBENCH_PRIVATE_CXX()ANKERL_NANOBENCH(x)ANKERL_NANOBENCH_PRIVATE_ ## x()ANKERL_NANOBENCH_VERSION_PATCHANKERL_NANOBENCH_VERSION_MINORANKERL_NANOBENCH_VERSION_MAJORANKERL_NANOBENCH_H_INCLUDEDankerlnanobenchtemplatesANKERL_NANOBENCH(CXX) >= ANKERL_NANOBENCH(CXX17)/home/tanteikg/QCVE/sources/bitcoin/src/benchbenchmarkNamebigONamerangeMeasurerangeToNdefined(__GNUC__)defined(ANKERL_NANOBENCH_LOG_ENABLED)defined(__linux__) && !defined(ANKERL_NANOBENCH_DISABLE_PERF_COUNTERS)LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)defined(_MSC_VER)defined(__GNUC__) && __GNUC__ < 5ANKERL_NANOBENCH(PERF_COUNTERS)defined(ANKERL_NANOBENCH_IMPLEMENT)defined(__linux__)defined(DEBUG)defined(PERF_FLAG_FD_CLOEXEC)"integer""integer", "undefined"NODISCARDIGNORE_PADDED_POPPERF_COUNTERSIGNORE_PADDED_PUSHIGNORE_EFFCPP_POPIGNORE_EFFCPP_PUSHNOINLINE__linux__CXX17CXX// ANKERL_NANOBENCH_H_INCLUDED// ANKERL_NANOBENCH_IMPLEMENT// namespace ankerl// namespace nanobench// calculate root mean square// estimate the constant factor// only internally used to copy the RNG.// Seeded as described in romu paper (update april 2020)// Sets the maximum time each epoch should take. Default is 100ms.// Desired evaluation time is a multiple of clock resolution. Default is to be 1000 times above this measurement precision.// Number of epochs to evaluate. The reported result will be the median of evaluation of each epoch.// If benchmarkTitle differs from currently set title, the stored results will be cleared.// Use singular (byte, not bytes).// If u differs from currently set unit, the stored results will be cleared.// Operation unit. Defaults to "op", could be e.g. "byte" for string processing.// means it is slower than the baseline.// Set a baseline to compare it to. 100% it is exactly as fast as the baseline, >100% means it is faster than the baseline, <100%// Configuration of a microbenchmark.// not found, return _size// here its save to assume that at least one element is there// transform the data to absolute error// see https://www.spiderfinancial.com/support/documentation/numxl/reference-manual/forecasting-performance/mdape// calculates MdAPE which is the median of percentage error// create copy// create a copy so we can sort// assuming at least one missed branch for the loop// can't have branch misses when there were branches...// correcting branch misses// correcting branches: remove branch introduced by the while (...) loop for each iteration.// Result returned after a benchmark has finished. Can be used as a baseline for relative().// provide implementation here so it's only generated once// namespace fmt// Formats any text as markdown code, escaping backticks.// sets back all stream info that we remembered at construction// RAII to save & restore a stream's state// adds thousands separator to numbers// formatting utilities// no need to check for nullptr, delete nullptr has no effect// something failed, don't monitor anything.// mHas.branchMisses = false;// prepare readformat with the correct size (after the insert)// insert into map, rely on the fact that map's references are constant.// couldn't get id// NOLINTNEXTLINE(hicpp-signed-bitwise,cppcoreguidelines-pro-type-vararg)// first call: set to fd, and use this from now on// NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg)// since Linux 3.14// all CPUs// the current process// NOLINTNEXTLINE(hicpp-signed-bitwise)// start counter as disabled// clear old data// overflow is ok, it's checked// start with minimum size of 3 for read_format// factor 2 because we have two instructions per loop// we now run *twice* so we can easily calculate the overhead// see https://godbolt.org/z/49RVQ5// This has the nice property that the compiler doesn't seem to be able to optimize multiple calls any further.// marsaglia's xorshift: mov, sal/shr, xor. Times 3.// calibrate loop overhead. For branches & instructions this makes sense, not so much for everything else like cycles.// create new calibration data// clear current calibration data,// rounded integer division// we subtract data ourselves.// Just reading data is faster than enable & disabling.// quick operation// NOLINT(misc-non-private-member-variables-in-classes)// NOLINTNEXTLINE(bugprone-incorrect-roundings)// no result yet, print header// combine all elements that are relevant for printing the header// write everything// prepare column data ///////// NOLINTNEXTLINE(readability-function-cognitive-complexity)// we got all the results that we need, finish it// that fluctuation, or else we would bias the result// just add measurements - no questions asked. Even when runtime is low. But we can't ignore// if we are close enough, add measurement and switch to always measuring// not close enough: switch to upscaling// still, we don't add the result to the measurements.// if elapsed is close enough, we can skip upscaling and go right to measurements// overflow :-(// we are far below the target runtime. Multiply iterations by 10 (with overflow check)// +0.5 for correct rounding when casting// directly calculates new iters based on elapsed&iters, and adds a 10% noise. Makes sure we don't underflow.// exact number of iterations// determine target runtime per epoch// Calculates clock resolution once, and remembers the result// determines resolution of the given clock. This is done by measuring multiple times and returning the minimum time difference.// remembers the last table settings used. When it changes, a new table header is automatically written for the new entry.// check frequency scaling// True when environment variable NANOBENCH_SUPPRESS_WARNINGS is either not set at all, or set to "0"// NOLINT(concurrency-mt-unsafe)// getenv': This function or variable may be unsafe.// NOLINT(misc-const-correctness)// see https://docs.microsoft.com/en-us/cpp/preprocessor/optimize// see https://github.com/facebook/folly/blob/master/folly/Benchmark.h#L280// see https://github.com/google/benchmark/blob/master/include/benchmark/benchmark.h#L307// Windows version of doNotOptimizeAway// This just uses the last result's config.// result & config are both supported there// when we only have a single result, we can immediately go into its measurement.// implementation /////////////////////////////////////////////////////////////////////////////////// helper replacement for std::to_string of signed/unsigned numbers so we are locale independent// Number formatter// don't allow copying / moving// helper stuff that only intended to be used internally// namespace templates// nothing matches :(// static std::regex const regOpArg2("^([a-zA-Z]+)\\(([a-zA-Z]*)\\s*,\\s+([a-zA-Z]*)\\)$");// match e.g. "sumProduct(elapsed, iterations)"// if (std::regex_match(n.begin, n.end, matchResult, regOpArg1)) {// std::cmatch matchResult;// static std::regex const regOpArg1("^([a-zA-Z]+)\\(([a-zA-Z]*)\\)$");// g++ 4.8 doesn't implement std::regex :(// match e.g. "median(elapsed)"// no whitespace no comma, append// got a comma => new string// skip whitespace// split by comma// NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-pointer-arithmetic)// finished! bail out// we found a tag// nothing found, finish node// NOLINTNEXTLINE(misc-no-recursion)// NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-array-to-pointer-decay)// NOLINTNEXTLINE(hicpp-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)// helpers to get double values// definitions ////////////////////////////////////////////////////////////////////////////////////// helper stuff that is only intended to be used internally// declarations ///////////////////////////////////////////////////////////////////////////////////// map//sysconf// std::tie// throw for rendering templates// to_s in Number// random_device// accumulate// cout// setw, setprecision// ifstream to parse proc files// strstr, strncmp// getenv// compare_exchange_strong in loop overhead// sort, reverse///////////////////////////////////////////////////////////////////////////////////////////////////// implementation part - only visible in .cpp// Makes sure none of the given arguments are optimized away by the compiler.// Convenience: makes sure none of the given arguments are optimized away by the compiler.// Sets the computation complexity of the next run. Any argument is cast to double.// Any argument is cast to double.// Set the batch size, e.g. number of processed bytes, or some other metric for the size of the processed data in each iteration.// Performs all evaluations.// It is important that this method is kept short so the compiler can do better optimizations/ inlining of op()// using decltype(i) instead of size_t to be compatible to containers with 32bit index (see #80)// std::memcpy is optimized anyways.// can't use union in c++ here for type puning, it's undefined behavior.// Gets the singleton// having to include <memory>, and the template instantiation overhead of unique_ptr which is unfortunately quite significant.// Not movable/copy-able, so we simply use a pointer instead of unique_ptr. This saves us from// internally used, but visible because run() is templated.// NOLINTNEXTLINE(hicpp-no-assembler)// this seemed to have compilation problems in some cases. Google Benchmark seemed to be the most well tested anyways.// These assembly magic is directly from what Google Benchmark is doing. I have previously used what facebook's folly was doing, but/**
 * @brief Makes sure none of the given arguments are optimized away by the compiler.
 *
 * @tparam Arg Type of the argument that shouldn't be optimized away.
 * @param arg The input that we mark as being used, even though we don't do anything with it.
 *//*!
      @verbatim embed:rst

      Convenience shortcut to :cpp:func:`ankerl::nanobench::render`.

      @endverbatim
     *//**
     * @brief Calculates bigO for a custom function.
     *
     * E.g. to calculate the mean squared error for @f$ \mathcal{O}(\log{}\log{}n) @f$, which is not part of the default set of
     * complexityBigO(), you can do this:
     *
     * ```
     * auto logLogN = bench.complexityBigO("O(log log n)", [](double n) {
     *     return std::log2(std::log2(n));
     * });
     * ```
     *
     * The resulting mean squared error can be printed with `std::cout << logLogN`. E.g. it prints something like this:
     *
     * ```text
     * 2.46985e-05 * O(log log n), rms=1.48121
     * ```
     *
     * @tparam Op Type of mapping operation.
     * @param name Name for the function, e.g. "O(log log n)"
     * @param op Op's operator() maps a `double` with the desired complexity function, e.g. `log2(log2(n))`.
     * @return BigO Error calculation, which is streamable to std::cout.
     *//*!
      Calculates [Big O](https://en.wikipedia.org/wiki/Big_O_notation>) of the results with all preconfigured complexity functions.
      Currently these complexity functions are fitted into the benchmark results:

       @f$ \mathcal{O}(1) @f$,
       @f$ \mathcal{O}(n) @f$,
       @f$ \mathcal{O}(\log{}n) @f$,
       @f$ \mathcal{O}(n\log{}n) @f$,
       @f$ \mathcal{O}(n^2) @f$,
       @f$ \mathcal{O}(n^3) @f$.

      If we e.g. evaluate the complexity of `std::sort`, this is the result of `std::cout << bench.complexityBigO()`:

      ```
      |   coefficient |   err% | complexity
      |--------------:|-------:|------------
      |   5.08935e-09 |   2.6% | O(n log n)
      |   6.10608e-08 |   8.0% | O(n)
      |   1.29307e-11 |  47.2% | O(n^2)
      |   2.48677e-15 |  69.6% | O(n^3)
      |   9.88133e-06 | 132.3% | O(log n)
      |   5.98793e-05 | 162.5% | O(1)
      ```

      So in this case @f$ \mathcal{O}(n\log{}n) @f$ provides the best approximation.

      @verbatim embed:rst
      See the tutorial :ref:`asymptotic-complexity` for details.
      @endverbatim
      @return Evaluation results, which can be printed or otherwise inspected.
     *//*!
      @verbatim embed:rst

      Sets N for asymptotic complexity calculation, so it becomes possible to calculate `Big O
      <https://en.wikipedia.org/wiki/Big_O_notation>`_ from multiple benchmark evaluations.

      Use :cpp:func:`ankerl::nanobench::Bench::complexityBigO` when the evaluation has finished. See the tutorial
      :ref:`asymptotic-complexity` for details.

      @endverbatim

      @tparam T Any type is cast to `double`.
      @param n Length of N for the next benchmark run, so it is possible to calculate `bigO`.
     *//*!
      @verbatim embed:rst

      Convenience shortcut to :cpp:func:`ankerl::nanobench::doNotOptimizeAway`.

      @endverbatim
     *//**
     * @brief Retrieves all benchmark results collected by the bench object so far.
     *
     * Each call to run() generates a Result that is stored within the Bench instance. This is mostly for advanced users who want to
     * see all the nitty gritty details.
     *
     * @return All results collected so far.
     *//**
     * @brief Enables/disables performance counters.
     *
     * On Linux nanobench has a powerful feature to use performance counters. This enables counting of retired instructions, count
     * number of branches, missed branches, etc. On default this is enabled, but you can disable it if you don't need that feature.
     *
     * @param showPerformanceCounters True to enable, false to disable.
     *//**
     * @brief Marks the next run as the baseline.
     *
     * Call `relative(true)` to mark the run as the baseline. Successive runs will be compared to this run. It is calculated by
     *
     * @f[
     * 100\% * \frac{baseline}{runtime}
     * @f]
     *
     *  * 100% means it is exactly as fast as the baseline
     *  * >100% means it is faster than the baseline. E.g. 200% means the current run is twice as fast as the baseline.
     *  * <100% means it is slower than the baseline. E.g. 50% means it is twice as slow as the baseline.
     *
     * See the tutorial section "Comparing Results" for example usage.
     *
     * @param isRelativeEnabled True to enable processing
     *//**
     * @brief Sets a number of iterations that are initially performed without any measurements.
     *
     * Some benchmarks need a few evaluations to warm up caches / database / whatever access. Normally this should not be needed, since
     * we show the median result so initial outliers will be filtered away automatically. If the warmup effect is large though, you
     * might want to set it. Default is 0.
     *
     * @param numWarmupIters Number of warmup iterations.
     *//**
     * Sets exactly the number of iterations for each epoch. Ignores all other epoch limits. This forces nanobench to use exactly
     * the given number of iterations for each epoch, not more and not less. Default is 0 (disabled).
     *
     * @param numIters Exact number of iterations to use. Set to 0 to disable.
     *//**
     * @brief Sets the minimum number of iterations each epoch should take.
     *
     * Default is 1, and we rely on clockResolutionMultiple(). If the `err%` is high and you want a more smooth result, you might want
     * to increase the minimum number of iterations, or increase the minEpochTime().
     *
     * @see minEpochTime, maxEpochTime, minEpochIterations
     *
     * @param numIters Minimum number of iterations per epoch.
     *//**
     * @brief Minimum time each epoch should take.
     *
     * Default is zero, so we are fully relying on clockResolutionMultiple(). In most cases this is exactly what you want. If you see
     * that the evaluation is unreliable with a high `err%`, you can increase either minEpochTime() or minEpochIterations().
     *
     * @see maxEpochTim), minEpochIterations
     *
     * @param t Minimum time each epoch should take.
     *//**
     * @brief Upper limit for the runtime of each epoch.
     *
     * As a safety precaution if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per
     * epoch. Default is 100ms. At least a single evaluation of the benchmark is performed.
     *
     * @see minEpochTime, minEpochIterations
     *
     * @param t Maximum target runtime for a single epoch.
     *//**
     * @brief Controls number of epochs, the number of measurements to perform.
     *
     * The reported result will be the median of evaluation of each epoch. The higher you choose this, the more
     * deterministic the result be and outliers will be more easily removed. Also the `err%` will be more accurate the higher this
     * number is. Note that the `err%` will not necessarily decrease when number of epochs is increased. But it will be a more accurate
     * representation of the benchmarked code's runtime stability.
     *
     * Choose the value wisely. In practice, 11 has been shown to be a reasonable choice between runtime performance and accuracy.
     * This setting goes hand in hand with minEpochIterations() (or minEpochTime()). If you are more interested in *median* runtime,
     * you might want to increase epochs(). If you are more interested in *mean* runtime, you might want to increase
     * minEpochIterations() instead.
     *
     * @param numEpochs Number of epochs.
     *//**
     * Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This is the main trick nanobech to
     * be so fast: we find out how accurate the clock is, then run the benchmark only so often that the clock's accuracy is good enough
     * for accurate measurements.
     *
     * The default is to run one epoch for 1000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total
     * runtime of
     *
     * @f[
     * 20ns * 1000 * 11 \approx 0.2ms
     * @f]
     *
     * To be precise, nanobench adds a 0-20% random noise to each evaluation. This is to prevent any aliasing effects, and further
     * improves accuracy.
     *
     * Total runtime will be higher though: Some initial time is needed to find out the target number of iterations for each epoch, and
     * there is some overhead involved to start & stop timers and calculate resulting statistics and writing the output.
     *
     * @param multiple Target number of times of clock resolution. Usually 1000 is a good compromise between runtime and accuracy.
     *//**
     * @brief Set the output stream where the resulting markdown table will be printed to.
     *
     * The default is `&std::cout`. You can disable all output by setting `nullptr`.
     *
     * @param outstream Pointer to output stream, can be `nullptr`.
     *//**
     * @brief Sets the time unit to be used for the default output.
     *
     * Nanobench defaults to using ns (nanoseconds) as output in the markdown. For some benchmarks this is too coarse, so it is
     * possible to configure this. E.g. use `timeUnit(1ms, "ms")` to show `ms/op` instead of `ns/op`.
     *
     * @param tu Time unit to display the results in, default is 1ns.
     * @param tuName Name for the time unit, default is "ns"
     *//**
     * @brief Sets the operation unit.
     *
     * Defaults to "op". Could be e.g. "byte" for string processing. This is used for the table header, e.g. to show `ns/byte`. Use
     * singular (*byte*, not *bytes*). A change clears the currently collected results.
     *
     * @param unit The unit name.
     *//**
     * @brief Sets the batch size.
     *
     * E.g. number of processed byte, or some other metric for the size of the processed data in each iteration. If you benchmark
     * hashing of a 1000 byte long string and want byte/sec as a result, you can specify 1000 as the batch size.
     *
     * @tparam T Any input type is internally cast to `double`.
     * @param b batch size
     *//**
     * @brief Reset context information.
     *
     * This may improve efficiency when using many context entries,
     * or improve robustness by removing spurious context entries.
     *
     * @see context
     *//**
     * @brief Set context information.
     *
     * The information can be accessed using custom render templates via `{{context(variableName)}}`.
     * Trying to render a variable that hasn't been set before raises an exception.
     * Not included in (default) markdown table.
     *
     * @see clearContext, render
     *
     * @param variableName The name of the context variable.
     * @param variableValue The value of the context variable.
     *//// Name of the benchmark, will be shown in the table row./**
     * @brief Gets the title of the benchmark
     *//**
     * @brief Title of the benchmark, will be shown in the table header. Changing the title will start a new markdown table.
     *
     * @param benchmarkTitle The title of the benchmark.
     *//**
     * @brief Same as run(char const* benchmarkName, Op op), but instead uses the previously set name.
     * @tparam Op The code to benchmark.
     *//*!
      @brief Repeatedly calls `op()` based on the configuration, and performs measurements.

      This call is marked with `noinline` to prevent the compiler to optimize beyond different benchmarks. This can have quite a big
      effect on benchmark accuracy.

      @verbatim embed:rst
      .. note::

        Each call to your lambda must have a side effect that the compiler can't possibly optimize it away. E.g. add a result to an
        externally defined number (like `x` in the above example), and finally call `doNotOptimizeAway` on the variables the compiler
        must not remove. You can also use :cpp:func:`ankerl::nanobench::doNotOptimizeAway` directly in the lambda, but be aware that
        this has a small overhead.

      @endverbatim

      @tparam Op The code to benchmark.
     *//**
     * @brief Creates a new benchmark for configuration and running of benchmarks.
     *//**
 * @brief Main entry point to nanobench's benchmarking facility.
 *
 * It holds configuration and results from one or more benchmark runs. Usually it is used in a single line, where the object is
 * constructed, configured, and then a benchmark is run. E.g. like this:
 *
 *     ankerl::nanobench::Bench().unit("byte").batch(1000).run("random fluctuations", [&] {
 *         // here be the benchmark code
 *     });
 *
 * In that example Bench() constructs the benchmark, it is then configured with unit() and batch(), and after configuration a
 * benchmark is executed with run(). Once run() has finished, it prints the result to `std::cout`. It would also store the results
 * in the Bench instance, but in this case the object is immediately destroyed so it's not available any more.
 *//**
     * Extracts the full state of the generator, e.g. for serialization. For this RNG this is just 2 values, but to stay API compatible
     * with future implementations that potentially use more state, we use a vector.
     *
     * @return Vector containing the full state:
     *//**
     * Shuffles all entries in the given container. Although this has a slight bias due to the implementation of bounded(), this is
     * preferable to `std::shuffle` because it is over 5 times faster. See Daniel Lemire's blog post [Fast random
     * shuffling](https://lemire.me/blog/2016/06/30/fast-random-shuffling/).
     *
     * @param container The whole container will be shuffled.
     *//**
     * Provides a random uniform double value between 0 and 1. This uses the method described in [Generating uniform doubles in the
     * unit interval](http://prng.di.unimi.it/), and is extremely fast.
     *
     * @return double Uniformly distributed double value in range [0,1(, excluding 1.
     */// see http://prng.di.unimi.it/// random double in range [0, 1(/**
     * Generates a random number between 0 and range (excluding range).
     *
     * The algorithm only produces 32bit numbers, and is slightly biased. The effect is quite small unless your range is close to the
     * maximum value of an integer. It is possible to correct the bias with rejection sampling (see
     * [here](https://lemire.me/blog/2016/06/30/fast-random-shuffling/), but this is most likely irrelevant in practices for the
     * purposes of this Rng.
     *
     * See Daniel Lemire's blog post [A fast alternative to the modulo
     * reduction](https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/)
     *
     * @param range Upper exclusive range. E.g a value of 3 will generate random numbers 0, 1, 2.
     * @return uint32_t Generated random values in range [0, range(.
     */// This is slightly biased. See/**
     * @brief Produces a 64bit random value. This should be very fast, thus it is marked as inline. In my benchmark, this is ~46 times
     * faster than `std::default_random_engine` for producing 64bit random values. It seems that the fastest std contender is
     * `std::mt19937_64`. Still, this RNG is 2-3 times as fast.
     *
     * @return uint64_t The next 64 bit random value.
     *//**
     * Creates a copy of the Rng, thus the copy provides exactly the same random sequence as the original.
     *//*!
      Creates a new Rng that is seeded with a specific seed. Each Rng created from the same seed will produce the same randomness
      sequence. This can be useful for deterministic behavior.

      @verbatim embed:rst
      .. note::

         The random algorithm might change between nanobench releases. Whenever a faster and/or better random
         generator becomes available, I will switch the implementation.
      @endverbatim

      As per the Romu paper, this seeds the Rng with splitMix64 algorithm and performs 10 initial rounds for further mixing up of the
      internal state.

      @param seed  The 64bit seed. All values are allowed, even 0.
     *//**
     * @brief Creates a new Random generator with random seed.
     *
     * Instead of a default seed (as the random generators from the STD), this properly seeds the random generator from
     * `std::random_device`. It guarantees correct seeding. Note that seeding can be relatively slow, depending on the source of
     * randomness used. So it is best to create a Rng once and use it for all your randomness purposes.
     */// moving is ok/**
     * Same as Rng(Rng const&), we don't allow assignment. If you need a new Rng create one with the default constructor Rng().
     *//**
     * As a safety precaution, we don't allow copying. Copying a PRNG would mean you would have two random generators that produce the
     * same sequence, which is generally not what one wants. Instead create a new rng with the default constructor Rng(), which is
     * automatically seeded from `std::random_device`. If you really need a copy, use `copy()`.
     *//**
     * @brief This RNG provides 64bit randomness.
     *//**
 * An extremely fast random generator. Currently, this implements *RomuDuoJr*, developed by Mark Overton. Source:
 * http://www.romu-random.org/
 *
 * RomuDuoJr is extremely fast and provides reasonable good randomness. Not enough for large jobs, but definitely
 * good enough for a benchmarking framework.
 *
 *  * Estimated capacity: @f$ 2^{51} @f$ bytes
 *  * Register pressure: 4
 *  * State size: 128 bits
 *
 * This random generator is a drop-in replacement for the generators supplied by ``<random>``. It is not
 * cryptographically secure. It's intended purpose is to be very fast so that benchmarks that make use
 * of randomness are not distorted too much by the random generator.
 *
 * Rng also provides a few non-standard helpers, optimized for speed.
 */// Finds string, if not found, returns _size.// all values are scaled by iters (except iters...)// adds new measurement results// If not 0, run *exactly* these number of iterations per epoch.// actual benchmark config/*!
  @brief Template to generate JSON data.

  The generated JSON data contains *all* data that has been generated. All times are as double values, in seconds. The output can get
  quite large.
  @verbatim embed:rst
  See the tutorial at :ref:`tutorial-template-json` for an example.
  @endverbatim
 *//*!
 @brief Output in pyperf compatible JSON format, which can be used for more analyzation.
 @verbatim embed:rst
 See the tutorial at :ref:`tutorial-template-pyperf` for an example how to further analyze the output.
 @endverbatim
 *//*!
  @brief HTML output that uses plotly to generate an interactive boxplot chart. See the tutorial for an example output.

  The output uses only the elapsed wall clock time, and displays each epoch as a single dot.
  @verbatim embed:rst
  See the tutorial at :ref:`tutorial-template-html` for an example.
  @endverbatim

  @see also ankerl::nanobench::render()
 *//*!
  @brief CSV data for the benchmark results.

  Generates a comma-separated values dataset. First line is the header, each following line is a summary of each benchmark run.

  @verbatim embed:rst
  See the tutorial at :ref:`tutorial-template-csv` for an example.
  @endverbatim
 */// Contains mustache-like templates/**
 * Same as render(char const* mustacheTemplate, Bench const& bench, std::ostream& out), but for when
 * you only have results available.
 *
 * @param mustacheTemplate The template.
 * @param results All the results to be used for rendering.
 * @param out Output for the generated output.
 *//**
 * @brief Renders output from a mustache-like template and benchmark results.
 *
 * The templating facility here is heavily inspired by [mustache - logic-less templates](https://mustache.github.io/).
 * It adds a few more features that are necessary to get all of the captured data out of nanobench. Please read the
 * excellent [mustache manual](https://mustache.github.io/mustache.5.html) to see what this is all about.
 *
 * nanobench output has two nested layers, *result* and *measurement*.  Here is a hierarchy of the allowed tags:
 *
 * * `{{#result}}` Marks the begin of the result layer. Whatever comes after this will be instantiated as often as
 *   a benchmark result is available. Within it, you can use these tags:
 *
 *    * `{{title}}` See Bench::title.
 *
 *    * `{{name}}` Benchmark name, usually directly provided with Bench::run, but can also be set with Bench::name.
 *
 *    * `{{unit}}` Unit, e.g. `byte`. Defaults to `op`, see Bench::unit.
 *
 *    * `{{batch}}` Batch size, see Bench::batch.
 *
 *    * `{{complexityN}}` Value used for asymptotic complexity calculation. See Bench::complexityN.
 *
 *    * `{{epochs}}` Number of epochs, see Bench::epochs.
 *
 *    * `{{clockResolution}}` Accuracy of the clock, i.e. what's the smallest time possible to measure with the clock.
 *      For modern systems, this can be around 20 ns. This value is automatically determined by nanobench at the first
 *      benchmark that is run, and used as a static variable throughout the application's runtime.
 *
 *    * `{{clockResolutionMultiple}}` Configuration multiplier for `clockResolution`. See Bench::clockResolutionMultiple.
 *      This is the target runtime for each measurement (epoch). That means the more accurate your clock is, the faster
 *      will be the benchmark. Basing the measurement's runtime on the clock resolution is the main reason why nanobench is so fast.
 *
 *    * `{{maxEpochTime}}` Configuration for a maximum time each measurement (epoch) is allowed to take. Note that at least
 *      a single iteration will be performed, even when that takes longer than maxEpochTime. See Bench::maxEpochTime.
 *
 *    * `{{minEpochTime}}` Minimum epoch time, defaults to 1ms. See Bench::minEpochTime.
 *
 *    * `{{minEpochIterations}}` See Bench::minEpochIterations.
 *
 *    * `{{epochIterations}}` See Bench::epochIterations.
 *
 *    * `{{warmup}}` Number of iterations used before measuring starts. See Bench::warmup.
 *
 *    * `{{relative}}` True or false, depending on the setting you have used. See Bench::relative.
 *
 *    * `{{context(variableName)}}` See Bench::context.
 *
 *    Apart from these tags, it is also possible to use some mathematical operations on the measurement data. The operations
 *    are of the form `{{command(name)}}`.  Currently `name` can be one of `elapsed`, `iterations`. If performance counters
 *    are available (currently only on current Linux systems), you also have `pagefaults`, `cpucycles`,
 *    `contextswitches`, `instructions`, `branchinstructions`, and `branchmisses`. All the measures (except `iterations`) are
 *    provided for a single iteration (so `elapsed` is the time a single iteration took). The following tags are available:
 *
 *    * `{{median(<name>)}}` Calculate median of a measurement data set, e.g. `{{median(elapsed)}}`.
 *
 *    * `{{average(<name>)}}` Average (mean) calculation.
 *
 *    * `{{medianAbsolutePercentError(<name>)}}` Calculates MdAPE, the Median Absolute Percentage Error. The MdAPE is an excellent
 *      metric for the variation of measurements. It is more robust to outliers than the
 *      [Mean absolute percentage error (M-APE)](https://en.wikipedia.org/wiki/Mean_absolute_percentage_error).
 *      @f[
 *       \mathrm{MdAPE}(e) = \mathrm{med}\{| \frac{e_i - \mathrm{med}\{e\}}{e_i}| \}
 *      @f]
 *      E.g. for *elapsed*: First, @f$ \mathrm{med}\{e\} @f$ calculates the median by sorting and then taking the middle element
 *      of all *elapsed* measurements. This is used to calculate the absolute percentage
 *      error to this median for each measurement, as in  @f$ | \frac{e_i - \mathrm{med}\{e\}}{e_i}| @f$. All these results
 *      are sorted, and the middle value is chosen as the median absolute percent error.
 *
 *      This measurement is a bit hard to interpret, but it is very robust against outliers. E.g. a value of 5% means that half of the
 *      measurements deviate less than 5% from the median, and the other deviate more than 5% from the median.
 *
 *    * `{{sum(<name>)}}` Sum of all the measurements. E.g. `{{sum(iterations)}}` will give you the total number of iterations
*        measured in this benchmark.
 *
 *    * `{{minimum(<name>)}}` Minimum of all measurements.
 *
 *    * `{{maximum(<name>)}}` Maximum of all measurements.
 *
 *    * `{{sumProduct(<first>, <second>)}}` Calculates the sum of the products of corresponding measures:
 *      @f[
 *          \mathrm{sumProduct}(a,b) = \sum_{i=1}^{n}a_i\cdot b_i
 *      @f]
 *      E.g. to calculate total runtime of the benchmark, you multiply iterations with elapsed time for each measurement, and
 *      sum these results up:
 *      `{{sumProduct(iterations, elapsed)}}`.
 *
 *    * `{{#measurement}}` To access individual measurement results, open the begin tag for measurements.
 *
 *       * `{{elapsed}}` Average elapsed wall clock time per iteration, in seconds.
 *
 *       * `{{iterations}}` Number of iterations in the measurement. The number of iterations will fluctuate due
 *         to some applied randomness, to enhance accuracy.
 *
 *       * `{{pagefaults}}` Average number of pagefaults per iteration.
 *
 *       * `{{cpucycles}}` Average number of CPU cycles processed per iteration.
 *
 *       * `{{contextswitches}}` Average number of context switches per iteration.
 *
 *       * `{{instructions}}` Average number of retired instructions per iteration.
 *
 *       * `{{branchinstructions}}` Average number of branches executed per iteration.
 *
 *       * `{{branchmisses}}` Average number of branches that were missed per iteration.
 *
 *    * `{{/measurement}}` Ends the measurement tag.
 *
 * * `{{/result}}` Marks the end of the result layer. This is the end marker for the template part that will be instantiated
 *   for each benchmark result.
 *
 *
 *  For the layer tags *result* and *measurement* you additionally can use these special markers:
 *
 *  * ``{{#-first}}`` - Begin marker of a template that will be instantiated *only for the first* entry in the layer. Use is only
 *    allowed between the begin and end marker of the layer. So between ``{{#result}}`` and ``{{/result}}``, or between
 *    ``{{#measurement}}`` and ``{{/measurement}}``. Finish the template with ``{{/-first}}``.
 *
 *  * ``{{^-first}}`` - Begin marker of a template that will be instantiated *for each except the first* entry in the layer. This,
 *    this is basically the inversion of ``{{#-first}}``. Use is only allowed between the begin and end marker of the layer.
 *    So between ``{{#result}}`` and ``{{/result}}``, or between ``{{#measurement}}`` and ``{{/measurement}}``.
 *
 *  * ``{{/-first}}`` - End marker for either ``{{#-first}}`` or ``{{^-first}}``.
 *
 *  * ``{{#-last}}`` - Begin marker of a template that will be instantiated *only for the last* entry in the layer. Use is only
 *    allowed between the begin and end marker of the layer. So between ``{{#result}}`` and ``{{/result}}``, or between
 *    ``{{#measurement}}`` and ``{{/measurement}}``. Finish the template with ``{{/-last}}``.
 *
 *  * ``{{^-last}}`` - Begin marker of a template that will be instantiated *for each except the last* entry in the layer. This,
 *    this is basically the inversion of ``{{#-last}}``. Use is only allowed between the begin and end marker of the layer.
 *    So between ``{{#result}}`` and ``{{/result}}``, or between ``{{#measurement}}`` and ``{{/measurement}}``.
 *
 *  * ``{{/-last}}`` - End marker for either ``{{#-last}}`` or ``{{^-last}}``.
 *
   @verbatim embed:rst

   For an overview of all the possible data you can get out of nanobench, please see the tutorial at :ref:`tutorial-template-json`.

   The templates that ship with nanobench are:

   * :cpp:func:`templates::csv() <ankerl::nanobench::templates::csv()>`
   * :cpp:func:`templates::json() <ankerl::nanobench::templates::json()>`
   * :cpp:func:`templates::htmlBoxplot() <ankerl::nanobench::templates::htmlBoxplot()>`
   * :cpp:func:`templates::pyperf() <ankerl::nanobench::templates::pyperf()>`

   @endverbatim
 *
 * @param mustacheTemplate The template.
 * @param bench Benchmark, containing all the results.
 * @param out Output for the generated output.
 */// See https://stackoverflow.com/a/31798726/48181// workaround missing "is_trivially_copyable" in g++ < 5.0// PERF_FLAG_FD_CLOEXEC since kernel 3.14// PERF_COUNT_HW_REF_CPU_CYCLES only available since kernel 3.3// holds all results// holds context information of results// all names// for std::ostream* custom output target in Config// memcpy// high_resolution_clock// public facing api - as minimal as possible// backwards-compatible bug fixes// backwards-compatible changes// incompatible API changes// see https://semver.org/// SOFTWARE.// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE// copies or substantial portions of the Software.// The above copyright notice and this permission notice shall be included in all// furnished to do so, subject to the following conditions:// copies of the Software, and to permit persons to whom the Software is// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell// in the Software without restriction, including without limitation the rights// of this software and associated documentation files (the "Software"), to deal// Permission is hereby granted, free of charge, to any person obtaining a copy// Copyright (c) 2019-2023 Martin Leitner-Ankerl <martin.ankerl@gmail.com>// SPDX-License-Identifier: MIT// Licensed under the MIT License <http://opensource.org/licenses/MIT>.// https://github.com/martinus/nanobench// Microbenchmark framework for C++11/14/17/20//  |  \_| |     | |  \_| |_____| |_____] |______ |  \_| |_____  |     |//  | \  | |_____| | \  | |     | |_____] |______ | \  | |       |_____|//  __   _ _______ __   _  _____  ______  _______ __   _ _______ _     _bigOsbigOscaledRangeMeasurebenchbenchmarkConfigtemplateContentshowPerformanceCountersisRelativeEnablednumWarmupItersnumEpochsmultipleoutstreamtutuNamevariableNamevariableValuebenchmarkTitleyidxm1m2totalElapseditersmustacheTemplate/home/tanteikg/QCVE/sources/bitcoin/src/bench/bench.h<bench/nanobench.h>StringToPriorityListPrioritiesBenchRunner &BenchRunner &&const BenchRunnerconst BenchRunner &BenchRunnerRunAllBenchmarkMap &map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &benchmarks~ArgsPriorityLevelLOWHIGHpriorityregex_filteroutput_jsonoutput_csvasymptotemin_timesanity_checkis_list_onlyBENCHMARK(n,priority_level)benchmark::BenchRunner PASTE2(bench_, PASTE2(__LINE__, n))(STRINGIZE(n), n, priority_level);BITCOIN_BENCH_BENCH_H// BITCOIN_BENCH_BENCH_H// BENCHMARK(foo) expands to:  benchmark::BenchRunner bench_11foo("foo", foo, priority_level);// namespace benchmark// maps from "name" -> (function, priority_level)// List priority labels, comma-separated and sorted by increasing priority/*
 * Usage:

static void NameOfYourBenchmarkFunction(benchmark::Bench& bench)
{
    ...do any setup needed...

    bench.run([&] {
         ...do stuff you want to time; refer to src/bench/nanobench.h
            for more information and the options that can be passed here...
    });

    ...do any cleanup needed...
}

BENCHMARK(NameOfYourBenchmarkFunction);

 */func/usr/include/linux/version.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/addrman.cpp<bench/bench.h>lambda [] type at line 151976, col. 21lambda [] type at line 151976, col. 21 &&lambda [] type at line 151976, col. 21 &const lambda [] type at line 151976, col. 21const lambda [] type at line 151976, col. 21 &const lambda [] type at line 151976, col. 21 *lambda [] type at line 151976, col. 21 *sizeof(addr)sizeof(port)AddrManAddThenGoodlambda [] type at line 152103, col. 27const lambda [] type at line 152103, col. 27const lambda [] type at line 152103, col. 27 &lambda [] type at line 152103, col. 27 &lambda [] type at line 152103, col. 27 &&operator void (*)(AddrMan &)const lambda [] type at line 152103, col. 27 *lambda [] type at line 152103, col. 27 *markSomeAsGoodlambda [] type at line 152113, col. 15const lambda [] type at line 152113, col. 15const lambda [] type at line 152113, col. 15 &lambda [] type at line 152113, col. 15 &lambda [] type at line 152113, col. 15 &&AddrManGetAddrADDRMAN_CONSISTENCY_CHECK_RATIOaddresses.size() > 0lambda [] type at line 152095, col. 15const lambda [] type at line 152095, col. 15const lambda [] type at line 152095, col. 15 &lambda [] type at line 152095, col. 15 &lambda [] type at line 152095, col. 15 &&AddrManSelectByNetworki2p_serviceudhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p"udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna.b32.i2p"i2p_address252.2.2.2"252.2.2.2"const CAddress[1]CAddress[1]lambda [] type at line 152084, col. 15const lambda [] type at line 152084, col. 15const lambda [] type at line 152084, col. 15 &lambda [] type at line 152084, col. 15 &lambda [] type at line 152084, col. 15 &&AddrManSelectFromAlmostEmpty250.3.1.1"250.3.1.1"8333lambda [] type at line 152065, col. 15const lambda [] type at line 152065, col. 15const lambda [] type at line 152065, col. 15 &lambda [] type at line 152065, col. 15 &lambda [] type at line 152065, col. 15 &&AddrManSelectaddress.first.GetPort() > 0lambda [] type at line 152048, col. 15const lambda [] type at line 152048, col. 15const lambda [] type at line 152048, col. 15 &lambda [] type at line 152048, col. 15 &lambda [] type at line 152048, col. 15 &&AddrManAddlambda [] type at line 152036, col. 15const lambda [] type at line 152036, col. 15const lambda [] type at line 152036, col. 15 &lambda [] type at line 152036, col. 15 &lambda [] type at line 152036, col. 15 &&ResolveServiceservResolveIPFillAddrManAddAddressesToAddrMansource_iNUM_SOURCESCreateAddressesrandAddraddr_iNUM_ADDRESSES_PER_SOURCEconst lambda [] type at line 152113, col. 15 *lambda [] type at line 152113, col. 15 *const lambda [] type at line 152095, col. 15 *lambda [] type at line 152095, col. 15 *2500bench/addrman.cpplambda []()->auto::operator()()->autoconst lambda [] type at line 152084, col. 15 *lambda [] type at line 152084, col. 15 *const lambda [] type at line 152065, col. 15 *lambda [] type at line 152065, col. 15 *const lambda [] type at line 152048, col. 15 *lambda [] type at line 152048, col. 15 *const pair<CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>const pair<CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>> &const lambda [] type at line 152036, col. 15 *lambda [] type at line 152036, col. 15 *bench_191AddrManAddThenGoodbenchmark::PriorityLevel::HIGHbench_PASTE2(__LINE__, AddrManAddThenGood)191AddrManAddThenGoodbench_190AddrManGetAddrPASTE2(__LINE__, AddrManGetAddr)190AddrManGetAddrbench_189AddrManSelectByNetworkPASTE2(__LINE__, AddrManSelectByNetwork)189AddrManSelectByNetworkbench_188AddrManSelectFromAlmostEmptyPASTE2(__LINE__, AddrManSelectFromAlmostEmpty)188AddrManSelectFromAlmostEmptybench_187AddrManSelectPASTE2(__LINE__, AddrManSelect)187AddrManSelectbench_186AddrManAddPASTE2(__LINE__, AddrManAdd)186AddrManAddg_addressesg_sourcesEMPTY_NETGROUPMAN__LINE__// AddrMan::Good() will still be noticeable.// This has some overhead (exactly the result of AddrManAdd benchmark), but that overhead is constant so improvements in// to the same method and we want to do the same amount of work in every loop iteration.// This is necessary because AddrMan::Good() method modifies the object, affecting the timing of subsequent calls// To make the benchmark independent of the number of evaluations, we always prepare a new addrman./*network=*//*max_pct=*//*max_addresses=*//*new_only=*/// add single I2P address to new table// Add one address to the new table// several buckets before identifying the correct bucket// one address on the table, because it linearly searches every position of// The worst case performance of the Select() function is when there is only/* Benchmarks */// already created/* A "source" is a source address from which we have received a bunch of other addresses. */// Copyright (c) 2020-2022 The Bitcoin Core developersvector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>allocator<vector<CAddress, allocator<CAddress>>> &pair<function<..(..)>, PriorityLevel>map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>conditional<false, system_clock, steady_clock>conditional<false, system_clock, steady_clock> &conditional<false, system_clock, steady_clock> &&const conditional<false, system_clock, steady_clock>const conditional<false, system_clock, steady_clock> &unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>unordered_multimap<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _H2, _P2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &&unordered_multimap<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _H2, _P2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _H2, _P2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &&unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _H2, _P2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &equal_to<basic_string<char, char_traits<char>, allocator<char>>> &PerfCountSet<unsigned long>PerfCountSet<unsigned long> &&PerfCountSetPerfCountSet<bool>PerfCountSet<bool> &&pair<double, double>vector<pair<double, double>, allocator<pair<double, double>>>vector<Result, allocator<Result>>allocator<Result> &vector<BigO, allocator<BigO>>_Vector_base<Result, allocator<Result>>_Vector_base<Result, allocator<Result>> &const _Vector_base<Result, allocator<Result>>const _Vector_base<Result, allocator<Result>> &_Vector_base<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>_Vector_base<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>> &const _Vector_base<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>const _Vector_base<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>> &_Insert_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>>_Insert_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &_Insert_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &&const _Insert_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>>const _Insert_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &_Base_manager<..(*)(..)>_Base_manager<..(*)(..)> &_Base_manager<..(*)(..)> &&const _Base_manager<..(*)(..)>const _Base_manager<..(*)(..)> &allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>allocator<Result>allocator<vector<CAddress, allocator<CAddress>>>new_allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>new_allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &const new_allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>const new_allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &new_allocator<Result>new_allocator<Result> &const new_allocator<Result>const new_allocator<Result> &new_allocator<vector<CAddress, allocator<CAddress>>>new_allocator<vector<CAddress, allocator<CAddress>>> &const new_allocator<vector<CAddress, allocator<CAddress>>>const new_allocator<vector<CAddress, allocator<CAddress>>> &allocator_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>allocator_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &allocator_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &&const allocator_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>const allocator_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &allocator_traits<allocator<Result>>allocator_traits<allocator<Result>> &allocator_traits<allocator<Result>> &&const allocator_traits<allocator<Result>>const allocator_traits<allocator<Result>> &allocator_traits<allocator<vector<CAddress, allocator<CAddress>>>>allocator_traits<allocator<vector<CAddress, allocator<CAddress>>>> &allocator_traits<allocator<vector<CAddress, allocator<CAddress>>>> &&const allocator_traits<allocator<vector<CAddress, allocator<CAddress>>>>const allocator_traits<allocator<vector<CAddress, allocator<CAddress>>>> &__rebind<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node_base *, void>__rebind<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node_base *, void> &__rebind<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node_base *, void> &&const __rebind<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node_base *, void>const __rebind<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node_base *, void> &__rebind<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>, void>__rebind<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>, void> &__rebind<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>, void> &&const __rebind<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>, void>const __rebind<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>, void> &BenchmarkMapBenchFunctionRangeMeasurevector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>> *_Vector_base<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>> *unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> *vector<Result, allocator<Result>> *allocator<vector<double, allocator<double>>> &_Vector_base<Result, allocator<Result>> *const _Vector_base<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>> *const allocator<vector<CAddress, allocator<CAddress>>>const allocator<vector<CAddress, allocator<CAddress>>> &_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &..(*const &)(..)..(*const *)(..)..(**)(..)..(**&)(..)..(***)(..)__is_location_invariant<_Functor>::valuesizeof(_Functor)sizeof(_Functor) <= _M_max_size__is_location_invariant<_Functor>::value
	 && sizeof(_Functor) <= _M_max_size__alignof__(_Functor)__alignof__(_Functor) <= _M_max_align__is_location_invariant<_Functor>::value
	 && sizeof(_Functor) <= _M_max_size
	 && __alignof__(_Functor) <= _M_max_align_M_max_align % __alignof__(_Functor)_M_max_align % __alignof__(_Functor) == 0(_M_max_align % __alignof__(_Functor) == 0)__is_location_invariant<_Functor>::value
	 && sizeof(_Functor) <= _M_max_size
	 && __alignof__(_Functor) <= _M_max_align
	 && (_M_max_align % __alignof__(_Functor) == 0)(__is_location_invariant<_Functor>::value
	 && sizeof(_Functor) <= _M_max_size
	 && __alignof__(_Functor) <= _M_max_align
	 && (_M_max_align % __alignof__(_Functor) == 0))initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>_Hash_code_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true>_Hash_code_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true> &_Hash_code_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true> &&const _Hash_code_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true>const _Hash_code_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true> &__alloc_traits<allocator<Result>, Result>__alloc_traits<allocator<Result>, Result> &__alloc_traits<allocator<Result>, Result> &&const __alloc_traits<allocator<Result>, Result>const __alloc_traits<allocator<Result>, Result> &_Function_handler<..(..), ..(*)(..)>_Function_handler_Function_handler<..(..), ..(*)(..)> &_Function_handler<..(..), ..(*)(..)> &&const _Function_handler<..(..), ..(*)(..)>const _Function_handler<..(..), ..(*)(..)> &const Result *Result *const _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>const _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *const _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> &_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> &_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> &&rebind<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>rebind<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &rebind<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &&const rebind<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>const rebind<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &_Local_storageallocator<BigO>allocator<pair<double, double>>pair<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, bool>unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _H2, _P2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>unordered_multimap<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _H2, _P2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>_Maybe_unary_or_binary_function<void, Bench &>_Maybe_unary_or_binary_function<void, Bench &> &_Maybe_unary_or_binary_function<void, Bench &> &&const _Maybe_unary_or_binary_function<void, Bench &>const _Maybe_unary_or_binary_function<void, Bench &> &_Callable<..(*)(..), __invoke_result<..(*&)(..), Bench &>>_Callable<..(*)(..), __invoke_result<..(*&)(..), Bench &>> &_Callable<..(*)(..), __invoke_result<..(*&)(..), Bench &>> &&const _Callable<..(*)(..), __invoke_result<..(*&)(..), Bench &>>const _Callable<..(*)(..), __invoke_result<..(*&)(..), Bench &>> &_Callable<type, __invoke_result<type &, Bench &>>_Callable<_Functor, __invoke_result<_Functor &, Bench &>>__alloc_traits<allocator<vector<CAddress, allocator<CAddress>>>, vector<CAddress, allocator<CAddress>>>__alloc_traits<allocator<vector<CAddress, allocator<CAddress>>>, vector<CAddress, allocator<CAddress>>> &__alloc_traits<allocator<vector<CAddress, allocator<CAddress>>>, vector<CAddress, allocator<CAddress>>> &&const __alloc_traits<allocator<vector<CAddress, allocator<CAddress>>>, vector<CAddress, allocator<CAddress>>>const __alloc_traits<allocator<vector<CAddress, allocator<CAddress>>>, vector<CAddress, allocator<CAddress>>> &allocator<Result> *allocator<vector<CAddress, allocator<CAddress>>> *const new_allocator<vector<CAddress, allocator<CAddress>>> *new_allocator<vector<CAddress, allocator<CAddress>>> *384307168202282325new_allocator<Result> *new_allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> *_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> *const __normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>>vector<CAddress, allocator<CAddress>> *constvector<CAddress, allocator<CAddress>> *const &vector<CAddress, allocator<CAddress>> *&const vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>const vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>> *const __normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>> &__normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>> &..(*)(..))(..)is_nothrow_constructible<vector<CAddress, allocator<CAddress>>>is_nothrow_constructible<vector<CAddress, allocator<CAddress>>> &is_nothrow_constructible<vector<CAddress, allocator<CAddress>>> &&const is_nothrow_constructible<vector<CAddress, allocator<CAddress>>>const is_nothrow_constructible<vector<CAddress, allocator<CAddress>>> &_Hashtable_alloc<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>_Hashtable_alloc<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &const _Hashtable_alloc<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>const _Hashtable_alloc<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &_Hashtable_alloc<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, true> *rebind<vector<CAddress, allocator<CAddress>>>rebind<vector<CAddress, allocator<CAddress>>> &rebind<vector<CAddress, allocator<CAddress>>> &&const rebind<vector<CAddress, allocator<CAddress>>>const rebind<vector<CAddress, allocator<CAddress>>> &__normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>>__normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>> &&__normal_iterator<const vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>>reverse_iterator<__normal_iterator<const vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>>>reverse_iterator<__normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>>>__invoke_result<_Functor &, Bench &>__invoke_result<type &, Bench &>__invoke_result<..(*&)(..), Bench &>__invoke_result__invoke_result<..(*&)(..), Bench &> &__invoke_result<..(*&)(..), Bench &> &&const __invoke_result<..(*&)(..), Bench &>const __invoke_result<..(*&)(..), Bench &> &unary_function<Bench &, void>unary_function<Bench &, void> &unary_function<Bench &, void> &&const unary_function<Bench &, void>const unary_function<Bench &, void> &_Local_iterator<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, false, true>_Local_const_iterator<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, false, true>_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>_Node_insert_return<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>>__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>vector<double, allocator<double>> *__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>const vector<double, allocator<double>>const vector<double, allocator<double>> *reverse_iterator<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>>reverse_iterator<__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>>__normal_iterator<Result *, vector<Result, allocator<Result>>>__normal_iterator<const Result *, vector<Result, allocator<Result>>>reverse_iterator<__normal_iterator<const Result *, vector<Result, allocator<Result>>>>reverse_iterator<__normal_iterator<Result *, vector<Result, allocator<Result>>>>_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>>const equal_to<basic_string<char, char_traits<char>, allocator<char>>>const equal_to<basic_string<char, char_traits<char>, allocator<char>>> &const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>>const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &_Hashtable_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true>>_Hashtable_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true>> &_Hashtable_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true>> &&const _Hashtable_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true>>const _Hashtable_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true>> &_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>_Node_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>_AllocNode<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>pair<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>>pair<_Node_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, _Node_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>>pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>_Hash_node_value_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>_Hash_node_value_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &_Hash_node_value_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &&const _Hash_node_value_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>const _Hash_node_value_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &rebind<Result>rebind<Result> &rebind<Result> &&const rebind<Result>const rebind<Result> &_Local_iterator_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true>allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> *..(..))(..)const __normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>> *__normal_iterator<vector<CAddress, allocator<CAddress>> *, vector<vector<CAddress, allocator<CAddress>>, allocator<vector<CAddress, allocator<CAddress>>>>> *is_nothrow_default_constructible<allocator<Result>>is_nothrow_default_constructible<allocator<Result>> &is_nothrow_default_constructible<allocator<Result>> &&const is_nothrow_default_constructible<allocator<Result>>const is_nothrow_default_constructible<allocator<Result>> &is_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>> &&>is_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>> &&> &is_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>> &&> &&const is_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>> &&>const is_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>> &&> &__is_move_constructible_impl<vector<CAddress, allocator<CAddress>>, true>__is_move_constructible_impl<vector<CAddress, allocator<CAddress>>, true> &__is_move_constructible_impl<vector<CAddress, allocator<CAddress>>, true> &&const __is_move_constructible_impl<vector<CAddress, allocator<CAddress>>, true>const __is_move_constructible_impl<vector<CAddress, allocator<CAddress>>, true> &is_move_constructible<vector<CAddress, allocator<CAddress>>>is_move_constructible<vector<CAddress, allocator<CAddress>>> &is_move_constructible<vector<CAddress, allocator<CAddress>>> &&const is_move_constructible<vector<CAddress, allocator<CAddress>>>const is_move_constructible<vector<CAddress, allocator<CAddress>>> &__is_move_insertable<allocator<vector<CAddress, allocator<CAddress>>>>__is_move_insertable<allocator<vector<CAddress, allocator<CAddress>>>> &__is_move_insertable<allocator<vector<CAddress, allocator<CAddress>>>> &&const __is_move_insertable<allocator<vector<CAddress, allocator<CAddress>>>>const __is_move_insertable<allocator<vector<CAddress, allocator<CAddress>>>> &is_nothrow_default_constructible<allocator<vector<CAddress, allocator<CAddress>>>>is_nothrow_default_constructible<allocator<vector<CAddress, allocator<CAddress>>>> &is_nothrow_default_constructible<allocator<vector<CAddress, allocator<CAddress>>>> &&const is_nothrow_default_constructible<allocator<vector<CAddress, allocator<CAddress>>>>const is_nothrow_default_constructible<allocator<vector<CAddress, allocator<CAddress>>>> &__and_<is_same<Result *, _Ptr>, __not_<is_pointer<_Ptr>>>__aligned_buffer<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>__aligned_buffer<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &__aligned_buffer<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &&const __aligned_buffer<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>const __aligned_buffer<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &_Equality<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true>_Equality<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> &_Equality<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> &&const _Equality<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true>const _Equality<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> &_Rehash_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, integral_constant<bool, true>>_Rehash_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, integral_constant<bool, true>> &_Rehash_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, integral_constant<bool, true>> &&const _Rehash_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, integral_constant<bool, true>>const _Rehash_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, integral_constant<bool, true>> &_Insert<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, false>_Insert<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, false> &_Insert<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, false> &&const _Insert<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, false>const _Insert<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, false> &_Map_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true>_Map_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> &_Map_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> &&const _Map_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true>const _Map_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> &__and_<is_same<vector<CAddress, allocator<CAddress>> *, _Ptr>, __not_<is_pointer<_Ptr>>>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, true>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, true> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, true> &&const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, true>const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, true> &remove_reference<Bench &>remove_reference<Bench &> &remove_reference<Bench &> &&const remove_reference<Bench &>const remove_reference<Bench &> &vector<CAddress, allocator<CAddress>> *&&is_nothrow_destructible<vector<CAddress, allocator<CAddress>>>is_nothrow_destructible<vector<CAddress, allocator<CAddress>>> &is_nothrow_destructible<vector<CAddress, allocator<CAddress>>> &&const is_nothrow_destructible<vector<CAddress, allocator<CAddress>>>const is_nothrow_destructible<vector<CAddress, allocator<CAddress>>> &is_same<vector<CAddress, allocator<CAddress>> *, _Ptr>iterator_traits<vector<CAddress, allocator<CAddress>> *>iterator_traits<vector<CAddress, allocator<CAddress>> *> &iterator_traits<vector<CAddress, allocator<CAddress>> *> &&const iterator_traits<vector<CAddress, allocator<CAddress>> *>const iterator_traits<vector<CAddress, allocator<CAddress>> *> &__result_of_impl<false, false, ..(*&)(..), Bench &>__result_of_impl__result_of_impl<false, false, ..(*&)(..), Bench &> &__result_of_impl<false, false, ..(*&)(..), Bench &> &&const __result_of_impl<false, false, ..(*&)(..), Bench &>const __result_of_impl<false, false, ..(*&)(..), Bench &> &__alloc_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>__alloc_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &__alloc_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &&const __alloc_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>const __alloc_traits<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &_ReuseOrAllocNode<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>_Equal_helper<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, unsigned long, true>conditional<true, pair<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, bool>, _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>>conditional<true, pair<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, bool>, _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>> &conditional<true, pair<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, bool>, _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>> &&const conditional<true, pair<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, bool>, _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>>const conditional<true, pair<_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>, bool>, _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>> &is_same<Result *, _Ptr>__is_referenceable<vector<CAddress, allocator<CAddress>>>__is_referenceable<vector<CAddress, allocator<CAddress>>> &__is_referenceable<vector<CAddress, allocator<CAddress>>> &&const __is_referenceable<vector<CAddress, allocator<CAddress>>>const __is_referenceable<vector<CAddress, allocator<CAddress>>> &is_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Pair &&>is_member_function_pointer<..(*)(..)>is_member_function_pointeris_member_function_pointer<..(*)(..)> &is_member_function_pointer<..(*)(..)> &&const is_member_function_pointer<..(*)(..)>const is_member_function_pointer<..(*)(..)> &is_member_object_pointer<..(*)(..)>is_member_object_pointeris_member_object_pointer<..(*)(..)> &is_member_object_pointer<..(*)(..)> &&const is_member_object_pointer<..(*)(..)>const is_member_object_pointer<..(*)(..)> &is_nothrow_copy_constructible<vector<CAddress, allocator<CAddress>> *>is_nothrow_copy_constructible<vector<CAddress, allocator<CAddress>> *> &is_nothrow_copy_constructible<vector<CAddress, allocator<CAddress>> *> &&const is_nothrow_copy_constructible<vector<CAddress, allocator<CAddress>> *>const is_nothrow_copy_constructible<vector<CAddress, allocator<CAddress>> *> &__and_<is_same<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *, _Ptr>__is_nothrow_copy_constructible_impl<vector<CAddress, allocator<CAddress>> *, true>__is_nothrow_copy_constructible_impl<vector<CAddress, allocator<CAddress>> *, true> &__is_nothrow_copy_constructible_impl<vector<CAddress, allocator<CAddress>> *, true> &&const __is_nothrow_copy_constructible_impl<vector<CAddress, allocator<CAddress>> *, true>const __is_nothrow_copy_constructible_impl<vector<CAddress, allocator<CAddress>> *, true> &is_nothrow_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>>>is_nothrow_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>>> &is_nothrow_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>>> &&const is_nothrow_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>>>const is_nothrow_constructible<vector<CAddress, allocator<CAddress>>, vector<CAddress, allocator<CAddress>>> &__is_referenceable<vector<CAddress, allocator<CAddress>> *>__is_referenceable<vector<CAddress, allocator<CAddress>> *> &__is_referenceable<vector<CAddress, allocator<CAddress>> *> &&const __is_referenceable<vector<CAddress, allocator<CAddress>> *>const __is_referenceable<vector<CAddress, allocator<CAddress>> *> &is_nothrow_constructible<vector<CAddress, allocator<CAddress>> *, vector<CAddress, allocator<CAddress>> *const &>is_nothrow_constructible<vector<CAddress, allocator<CAddress>> *, vector<CAddress, allocator<CAddress>> *const &> &is_nothrow_constructible<vector<CAddress, allocator<CAddress>> *, vector<CAddress, allocator<CAddress>> *const &> &&const is_nothrow_constructible<vector<CAddress, allocator<CAddress>> *, vector<CAddress, allocator<CAddress>> *const &>const is_nothrow_constructible<vector<CAddress, allocator<CAddress>> *, vector<CAddress, allocator<CAddress>> *const &> &remove_reference<vector<CAddress, allocator<CAddress>>>remove_reference<vector<CAddress, allocator<CAddress>>> &remove_reference<vector<CAddress, allocator<CAddress>>> &&const remove_reference<vector<CAddress, allocator<CAddress>>>const remove_reference<vector<CAddress, allocator<CAddress>>> &auto_ptr<<unnamed>>/home/tanteikg/QCVE/sources/bitcoin/src/bench/base58.cppBase58Decode17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem"17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem"lambda [] type at line 119685, col. 48const lambda [] type at line 119685, col. 48const lambda [] type at line 119685, col. 48 &lambda [] type at line 119685, col. 48 &lambda [] type at line 119685, col. 48 &&"byte"Base58CheckEncodebufflambda [] type at line 119675, col. 47const lambda [] type at line 119675, col. 47const lambda [] type at line 119675, col. 47 &lambda [] type at line 119675, col. 47 &lambda [] type at line 119675, col. 47 &&buff.size()Base58Encodelambda [] type at line 119660, col. 47const lambda [] type at line 119660, col. 47const lambda [] type at line 119660, col. 47 &lambda [] type at line 119660, col. 47 &lambda [] type at line 119660, col. 47 &&const lambda [] type at line 119685, col. 48 *lambda [] type at line 119685, col. 48 *const lambda [] type at line 119675, col. 47 *lambda [] type at line 119675, col. 47 *const lambda [] type at line 119660, col. 47 *lambda [] type at line 119660, col. 47 *bench_55Base58DecodePASTE2(__LINE__, Base58Decode)55Base58Decodebench_54Base58CheckEncodePASTE2(__LINE__, Base58CheckEncode)54Base58CheckEncodebench_53Base58EncodePASTE2(__LINE__, Base58Encode)53Base58Encode// Copyright (c) 2016-2022 The Bitcoin Core developersIntIdentity &IntIdentity &&const IntIdentityconst IntIdentity &maybe_unusedconst IntIdentity *IntIdentity *ParseByteUnitsCapitalizeToUpperToLoweraccmaxvtobitsmax_accfrombitspadConvertBitsParseFixedPointint64_t *TimingResistantEqualFormatParagraphHexStrParseUInt64ParseUInt32ParseUInt16ParseUInt8ParseInt64ParseInt32int32_t *signed int *ToIntegralIsSpace'\f''\n''\r''\t''\v'IsDigitLocaleIndependentAtoiSplitHostPortEncodeBase32DecodeBase32EncodeBase64DecodeBase64IsHexNumberIsHexHexDigitParseHexByteTryParseHexSanitizeStringSAFE_CHARS_DEFAULTIntIdentityByteUnitNOOP1ULL1000ULL1024ULL1'000'000ULLM1ULL << 20g1'000'000'000ULLG1ULL << 3010000000000001'000'000'000'000ULL10995116277761ULL << 40SafeCharsSAFE_CHARS_UA_COMMENTSAFE_CHARS_FILENAMESAFE_CHARS_URIBITCOIN_UTIL_STRENCODINGS_H// BITCOIN_UTIL_STRENCODINGS_H/**
 * Parse a string with suffix unit [k|K|m|M|g|G|t|T].
 * Must be a whole integer, fractions not allowed (0.5t), no whitespace or +-
 * Lowercase units are 1000 base. Uppercase units are 1024 base.
 * Examples: 2m,27M,19g,41T
 *
 * @param[in] str                  the string to convert into bytes
 * @param[in] default_multiplier   if no unit is found in str use this unit
 * @returns                        optional uint64_t bytes from str or nullopt
 *                                 if ToIntegral is false, str is empty, trailing whitespace or overflow
 *//**
 * Capitalizes the first character of the given string.
 * This function is locale independent. It only converts lowercase
 * characters in the standard 7-bit ASCII range.
 * This is a feature, not a limitation.
 *
 * @param[in] str   the string to capitalize.
 * @returns         string with the first letter capitalized.
 *//**
 * Returns the uppercase equivalent of the given string.
 * This function is locale independent. It only converts lowercase
 * characters in the standard 7-bit ASCII range.
 * This is a feature, not a limitation.
 *
 * @param[in] str   the string to convert to uppercase.
 * @returns         UPPERCASED EQUIVALENT OF str
 *//**
 * Converts the given character to its uppercase equivalent.
 * This function is locale independent. It only converts lowercase
 * characters in the standard 7-bit ASCII range.
 * This is a feature, not a limitation.
 *
 * @param[in] c     the character to convert to uppercase.
 * @return          the uppercase equivalent of c; or the argument
 *                  if no conversion is possible.
 *//**
 * Returns the lowercase equivalent of the given string.
 * This function is locale independent. It only converts uppercase
 * characters in the standard 7-bit ASCII range.
 * This is a feature, not a limitation.
 *
 * @param[in] str   the string to convert to lowercase.
 * @returns         lowercased equivalent of str
 *//**
 * Converts the given character to its lowercase equivalent.
 * This function is locale independent. It only converts uppercase
 * characters in the standard 7-bit ASCII range.
 * This is a feature, not a limitation.
 *
 * @param[in] c     the character to convert to lowercase.
 * @return          the lowercase equivalent of c; or the argument
 *                  if no conversion is possible.
 *//** Convert from one power-of-2 number base to another. *//** Helper class for the default infn argument to ConvertBits (just returns the input). *//** Parse number as fixed point according to JSON number syntax.
 * See https://json.org/number.gif
 * @returns true on success, false on error.
 * @note The result must be in the range (-10^18,10^18), otherwise an overflow error will trigger.
 *//**
 * Timing-attack-resistant comparison.
 * Takes time proportional to length
 * of first argument.
 *//**
 * Format a paragraph of text to a fixed width, adding spaces for
 * indentation to any added line.
 *//**
 * Convert a span of bytes to a lower-case hexadecimal string.
 *//**
 * Convert decimal string to unsigned 64-bit integer with strict parse error feedback.
 * @returns true if the entire string could be parsed as valid integer,
 *   false if not the entire string could be parsed or when overflow or underflow occurred.
 *//**
 * Convert decimal string to unsigned 32-bit integer with strict parse error feedback.
 * @returns true if the entire string could be parsed as valid integer,
 *   false if not the entire string could be parsed or when overflow or underflow occurred.
 *//**
 * Convert decimal string to unsigned 16-bit integer with strict parse error feedback.
 * @returns true if the entire string could be parsed as valid integer,
 *   false if the entire string could not be parsed or if overflow or underflow occurred.
 *//**
 * Convert decimal string to unsigned 8-bit integer with strict parse error feedback.
 * @returns true if the entire string could be parsed as valid integer,
 *   false if not the entire string could be parsed or when overflow or underflow occurred.
 *//**
 * Convert string to signed 64-bit integer with strict parse error feedback.
 * @returns true if the entire string could be parsed as valid integer,
 *   false if not the entire string could be parsed or when overflow or underflow occurred.
 *//**
 * Convert string to signed 32-bit integer with strict parse error feedback.
 * @returns true if the entire string could be parsed as valid integer,
 *   false if not the entire string could be parsed or when overflow or underflow occurred.
 *//**
 * Convert string to integral type T. Leading whitespace, a leading +, or any
 * trailing character fail the parsing. The required format expressed as regex
 * is `-?[0-9]+`. The minus sign is only permitted for signed integer types.
 *
 * @returns std::nullopt if the entire string could not be parsed, or if the
 *   parsed value is not in the range representable by the type T.
 *//**
 * Tests if the given character is a whitespace character. The whitespace characters
 * are: space, form-feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal
 * tab ('\t'), and vertical tab ('\v').
 *
 * This function is locale independent. Under the C locale this function gives the
 * same result as std::isspace.
 *
 * @param[in] c     character to test
 * @return          true if the argument is a whitespace character; otherwise false
 *//**
 * Tests if the given character is a decimal digit.
 * @param[in] c     character to test
 * @return          true if the argument is a decimal digit; otherwise false.
 */// Saturate overflow, per strtoll's behavior.// Saturate underflow, per strtoll's behavior.// Emulate atoi(...) handling of white space and leading +/-.// values, respectively.// undefined behavior, while this function returns the maximum or minimum// value, or smaller than the integer type's minimum value, std::atoi has// behavior. If the parsed value is bigger than the integer type's maximum// std::atoi as it behaves under the "C" locale, and remove some undefined// The goal of LocaleIndependentAtoi is to replicate the defined behaviour of// which provide parse error feedback.// New code should use ToIntegral or the ParseInt* functions// LocaleIndependentAtoi is provided for backwards compatibility reasons./**
 * Splits socket address string into host string and port value.
 * Validates port value.
 *
 * @param[in] in        The socket address string to split.
 * @param[out] portOut  Port-portion of the input, if found and parsable.
 * @param[out] hostOut  Host-portion of the input, if found.
 * @return              true if port-portion is absent or within its allowed range, otherwise false
 *//**
 * Base32 encode.
 * If `pad` is true, then the output will be padded with '=' so that its length
 * is a multiple of 8.
 *//**
* Return true if the string is a hex number, optionally prefixed with "0x"
*//* Returns true if each character in str is a hex character, and has an even
 * number of hex digits.*//** Like TryParseHex, but returns an empty vector on invalid input. *//** Parse the hex string into bytes (uint8_t or std::byte). Ignores whitespace. Returns nullopt on invalid input. *//**
* Remove unsafe chars. Safe chars chosen to allow simple messages/URLs/email
* addresses, but avoid anything even possibly remotely dangerous like & or >
* @param[in] str    The string to sanitize
* @param[in] rule   The set of safe chars to choose (default: least restrictive)
* @return           A new string without unsafe chars
*//**
 * Used by ParseByteUnits()
 * Lowercase base 1000
 * Uppercase base 1024
*///!< Chars allowed in URIs (RFC 3986)//!< Chars allowed in filenames//!< BIP-0014 subset//!< The full set of allowed chars/** Used by SanitizeString() *//**
 * Utilities for converting data from/to strings.
 */outfninfnhex_strdefault_multiplierdecimalsamount_outindentportOuthostOutrule/home/tanteikg/QCVE/sources/bitcoin/src/bench/bech32.cppBech32Decodebc1qkallence7tjawwvy0dwt4twc62qjgaw8f4vlhyd006d99f09"bc1qkallence7tjawwvy0dwt4twc62qjgaw8f4vlhyd006d99f09"const char[53]char[53]lambda [] type at line 121148, col. 47const lambda [] type at line 121148, col. 47const lambda [] type at line 121148, col. 47 &lambda [] type at line 121148, col. 47 &lambda [] type at line 121148, col. 47 &&lambda [] type at line 121138, col. 29lambda [] type at line 121138, col. 29 &&lambda [] type at line 121138, col. 29 &const lambda [] type at line 121138, col. 29const lambda [] type at line 121138, col. 29 &const lambda [] type at line 121138, col. 29 *lambda [] type at line 121138, col. 29 *Bech32Encodec97f5a67ec381b760aeaf67573bc164845ff39a3bb26a1cee401ac67243b48db"c97f5a67ec381b760aeaf67573bc164845ff39a3bb26a1cee401ac67243b48db"const unsigned char[1]unsigned char[1]32 * 832 * 8 / 51 + 32 * 8 / 5lambda [] type at line 121139, col. 44const lambda [] type at line 121139, col. 44const lambda [] type at line 121139, col. 44 &lambda [] type at line 121139, col. 44 &lambda [] type at line 121139, col. 44 &&const lambda [] type at line 121148, col. 47 *lambda [] type at line 121148, col. 47 *const lambda [] type at line 121139, col. 44 *lambda [] type at line 121139, col. 44 *bech32::Encoding::BECH32bc"bc"bench_36Bech32DecodePASTE2(__LINE__, Bech32Decode)36Bech32Decodebench_35Bech32EncodePASTE2(__LINE__, Bech32Encode)35Bech32Encode1 << tobits(1 << tobits)(1 << tobits) - 1frombits + tobitsfrombits + tobits - 1(frombits + tobits - 1)1 << (frombits + tobits - 1)(1 << (frombits + tobits - 1))(1 << (frombits + tobits - 1)) - 1_Iter_negate<_Predicate> *_Iter_pred<_Predicate> *_Iter_equals_val<_Value> *const _Iter_equal_to_iter *_Iter_equal_to_iter *const _Val_less_iter *const _Iter_less_val *const _Iter_less_iter *_Iter_less_iter *_RATag_Cat1_Cat2_RAIters__d1__d2_DistanceType__half__builtin_memcmp__cutbasic_string::erase"basic_string::erase"__xlen<bits/basic_ios.tcc><bits/streambuf_iterator.h><bits/locale_facets.h><bits/locale_classes.h><bits/localefwd.h>_Facetconst _Facetconst _Facet *_Facet *const _Facet &_Facet &__check_facetset_rdbufbasic_ios<_CharT, _Traits> &&const basic_ios<_CharT, _Traits>const basic_ios<_CharT, _Traits> &basic_iosbasic_ios<_CharT, _Traits> *_M_fill_init(false)const __ctype_typeconst __ctype_type *ctype<_CharT> *const __num_put_typeconst __num_put_type *num_put<_CharT, ostreambuf_iterator<_CharT, _Traits>> *const __num_get_typeconst __num_get_type *num_get<_CharT, istreambuf_iterator<_CharT, _Traits>> *widenconst basic_ios<_CharT, _Traits> *narrow__oldrdbuf~basic_iosexceptionsbadbadbitfailbitgood_M_setstaterdstateconst ios_base *ios_base *operator!basic_ios<_CharT, _Traits>_M_num_get_M_num_put_M_ctype_M_streambuf_M_fill_init_M_fill_M_tie_BASIC_IOS_H_M_cache_localeconst localeconst locale &locale &imbuecopyfmt/* _BASIC_IOS_H *//**
       *  @brief  All setup is performed here.
       *
       *  This is called from the public constructor.  It is not virtual and
       *  cannot be redefined.
      *//**
       *  @brief  Empty.
       *
       *  The default constructor does nothing and is not normally
       *  accessible to users.
      */// 27.4.5.1  basic_ios constructors/**
       *  @brief  Widens characters.
       *  @param  __c  The character to widen.
       *  @return  The widened character.
       *
       *  Maps a character of @c char to a character of @c char_type.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).widen(c)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      *//**
       *  @brief  Squeezes characters.
       *  @param  __c  The character to narrow.
       *  @param  __dfault  The character to narrow.
       *  @return  The narrowed character.
       *
       *  Maps a character of @c char_type to a character of @c char,
       *  if possible.
       *
       *  Returns the result of
       *  @code
       *    std::use_facet<ctype<char_type> >(getloc()).narrow(c,dfault)
       *  @endcode
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      *//**
       *  @brief  Moves to a new locale.
       *  @param  __loc  The new locale.
       *  @return  The previous locale.
       *
       *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated
       *  with this stream, calls that buffer's @c pubimbue(loc).
       *
       *  Additional l10n notes are at
       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/localization.html
      */// Locales:/**
       *  @brief  Sets a new @a empty character.
       *  @param  __ch  The new character.
       *  @return  The previous fill character.
       *
       *  The fill character is used to fill out space when P+ characters
       *  have been requested (e.g., via setw), Q characters are actually
       *  used, and Q<P.  It defaults to a space (' ') in the current locale.
      *//**
       *  @brief  Retrieves the @a empty character.
       *  @return  The current fill character.
       *
       *  It defaults to a space (' ') in the current locale.
      *//**
       *  @brief  Copies fields of __rhs into this.
       *  @param  __rhs  The source values for the copies.
       *  @return  Reference to this object.
       *
       *  All fields of __rhs are copied into this object except that rdbuf()
       *  and rdstate() remain unchanged.  All values in the pword and iword
       *  arrays are copied.  Before copying, each callback is invoked with
       *  erase_event.  After copying, each (new) callback is invoked with
       *  copyfmt_event.  The final step is to copy exceptions().
      *//**
       *  @brief  Changing the underlying buffer.
       *  @param  __sb  The new stream buffer.
       *  @return  The previous stream buffer.
       *
       *  Associates a new buffer with the current stream, and clears the
       *  error state.
       *
       *  Due to historical accidents which the LWG refuses to correct, the
       *  I/O library suffers from a design error:  this function is hidden
       *  in derived classes by overrides of the zero-argument @c rdbuf(),
       *  which is non-virtual for hysterical raisins.  As a result, you
       *  must use explicit qualifications to access this function via any
       *  derived class.  For example:
       *
       *  @code
       *  std::fstream     foo;         // or some other derived type
       *  std::streambuf*  p = .....;
       *
       *  foo.ios::rdbuf(p);            // ios == basic_ios<char>
       *  @endcode
      *//**
       *  @brief  Accessing the underlying buffer.
       *  @return  The current stream buffer.
       *
       *  This does not change the state of the stream.
      *//**
       *  @brief  Ties this stream to an output stream.
       *  @param  __tiestr  The output stream.
       *  @return  The previously tied output stream, or NULL if the stream
       *           was not tied.
       *
       *  This sets up a new tie; see tie() for more.
      *//**
       *  @brief  Fetches the current @e tied stream.
       *  @return  A pointer to the tied stream, or NULL if the stream is
       *           not tied.
       *
       *  A stream may be @e tied (or synchronized) to a second output
       *  stream.  When this stream performs any I/O, the tied stream is
       *  first flushed.  For example, @c std::cin is tied to @c std::cout.
      */// Members:/**
       *  @brief  Empty.
       *
       *  The destructor does nothing.  More specifically, it does not
       *  destroy the streambuf held by rdbuf().
      *//**
       *  @brief  Constructor performs initialization.
       *
       *  The parameter is passed by derived streams.
      */// Constructor/destructor:/**
       *  @brief  Throwing exceptions on errors.
       *  @param  __except  The new exceptions mask.
       *
       *  By default, error flags are set silently.  You can set an
       *  exceptions mask for each stream; if a bit in the mask becomes set
       *  in the error flags, then an exception of type
       *  std::ios_base::failure is thrown.
       *
       *  If the error flag is already set when the exceptions mask is
       *  added, the exception is immediately thrown.  Try running the
       *  following under GCC 3.1 or later:
       *  @code
       *  #include <iostream>
       *  #include <fstream>
       *  #include <exception>
       *
       *  int main()
       *  {
       *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);
       *
       *      std::ifstream f ("/etc/motd");
       *
       *      std::cerr << "Setting badbit\n";
       *      f.setstate (std::ios_base::badbit);
       *
       *      std::cerr << "Setting exception mask\n";
       *      f.exceptions (std::ios_base::badbit);
       *  }
       *  @endcode
      *//**
       *  @brief  Throwing exceptions on errors.
       *  @return  The current exceptions mask.
       *
       *  This changes nothing in the stream.  See the one-argument version
       *  of exceptions(iostate) for the meaning of the return value.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if the badbit is set.
       *
       *  Note that other iostate flags may also be set.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if either the badbit or the failbit is set.
       *
       *  Checking the badbit in fail() is historical practice.
       *  Note that other iostate flags may also be set.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if the eofbit is set.
       *
       *  Note that other iostate flags may also be set.
      *//**
       *  @brief  Fast error checking.
       *  @return  True if no error flags are set.
       *
       *  A wrapper around rdstate.
      */// Turn this on without causing an ios::failure to be thrown.// 27.6.1.2.1 Common requirements.// exceptions().// rethrows the propagated exception if bit also set in// Flip the internal state on for the proper state bits, then/**
       *  @brief  Sets additional flags in the error state.
       *  @param  __state  The additional state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.
      *//**
       *  @brief  [Re]sets the error state.
       *  @param  __state  The new state flag(s) to set.
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will not need to pass an argument.
      *//**
       *  @brief  Returns the error state of the stream buffer.
       *  @return  A bit pattern (well, isn't everything?)
       *
       *  See std::ios_base::iostate for the possible bit values.  Most
       *  users will call one of the interpreting wrappers, e.g., good().
      *//**
       *  @brief  The quick-and-easy status check.
       *
       *  This allows you to write constructs such as
       *  <code>if (!a_stream) ...</code> and <code>while (a_stream) ...</code>
      */// For istream.// For ostream.// Cached use_facet<ctype>, which is based on the current locale info.// Data members:/**
       *  These are non-standard types.
      *//**
       *  These are standard types.  They permit a standardized way of
       *  referring to names of (or names dependent on) the template
       *  parameters, which are specific to the implementation.
      *//**
   *  @brief Template class basic_ios, virtual base class for all
   *  stream classes. 
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  Most of the member functions called dispatched on stream objects
   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.
  *//** @file bits/basic_ios.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{ios}
 */// Iostreams base classes -*- C++ -*-__dfault__ch__tiestr__exceptunique_ptr<_Tp[], _Dp> *const unique_ptr<_Tp[], _Dp> *const default_delete<_Tp[]>const default_delete<_Tp[]> *default_delete<_Tp[]> *_Rb_tree_const_iterator<pair<const long, long>> &_Rb_tree_iterator<pair<const long, long>> &const _Rb_tree<long, pair<const long, long>, _Select1st<pair<const long, long>>, less<long>, allocator<pair<const long, long>>>const _Rb_tree<long, pair<const long, long>, _Select1st<pair<const long, long>>, less<long>, allocator<pair<const long, long>>> &_Rb_tree<long, pair<const long, long>, _Select1st<pair<const long, long>>, less<long>, allocator<pair<const long, long>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &const _Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const _Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree_const_iterator<pair<const unsigned long, void *>> &_Rb_tree_iterator<pair<const unsigned long, void *>> &const _Rb_tree<unsigned long, pair<const unsigned long, void *>, _Select1st<pair<const unsigned long, void *>>, less<unsigned long>, allocator<pair<const unsigned long, void *>>>const _Rb_tree<unsigned long, pair<const unsigned long, void *>, _Select1st<pair<const unsigned long, void *>>, less<unsigned long>, allocator<pair<const unsigned long, void *>>> &_Rb_tree<unsigned long, pair<const unsigned long, void *>, _Select1st<pair<const unsigned long, void *>>, less<unsigned long>, allocator<pair<const unsigned long, void *>>> &BigO *BenchRunner *<bits/list.tcc><bits/stl_list.h>polymorphic_allocator<_Tp>_GLIBCXX_LIST/* _GLIBCXX_LIST */// namespace pmr/** @file include/list
 *  This is a Standard C++ Library header.
 */// <list> -*- C++ -*-<bits/erase_if.h><bits/stl_multiset.h><bits/stl_set.h><bits/stl_tree.h>_GLIBCXX_SET/* _GLIBCXX_SET *//** @file include/set
 *  This is a Standard C++ Library header.
 */// <set> -*- C++ -*-/usr/include/c++/9/fstream<bits/fstream.tcc><bits/basic_file.h><bits/codecvt.h><ostream><istream>basic_fstream<_CharT, _Traits> &basic_ofstream<_CharT, _Traits> &basic_ifstream<_CharT, _Traits> &basic_filebuf<_CharT, _Traits> &_Pathconst _Pathconst _Path &_Path &is_open__filebuf_type *basic_filebuf<_CharT, _Traits> *basic_fstream<_CharT, _Traits> &&const basic_fstream<_CharT, _Traits>const basic_fstream<_CharT, _Traits> &~basic_fstreambasic_fstream_Requirebasic_ofstream<_CharT, _Traits> *const openmodeios_base::outbasic_ofstream<_CharT, _Traits> &&const basic_ofstream<_CharT, _Traits>const basic_ofstream<_CharT, _Traits> &~basic_ofstreambasic_ofstreambasic_ifstream<_CharT, _Traits> &&const basic_ifstream<_CharT, _Traits>const basic_ifstream<_CharT, _Traits> &~basic_ifstreambasic_ifstream_M_set_bufferconst basic_filebuf<_CharT, _Traits>const basic_filebuf<_CharT, _Traits> *const basic_filebuf<_CharT, _Traits> &~basic_filebufbasic_filebuf_M_destroy_pback_M_create_pback_If_fs_pathbasic_fstream<_CharT, _Traits>basic_ofstream<_CharT, _Traits>basic_ifstream<_CharT, _Traits>basic_filebuf<_CharT, _Traits>__filebuf_typestate_type__state_type__file_type_Path2_M_filebuf_M_ext_end_M_ext_next_M_ext_buf_size_M_ext_bufconst __codecvt_typeconst __codecvt_type *codecvt<_CharT, char, state_type> *_M_codecvt_M_pback_initchar_type *_M_pback_end_save_M_pback_cur_save_M_pback_M_writing_M_reading_M_buf_allocated_M_buf_size_M_buf_M_state_last_M_state_cur_M_state_beg_M_mode_M_file_M_lockpos_type must be fpos<state_type>state_type must be CopyAssignable, CopyConstructible and DefaultConstructible_GLIBCXX_FSTREAM_GLIBCXX_HAVE__WFOPEN && _GLIBCXX_USE_WCHAR_T_M_terminate_outputxsputnxsgetn_M_get_ext_pos__state_type &state_type &_M_seekseekposseekoffsetbuf_M_convert_to_externaloverflowpbackfailunderflowshowmanyc_M_destroy_internal_buffer_M_allocate_internal_bufferbasic_filebuf<_CharT, _Traits> &&/* _GLIBCXX_FSTREAM *//// Swap specialization for fstreams./// Swap specialization for ofstreams./// Swap specialization for ifstreams./// Swap specialization for filebufs./**
       *  @brief  Close the file.
       *
       *  Calls @c std::basic_filebuf::close().  If that function
       *  fails, @c failbit is set in the stream's error state.
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file, as a filesystem::path.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(__s,__mode).  If that
       *  function fails, @c failbit is set in the stream's error state.
       */// 409. Closing an fstream should clear error state/**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(__s,__mode).  If that
       *  function fails, @c failbit is set in the stream's error state.
       */// 365. Lack of const-qualification in clause 27/**
       *  @brief  Wrapper to test for an open file.
       *  @return  @c rdbuf()->is_open()
       *//**
       *  @brief  Accessing the underlying buffer.
       *  @return  The current basic_filebuf buffer.
       *
       *  This hides both signatures of std::basic_ios::rdbuf().
       */// 27.8.3.2 Assign and swap:/**
       *  @brief  The destructor does nothing.
       *
       *  The file is closed by the filebuf object, not the formatting
       *  stream.
       *//**
       *  @param  Create an input/output file stream.
       *  @param  __s  filesystem::path specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *//**
       *  @brief  Create an input/output file stream.
       *  @param  __s  Null terminated string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *//**
       *  @param  Create an input/output file stream.
       *  @param  __s  Wide string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *//**
       *  @brief  Default constructor.
       *
       *  Initializes @c sb using its default constructor, and passes
       *  @c &sb to the base class initializer.  Does not open any files
       *  (you haven't given it a filename to open).
       */// Constructors/destructor:// Non-standard types:/**
   *  @brief  Controlling input and output for files.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class supports reading from and writing to named files, using
   *  the inherited functions from std::basic_iostream.  To control the
   *  associated sequence, an instance of std::basic_filebuf is used, which
   *  this page refers to as @c sb.
   */// [27.8.1.11] Template class basic_fstream/**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file, as a filesystem::path.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(__s,__mode|out).  If that
       *  function fails, @c failbit is set in the stream's error state.
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(s,mode|out).  If that
       *  function fails, @c failbit is set in the stream's error state.
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(__s,__mode|out).  If that
       *  function fails, @c failbit is set in the stream's error state.
       *//**
       *  @param  Create an output file stream.
       *  @param  __s  filesystem::path specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::out is automatically included in @a __mode.
       *//**
       *  @brief  Create an output file stream.
       *  @param  __s  std::string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::out is automatically included in @a __mode.
       *//**
       *  @param  Create an output file stream.
       *  @param  __s  Wide string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::out | @c ios_base::trunc is automatically included in
       *  @a __mode.
       *//**
       *  @brief  Create an output file stream.
       *  @param  __s  Null terminated string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::out is automatically included in @a __mode.
       */// Constructors:/**
   *  @brief  Controlling output for files.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class supports reading from named files, using the inherited
   *  functions from std::basic_ostream.  To control the associated
   *  sequence, an instance of std::basic_filebuf is used, which this page
   *  refers to as @c sb.
   */// [27.8.1.8] Template class basic_ofstream/**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file, as a filesystem::path.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(__s,__mode|in).  If that function
       *  fails, @c failbit is set in the stream's error state.
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(__s,__mode|in).  If that function
       *  fails, @c failbit is set in the stream's error state.
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file, as a wide character string.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(__s,__mode|in).  If that function
       *  fails, @c failbit is set in the stream's error state.
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file.
       *  @param  __mode  The open mode flags.
       *
       *  Calls @c std::basic_filebuf::open(s,__mode|in).  If that function
       *  fails, @c failbit is set in the stream's error state.
       *//**
       *  @param  Create an input file stream.
       *  @param  __s  filesystem::path specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::in is automatically included in @a __mode.
       *//**
       *  @brief  Create an input file stream.
       *  @param  __s  std::string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::in is automatically included in @a __mode.
       *//**
       *  @param  Create an input file stream.
       *  @param  __s  Wide string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::in is automatically included in @a __mode.
       *//**
       *  @brief  Create an input file stream.
       *  @param  __s  Null terminated string specifying the filename.
       *  @param  __mode  Open file in specified mode (see std::ios_base).
       *
       *  @c ios_base::in is automatically included in @a __mode.
       */// Constructors/Destructors:/**
   *  @brief  Controlling input for files.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class supports reading from named files, using the inherited
   *  functions from std::basic_istream.  To control the associated
   *  sequence, an instance of std::basic_filebuf is used, which this page
   *  refers to as @c sb.
   */// [27.8.1.5] Template class basic_ifstream/**
       *  This function sets the pointers of the internal buffer, both get
       *  and put areas. Typically:
       *
       *   __off == egptr() - eback() upon underflow/uflow (@b read mode);
       *   __off == 0 upon overflow (@b write mode);
       *   __off == -1 upon open, setbuf, seekoff/pos (@b uncommitted mode).
       *
       *  NB: epptr() - pbase() == _M_buf_size - 1, since _M_buf_size
       *  reflects the actual allocated memory and the last cell is reserved
       *  for the overflow char of a full put area.
       */// Flushes output buffer, then writes unshift sequence.// Common code for seekoff, seekpos, and overflow/**
       *  @brief  Manipulates the buffer.
       *  @param  __s  Pointer to a buffer area.
       *  @param  __n  Size of @a __s.
       *  @return  @c this
       *
       *  If no file has been opened, and both @a __s and @a __n are zero, then
       *  the stream becomes unbuffered.  Otherwise, @c __s is used as a
       *  buffer; see
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
       *  for more.
       */// sequence via codecvt.// Convert internal byte sequence to external, char-based// Consume some sequence of the characters in the pending sequence.// 27.5.2.4.5// character c.// overflow(c) outputs the contents of the buffer plus the// real output destination when the buffer is full. A call to// The overflow() function is called to transfer characters to the// Stroustrup, 1998, p 648// Buffered input uses underflow()// character from the real input source when the buffer is empty.// underflow() and uflow() functions are called to get the next// Stroustrup, 1998, p. 628// [27.8.1.4] overridden virtual functions/**
       *  @brief  Closes the currently associated file.
       *  @return  @c this on success, NULL on failure
       *
       *  If no file is currently open, this function immediately fails.
       *
       *  If a <em>put buffer area</em> exists, @c overflow(eof) is
       *  called to flush all the characters.  The file is then
       *  closed.
       *
       *  If any operations fail, this function also fails.
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file, as a filesystem::path.
       *  @param  __mode  The open mode flags.
       *  @return  @c this on success, NULL on failure
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file.
       *  @param  __mode  The open mode flags.
       *  @return  @c this on success, NULL on failure
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file, as a wide character string.
       *  @param  __mode  The open mode flags.
       *  @return  @c this on success, NULL on failure
       *//**
       *  @brief  Opens an external file.
       *  @param  __s  The name of the file.
       *  @param  __mode  The open mode flags.
       *  @return  @c this on success, NULL on failure
       *
       *  If a file is already open, this function immediately fails.
       *  Otherwise it tries to open the file named @a __s using the flags
       *  given in @a __mode.
       *
       *  Table 92, adapted here, gives the relation between openmode
       *  combinations and the equivalent @c fopen() flags.
       *  (NB: lines app, in|out|app, in|app, binary|app, binary|in|out|app,
       *  and binary|in|app per DR 596)
       *  <pre>
       *  +---------------------------------------------------------+
       *  | ios_base Flag combination            stdio equivalent   |
       *  |binary  in  out  trunc  app                              |
       *  +---------------------------------------------------------+
       *  |             +                        w                  |
       *  |             +           +            a                  |
       *  |                         +            a                  |
       *  |             +     +                  w                  |
       *  |         +                            r                  |
       *  |         +   +                        r+                 |
       *  |         +   +     +                  w+                 |
       *  |         +   +           +            a+                 |
       *  |         +               +            a+                 |
       *  +---------------------------------------------------------+
       *  |   +         +                        wb                 |
       *  |   +         +           +            ab                 |
       *  |   +                     +            ab                 |
       *  |   +         +     +                  wb                 |
       *  |   +     +                            rb                 |
       *  |   +     +   +                        r+b                |
       *  |   +     +   +     +                  w+b                |
       *  |   +     +   +           +            a+b                |
       *  |   +     +               +            a+b                |
       *  +---------------------------------------------------------+
       *  </pre>
       *//**
       *  @brief  Returns true if the external file is open.
       *//**
       *  @brief  The destructor closes the file first.
       *//**
       *  @brief  Does not open any files.
       *
       *  The default constructor initializes the parent class using its
       *  own default ctor.
       */// Length _M_in_cur moved in the pback buffer./**
       *  Deactivates pback buffer contents, and restores normal buffer.
       *  Assumptions:
       *  The pback buffer has only moved forward.
       *//**
       *  Initializes pback buffers, and moves normal buffers to safety.
       *  Assumptions:
       *  _M_in_cur has already been moved back
       *//**
       *  Pointers into the buffer held by _M_ext_buf that delimit a
       *  subsequence of bytes that have been read but not yet converted.
       *  When valid, _M_ext_next corresponds to egptr().
       *//**
       *  Size of buffer held by _M_ext_buf.
       *//**
       *  Buffer for external characters. Used for input when
       *  codecvt::always_noconv() == false. When valid, this corresponds
       *  to eback().
       */// Cached codecvt facet./**
       *  Necessary bits for putback buffer management.
       *
       *  @note pbacks of over one character are not currently supported.
       *//**
       *  _M_reading == false && _M_writing == false for @b uncommitted mode;
       *  _M_reading == true for @b read mode;
       *  _M_writing == true for @b write mode;
       *
       *  NB: _M_reading == true && _M_writing == true is unused.
       */// Set iff _M_buf is allocated memory from _M_allocate_internal_buffer./**
       *  Actual size of internal buffer. This number is equal to the size
       *  of the put area + 1 position, reserved for the overflow char of
       *  a full area.
       *//// Pointer to the beginning of internal buffer.// to eback() and _M_ext_buf.// Not used for output. During input, the state that corresponds// _M_ext_next.// during input, the state that corresponds to egptr() and// During output, the state that corresponds to pptr(),// Beginning state type for codecvt./// Place to stash in || out || in | out settings for current filebuf.// External buffer.// MT lock inherited from libio or other low-level io library.// Data Members:// For sync_with_stdio./**
   *  @brief  The actual work of input and output (for files).
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class associates both its input and output sequence with an
   *  external disk file, and maintains a joint file position for both
   *  sequences.  Many of its semantics are described in terms of similar
   *  behavior in the Standard C Library's @c FILE streams.
   *
   *  Requirements on traits_type, specific to this class:
   *  - traits_type::pos_type must be fpos<traits_type::state_type>
   *  - traits_type::off_type must be streamoff
   *  - traits_type::state_type must be Assignable and DefaultConstructible,
   *  - traits_type::state_type() must be the initial state for codecvt.
   */// [27.8.1.1] template class basic_filebuf// Enable if _Path is a filesystem::path or experimental::filesystem::path// For std::string overloads.// For __basic_file, __c_lock// For BUFSIZ// ISO C++ 14882: 27.8  File-based streams/** @file include/fstream
 *  This is a Standard C++ Library header.
 */// File based streams -*- C++ -*-__way/usr/include/c++/9/bits/regex.tccconst basic_regex<_CharT, _TraitsT>const basic_regex<_CharT, _TraitsT> &basic_regex<_CharT, _TraitsT> &_M_automaton_Base_type &match_results<_BiIter, _Alloc> &_BiIter_M_resize_M_sub_countmatchedconst syntax_option_type_RegexExecutorPolicy::_S_alternate_M_has_backref__executor__match_mode_M_match_M_search__pre_M_prefix__suf_M_suffix__regex_algo_impl_TraitsT_Bi_iterregex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits> &const regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>const regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits> &regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> &const regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>const regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> &_Out_iterregex_replaceconst basic_regex<_Ch_type, _Rx_traits>const basic_regex<_Ch_type, _Rx_traits> &basic_regex<_Ch_type, _Rx_traits> &_Ch_typeconst _Ch_typeconst _Ch_type *_Ch_type *_Rx_traitsconst regex_traits<_Ch_type>const regex_traits<_Ch_type> *regex_traits<_Ch_type> *isctype__ctype_typeconst __ctype_type &ctype<_Ch_type> &__fctyp_M_extended_S_under'_'const pair<const char *, _RegexMask>const pair<const char *, _RegexMask>[]pair<const char *, _RegexMask>[]__classnames_Fwd_itertolowerconst pair<const char *, _RegexMask>[15]pair<const char *, _RegexMask>[15]const pair<const char *, _RegexMask>(&)[15]pair<const char *, _RegexMask>(&)[15]const maskctype_base::lowerctype_base::upper768ctype_base::lower | ctype_base::upper(ctype_base::lower | ctype_base::upper)walnumalphablankcntrldigitgraphprintpunctspacexdigitlookup_classnameconst char *[]__collatenamesconst char *[128]char *[128]const char *(&)[128]char *(&)[128]const char **NUL"NUL"SOH"SOH"STX"STX"ETX"ETX"EOT"EOT"ENQ"ENQ"ACK"ACK"alert"alert"backspace"backspace"tab"tab"newline"newline"vertical-tab"vertical-tab"form-feed"form-feed"carriage-return"carriage-return"SO"SO"SI"SI"DLE"DLE"DC1"DC1"DC2"DC2"DC3"DC3"DC4"DC4"NAK"NAK"SYN"SYN"ETB"ETB"CAN"CAN"EM"EM"SUB"SUB"ESC"ESC"IS4"IS4"IS3"IS3"IS2"IS2"IS1"IS1""space"exclamation-mark"exclamation-mark"quotation-mark"quotation-mark"number-sign"number-sign"dollar-sign"dollar-sign"percent-sign"percent-sign"ampersand"ampersand"apostrophe"apostrophe"left-parenthesis"left-parenthesis"right-parenthesis"right-parenthesis"asterisk"asterisk"plus-sign"plus-sign"comma"comma"hyphen"hyphen""period"slash"slash""zero"one"one"two"two"three"three"four"four"five"five"six"six"seven"seven"eight"eight"nine"nine"colon"colon"semicolon"semicolon"less-than-sign"less-than-sign"equals-sign"equals-sign"greater-than-sign"greater-than-sign"question-mark"question-mark"commercial-at"commercial-at""A"B"B""C""D"E"E"F"F""G"H"H""I"J"J""K"L"L""M""N""O"P"P"Q"Q""R""S""T""U""V"W"W""X"Y"Y"Z"Z"left-square-bracket"left-square-bracket"backslash"backslash"right-square-bracket"right-square-bracket"circumflex"circumflex"underscore"underscore"grave-accent"grave-accent""a""b""c""d""e"f"f""g""h""i""j""k"l"l""m""n"o"o""p"q"q"r"r""s""t""u""v""w""x""y"z"z"left-curly-bracket"left-curly-bracket"vertical-line"vertical-line"right-curly-bracket"right-curly-bracket"tilde"tilde"DEL"DEL"lookup_collatename_M_match[0].matchedready()// [28.12.1.4.5]// match[i].position() shall return distance(begin, match[i].first).// [0, match.size()) for which match[i].matched is true,// match[0].second, and for each index i in the half-open range// match.prefix().first shall be equal to the previous value of// In all cases in which the call to regex_search returns true,// [[:w:]]// Mappings from class name to class mask.// http://boost.sourceforge.net/libs/regex/doc/collating_names.html// TODO Add digraph support:// That __match_mode is true means regex_match, else regex_search.// the other one if possible, for test purpose).// __policy now can be _S_auto (auto dispatch) and _S_alternate (use// Result of merging regex_match and regex_search./**
 *  @file bits/regex.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{regex}
 */// class template regex -*- C++ -*-__radix__re__fmt_first__fmt_last__icase/usr/include/c++/9/bits/regex.h<bits/regex.tcc>_Bpmatch_results<_Bp, _Ap> &const basic_regex<_Cp, _Rp>const basic_regex<_Cp, _Rp> &basic_regex<_Cp, _Rp> &_Ap_Cp_Rpmatch_results<_Bi_iter, _Alloc> &const match_results<_Bi_iter, _Alloc>const match_results<_Bi_iter, _Alloc> &basic_ostream<_Ch_type, _Ch_traits> &const sub_match<_Bi_iter>const sub_match<_Bi_iter> &sub_match<_Bi_iter> &_Ch_traitsconst __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc> &basic_string<value_type, _Ch_traits, _Ch_alloc> &_Ch_allocconst sub_match<_BiIter>const sub_match<_BiIter> &sub_match<_BiIter> &basic_regex_M_normalize_result_M_end_of_seq_M_current_matchsub_match<_Bi_iter> *regex_token_iteratorconst regex_typeconst regex_type &&basic_regex<_Ch_type, _Rx_traits> &&const int[]int[]const int(&)[]int(&)[]const regex_type &match_results<_Bi_iter, allocator<sub_match<_Bi_iter>>> *match_results<_Bi_iter, allocator<sub_match<_Bi_iter>>> &~regex_iteratorregex_iteratormatch_results<_Bi_iter, _Alloc> *_M_unmatched_subconst basic_string<char_type, _St, _Sa>const basic_string<char_type, _St, _Sa> &basic_string<char_type, _St, _Sa> &_St_Sasuffixready~match_resultsmatch_results<_Bi_iter, _Alloc> &&match_results_FwdIterbasic_regex<_Ch_type, _Rx_traits> *getlocconst basic_regex<_Ch_type, _Rx_traits> *mark_countconst basic_string<_Ch_type, _Ch_traits, _Alloc>const basic_string<_Ch_type, _Ch_traits, _Alloc> &basic_string<_Ch_type, _Ch_traits, _Alloc> &~basic_regexconst basic_string<_Ch_type, _Ch_traits, _Ch_alloc>const basic_string<_Ch_type, _Ch_traits, _Ch_alloc> &basic_string<_Ch_type, _Ch_traits, _Ch_alloc> &const basic_string<_Ch_type, _St, _Sa>const basic_string<_Ch_type, _St, _Sa> &basic_string<_Ch_type, _St, _Sa> &const basic_string<_Ch_type, _Fst, _Fsa>const basic_string<_Ch_type, _Fst, _Fsa> &basic_string<_Ch_type, _Fst, _Fsa> &_Fst_Fsaregex_searchconst basic_string<_Ch_type, _Ch_traits, _Ch_alloc> &&basic_string<_Ch_type, _Ch_traits, _Ch_alloc> &&match_results<const_iterator, _Alloc> &const basic_string<_Ch_type, _Ch_traits, _String_allocator>const basic_string<_Ch_type, _Ch_traits, _String_allocator> &basic_string<_Ch_type, _Ch_traits, _String_allocator> &__submatches__submatch__that__sub_String_allocatormatch_results<const _Ch_type *, _Alloc> &regex_matchconst basic_string<_Ch_type, _Ch_traits, _Str_allocator>const basic_string<_Ch_type, _Ch_traits, _Str_allocator> &basic_string<_Ch_type, _Ch_traits, _Str_allocator> &_Str_allocatorlocale_type &transform_primary__collate_typeconst __collate_typeconst __collate_type &collate<_Ch_type> &__fclttranslate_nocasetranslateregex_traitsconst _RegexMaskconst _RegexMask *_RegexMask *_S_valid_mask_RegexMask &_RegexMask_M_str_M_compareconst string_typeconst string_type &basic_string<value_type, char_traits<value_type>, allocator<value_type>> &operator std::__cxx11::basic_string<std::iterator_traits<_BiIter>::value_type, std::char_traits<std::iterator_traits<_BiIter>::value_type>, std::allocator<std::iterator_traits<_BiIter>::value_type>>sub_matchsub_match<_BiIter> *__string_viewregex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>match_results<_Bi_iter, _Alloc>regex_iterator<<unnamed>, <unnamed>, <unnamed>>match_flag_typebasic_regex<_Ch_type, _Rx_traits>_RegexExecutorPolicy_S_auto_S_alternatestring_typelocale_typeflag_typeregex_traits<_Ch_type>char_class_type_BaseTypesub_match<_BiIter>_Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>__extendedegrepgrepawkextendedbasicECMAScriptcollateoptimizenosubsicase_M_has_m1_M_result_M_n_M_subs_M_position_M_flagsconst regex_type *_M_pregex_M_loc_M_localeregex_constants::egrepregex_constants::grepregex_constants::awkregex_constants::extendedregex_constants::basicregex_constants::ECMAScriptregex_constants::collateregex_constants::optimizeregex_constants::nosubsregex_constants::icase0x1regex traits class must have the same char_type__cplusplus < 201703L///@} // group regex/** @brief Token iterator for standard wide-character strings. *//** @brief Token iterator for C-style NULL-terminated wide strings. *//** @brief Token iterator for standard strings. *//** @brief Token iterator for C-style NULL-terminated strings. */// Show whether _M_subs contains -1// [28.12.2.2.4]/**
       * @brief Postincrements a %regex_token_iterator.
       *//**
       * @brief Increments a %regex_token_iterator.
       *//**
       * @brief Selects a %regex_token_iterator member.
       *//**
       * @brief Dereferences a %regex_token_iterator.
       *//**
       * @brief Compares a %regex_token_iterator to another for inequality.
       *//**
       * @brief Compares a %regex_token_iterator to another for equality.
       *//**
       * @brief Assigns a %regex_token_iterator to another.
       * @param __rhs [IN] A %regex_token_iterator to copy.
       *//**
       * @brief Copy constructs a %regex_token_iterator.
       * @param __rhs [IN] A %regex_token_iterator to copy.
       */// 2332. regex_token_iterator should forbid temporary regexes/**
       * Constructs a %regex_token_iterator...
       * @param __a          [IN] The start of the text to search.
       * @param __b          [IN] One-past-the-end of the text to search.
       * @param __re         [IN] The regular expression to search for.
       * @param __submatches [IN] A list of subexpressions to return for each
       *                          regular expression match within the text.
       * @param __m          [IN] Policy flags for match rules.
       *//**
       * Constructs a %regex_token_iterator...
       * @param __a          [IN] The start of the text to search.
       * @param __b          [IN] One-past-the-end of the text to search.
       * @param __re         [IN] The regular expression to search for.
       * @param __submatch   [IN] Which submatch to return.  There are some
       *                        special values for this parameter:
       *                        - -1 each enumerated subexpression does NOT
       *                          match the regular expression (aka field
       *                          splitting)
       *                        - 0 the entire string matching the
       *                          subexpression is returned for each match
       *                          within the text.
       *                        - >0 enumerates only the indicated
       *                          subexpression from a match within the text.
       * @param __m          [IN] Policy flags for match rules.
       *//**
       * @brief Default constructs a %regex_token_iterator.
       *
       * A default-constructed %regex_token_iterator is a singular iterator
       * that will compare equal to the one-past-the-end value for any
       * iterator of the same type.
       *//**
   * Iterates over submatches in a range (or @a splits a text string).
   *
   * The purpose of this iterator is to enumerate all, or all specified,
   * matches of a regular expression within a text range.  The dereferenced
   * value of an iterator of this class is a std::sub_match object.
   */// [7.12.2] Class template regex_token_iterator/**
       * @brief Postincrements a %regex_iterator.
       *//**
       * @brief Increments a %regex_iterator.
       *//**
       * @brief Selects a %regex_iterator member.
       *//**
       * @brief Dereferences a %regex_iterator.
       *//**
       * @brief Tests the inequivalence of two regex iterators.
       *//**
       * @brief Tests the equivalence of two regex iterators.
       *//// Copy assigns one %regex_iterator to another./// Copy constructs a %regex_iterator.// 2332. regex_iterator should forbid temporary regexes/**
       * Constructs a %regex_iterator...
       * @param __a  [IN] The start of a text range to search.
       * @param __b  [IN] One-past-the-end of the text range to search.
       * @param __re [IN] The regular expression to match.
       * @param __m  [IN] Policy flags for match rules.
       *//**
       * @brief Provides a singular iterator, useful for indicating
       * one-past-the-end of a range.
       *//**
   * An iterator adaptor that will provide repeated calls of regex_search over
   * a range until no more matches remain.
   */// std [28.12] Class template regex_iterator/**
   * @brief Search for a regular expression within a C-string for multiple
   times, and replace the matched parts through filling a format C-string.
   * @param __s     [IN] The C-string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format C-string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   *//**
   * @brief Search for a regular expression within a C-string for multiple
   times, and replace the matched parts through filling a format string.
   * @param __s     [IN] The C-string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   *//**
   * @brief Search for a regular expression within a string for multiple times,
   and replace the matched parts through filling a format C-string.
   * @param __s     [IN] The string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format C-string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   *//**
   * @brief Search for a regular expression within a string for multiple times,
   and replace the matched parts through filling a format string.
   * @param __s     [IN] The string to search and replace.
   * @param __e     [IN] The regular expression to search for.
   * @param __fmt   [IN] The format string.
   * @param __flags [IN] Search and replace policy flags.
   *
   * @returns The string after replacing.
   * @throws an exception of type regex_error.
   *//**
   * @brief Search for a regular expression within a range for multiple times,
   and replace the matched parts through filling a format C-string.
   * @param __out   [OUT] The output iterator.
   * @param __first [IN]  The start of the string to search.
   * @param __last  [IN]  One-past-the-end of the string to search.
   * @param __e     [IN]  The regular expression to search for.
   * @param __fmt   [IN]  The format C-string.
   * @param __flags [IN]  Search and replace policy flags.
   *
   * @returns __out
   * @throws an exception of type regex_error.
   *//**
   * @brief Search for a regular expression within a range for multiple times,
   and replace the matched parts through filling a format string.
   * @param __out   [OUT] The output iterator.
   * @param __first [IN]  The start of the string to search.
   * @param __last  [IN]  One-past-the-end of the string to search.
   * @param __e     [IN]  The regular expression to search for.
   * @param __fmt   [IN]  The format string.
   * @param __flags [IN]  Search and replace policy flags.
   *
   * @returns __out
   * @throws an exception of type regex_error.
   */// std [28.11.4] Function template regex_replace/// Prevent unsafe attempts to get match_results from a temporary string.// 2329. regex_search() with match_results should forbid temporary strings/**
   * @brief Searches for a regular expression within a string.
   * @param __s [IN]  A C++ string to search for the regex.
   * @param __m [OUT] The set of regex matches.
   * @param __e [IN]  The regex to search for in @p s.
   * @param __f [IN]  The search flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   *
   * @throws an exception of type regex_error.
   *//**
   * @brief Searches for a regular expression within a string.
   * @param __s     [IN]  The string to search.
   * @param __e     [IN]  The regular expression to search for.
   * @param __flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   *
   * @throws an exception of type regex_error.
   *//**
   * @brief Searches for a regular expression within a C-string.
   * @param __s [IN]  The C-string to search.
   * @param __e [IN]  The regular expression to search for.
   * @param __f [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   *
   * @throws an exception of type regex_error.
   *//**
   * @brief Searches for a regular expression within a C-string.
   * @param __s [IN]  A C-string to search for the regex.
   * @param __m [OUT] The set of regex matches.
   * @param __e [IN]  The regex to search for in @p s.
   * @param __f [IN]  The search flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   *
   * @throws an exception of type regex_error.
   *//**
   * Searches for a regular expression within a range.
   * @param __first [IN]  The start of the string to search.
   * @param __last  [IN]  One-past-the-end of the string to search.
   * @param __re    [IN]  The regular expression to search for.
   * @param __flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string.
   *
   * @throws an exception of type regex_error.
   *//**
   * Searches for a regular expression within a range.
   * @param __s     [IN]  The start of the string to search.
   * @param __e     [IN]  One-past-the-end of the string to search.
   * @param __m     [OUT] The match results.
   * @param __re    [IN]  The regular expression to search for.
   * @param __flags [IN]  Search policy flags.
   * @retval true  A match was found within the string.
   * @retval false No match was found within the string, the content of %m is
   *               undefined.
   *
   * @throws an exception of type regex_error.
   */// [7.11.3] Function template regex_search/**
   * @brief Indicates if there is a match between the regular expression @p e
   * and a string.
   *
   * @param __s     [IN] The string to match.
   * @param __re    [IN] The regular expression.
   * @param __flags [IN] Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   *//**
   * @brief Indicates if there is a match between the regular expression @p e
   * and a C-style null-terminated string.
   *
   * @param __s  The C-style null-terminated string to match.
   * @param __re The regular expression.
   * @param __f  Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   */// 2329. regex_match() with match_results should forbid temporary strings/**
   * @brief Determines if there is a match between the regular expression @p e
   * and a string.
   *
   * @param __s     The string to match.
   * @param __m     The match results.
   * @param __re    The regular expression.
   * @param __flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   *//**
   * @brief Determines if there is a match between the regular expression @p e
   * and a C-style null-terminated string.
   *
   * @param __s  The C-style null-terminated string to match.
   * @param __m  The match results.
   * @param __re The regular expression.
   * @param __f  Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   *//**
   * @brief Indicates if there is a match between the regular expression @p e
   * and all of the character sequence [first, last).
   *
   * @param __first Beginning of the character sequence to match.
   * @param __last  One-past-the-end of the character sequence to match.
   * @param __re    The regular expression.
   * @param __flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   *//**
   * @brief Determines if there is a match between the regular expression @p e
   * and all of the character sequence [first, last).
   *
   * @param __s     Start of the character sequence to match.
   * @param __e     One-past-the-end of the character sequence to match.
   * @param __m     The match results.
   * @param __re    The regular expression.
   * @param __flags Controls how the regular expression is matched.
   *
   * @retval true  A match exists.
   * @retval false Otherwise.
   *
   * @throws an exception of type regex_error.
   *//**
   * @name Matching, Searching, and Replacing
   */// [7.11.2] Function template regex_match/**
   * @brief Swaps two match results.
   * @param __lhs A match result.
   * @param __rhs A match result.
   *
   * The contents of the two match_results objects are swapped.
   */// [7.10.6] match_results swap/**
   * @brief Compares two match_results for inequality.
   * @returns true if the two objects do not refer to the same match,
   * false otherwise.
   */// both are empty// both are not ready/**
   * @brief Compares two match_results for equality.
   * @returns true if the two objects refer to the same match,
   * false otherwise.
   */// match_results comparisons/**
       * @brief Swaps the contents of two match_results.
       *//**
       * @name 10.6 Swap
       *//**
       * @brief Gets a copy of the allocator.
       *//**
       * @name 10.5 Allocator
       *//**
       * @pre   ready() == true
       *//**
       * @name 10.4 Formatting
       *
       * These functions perform formatted substitution of the matched
       * character sequences into their target.  The format specifiers and
       * escape sequences accepted by these functions are determined by
       * their @p flags parameter as documented above.
       *//**
       * @brief Gets an iterator to one-past-the-end of the collection.
       *//**
       * @brief Gets an iterator to the start of the %sub_match collection.
       *//**
       * @brief Gets a %sub_match representing the match suffix.
       * @pre   ready() == true
       *
       * This function gets a reference to a %sub_match object representing the
       * part of the target range between the end of the match and the end of
       * the target range.
       *//**
       * @brief Gets a %sub_match representing the match prefix.
       * @pre   ready() == true
       *
       * This function gets a reference to a %sub_match object representing the
       * part of the target range between the start of the target range and the
       * start of the match.
       *//**
       * @brief Gets a %sub_match reference for the match or submatch.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function gets a reference to the indicated submatch, or
       * the entire match if @p __sub is zero.
       *
       * If @p __sub >= size() then this function returns a %sub_match with a
       * special value indicating no submatch.
       *//**
       * @brief Gets the match or submatch converted to a string type.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function gets the submatch (or match, if @p __sub is
       * zero) extracted from the target range and converted to the
       * associated string type.
       *//**
       * @brief Gets the offset of the beginning of the indicated submatch.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function returns the offset from the beginning of the target
       * sequence to the beginning of the submatch, unless the value of @p __sub
       * is zero (the default), in which case this function returns the offset
       * from the beginning of the target sequence to the beginning of the
       * match.
       *//**
       * @brief Gets the length of the indicated submatch.
       * @param __sub indicates the submatch.
       * @pre   ready() == true
       *
       * This function returns the length of the indicated submatch, or the
       * length of the entire match if @p __sub is zero (the default).
       *//**
       * @name 10.3 Element Access
       *//**
       * @brief Indicates if the %match_results contains no results.
       * @retval true The %match_results object is empty.
       * @retval false The %match_results object is not empty.
       *//**
       * @brief Gets the number of matches and submatches.
       *
       * The number of matches for a given regular expression will be either 0
       * if there was no match or mark_count() + 1 if a match was successful.
       * Some matches may be empty.
       *
       * @returns the number of matches found.
       *//**
       * @name 28.10.2 Size
       *//**
       * @brief Indicates if the %match_results is ready.
       * @retval true   The object has a fully-established result state.
       * @retval false  The object is not ready.
       */// 28.10.2, state:/**
       * @brief Destroys a %match_results object.
       *//**
       * @brief Move-assigns rhs to *this.
       *//**
       * @brief Assigns rhs to *this.
       *//**
       * @brief Move constructs a %match_results.
       *//**
       * @brief Copy constructs a %match_results.
       *//**
       * @brief Constructs a default %match_results container.
       * @post size() returns 0 and str() returns an empty string.
       * @{
       *//**
       * @name 28.10.1 Construction, Copying, and Destruction
       *//**
       * @name 10.? Public Types
       *//*
       * The vector base is empty if this does not represent a match (!ready());
       * Otherwise if it's a match failure, it contains 3 elements:
       * [0] unmatched
       * [1] prefix
       * [2] suffix
       * Otherwise it contains n+4 elements where n is the number of marked
       * sub-expressions:
       * [0] entire match
       * [1] 1st marked subexpression
       * ...
       * [n] nth marked subexpression
       * [n+1] unmatched
       * [n+2] prefix
       * [n+3] suffix
       *//**
   * @brief The results of a match or search operation.
   *
   * A collection of character sequences representing the result of a regular
   * expression match.  Storage for the collection is allocated and freed as
   * necessary by the member functions of class template match_results.
   *
   * This class satisfies the Sequence requirements, with the exception that
   * only the operations defined for a const-qualified Sequence are supported.
   *
   * The sub_match object stored at index 0 represents sub-expression 0, i.e.
   * the whole match. In this case the %sub_match member matched is always true.
   * The sub_match object stored at index n denotes what matched the marked
   * sub-expression n within the matched expression. If the sub-expression n
   * participated in a regular expression match then the %sub_match member
   * matched evaluates to true, and members first and second denote the range
   * of characters [first, second) which formed that match. Otherwise matched
   * is false, and members first and second point to the end of the sequence
   * that was searched.
   *
   * @nosubgrouping
   */// [7.10] Class template match_results/**
   * @brief Inserts a matched string into an output stream.
   *
   * @param __os The output stream.
   * @param __m  A submatch string.
   *
   * @returns the output stream with the submatch string inserted.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a
   *        character.
   * @param __lhs A regular expression submatch.
   * @param __rhs A character.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a
   *        character.
   * @param __lhs A regular expression submatch.
   * @param __rhs A character.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a
   *        character.
   * @param __lhs A regular expression submatch.
   * @param __rhs A character.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a
   *        character.
   * @param __lhs A regular expression submatch.
   * @param __rhs A character.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   *//**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        character.
   * @param __lhs A regular expression submatch.
   * @param __rhs A character.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        character.
   * @param __lhs A regular expression submatch.
   * @param __rhs A character.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a character and a regular expression
   *        submatch.
   * @param __lhs A character.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a character and a regular expression
   *        submatch.
   * @param __lhs A character.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a character and a regular expression
   *        submatch.
   * @param __lhs A character.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a character and a regular expression
   *        submatch.
   * @param __lhs A character.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   *//**
   * @brief Tests the inequivalence of a character and a regular expression
   *        submatch.
   * @param __lhs A character.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the equivalence of a character and a regular expression
   *        submatch.
   * @param __lhs A character.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a C string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A null-terminated string.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a C string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A null-terminated string.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a C string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A null-terminated string.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a C string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A null-terminated string.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   *//**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A null-terminated string.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the equivalence of a regular expression submatch and a C
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A null-terminated string.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a C string and a regular expression submatch.
   * @param __lhs A null-terminated string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a C string and a regular expression submatch.
   * @param __lhs A null-terminated string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a C string and a regular expression submatch.
   * @param __lhs A null-terminated string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a C string and a regular expression submatch.
   * @param __lhs A null-terminated string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   *//**
   * @brief Tests the inequivalence of a C string and a regular
   *        expression submatch.
   * @param __lhs A null-terminated string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the equivalence of a C string and a regular expression
   *        submatch.
   * @param __lhs A null-terminated string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a regular expression submatch and a string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   *//**
   * @brief Tests the inequivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs is not equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the equivalence of a regular expression submatch and a
   *        string.
   * @param __lhs A regular expression submatch.
   * @param __rhs A string.
   * @returns true if @a __lhs is equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of a string and a regular expression submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   *//**
   * @brief Tests the inequivalence of a string and a regular expression
   *        submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the equivalence of a string and a regular expression
   *        submatch.
   * @param __lhs A string.
   * @param __rhs A regular expression submatch.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   */// Alias for a basic_string that can be compared to a sub_match./**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs succeeds @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs does not precede @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs does not succeed @a __rhs, false otherwise.
   *//**
   * @brief Tests the ordering of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs precedes @a __rhs, false otherwise.
   *//**
   * @brief Tests the inequivalence of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs  is not equivalent to @a __rhs, false otherwise.
   *//**
   * @brief Tests the equivalence of two regular expression submatches.
   * @param __lhs First regular expression submatch.
   * @param __rhs Second regular expression submatch.
   * @returns true if @a __lhs  is equivalent to @a __rhs, false otherwise.
   */// [7.9.2] sub_match non-member operators/** @brief Regex submatch over a standard wide string. *//** @brief Regex submatch over a C-style null-terminated wide string. *//** @brief Standard regex submatch over a standard string. *//** @brief Standard regex submatch over a C-style null-terminated string. */// Create a temporary string that can be converted to __string_view.// Create a __string_view over the iterator range.// Simplified basic_string_view for C++11// Non-standard, used by comparison operators/**
       * @{
       * @brief Compares this `sub_match` to a string.
       *
       * @param __s A string to compare to this `sub_match`.
       *
       * @retval negative  This matched sequence will collate before `__s`.
       * @retval zero      This matched sequence is equivalent to `__s`.
       * @retval positive  This matched sequence will collate after `__s`.
       *//**
       * @brief Compares this and another matched sequence.
       *
       * @param __s Another matched sequence to compare to this one.
       *
       * @retval negative  This matched sequence will collate before `__s`.
       * @retval zero      This matched sequence is equivalent to `__s`.
       * @retval positive  This matched sequence will collate after `__s`.
       *//**
       * @brief Gets the matching sequence as a string.
       *
       * @returns the matching sequence as a string.
       *//**
       * @brief Gets the matching sequence as a string.
       *
       * @returns the matching sequence as a string.
       *
       * This is the implicit conversion operator.  It is identical to the
       * str() member function except that it will want to pop up in
       * unexpected places and cause a great deal of confusion and cursing
       * from the unwary.
       *//// Gets the length of the matching sequence./**
   * A sequence of characters matched by a particular marked sub-expression.
   *
   * An object of this class is essentially a pair of iterators marking a
   * matched subexpression within a regular expression pattern match. Such
   * objects can be converted to and compared with std::basic_string objects
   * of a similar base character type as the pattern matched by the regular
   * expression.
   *
   * The iterators that make up the pair are the usual half-open interval
   * referencing the actual original pattern matched.
   */// C++11 28.9 [re.submatch] Class template sub_match/**
   * @brief Swaps the contents of two regular expression objects.
   * @param __lhs First regular expression.
   * @param __rhs Second regular expression.
   */// [7.8.6] basic_regex swap/** @brief Standard wide-character regular expressions. *//** @brief Standard regular expressions. */// ! C++17/**
       * @brief Swaps the contents of two regular expression objects.
       *
       * @param __rhs Another regular expression object.
       */// [7.8.6] swap/**
       * @brief Gets the locale currently imbued in the regular expression
       *        object.
       *//**
       * @brief Imbues the regular expression object with the given locale.
       *
       * @param __loc A locale.
       */// [7.8.5] locale/**
       * @brief Gets the flags used to construct the regular expression
       * or in the last call to assign().
       *//**
       * @brief Gets the number of marked subexpressions within the regular
       * expression.
       */// [7.8.4] const operations/**
       * @brief Assigns a new regular expression to a regex object.
       *
       * @param __l     An initializer list representing a regular expression.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if @p __l does not contain a valid
       * regular expression pattern interpreted according to @p
       * __flags.  If regex_error is thrown, the object remains
       * unchanged.
       *//**
       * @brief Assigns a new regular expression to a regex object.
       *
       * @param __first The start of a range containing a valid regular
       *                expression.
       * @param __last  The end of a range containing a valid regular
       *                expression.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, the object remains unchanged.
       *//**
       * @brief Assigns a new regular expression to a regex object from a
       * string containing a regular expression pattern.
       *
       * @param __s     A string containing a regular expression pattern.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if __s does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, *this remains unchanged.
       *//**
       * @brief Assigns a new regular expression to a regex object from a
       * C-style string containing a regular expression pattern.
       *
       * @param __p     A pointer to a C-style string containing a
       *                regular expression pattern.
       * @param __len   The length of the regular expression pattern string.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if p does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, *this remains unchanged.
       *//**
       * @brief Assigns a new regular expression to a regex object from a
       * C-style null-terminated string containing a regular expression
       * pattern.
       *
       * @param __p     A pointer to a C-style null-terminated string containing
       *              a regular expression pattern.
       * @param __flags Syntax option flags.
       *
       * @throws regex_error if __p does not contain a valid regular
       * expression pattern interpreted according to @p __flags.  If
       * regex_error is thrown, *this remains unchanged.
       *//**
       * @brief The move-assignment operator.
       *
       * @param __rhs Another regular expression object.
       *//**
       * @brief the real assignment operator.
       *
       * @param __rhs Another regular expression object.
       */// [7.8.3] assign/**
       * @brief Replaces a regular expression with a new one constructed from
       * a string.
       *
       * @param __s A pointer to a string containing a regular expression.
       *//**
       * @brief Replaces a regular expression with a new one constructed from
       * an initializer list.
       *
       * @param __l  The initializer list.
       *
       * @throws regex_error if @p __l is not a valid regular expression.
       *//**
       * @brief Replaces a regular expression with a new one constructed from
       * a C-style null-terminated string.
       *
       * @param __p A pointer to the start of a null-terminated C-style string
       *        containing a regular expression.
       *//**
       * @brief Move-assigns one regular expression to another.
       *//**
       * @brief Assigns one regular expression to another.
       *//**
       * @brief Destroys a basic regular expression.
       *//**
       * @brief Constructs a basic regular expression from an initializer list.
       *
       * @param __l  The initializer list.
       * @param __f  The format flags of the regular expression.
       *
       * @throws regex_error if @p __l is not a valid regular expression.
       *//**
       * @brief Constructs a basic regular expression from the range
       * [first, last) interpreted according to the flags in @p f.
       *
       * @param __first The start of a range containing a valid regular
       *                expression.
       * @param __last  The end of a range containing a valid regular
       *                expression.
       * @param __f     The format flags of the regular expression.
       *
       * @throws regex_error if @p [__first, __last) is not a valid regular
       *         expression.
       *//**
       * @brief Constructs a basic regular expression from the string
       * @p s interpreted according to the flags in @p f.
       *
       * @param __s A string containing a regular expression.
       * @param __f Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p __s is not a valid regular expression.
       *//**
       * @brief Move-constructs a basic regular expression.
       *
       * @param __rhs A @p regex object.
       *//**
       * @brief Copy-constructs a basic regular expression.
       *
       * @param __rhs A @p regex object.
       *//**
       * @brief Constructs a basic regular expression from the sequence
       * [p, p + len) interpreted according to the flags in @p f.
       *
       * @param __p   A pointer to the start of a string containing a regular
       *              expression.
       * @param __len The length of the string containing the regular
       *              expression.
       * @param __f   Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p __p is not a valid regular expression.
       *//**
       * @brief Constructs a basic regular expression from the
       * sequence [__p, __p + char_traits<_Ch_type>::length(__p))
       * interpreted according to the flags in @p __f.
       *
       * @param __p A pointer to the start of a C-style null-terminated string
       *          containing a regular expression.
       * @param __f Flags indicating the syntax rules and options.
       *
       * @throws regex_error if @p __p is not a valid regular expression.
       *//**
       * Constructs a basic regular expression that does not match any
       * character sequence.
       */// [7.8.2] construct/copy/destroy/**
       * @name Constants
       * std [28.8.1](1)
       */// types:/**
   * Objects of specializations of this class represent regular expressions
   * constructed from sequences of character type @p _Ch_type.
   *
   * Storage for the regular expression is allocated and deallocated as
   * necessary by the member functions of this class.
   */// [7.8] Class basic_regex/**
       * @brief Gets a copy of the current locale in use by the regex_traits
       * object.
       *//**
       * @brief Imbues the regex_traits object with a copy of a new locale.
       *
       * @param __loc A locale.
       *
       * @returns a copy of the previous locale in use by the regex_traits
       *          object.
       *
       * @note Calling imbue with a different locale than the one currently in
       *       use invalidates all cached data held by *this.
       *//**
       * @brief Converts a digit to an int.
       *
       * @param __ch    a character representing a digit.
       * @param __radix the radix if the numeric conversion (limited to 8, 10,
       *              or 16).
       *
       * @returns the value represented by the digit __ch in base radix if the
       * character __ch is a valid digit in base radix; otherwise returns -1.
       *//**
       * @brief Determines if @p c is a member of an identified class.
       *
       * @param __c a character.
       * @param __f a class type (as returned from lookup_classname).
       *
       * @returns true if the character @p __c is a member of the classification
       * represented by @p __f, false otherwise.
       *
       * @throws std::bad_cast if the current locale does not have a ctype
       *         facet.
       *//**
       * @brief Maps one or more characters to a named character
       *        classification.
       *
       * @param __first beginning of the character sequence.
       * @param __last  one-past-the-end of the character sequence.
       * @param __icase ignores the case of the classification name.
       *
       * @returns an unspecified value that represents the character
       * classification named by the character sequence designated by
       * the iterator range [__first, __last). If @p icase is true,
       * the returned mask identifies the classification regardless of
       * the case of the characters to be matched (for example,
       * [[:lower:]] is the same as [[:alpha:]]), otherwise a
       * case-dependent classification is returned.  The value
       * returned shall be independent of the case of the characters
       * in the character sequence. If the name is not recognized then
       * returns a value that compares equal to 0.
       *
       * At least the following names (or their wide-character equivalent) are
       * supported.
       * - d
       * - w
       * - s
       * - alnum
       * - alpha
       * - blank
       * - cntrl
       * - digit
       * - graph
       * - lower
       * - print
       * - punct
       * - space
       * - upper
       * - xdigit
       *//**
       * @brief Gets a collation element by name.
       *
       * @param __first beginning of the collation element name.
       * @param __last  one-past-the-end of the collation element name.
       *
       * @returns a sequence of one or more characters that represents the
       * collating element consisting of the character sequence designated by
       * the iterator range [__first, __last). Returns an empty string if the
       * character sequence is not a valid collating element.
       */// for details.// http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2003/n1429.htm// Read http://gcc.gnu.org/ml/libstdc++/2013-09/msg00117.html and// This function requires extra support from the platform.// TODO : this is not entirely correct./**
       * @brief Gets a sort key for a character sequence, independent of case.
       *
       * @param __first beginning of the character sequence.
       * @param __last  one-past-the-end of the character sequence.
       *
       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==
       * typeid(collate_byname<_Ch_type>) and the form of the sort key
       * returned by collate_byname<_Ch_type>::transform(__first, __last)
       * is known and can be converted into a primary sort key
       * then returns that key, otherwise returns an empty string.
       *
       * @todo Implement this function correctly.
       *//**
       * @brief Gets a sort key for a character sequence.
       *
       * @param __first beginning of the character sequence.
       * @param __last  one-past-the-end of the character sequence.
       *
       * Returns a sort key for the character sequence designated by the
       * iterator range [F1, F2) such that if the character sequence [G1, G2)
       * sorts before the character sequence [H1, H2) then
       * v.transform(G1, G2) < v.transform(H1, H2).
       *
       * What this really does is provide a more efficient way to compare a
       * string to multiple other strings in locales with fancy collation
       * rules and equivalence classes.
       *
       * @returns a locale-specific sort key equivalent to the input range.
       *
       * @throws std::bad_cast if the current locale does not have a collate
       *         facet.
       *//**
       * @brief Translates a character into a case-insensitive equivalent.
       *
       * @param __c A character to the locale-specific character set.
       *
       * @returns the locale-specific lower-case equivalent of __c.
       * @throws std::bad_cast if the imbued locale does not support the ctype
       *         facet.
       *//**
       * @brief Performs the identity translation.
       *
       * @param __c A character to the locale-specific character set.
       *
       * @returns __c.
       *//**
       * @brief Gives the length of a C-style string starting at @p __p.
       *
       * @param __p a pointer to the start of a character sequence.
       *
       * @returns the number of characters between @p *__p and the first
       * default-initialized value of type @p char_type.  In other words, uses
       * the C-string algorithm for determining the length of a sequence of
       * characters.
       *//**
       * @brief Constructs a default traits object.
       *//**
   * @brief Describes aspects of a regular expression.
   *
   * A regular expression traits class that satisfies the requirements of
   * section [28.7].
   *
   * The class %regex is parameterized around a set of related types and
   * functions used to complete the definition of its semantics.  This class
   * satisfies the requirements of such a traits class.
   *//**
   * @addtogroup regex
   * @{
   *//**
 *  @file bits/regex.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{regex}
 *//home/tanteikg/QCVE/sources/bitcoin/src/test/util/setup_common.h/home/tanteikg/QCVE/sources/bitcoin/src/key.h/home/tanteikg/QCVE/sources/bitcoin/src/pubkey.h/home/tanteikg/QCVE/sources/bitcoin/src/support/allocators/secure.h/home/tanteikg/QCVE/sources/bitcoin/src/support/lockedpool.h/home/tanteikg/QCVE/sources/bitcoin/src/node/caches.h/home/tanteikg/QCVE/sources/bitcoin/src/node/context.h/home/tanteikg/QCVE/sources/bitcoin/src/kernel/context.h/usr/include/x86_64-linux-gnu/c++/9/bits/basic_file.h/usr/include/x86_64-linux-gnu/c++/9/bits/c++io.h/usr/include/c++/9/bits/fstream.tcc/usr/include/c++/9/regex/usr/include/c++/9/bitset/usr/include/c++/9/stack/usr/include/c++/9/deque/usr/include/c++/9/bits/stl_deque.h/usr/include/c++/9/bits/deque.tcc/usr/include/c++/9/bits/stl_stack.h/usr/include/c++/9/bits/regex_constants.h/usr/include/c++/9/bits/regex_error.h/usr/include/c++/9/bits/regex_automaton.h/usr/include/c++/9/bits/regex_automaton.tcc/usr/include/c++/9/bits/regex_scanner.h/usr/include/c++/9/bits/regex_scanner.tcc/usr/include/c++/9/bits/regex_compiler.h/usr/include/c++/9/bits/regex_compiler.tcc/usr/include/c++/9/bits/regex_executor.h/usr/include/c++/9/bits/regex_executor.tcc/usr/include/c++/9/memory_resource/usr/include/c++/9/shared_mutex/home/tanteikg/QCVE/sources/bitcoin/src/bench/bench.cpp<regex><fstream><test/util/setup_common.h>item_tGenerateTemplateResultsfoutCreated "Created "Could not write to file "Could not write to file "lambda [] type at line 170381, col. 41lambda [] type at line 170381, col. 41 &&lambda [] type at line 170381, col. 41 &const lambda [] type at line 170381, col. 41const lambda [] type at line 170381, col. 41 &operator auto (*)(const auto &)const lambda [] type at line 170381, col. 41 *lambda [] type at line 170381, col. 41 *lambda [] type at line 170379, col. 29lambda [] type at line 170379, col. 29 &&lambda [] type at line 170379, col. 29 &const lambda [] type at line 170379, col. 29const lambda [] type at line 170379, col. 29 &operator bool (*)(item_t, item_t)const lambda [] type at line 170379, col. 29 *lambda [] type at line 170379, col. 29 *Unknown priority level %s"Unknown priority level %s"const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>sort_by_prioritysorted_prioritiesconst pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &const set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &const _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>','reFilterbaseMatchRunning with -sanity-check option, output is being suppressed as benchmark results will be useless."Running with -sanity-check option, output is being suppressed as benchmark results will be useless."const char[100]char[100]benchmarkResultsconst pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>pair<function<..(..)>, PriorityLevel> &bench_funcconst pair<function<..(..)>, PriorityLevel>const pair<function<..(..)>, PriorityLevel> &PriorityLevel &priority_levelmatch_results<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>> &const basic_regex<char, regex_traits<char>>const basic_regex<char, regex_traits<char>> &basic_regex<char, regex_traits<char>> &smatch &const millisecondsconst milliseconds &min_time_nsconst duration<unsigned long, ratio<1L, 1000000000L>>const duration<unsigned long, ratio<1L, 1000000000L>> &duration<unsigned long, ratio<1L, 1000000000L>> &const vector<double, allocator<double>> &vector<double, allocator<double>> &const __normal_iterator<const double *, vector<double, allocator<double>>>const __normal_iterator<const double *, vector<double, allocator<double>>> &__normal_iterator<const double *, vector<double, allocator<double>>> &# Benchmark, evals, iterations, total, min, max, median
{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}
{{/result}}"# Benchmark, evals, iterations, total, min, max, median\n"
                                                               "{{#result}}{{name}}, {{epochs}}, {{average(iterations)}}, {{sumProduct(iterations, elapsed)}}, {{minimum(elapsed)}}, {{maximum(elapsed)}}, {{median(elapsed)}}\n"
                                                               "{{/result}}"const char[227]char[227]pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &&pair<function<..(..)>, PriorityLevel> &&BenchFunction &pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &benchmarks_map<auto-1>G_TEST_COMMAND_LINE_ARGUMENTSG_TEST_LOG_FUNmap_label_priorityconst pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>[3]pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>[3]high"high"const char(&)[5]char(&)[5]PriorityLevel::HIGH"low"const char(&)[4]char(&)[4]PriorityLevel::LOWall"all"const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *// convert to nanos before dividing to reduce rounding errors// map a label to one or multiple priority levels// nothing to write, bail outtplinitializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> *pair<function<..(..)>, PriorityLevel> *duration<unsigned long, ratio<1L, 1000000000L>>pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> *pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &map<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const map<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const map<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *map<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *multimap<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&multimap<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &map<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&map<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *multiset<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Compare1, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&multiset<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Compare1, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Compare1, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Compare1, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &regex_iterator<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>, char, regex_traits<char>>const PriorityLevelconst PriorityLevel &const map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> *map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> *multimap<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&multimap<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &allocator<BigO> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Compare2, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &_Vector_base<BigO, allocator<BigO>>_Vector_base<BigO, allocator<BigO>> &const _Vector_base<BigO, allocator<BigO>>const _Vector_base<BigO, allocator<BigO>> &_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &const _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &_S_pointer_to_M_pmapped_M_pkey_Optional_payload_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>_Optional_payload<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true, false, false>const _Optional_payload_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const _Optional_payload_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &_Optional_payload_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &_Optional_payload_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &new_allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>new_allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &const new_allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const new_allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &new_allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>new_allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &const new_allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const new_allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &new_allocator<BigO>new_allocator<BigO> &const new_allocator<BigO>const new_allocator<BigO> &allocator_traits<allocator<BigO>>allocator_traits<allocator<BigO>> &allocator_traits<allocator<BigO>> &&const allocator_traits<allocator<BigO>>const allocator_traits<allocator<BigO>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>allocator_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const allocator_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const allocator_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>allocator_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>> &allocator_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>const allocator_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>> &allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &__rebind<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, void>__rebind<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, void> &__rebind<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, void> &&const __rebind<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, void>const __rebind<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, void> &sregex_iteratorconst shared_ptr<const _NFA<regex_traits<char>>>const shared_ptr<const _NFA<regex_traits<char>>> &shared_ptr<const _NFA<regex_traits<char>>> &const _AutomatonPtrconst _AutomatonPtr &vector<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>> &_NFA<regex_traits<char>> *const __shared_ptr<const _NFA<regex_traits<char>>, _S_atomic>const __shared_ptr_access<const _NFA<regex_traits<char>>, _S_atomic, false, false>const _NFA_baseconst _NFA_base *_NFA_base *sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>> &const __normal_iterator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>> *, vector<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>>>const __normal_iterator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>> *, vector<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>>> &__normal_iterator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>> *, vector<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>>> &regex_constants::__polynomial__policy == _RegexExecutorPolicy::_S_alternate__policy == _RegexExecutorPolicy::_S_alternate
	      && !__re._M_automaton->_M_has_backref(__policy == _RegexExecutorPolicy::_S_alternate
	      && !__re._M_automaton->_M_has_backref)~_Executor_Executor<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>, regex_traits<char>, false> *~_State_info_State_info<integral_constant<bool, false>, vector<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>>> *_Executor<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>, allocator<sub_match<__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>>>, regex_traits<char>, true> *PriorityLevel &&..(*)(..))[5]initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *basic_regex<char, regex_traits<char>> *~shared_ptrshared_ptr<const _NFA<regex_traits<char>>> *const vector<Result, allocator<Result>> *const __normal_iterator<const Result *, vector<Result, allocator<Result>>>regex_constants::match_defaultconst _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *const _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *const _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const __normal_iterator<const Result *, vector<Result, allocator<Result>>> &__normal_iterator<const Result *, vector<Result, allocator<Result>>> &_Vector_base<BigO, allocator<BigO>> *const _Vector_base<Result, allocator<Result>> *const allocator<Result>const allocator<Result> &common_type<signed long, unsigned long>common_type<signed long, unsigned long> &common_type<signed long, unsigned long> &&const common_type<signed long, unsigned long>const common_type<signed long, unsigned long> &common_type<unsigned long, signed long>common_type<unsigned long, signed long> &common_type<unsigned long, signed long> &&const common_type<unsigned long, signed long>const common_type<unsigned long, signed long> &__alloc_traits<allocator<BigO>, BigO>__alloc_traits<allocator<BigO>, BigO> &__alloc_traits<allocator<BigO>, BigO> &&const __alloc_traits<allocator<BigO>, BigO>const __alloc_traits<allocator<BigO>, BigO> &__normal_iterator<const Result *, vector<Result, allocator<Result>>> &&const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> *const BigO *const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &const _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&_Storage<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false>_Storage<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false> &const _Storage<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false>const _Storage<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false> &_Node_handle_common<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>_Node_handle_common<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &const _Node_handle_common<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const _Node_handle_common<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &pair<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool>pair<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Compare2, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Rb_tree_impl<lambda [] type at line 170379, col. 29, false>_Rb_tree_impl<lambda [] type at line 170379, col. 29, false> &const _Rb_tree_impl<lambda [] type at line 170379, col. 29, false>const _Rb_tree_impl<lambda [] type at line 170379, col. 29, false> &_Rb_tree_impl<lambda [] type at line 170379, col. 29, false> *_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &map<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>multimap<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>pair<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>__pair_base<function<..(..)>, PriorityLevel>_Callable<function<..(..)>, __invoke_result<function<..(..)> &, Bench &>>_Callable<function<..(..)>, __invoke_result<function<..(..)> &, Bench &>> &_Callable<function<..(..)>, __invoke_result<function<..(..)> &, Bench &>> &&const _Callable<function<..(..)>, __invoke_result<function<..(..)> &, Bench &>>const _Callable<function<..(..)>, __invoke_result<function<..(..)> &, Bench &>> &pair<_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool>set<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Compare1, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>multiset<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Compare1, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>pair<_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>map<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>multimap<basic_string<char, char_traits<char>, allocator<char>>, unsigned char, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>pair<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>__pair_base<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>__pair_base<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>tuple_element<(unsigned long)0UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>tuple_element<(unsigned long)0UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<(unsigned long)0UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const tuple_element<(unsigned long)0UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const tuple_element<(unsigned long)0UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<(unsigned long)0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>tuple_element<(unsigned long)0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<(unsigned long)0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const tuple_element<(unsigned long)0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const tuple_element<(unsigned long)0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<1UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>tuple_element<1UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<1UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const tuple_element<1UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const tuple_element<1UL, const pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<1UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>tuple_element<1UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<1UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const tuple_element<1UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const tuple_element<1UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &tuple_element<(unsigned long)0UL, const pair<function<..(..)>, PriorityLevel>>tuple_element<(unsigned long)0UL, const pair<function<..(..)>, PriorityLevel>> &tuple_element<(unsigned long)0UL, const pair<function<..(..)>, PriorityLevel>> &&const tuple_element<(unsigned long)0UL, const pair<function<..(..)>, PriorityLevel>>const tuple_element<(unsigned long)0UL, const pair<function<..(..)>, PriorityLevel>> &tuple_element<(unsigned long)0UL, pair<function<..(..)>, PriorityLevel>>tuple_element<(unsigned long)0UL, pair<function<..(..)>, PriorityLevel>> &tuple_element<(unsigned long)0UL, pair<function<..(..)>, PriorityLevel>> &&const tuple_element<(unsigned long)0UL, pair<function<..(..)>, PriorityLevel>>const tuple_element<(unsigned long)0UL, pair<function<..(..)>, PriorityLevel>> &tuple_element<1UL, const pair<function<..(..)>, PriorityLevel>>tuple_element<1UL, const pair<function<..(..)>, PriorityLevel>> &tuple_element<1UL, const pair<function<..(..)>, PriorityLevel>> &&const tuple_element<1UL, const pair<function<..(..)>, PriorityLevel>>const tuple_element<1UL, const pair<function<..(..)>, PriorityLevel>> &tuple_element<1UL, pair<function<..(..)>, PriorityLevel>>tuple_element<1UL, pair<function<..(..)>, PriorityLevel>> &tuple_element<1UL, pair<function<..(..)>, PriorityLevel>> &&const tuple_element<1UL, pair<function<..(..)>, PriorityLevel>>const tuple_element<1UL, pair<function<..(..)>, PriorityLevel>> &pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>__pair_base<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> *allocator<BigO> *new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> *const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> *new_allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *const new_allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *const new_allocator<Result> *30340039594917025new_allocator<BigO> *const Result *constconst Result *const &Result *&_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *const allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *const _Rb_tree<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, lambda [] type at line 170379, col. 29, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> *const duration<unsigned long, ratio<1L, 1000000000L>> *duration<unsigned long, ratio<1L, 1000000000L>> *const double *constconst double *const &double *&Result *constResult *const &const __normal_iterator<Result *, vector<Result, allocator<Result>>>const __normal_iterator<Result *, vector<Result, allocator<Result>>> &__normal_iterator<Result *, vector<Result, allocator<Result>>> &const __normal_iterator<const Result *, vector<Result, allocator<Result>>> *__normal_iterator<const Result *, vector<Result, allocator<Result>>> *const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *is_trivially_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_trivially_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_trivially_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_trivially_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_trivially_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_nothrow_constructible<Result, const Result &>is_nothrow_constructible<Result, const Result &> &is_nothrow_constructible<Result, const Result &> &&const is_nothrow_constructible<Result, const Result &>const is_nothrow_constructible<Result, const Result &> &__duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true>__duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true> &__duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true> &&const __duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true>const __duration_cast_impl<duration<signed long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true> &_PCC<true, basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>_PCC<true, basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &_PCC<true, basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &&const _PCC<true, basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>const _PCC<true, basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &_PCC<<expression>, basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>enable_if<true, pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>>enable_if<true, pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>> &enable_if<true, pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>> &&const enable_if<true, pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>>const enable_if<true, pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>> &__pair_base<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>treat_as_floating_point<unsigned long>treat_as_floating_point<unsigned long> &treat_as_floating_point<unsigned long> &&const treat_as_floating_point<unsigned long>const treat_as_floating_point<unsigned long> &add_const<PriorityLevel>add_const<PriorityLevel> &add_const<PriorityLevel> &&const add_const<PriorityLevel>const add_const<PriorityLevel> &add_const<function<..(..)>>add_const<function<..(..)>> &add_const<function<..(..)>> &&const add_const<function<..(..)>>const add_const<function<..(..)>> &add_const<pair<function<..(..)>, PriorityLevel>>add_const<pair<function<..(..)>, PriorityLevel>> &add_const<pair<function<..(..)>, PriorityLevel>> &&const add_const<pair<function<..(..)>, PriorityLevel>>const add_const<pair<function<..(..)>, PriorityLevel>> &_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &&const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> &_PCC<<expression>, const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &&const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &_PCC<<expression>, const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__pair_base<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>__pair_base<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>__alloc_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>__alloc_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__alloc_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const __alloc_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const __alloc_traits<allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__pair_base<_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>__invoke_result<function<..(..)> &, Bench &>_PCC<true, function<..(..)>, PriorityLevel>_PCC<true, function<..(..)>, PriorityLevel> &_PCC<true, function<..(..)>, PriorityLevel> &&const _PCC<true, function<..(..)>, PriorityLevel>const _PCC<true, function<..(..)>, PriorityLevel> &_PCC<<expression>, function<..(..)>, PriorityLevel>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &__pair_base<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>__pair_base<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>__normal_iterator<Result *, vector<Result, allocator<Result>>> &&__normal_iterator<BigO *, vector<BigO, allocator<BigO>>>__normal_iterator<const BigO *, vector<BigO, allocator<BigO>>>reverse_iterator<__normal_iterator<const BigO *, vector<BigO, allocator<BigO>>>>reverse_iterator<__normal_iterator<BigO *, vector<BigO, allocator<BigO>>>>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &reverse_iterator<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>reverse_iterator<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>_Node_insert_return<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, value_type>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const basic_string<char, char_traits<char>, allocator<char>>>unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const basic_string<char, char_traits<char>, allocator<char>>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const basic_string<char, char_traits<char>, allocator<char>>> &&const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const basic_string<char, char_traits<char>, allocator<char>>>const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const basic_string<char, char_traits<char>, allocator<char>>> &__alloc_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>__alloc_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &__alloc_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const __alloc_traits<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>, _Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree_key_compare<lambda [] type at line 170379, col. 29>_Rb_tree_key_compare<lambda [] type at line 170379, col. 29> &const _Rb_tree_key_compare<lambda [] type at line 170379, col. 29>const _Rb_tree_key_compare<lambda [] type at line 170379, col. 29> &reverse_iterator<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>reverse_iterator<_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_Node_handle<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>_Node_insert_return<_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Node_handle<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>>>is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, value_type>is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &unary_function<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>unary_function<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &unary_function<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const unary_function<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const unary_function<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__pair_base<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &reverse_iterator<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>reverse_iterator<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>_Node_insert_return<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, value_type>unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, const basic_string<char, char_traits<char>, allocator<char>>>unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, const basic_string<char, char_traits<char>, allocator<char>>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, const basic_string<char, char_traits<char>, allocator<char>>> &&const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, const basic_string<char, char_traits<char>, allocator<char>>>const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, const basic_string<char, char_traits<char>, allocator<char>>> &__ptr_rebindoptional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &unsigned char[40]__aligned_membuf<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>__aligned_membuf<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__aligned_membuf<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const __aligned_membuf<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const __aligned_membuf<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &unsigned char[72]remove_reference<PriorityLevel>remove_reference<PriorityLevel> &remove_reference<PriorityLevel> &&const remove_reference<PriorityLevel>const remove_reference<PriorityLevel> &__decay_and_strip<function<..(..)> &>__decay_and_strip<function<..(..)> &> &__decay_and_strip<function<..(..)> &> &&const __decay_and_strip<function<..(..)> &>const __decay_and_strip<function<..(..)> &> &__decay_and_strip<PriorityLevel &>__decay_and_strip<PriorityLevel &> &__decay_and_strip<PriorityLevel &> &&const __decay_and_strip<PriorityLevel &>const __decay_and_strip<PriorityLevel &> &remove_reference<PriorityLevel &>remove_reference<PriorityLevel &> &remove_reference<PriorityLevel &> &&const remove_reference<PriorityLevel &>const remove_reference<PriorityLevel &> &__decay_and_strip<pair<function<..(..)>, PriorityLevel>>__decay_and_strip<pair<function<..(..)>, PriorityLevel>> &__decay_and_strip<pair<function<..(..)>, PriorityLevel>> &&const __decay_and_strip<pair<function<..(..)>, PriorityLevel>>const __decay_and_strip<pair<function<..(..)>, PriorityLevel>> &remove_reference<pair<function<..(..)>, PriorityLevel>>remove_reference<pair<function<..(..)>, PriorityLevel>> &remove_reference<pair<function<..(..)>, PriorityLevel>> &&const remove_reference<pair<function<..(..)>, PriorityLevel>>const remove_reference<pair<function<..(..)>, PriorityLevel>> &remove_reference<pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>remove_reference<pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &remove_reference<pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const remove_reference<pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const remove_reference<pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &rebind<BigO>rebind<BigO> &rebind<BigO> &&const rebind<BigO>const rebind<BigO> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *&const __normal_iterator<Result *, vector<Result, allocator<Result>>> *__normal_iterator<Result *, vector<Result, allocator<Result>>> *__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *const __aligned_membuf<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *__aligned_membuf<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *new_allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *12810238940076077588686269585142075__duration_cast_impl<duration<unsigned long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true>__duration_cast_impl<duration<unsigned long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true> &__duration_cast_impl<duration<unsigned long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true> &&const __duration_cast_impl<duration<unsigned long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true>const __duration_cast_impl<duration<unsigned long, ratio<1L, 1000000000L>>, ratio<1L, 1L>, unsigned long, true, true> &is_constructible<Result, Result &&>is_constructible<Result, Result &&> &is_constructible<Result, Result &&> &&const is_constructible<Result, Result &&>const is_constructible<Result, Result &&> &__is_move_constructible_impl<Result, true>__is_move_constructible_impl<Result, true> &__is_move_constructible_impl<Result, true> &&const __is_move_constructible_impl<Result, true>const __is_move_constructible_impl<Result, true> &is_move_constructible<Result>is_move_constructible<Result> &is_move_constructible<Result> &&const is_move_constructible<Result>const is_move_constructible<Result> &__is_move_insertable<allocator<Result>>__is_move_insertable<allocator<Result>> &__is_move_insertable<allocator<Result>> &&const __is_move_insertable<allocator<Result>>const __is_move_insertable<allocator<Result>> &__common_type_impl<signed long, unsigned long>__common_type_impl<signed long, unsigned long> &__common_type_impl<signed long, unsigned long> &&const __common_type_impl<signed long, unsigned long>const __common_type_impl<signed long, unsigned long> &__common_type_impl<unsigned long, signed long>__common_type_impl<unsigned long, signed long> &__common_type_impl<unsigned long, signed long> &&const __common_type_impl<unsigned long, signed long>const __common_type_impl<unsigned long, signed long> &__and_<is_same<BigO *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<const Result *>iterator_traits<const Result *> &iterator_traits<const Result *> &&const iterator_traits<const Result *>const iterator_traits<const Result *> &__strip_reference_wrapper<pair<function<..(..)>, PriorityLevel>>__strip_reference_wrapper<pair<function<..(..)>, PriorityLevel>> &__strip_reference_wrapper<pair<function<..(..)>, PriorityLevel>> &&const __strip_reference_wrapper<pair<function<..(..)>, PriorityLevel>>const __strip_reference_wrapper<pair<function<..(..)>, PriorityLevel>> &__strip_reference_wrapper<PriorityLevel>__strip_reference_wrapper<PriorityLevel> &__strip_reference_wrapper<PriorityLevel> &&const __strip_reference_wrapper<PriorityLevel>const __strip_reference_wrapper<PriorityLevel> &__strip_reference_wrapper<function<..(..)>>__strip_reference_wrapper<function<..(..)>> &__strip_reference_wrapper<function<..(..)>> &&const __strip_reference_wrapper<function<..(..)>>const __strip_reference_wrapper<function<..(..)>> &_Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>_Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &_Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const _Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const _Enable_copy_move<true, true, true, true, optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &_Optional_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false, false>_PCC<true, _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool>_PCC<true, _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool> &_PCC<true, _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool> &&const _PCC<true, _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool>const _PCC<true, _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool> &_PCC<<expression>, _Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, bool>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &is_same<PriorityLevel, _U2>is_same<function<..(..)>, _U1>_PCC<true, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_PCC<true, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_PCC<true, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const _PCC<true, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>rebind<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>rebind<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &rebind<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const rebind<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const rebind<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &rebind<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>rebind<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &rebind<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const rebind<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const rebind<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &is_same<pair<function<..(..)>, PriorityLevel>, _U2>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool> &&const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool> &_PCC<<expression>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, bool>remove_reference<const Result &>remove_reference<const Result &> &remove_reference<const Result &> &&const remove_reference<const Result &>const remove_reference<const Result &> &__and_<is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>>__and_<is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &__and_<is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &&const __and_<is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>>const __and_<is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &unsigned char(*)[40]_Rb_tree_key_compare<lambda [] type at line 170379, col. 29> *_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&const unsigned char[40]const unsigned char(*)[40]unsigned char(*)[72]Result *&&const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> *is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>__and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const __and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const __and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &__and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>__and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &__and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const __and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const __and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &is_trivially_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_trivially_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_trivially_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_trivially_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_trivially_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_trivially_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_trivially_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_trivially_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_trivially_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_trivially_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_nothrow_destructible<Result>is_nothrow_destructible<Result> &is_nothrow_destructible<Result> &&const is_nothrow_destructible<Result>const is_nothrow_destructible<Result> &__is_invocable<lambda [] type at line 170379, col. 29 &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>__is_invocable<lambda [] type at line 170379, col. 29 &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &__is_invocable<lambda [] type at line 170379, col. 29 &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &&const __is_invocable<lambda [] type at line 170379, col. 29 &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>const __is_invocable<lambda [] type at line 170379, col. 29 &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &, const pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &enable_if<true, duration<unsigned long, ratio<1L, 1000000000L>>>enable_if<true, duration<unsigned long, ratio<1L, 1000000000L>>> &enable_if<true, duration<unsigned long, ratio<1L, 1000000000L>>> &&const enable_if<true, duration<unsigned long, ratio<1L, 1000000000L>>>const enable_if<true, duration<unsigned long, ratio<1L, 1000000000L>>> &is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _U1>__and_<is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _U2>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _U1>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _U2>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _U1>__and_<is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _U2>is_same<_Rb_tree_const_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _U1>__and_<is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _U2>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _U1>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>, _U2>__and_<is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>, _U1>__and_<is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *, _Ptr>, __not_<is_pointer<_Ptr>>>pointer_traits<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *>pointer_traits<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *> &pointer_traits<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *> &&const pointer_traits<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *>const pointer_traits<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *> &__not_<is_same<optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, type>>_Optional_payload<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false, false, false>_Optional_base_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Optional_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false, false>>_Optional_base_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Optional_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false, false>> &_Optional_base_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Optional_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false, false>> &&const _Optional_base_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Optional_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false, false>>const _Optional_base_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, _Optional_base<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, false, false>> &remove_const<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>remove_const<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &remove_const<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const remove_const<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const remove_const<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_same<BigO *, _Ptr>remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &&const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &>remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &> &remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &> &&const remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &>const remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &> &remove_reference<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>remove_reference<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &remove_reference<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&const remove_reference<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const remove_reference<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &iterator_traits<Result *>iterator_traits<Result *> &iterator_traits<Result *> &&const iterator_traits<Result *>const iterator_traits<Result *> &__is_referenceable<Result>__is_referenceable<Result> &__is_referenceable<Result> &&const __is_referenceable<Result>const __is_referenceable<Result> &remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &&const remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>const remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &remove_reference<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &>remove_reference<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &> &remove_reference<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &> &&const remove_reference<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &>const remove_reference<allocator<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *const _Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *_Identity<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *is_trivially_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_trivially_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_trivially_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_trivially_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_trivially_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_trivially_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>is_trivially_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_trivially_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const is_trivially_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const is_trivially_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>, pair<basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &is_same<optional<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, type>is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *, _Ptr>is_same<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *, _Ptr>is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *, _Ptr>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>> *, _Ptr>is_same<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *, _Ptr>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> *, _Ptr>conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const conditional<true, integral_constant<bool, false>, is_destructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &remove_reference<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>remove_reference<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &remove_reference<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &&const remove_reference<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>>const remove_reference<_Rb_tree_iterator<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *&>remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *&> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *&> &&const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *&>const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> *&> &__is_trivially_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_trivially_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_trivially_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_trivially_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_trivially_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_trivially_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_move_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_copy_constructible_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *const unsigned char[72]const unsigned char(*)[72]is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &&const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>> &is_nothrow_copy_constructible<Result *>is_nothrow_copy_constructible<Result *> &is_nothrow_copy_constructible<Result *> &&const is_nothrow_copy_constructible<Result *>const is_nothrow_copy_constructible<Result *> &is_nothrow_constructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>is_nothrow_constructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &is_nothrow_constructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &&const is_nothrow_constructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>const is_nothrow_constructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &> &is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &> &&const is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &>const is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &> &is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &>is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &> &is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &> &&const is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &>const is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &> &conditional<true, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>conditional<true, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &conditional<true, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const conditional<true, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const conditional<true, is_copy_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&> &is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&> &&const is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&>const is_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&> &is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&>is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&> &is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&> &&const is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&>const is_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>> &&> &conditional<true, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>conditional<true, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &conditional<true, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const conditional<true, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const conditional<true, is_move_assignable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>>__and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &__and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &&const __and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>>const __and_<is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &__is_referenceable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>__is_referenceable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &__is_referenceable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &&const __is_referenceable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>const __is_referenceable<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>> &__and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>>__and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &__and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &&const __and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>>const __and_<is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>, integral_constant<bool, false>> &remove_reference<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&>remove_reference<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&> &remove_reference<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&> &&const remove_reference<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&>const remove_reference<_Rb_tree_node<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&> &__is_trivially_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_trivially_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_trivially_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_trivially_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_trivially_move_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>__is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &__is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &&const __is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true>const __is_trivially_copy_assignable_impl<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>, true> &is_nothrow_destructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>is_nothrow_destructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &is_nothrow_destructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &&const is_nothrow_destructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>>const is_nothrow_destructible<pair<basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> &__is_nothrow_copy_constructible_impl<Result *, true>__is_nothrow_copy_constructible_impl<Result *, true> &__is_nothrow_copy_constructible_impl<Result *, true> &&const __is_nothrow_copy_constructible_impl<Result *, true>const __is_nothrow_copy_constructible_impl<Result *, true> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&>remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&> &&const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&>const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>> *&> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &&const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &>const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, unsigned char> &> &is_nothrow_constructible<Result, Result>is_nothrow_constructible<Result, Result> &is_nothrow_constructible<Result, Result> &&const is_nothrow_constructible<Result, Result>const is_nothrow_constructible<Result, Result> &__is_referenceable<Result *>__is_referenceable<Result *> &__is_referenceable<Result *> &&const __is_referenceable<Result *>const __is_referenceable<Result *> &is_nothrow_constructible<Result *, Result *const &>is_nothrow_constructible<Result *, Result *const &> &is_nothrow_constructible<Result *, Result *const &> &&const is_nothrow_constructible<Result *, Result *const &>const is_nothrow_constructible<Result *, Result *const &> &conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const conditional<true, integral_constant<bool, false>, is_copy_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &&const conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>>const conditional<true, integral_constant<bool, false>, is_move_constructible<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, pair<function<..(..)>, PriorityLevel>>>>>> &remove_reference<Result &>remove_reference<Result &> &remove_reference<Result &> &&const remove_reference<Result &>const remove_reference<Result &> &remove_reference<Result>remove_reference<Result> &remove_reference<Result> &&const remove_reference<Result>const remove_reference<Result> &<bits/istream.tcc>_Istream_Istream &&basic_istream<_Ch, _Up> &__is_convertible_to_basic_istream_testbasic_istream<_Ch, _Up> *basic_istream<char, _Traits> &basic_iostream<_CharT, _Traits> &&const basic_iostream<_CharT, _Traits>const basic_iostream<_CharT, _Traits> &basic_iostreambasic_iostream<_CharT, _Traits> *~basic_iostreamconst basic_istream<_CharT, _Traits>const basic_istream<_CharT, _Traits> &basic_istreambasic_istream<_CharT, _Traits> *__istream_type &__streambuf_type &basic_streambuf<_CharT, _Traits> &gcountunsigned long long &long long &long &~basic_istream__istream_type__rvalue_istream_type__is_extractable<_Istream, _Tp, __void_t<decltype((<expression>))>>__is_extractable<_Istream, _Tp, <unnamed>>__is_convertible_to_basic_istream<_Tp>__is_convertible_to_basic_istream_impl<_Tp, __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>__do_is_convertible_to_basic_istream_impl__is_convertible_to_basic_istream_impl<_Tp, <unnamed>>basic_iostream<_CharT, _Traits>basic_istream<_CharT, _Traits>wsbasic_istream<_CharT2, _Traits2> &_CharT2_CharT2 *_Traits2_CharT &_ValueT &_M_gcount_GLIBCXX_ISTREAMseekgtellgungetputbackreadsomepeekchar_type &short &/* _GLIBCXX_ISTREAM *//**
   *  @brief  Generic extractor for rvalue stream
   *  @param  __is  An input stream.
   *  @param  __x  A reference to the extraction target.
   *  @return  is
   *
   *  This is just a forwarding function to allow extraction from
   *  rvalue streams since they won't bind to the extractor functions
   *  that take an lvalue reference.
  */// 2328. Rvalue stream extraction should use perfect forwarding// [27.7.1.6] Rvalue stream extraction/**
   *  @brief  Quick and easy way to eat whitespace
   *
   *  This manipulator extracts whitespace characters, stopping when the
   *  next character is non-whitespace, or when the input sequence is empty.
   *  If the sequence is empty, @c eofbit is set in the stream, but not
   *  @c failbit.
   *
   *  The current locale is used to distinguish whitespace characters.
   *
   *  Example:
   *  @code
   *     MyClass   mc;
   *
   *     std::cin >> std::ws >> mc;
   *  @endcode
   *  will skip leading whitespace before calling operator>> on cin and your
   *  object.  Note that the same effect can be achieved by creating a
   *  std::basic_istream::sentry inside your definition of operator>>.
  *//**
       *  @brief  Destructor does nothing.
      *//**
       *  @brief  Constructor does nothing.
       *
       *  Both of the parent classes are initialized with the same
       *  streambuf pointer passed to this constructor.
      */// Types (inherited):// 271. basic_iostream missing typedefs/**
   *  @brief  Template class basic_iostream
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This class multiply inherits from the input and output stream classes
   *  simply to provide a single interface.
  */// Explicit specialization declaration, defined in src/istream.cc./**
   *  @brief  Character string extractors
   *  @param  __in  An input stream.
   *  @param  __s  A pointer to a character array.
   *  @return  __in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts up to @c n characters and stores them
   *  into the array starting at @a __s.  @c n is defined as:
   *
   *  - if @c width() is greater than zero, @c n is width() otherwise
   *  - @c n is <em>the number of elements of the largest array of *
   *  - @c char_type that can store a terminating @c eos.</em>
   *  - [27.6.1.2.3]/6
   *
   *  Characters are extracted and stored until one of the following happens:
   *  - @c n-1 characters are stored
   *  - EOF is reached
   *  - the next character is whitespace according to the current locale
   *  - the next character is a null byte (i.e., @c charT() )
   *
   *  @c width(0) is then called for the input stream.
   *
   *  If no characters are extracted, sets failbit.
  *//**
   *  @brief  Character extractors
   *  @param  __in  An input stream.
   *  @param  __c  A character reference.
   *  @return  in
   *
   *  Behaves like one of the formatted arithmetic extractors described in
   *  std::basic_istream.  After constructing a sentry object with good
   *  status, this function extracts a character (if one is available) and
   *  stores it in @a __c.  Otherwise, sets failbit in the input stream.
  *//**
       *  @brief  The constructor performs all the work.
       *  @param  __is  The input stream to guard.
       *  @param  __noskipws  Whether to consume whitespace or not.
       *
       *  If the stream state is good (@a __is.good() is true), then the
       *  following actions are performed, otherwise the sentry state
       *  is false (<em>not okay</em>) and failbit is set in the
       *  stream state.
       *
       *  The sentry's preparatory actions are:
       *
       *  -# if the stream is tied to an output stream, @c is.tie()->flush()
       *     is called to synchronize the output sequence
       *  -# if @a __noskipws is false, and @c ios_base::skipws is set in
       *     @c is.flags(), the sentry extracts and discards whitespace
       *     characters from the stream.  The currently imbued locale is
       *     used to determine whether each character is whitespace.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      *//// Easy access to dependent types./**
   *  @brief  Performs setup work for input streams.
   *
   *  Objects of this class are created before all of the standard
   *  extractors are run.  It is responsible for <em>exception-safe
   *  prefix and suffix operations,</em> although only prefix actions
   *  are currently required by the standard.
  *//// Explicit specialization declarations, defined in src/istream.cc./**
       *  @brief  Changing the current read position.
       *  @param  __off  A file offset object.
       *  @param  __dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(__off,__dir).
       *  If that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      *//**
       *  @brief  Changing the current read position.
       *  @param  __pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(__pos).  If
       *  that function fails, sets failbit.
       *
       *  @note  This function first clears eofbit.  It does not count the
       *         number of characters extracted, if any, and therefore does
       *         not affect the next call to @c gcount().
      *//**
       *  @brief  Getting the current read position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().  At variance with putback, unget and
       *         seekg, eofbit is not cleared first.
      *//**
       *  @brief  Synchronizing the stream buffer.
       *  @return  0 on success, -1 on failure
       *
       *  If @c rdbuf() is a null pointer, returns -1.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit and returns -1.
       *
       *  Otherwise, returns 0.
       *
       *  @note  This function does not count the number of characters
       *         extracted, if any, and therefore does not affect the next
       *         call to @c gcount().
      *//**
       *  @brief  Unextracting the previous character.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).
       *
       *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      *//**
       *  @brief  Unextracting a single character.
       *  @param  __c  The character to push back into the input stream.
       *  @return  *this
       *
       *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).
       *
       *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in
       *  the error state.
       *
       *  @note  This function first clears eofbit.  Since no characters
       *         are extracted, the next call to @c gcount() will return 0,
       *         as required by DR 60.
      *//**
       *  @brief  Extraction until the buffer is exhausted, but no more.
       *  @param  __s  A character array.
       *  @param  __n  Maximum number of characters to store.
       *  @return  The number of characters extracted.
       *
       *  Extracts characters and stores them into @a __s depending on the
       *  number of characters remaining in the streambuf's buffer,
       *  @c rdbuf()->in_avail(), called @c A here:
       *  - if @c A @c == @c -1, sets eofbit and extracts no characters
       *  - if @c A @c == @c 0, extracts no characters
       *  - if @c A @c > @c 0, extracts @c min(A,n)
       *
       *  The goal is to empty the current buffer, and to not request any
       *  more from the external input sequence controlled by the streambuf.
      *//**
       *  @brief  Extraction without delimiters.
       *  @param  __s  A character array.
       *  @param  __n  Maximum number of characters to store.
       *  @return  *this
       *
       *  If the stream state is @c good(), extracts characters and stores
       *  them into @a __s until one of the following happens:
       *  - @a __n characters are stored
       *  - the input sequence reaches end-of-file, in which case the error
       *    state is set to @c failbit|eofbit.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Looking ahead in the stream
       *  @return  The next character, or eof().
       *
       *  If, after constructing the sentry object, @c good() is false,
       *  returns @c traits::eof().  Otherwise reads but does not extract
       *  the next input character.
      *//**
       *  @brief  Discarding characters
       *  @param  __n  Number of characters to discard.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts characters and throws them away until one of the
       *  following happens:
       *  - if @a __n @c != @c std::numeric_limits<int>::max(), @a __n
       *    characters are extracted
       *  - the input sequence reaches end-of-file
       *  - the next character equals @a __delim (in this case, the character
       *    is extracted); note that this condition will never occur if
       *    @a __delim equals @c traits::eof().
       *
       *  NB: Provide three overloads, instead of the single function
       *  (with defaults) mandated by the Standard: this leads to a
       *  better performing implementation, while still conforming to
       *  the Standard.
      *//**
       *  @brief  String extraction.
       *  @param  __s  A character array in which to store the data.
       *  @param  __n  Maximum number of characters to extract.
       *  @return  *this
       *
       *  Returns @c getline(__s,__n,widen(&apos;\\n&apos;)).
      *//**
       *  @brief  String extraction.
       *  @param  __s  A character array in which to store the data.
       *  @param  __n  Maximum number of characters to extract.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Extracts and stores characters into @a __s until one of the
       *  following happens.  Note that these criteria are required to be
       *  tested in the order listed here, to allow an input line to exactly
       *  fill the @a __s array without setting failbit.
       *
       *  -# the input sequence reaches end-of-file, in which case eofbit
       *     is set in the stream error state
       *  -# the next character equals @c __delim, in which case the character
       *     is extracted (and therefore counted in @c gcount()) but not stored
       *  -# @c __n-1 characters are stored, in which case failbit is set
       *     in the stream error state
       *
       *  If no characters are extracted, failbit is set.  (An empty line of
       *  input should therefore not cause failbit to be set.)
       *
       *  In any case, a null character is stored in the next location in
       *  the array.
      *//**
       *  @brief  Extraction into another streambuf.
       *  @param  __sb  A streambuf in which to store data.
       *  @return  *this
       *
       *  Returns @c get(__sb,widen(&apos;\\n&apos;)).
      *//**
       *  @brief  Extraction into another streambuf.
       *  @param  __sb  A streambuf in which to store data.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and inserted into @a __sb until one of the
       *  following happens:
       *
       *  - the input sequence reaches EOF
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted)
       *  - the next character equals @a __delim (in this case, the character
       *    is not extracted)
       *  - an exception occurs (and in this case is caught)
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
      *//**
       *  @brief  Simple multiple-character extraction.
       *  @param  __s  Pointer to an array.
       *  @param  __n  Maximum number of characters to store in @a s.
       *  @return  *this
       *
       *  Returns @c get(__s,__n,widen(&apos;\\n&apos;)).
      *//**
       *  @brief  Simple multiple-character extraction.
       *  @param  __s  Pointer to an array.
       *  @param  __n  Maximum number of characters to store in @a __s.
       *  @param  __delim  A "stop" character.
       *  @return  *this
       *
       *  Characters are extracted and stored into @a __s until one of the
       *  following happens:
       *
       *  - @c __n-1 characters are stored
       *  - the input sequence reaches EOF
       *  - the next character equals @a __delim, in which case the character
       *    is not extracted
       *
       * If no characters are stored, failbit is set in the stream's error
       * state.
       *
       * In any case, a null character is stored into the next location in
       * the array.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Simple extraction.
       *  @param  __c  The character in which to store data.
       *  @return  *this
       *
       *  Tries to extract a character and store it in @a __c.  If none are
       *  available, sets failbit and returns traits::eof().
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Simple extraction.
       *  @return  A character, or eof().
       *
       *  Tries to extract a character.  If none are available, sets failbit
       *  and returns traits::eof().
      *//**
       *  @name Unformatted Input Functions
       *
       *  All the unformatted input functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_istream::sentry with the second argument (noskipws)
       *  set to true.  This has several effects, concluding with the
       *  setting of a status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  The number of characters extracted is stored for later retrieval
       *  by gcount().
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state (without causing an
       *  ios_base::failure to be thrown) and the original exception will
       *  be rethrown if badbit is set in the exceptions mask.
      *//**
       *  @brief  Character counting
       *  @return  The number of characters extracted by the previous
       *           unformatted input function dispatched for this stream.
      */// [27.6.1.3] unformatted input/**
       *  @brief  Extracting into another streambuf.
       *  @param  __sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @p __sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from this stream and inserted into the
       *  @p __sb streambuf until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output buffer fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs (and in this case is caught)
       *
       *  If the function inserts no characters, failbit is set.
      *//**
       *  @brief  Basic arithmetic extractors
       *  @param  __p A variable of pointer type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      *//**
       *  @brief  Floating point arithmetic extractors
       *  @param  __f A variable of builtin floating point type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      *//**
       *  @brief  Integer arithmetic extractors
       *  @param  __n A variable of builtin integral type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to parse the input data.
      *//**
       *  @name Extractors
       *
       *  All the @c operator>> functions (aka <em>formatted input
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_istream::sentry
       *  with the second argument (noskipws) set to false.  This has several
       *  effects, concluding with the setting of a status flag; see the
       *  sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to extract
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during extraction, ios_base::badbit
       *  will be turned on in the stream's error state (without causing an
       *  ios_base::failure to be thrown) and the original exception will
       *  be rethrown if badbit is set in the exceptions mask.
      *//**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::ws and @c std::dec use these
       *  functions in constructs like
       *  <code>std::cin >> std::ws</code>.
       *  For more information, see the iomanip header.
      *//**
       *  The number of characters extracted in the previous unformatted
       *  function; see gcount().
      */// Types (inherited from basic_ios (27.4.4)):/**
   *  @brief  Template class basic_istream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all input streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual input.
  *//** @file include/istream
 *  This is a Standard C++ Library header.
 */// ISO C++ 14882: 27.6.1  Input streams// Input streams -*- C++ -*-__noskipwsArgs */home/tanteikg/QCVE/sources/bitcoin/src/bench/bench_bitcoin.cppmainargsmanError parsing command line arguments: %s
"Error parsing command line arguments: %s\n"EXIT_FAILUREUsage:  bench_bitcoin [options]

"Usage:  bench_bitcoin [options]\n"
                     "\n"Description:

  bench_bitcoin executes microbenchmarks. The quality of the benchmark results
  highly depend on the stability of the machine. It can sometimes be difficult
  to get stable, repeatable results, so here are a few tips:

  * Use pyperf [1] to disable frequency scaling, turbo boost etc. For best
    results, use CPU pinning and CPU isolation (see [2]).

  * Each call of run() should do exactly the same work. E.g. inserting into
    a std::vector doesn't do that as it will reallocate on certain calls. Make
    sure each run has exactly the same preconditions.

  * If results are still not reliable, increase runtime with e.g.
    -min-time=5000 to let a benchmark run for at least 5 seconds.

  * bench_bitcoin uses nanobench [3] for which there is extensive
    documentation available online.

Environment Variables:

  To attach a profiler you can run a benchmark in endless mode. This can be
  done with the environment variable NANOBENCH_ENDLESS. E.g. like so:

    NANOBENCH_ENDLESS=MuHash ./bench_bitcoin -filter=MuHash

  In rare cases it can be useful to suppress stability warnings. This can be
  done with the environment variable NANOBENCH_SUPPRESS_WARNINGS, e.g:

    NANOBENCH_SUPPRESS_WARNINGS=1 ./bench_bitcoin

Notes:

  1. pyperf
     https://github.com/psf/pyperf

  2. CPU pinning & isolation
     https://pyperf.readthedocs.io/en/latest/system.html

  3. nanobench
     https://github.com/martinus/nanobench

"Description:\n"
                     "\n"
                     "  bench_bitcoin executes microbenchmarks. The quality of the benchmark results\n"
                     "  highly depend on the stability of the machine. It can sometimes be difficult\n"
                     "  to get stable, repeatable results, so here are a few tips:\n"
                     "\n"
                     "  * Use pyperf [1] to disable frequency scaling, turbo boost etc. For best\n"
                     "    results, use CPU pinning and CPU isolation (see [2]).\n"
                     "\n"
                     "  * Each call of run() should do exactly the same work. E.g. inserting into\n"
                     "    a std::vector doesn't do that as it will reallocate on certain calls. Make\n"
                     "    sure each run has exactly the same preconditions.\n"
                     "\n"
                     "  * If results are still not reliable, increase runtime with e.g.\n"
                     "    -min-time=5000 to let a benchmark run for at least 5 seconds.\n"
                     "\n"
                     "  * bench_bitcoin uses nanobench [3] for which there is extensive\n"
                     "    documentation available online.\n"
                     "\n"
                     "Environment Variables:\n"
                     "\n"
                     "  To attach a profiler you can run a benchmark in endless mode. This can be\n"
                     "  done with the environment variable NANOBENCH_ENDLESS. E.g. like so:\n"
                     "\n"
                     "    NANOBENCH_ENDLESS=MuHash ./bench_bitcoin -filter=MuHash\n"
                     "\n"
                     "  In rare cases it can be useful to suppress stability warnings. This can be\n"
                     "  done with the environment variable NANOBENCH_SUPPRESS_WARNINGS, e.g:\n"
                     "\n"
                     "    NANOBENCH_SUPPRESS_WARNINGS=1 ./bench_bitcoin\n"
                     "\n"
                     "Notes:\n"
                     "\n"
                     "  1. pyperf\n"
                     "     https://github.com/psf/pyperf\n"
                     "\n"
                     "  2. CPU pinning & isolation\n"
                     "     https://pyperf.readthedocs.io/en/latest/system.html\n"
                     "\n"
                     "  3. nanobench\n"
                     "     https://github.com/martinus/nanobench\n"
                     "\n"const char[1449]char[1449]EXIT_SUCCESSvector<double, allocator<double>> &&-asymptote"-asymptote"-list"-list"-min-time"-min-time"DEFAULT_MIN_TIME_MS-output-csv"-output-csv"-output-json"-output-json"-filter"-filter"-sanity-check"-sanity-check"-priority-level"-priority-level"Error: %s
"Error: %s\n"parsePriorityLevelvector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&parseAsymptotessnumbersSetupBenchArgs-asymptote=<n1,n2,n3,...>"-asymptote=<n1,n2,n3,...>"Test asymptotic growth of the runtime of an algorithm, if supported by the benchmark"Test asymptotic growth of the runtime of an algorithm, if supported by the benchmark"const char[85]char[85]ArgsManager::ALLOW_ANYOptionsCategory::OPTIONS-filter=<regex>"-filter=<regex>"Regular expression filter to select benchmark by name (default: %s)"Regular expression filter to select benchmark by name (default: %s)"List benchmarks without executing them"List benchmarks without executing them"-min-time=<milliseconds>"-min-time=<milliseconds>"Minimum runtime per benchmark, in milliseconds (default: %d)"Minimum runtime per benchmark, in milliseconds (default: %d)"ArgsManager::DISALLOW_NEGATIONArgsManager::ALLOW_ANY | ArgsManager::DISALLOW_NEGATION-output-csv=<output.csv>"-output-csv=<output.csv>"Generate CSV file with the most important benchmark results"Generate CSV file with the most important benchmark results"-output-json=<output.json>"-output-json=<output.json>"Generate JSON file with all benchmark results"Generate JSON file with all benchmark results"Run benchmarks for only one iteration with no output"Run benchmarks for only one iteration with no output"-priority-level=<l1,l2,l3>"-priority-level=<l1,l2,l3>"Run benchmarks of one or multiple priority level(s) (%s), default: '%s'"Run benchmarks of one or multiple priority level(s) (%s), default: '%s'"DEFAULT_PRIORITYDEFAULT_BENCH_FILTER.*".*"// parses a comma separated list like "10,20,30,50"/** Priority level default value, run "all" priority levels */const _Vector_base<double, allocator<double>>const _Vector_base<double, allocator<double>> *_Vector_base<double, allocator<double>> *allocator<double> &allocator<double> &&remove_reference<allocator<double> &>remove_reference<allocator<double> &> &remove_reference<allocator<double> &> &&const remove_reference<allocator<double> &>const remove_reference<allocator<double> &> &_Never_valueless_alt<_Tp>fAllowWitnessvinDummyprevector<28U, unsigned char, unsigned int, signed int> &&const CTxIn */home/tanteikg/QCVE/sources/bitcoin/src/node/miner.h<boost/multi_index_container.hpp><boost/multi_index/ordered_index.hpp><txmempool.h><primitives/block.h><policy/policy.h>ApplyArgsManOptionsOptions &RegenerateCommitmentsChainstateManager &UpdateTimeconst Paramsconst Params &Params &BlockAssembler &const BlockAssemblerconst BlockAssembler &~BlockAssemblerBlockAssemblerBlockAssembler &&SortForBlockconst setEntriesconst setEntries &set<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, CompareIteratorByHash, allocator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>> &vector<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, allocator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>> &TestPackageTransactionsTestPackageonlyUnconfirmedsetEntries &addPackageTxsconst CTxMemPoolconst CTxMemPool &CTxMemPool &AddToBlockresetBlockCreateNewBlockChainstate &const CTxMemPool *CTxMemPool *const Optionsconst Options &update_for_parent_inclusion &update_for_parent_inclusion &&const update_for_parent_inclusionconst update_for_parent_inclusion &update_for_parent_inclusionCTxMemPoolModifiedEntry &update_for_parent_inclusion *const CTxMemPoolEntryconst CTxMemPoolEntry *CTxMemPoolEntry *const dereferenceable<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, const CTxMemPoolEntry *, iterator_helper<forward_iterator_tag, CTxMemPoolEntry, long, const CTxMemPoolEntry *, const CTxMemPoolEntry &>>CompareTxIterByAncestorCount &CompareTxIterByAncestorCount &&const CompareTxIterByAncestorCountconst CompareTxIterByAncestorCount &const txiterconst txiter &hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag> &const CompareTxIterByAncestorCount *CompareTxIterByAncestorCount *const forward_iterator_helper<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, CTxMemPoolEntry, long, const CTxMemPoolEntry *, const CTxMemPoolEntry &>const forward_iteratable<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, const CTxMemPoolEntry *, iterator_helper<forward_iterator_tag, CTxMemPoolEntry, long, const CTxMemPoolEntry *, const CTxMemPoolEntry &>>const input_iteratable<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, const CTxMemPoolEntry *, iterator_helper<forward_iterator_tag, CTxMemPoolEntry, long, const CTxMemPoolEntry *, const CTxMemPoolEntry &>>const equality_comparable1<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, incrementable<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, dereferenceable<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, const CTxMemPoolEntry *, iterator_helper<forward_iterator_tag, CTxMemPoolEntry, long, const CTxMemPoolEntry *, const CTxMemPoolEntry &>>>>const incrementable<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, dereferenceable<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, const CTxMemPoolEntry *, iterator_helper<forward_iterator_tag, CTxMemPoolEntry, long, const CTxMemPoolEntry *, const CTxMemPoolEntry &>>>const hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>const hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag> &const CompareIteratorByHashOptions &&OptionsOptions *CBlockTemplate &CBlockTemplate &&const CBlockTemplateconst CBlockTemplate &~CBlockTemplateCBlockTemplateCompareCTxMemPoolIter &CompareCTxMemPoolIter &&const CompareCTxMemPoolIterconst CompareCTxMemPoolIter &const CompareCTxMemPoolIter *CompareCTxMemPoolIter *CTxMemPoolEntry &modifiedentry_iter &modifiedentry_iter &&const modifiedentry_iterconst modifiedentry_iter &const CTxMemPoolModifiedEntryconst CTxMemPoolModifiedEntry &const modifiedentry_iter *modifiedentry_iter *CTxMemPoolModifiedEntry &&CTxMemPoolModifiedEntryGetTxconst CTxMemPoolModifiedEntry *CTxMemPoolModifiedEntry *GetTxSizeGetModFeesWithAncestorsGetSizeWithAncestorsGetModifiedFeeCompareTxIterByAncestorCountCompareCTxMemPoolItermodifiedentry_iterm_optionsm_chainstateconst CTxMemPool *constm_mempoolchainparamsm_lock_time_cutoffnHeightinBlocknFeesnBlockSigOpsCostnBlockTxnBlockWeightpblocktemplatetest_block_validityblockMinFeeRateDEFAULT_BLOCK_MIN_TX_FEEnBlockMaxWeight3996000DEFAULT_BLOCK_MAX_WEIGHTvchCoinbaseCommitmentvTxSigOpsCostvTxFeesnSigOpCostWithAncestorsnModFeesWithAncestorsnSizeWithAncestorsDEFAULT_PRINTPRIORITYm_last_block_weightm_last_block_num_txsBITCOIN_NODE_MINER_HnodeConsensusParamsCChainParamsChainstateManagermempool.cs// BITCOIN_NODE_MINER_H// namespace node/** Apply -blockmintxfee and -blockmaxweight options from ArgsManager to BlockAssembler options. *//** Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed *//** Sort the package in an order that is valid to appear in a block *//** Perform checks on each transaction in a package:
      * locktime, premature-witness, serialized size (if necessary)
      * These checks should always succeed, and they're here
      * only as an extra check in case of suboptimal node configuration *//** Test if a new package would "fit" in the block *//** Remove confirmed (inBlock) entries from given set */// helper functions for addPackageTxs()/** Add transactions based on feerate including unconfirmed ancestors
      * Increments nPackagesSelected / nDescendantsUpdated with corresponding
      * statistics from the package selection (for logging statistics). */// Methods for how to add transactions to a block./** Add a tx to the block *//** Clear the block's state and prepare for assembling a new block */// utility functions/** Construct a new block template with coinbase to scriptPubKeyIn */// Whether to call TestBlockValidity() at the end of CreateNewBlock().// Configuration parameters for the block size// Chain context for the block// Information on the current status of the block// The constructed block template/** Generate a new block, without valid proof-of-work */// Reuse same tag from CTxMemPool's similar index// sorted by modified ancestor fee rate// to appear in a block.// This is sufficient to sort an ancestor package in an order that is valid// A comparator that sorts transactions based on number of ancestors./** Comparator for CTxMemPool::txiter objects.
 *  It simply compares the internal memory address of the CTxMemPoolEntry object
 *  pointed to. This means it has no meaning, and is only useful for using them
 *  as key in other indexes.
 */// transactions in a block// Container for tracking updates to ancestor feerate as we include (parent)optionschainmanpblockconsensusParamspindexPrevpackagesortedEntriespackageSizepackageSigOpsCosttestSetmempoolnPackagesSelectednDescendantsUpdatedchainstate<pubkey.h><node/context.h><node/caches.h><key.h><chainparamsbase.h>getBlock13b8aconst vector<const char *, allocator<const char *>>argumentsconst vector<const char *, allocator<const char *>> &vector<const char *, allocator<const char *>> &const char *const[2]-nodebuglogfile"-nodebuglogfile"-nodebug"-nodebug"MakeNoLogFileContextSeedInsecureRandSeedRand::SEEDSeedRand::ZEROSSeedHasReason &const HasReasonconst HasReason &~HasReasonHasReasonHasReason &&const HasReason *HasReason *RegTestingSetup &const RegTestingSetupconst RegTestingSetup &~RegTestingSetupRegTestingSetupRegTestingSetup *TestChain100Setup &const TestChain100Setupconst TestChain100Setup &~TestChain100SetupTestChain100Setup *~CKeyCKey *~TestingSetupTestingSetup *TestChain100SetupMockMempoolMinFeeconst CFeeRateconst CFeeRate &CFeeRate &PopulateMempoolCreateValidMempoolTransactionCOINCAmount(1 * COIN)mineBlocksCreateBlockconst vector<CMutableTransaction, allocator<CMutableTransaction>>const vector<CMutableTransaction, allocator<CMutableTransaction>> &vector<CMutableTransaction, allocator<CMutableTransaction>> &CreateAndProcessBlockChainstate *TestingSetup &const TestingSetupconst TestingSetup &TestingSetupLoadVerifyActivateChainstateChainTestingSetup &const ChainTestingSetupconst ChainTestingSetup &ChainTestingSetup~ChainTestingSetupBasicTestingSetup &const BasicTestingSetupconst BasicTestingSetup &BasicTestingSetup~BasicTestingSetupSeedRandZEROSSEEDm_reasoncoinbaseKeym_coinbase_txnsm_path_rootm_nodem_cache_sizesm_block_tree_db_in_memorym_coins_db_in_memoryCENTg_mock_deterministic_testsg_insecure_rand_ctxBITCOIN_TEST_UTIL_SETUP_COMMON_HChainstateCFeeRate// BITCOIN_TEST_UTIL_SETUP_COMMON_H/**
 * BOOST_CHECK_EXCEPTION predicates to check the specific validation error.
 * Use as
 * BOOST_CHECK_EXCEPTION(code that throws, exception type, HasReason("foo"));
 */// define an implicit conversion here so that uint256 may be used directly in BOOST_CHECK_*/**
 * Make a test setup that has disk access to the debug.log file disabled. Can
 * be used in "hot loops", for example fuzzing or benchmarking.
 */// private/public key needed to spend coinbase transactions// For convenience, coinbase transactions/** Mock the mempool minimum feerate by adding a transaction and calling TrimToSize(0),
     * simulating the mempool "reaching capacity" and evicting by descendant feerate.  Note that
     * this clears the mempool, and the new minimum feerate will depend on the maximum feerate of
     * transactions removed, so this must be called while the mempool is empty.
     *
     * @param target_feerate    The new mempool minimum feerate after this function returns.
     *                          Must be above max(incremental feerate, min relay feerate),
     *                          or 1sat/vB with default settings.
     *//** Create transactions spending from m_coinbase_txns. These transactions will only spend coins
     * that exist in the current chain, but may be premature coinbase spends, have missing
     * signatures, or violate some other consensus rules. They should only be used for testing
     * mempool consistency. All transactions will have some random number of inputs and outputs
     * (between 1 and 24). Transactions may or may not be dependent upon each other; if dependencies
     * exit, every parent will always be somewhere in the list before the child so each transaction
     * can be submitted in the same order they appear in the list.
     * @param[in]   submit      When true, submit transactions to the mempool.
     *                          When false, return them but don't submit them.
     * @returns A vector of transactions that can be submitted to the mempool.
     *//**
     * Create a transaction and submit to the mempool.
     *
     * @param input_transaction  The transaction to spend
     * @param input_vout         The vout to spend from the input_transaction
     * @param input_height       The height of the block that included the input_transaction
     * @param input_signing_key  The key to spend the input_transaction
     * @param output_destination Where to send the output
     * @param output_amount      How much to send
     * @param submit             Whether or not to submit to mempool
     *///! Mine a series of new blocks on the active chain./**
     * Create a new block with just given transactions, coinbase paying to
     * scriptPubKey.
     *//**
     * Create a new block with just given transactions, coinbase paying to
     * scriptPubKey, and try to add it to the current chain.
     * If no chainstate is specified, default to the active.
     *//**
 * Testing fixture that pre-creates a 100-block REGTEST-mode block chain
 *//** Identical to TestingSetup, but chain set to regtest *//** Testing setup that configures a complete environment.
 *//** Testing setup that performs all steps up until right before
 * ChainstateManager gets initialized. Meant for testing ChainstateManager
 * initialization behaviour.
 */// keep as first member to be destructed last/** Basic testing setup.
 * This just configures logging, data dir and chain parameters.
 *//*fDeterministic=*//** Seed the given random ctx or use the seed passed in via an environment var *///!< Call the Seed() helper//!< Seed with a compile time constant of zeros/**
 * Flag to make GetRand in random.h return the same number
 *//**
 * This global and the helpers that use it are not thread-safe.
 *
 * If thread-safety is needed, the global could be made thread_local (given
 * that thread_local is supported on all architectures we support) or a
 * per-thread instance could be used in the multi-threaded test.
 */// Enable BOOST_CHECK_EQUAL for enum class types/** Retrieve the command line arguments. *//** This is connected to the logger. Can be used to redirect logs to any other log *//home/tanteikg/QCVE/sources/bitcoin/src/test/util/home/tanteikg/QCVE/sources/bitcoin/src/testreasonchain_nameextra_argstarget_feeratedet_randnum_transactionssubmitinput_transactioninput_voutinput_heightinput_signing_keyoutput_destinationoutput_amountnum_blockstxnscoins_db_in_memoryblock_tree_db_in_memorychainName/home/tanteikg/QCVE/sources/bitcoin/src/chain.h<kernel/cs_main.h><flatfile.h><consensus/params.h>LocatorEntriesGetLocatorLastCommonAncestorGetBlockProofEquivalentTimeconst CBlockIndex &CBlockIndex &GetBlockProofCDiskBlockIndex &const CDiskBlockIndexconst CDiskBlockIndex &CDiskBlockIndexGetBlockHashConstructBlockHashconst CDiskBlockIndex *CDiskBlockIndex *~CChainFindEarliestAtLeastFindForkSetTipHeightconst CChainconst CChain *CChain *NextContainsTipGenesisCChain &const CChain &CChainCBlockFileInfo &CBlockFileInfo &&const CBlockFileInfoconst CBlockFileInfo &CBlockFileInfoAddBlockCBlockFileInfo *CBlockIndex &&const uint256 *~CBlockIndexGetAncestorBuildSkipRaiseValidity::cs_main./chain.h!(nUpTo & ~BLOCK_VALID_MASK)4294967288bool CBlockIndex::RaiseValidity(BlockStatus)BLOCK_FAILED_MASKBLOCK_VALID_MASKBLOCK_ASSUMED_VALIDBLOCK_VALID_SCRIPTS4294967039~BLOCK_ASSUMED_VALID~BLOCK_VALID_MASKIsAssumedValidBLOCK_VALID_TRANSACTIONSbool CBlockIndex::IsValid(BlockStatus) constGetMedianTimePastint64_t[11]signed long[11]nMedianTimeSpanpmedianpindexGetBlockTimeMaxHaveTxsDownloadedphashBlock != nullptruint256 CBlockIndex::GetBlockHash() constGetUndoPosBLOCK_HAVE_UNDOGetBlockPosBLOCK_HAVE_DATABlockStatusBLOCK_VALID_UNKNOWNBLOCK_VALID_RESERVEDBLOCK_VALID_TREEnHeightInnTimeInnUpToBLOCK_VALID_CHAINBLOCK_VALID_RESERVED | BLOCK_VALID_TREEBLOCK_VALID_RESERVED | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONSBLOCK_VALID_RESERVED | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |
                                 BLOCK_VALID_CHAINBLOCK_VALID_RESERVED | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |
                                 BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTSBLOCK_HAVE_MASKBLOCK_HAVE_DATA | BLOCK_HAVE_UNDOBLOCK_FAILED_VALIDBLOCK_FAILED_CHILDBLOCK_FAILED_VALID | BLOCK_FAILED_CHILDBLOCK_OPT_WITNESShashPrevvChainnTimeLastnTimeFirstnHeightLastnHeightFirstnUndoSizenBlocksnTimeMaxnSequenceIdnStatusnChainTxnTxnChainWorknUndoPosnDataPosnFilepskippprevphashBlockMAX_BLOCK_TIME_GAP540090 * 60TIMESTAMP_WINDOW7200MAX_FUTURE_BLOCK_TIME2 * 602 * 60 * 60BITCOIN_CHAIN_Hobj.nNonceobj.nBitsobj.nTimeobj.hashMerkleRootobj.hashPrevobj.nVersionVARINT(obj.nUndoPos)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nUndoPos)obj.nUndoPosVARINT(obj.nDataPos)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nDataPos)obj.nDataPosVARINT_MODE(obj.nFile, VarIntMode::NONNEGATIVE_SIGNED)Using<VarIntFormatter<VarIntMode::NONNEGATIVE_SIGNED>>(obj.nFile)obj.nFileVarIntMode::NONNEGATIVE_SIGNEDVARINT(obj.nTx)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nTx)obj.nTxVARINT(obj.nStatus)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nStatus)obj.nStatusVARINT_MODE(obj.nHeight, VarIntMode::NONNEGATIVE_SIGNED)Using<VarIntFormatter<VarIntMode::NONNEGATIVE_SIGNED>>(obj.nHeight)obj.nHeightVARINT_MODE(_nVersion, VarIntMode::NONNEGATIVE_SIGNED)Using<VarIntFormatter<VarIntMode::NONNEGATIVE_SIGNED>>(_nVersion)_nVersionVARINT(obj.nTimeLast)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nTimeLast)obj.nTimeLastVARINT(obj.nTimeFirst)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nTimeFirst)obj.nTimeFirstVARINT(obj.nHeightLast)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nHeightLast)obj.nHeightLastVARINT(obj.nHeightFirst)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nHeightFirst)obj.nHeightFirstVARINT(obj.nUndoSize)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nUndoSize)obj.nUndoSizeVARINT(obj.nSize)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nSize)obj.nSizeVARINT(obj.nBlocks)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj.nBlocks)obj.nBlocks// BITCOIN_CHAIN_H/** Construct a list of hash entries to put in a locator.  *//** Get a locator for a block index entry. *//** Find the earliest block with timestamp equal or greater than the given time and height equal or greater than the given height. *//** Find the last common block between this chain and a block index entry. *//** Return a CBlockLocator that refers to the tip in of this chain. *//** Set/initialize a chain with a given tip. *//** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. *//** Find the successor of a block in this chain, or nullptr if the given index is not found or is the tip. *//** Efficiently check whether a block is present in this chain. *//** Returns the index entry at a particular height in this chain, or nullptr if no such height exists. *//** Returns the index entry for the tip of this chain, or nullptr if none. *//** Returns the index entry for the genesis block of this chain, or nullptr if none. *//** An in-memory indexed chain of blocks. */// block header/** Used to marshal pointers into hashes for db storage. *//** Find the forking point between two chain tips. *//** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. *///! CDiskBlockIndex can reuse copy construction.//! We declare these protected instead of simply deleting them so that//! instance.//! pskip, which are at risk of becoming dangling pointers in a copied//! of simplifying lifetime considerations due to attributes like pprev and//! use of copy a footgun. Also, use of copies do not have the benefit//! comparison via pointer is very common throughout the codebase, making//! CBlockIndex should not allow public copy construction because equality//! Efficiently find an ancestor of this block.//! Build the skiplist pointer for this entry.// its validity to a certain point, there is no longer an assumption.// If this block had been marked assumed-valid and we're raising// Only validity flags allowed.//! Returns true if the validity was changed.//! Raise the validity level of this block index entry.//!   validated by a background chainstate.//! @returns true if the block is assumed-valid; this means it is queued to be//! Check whether this block index entry is valid up to the passed validity level./**
     * Check whether this block's and all previous blocks' transactions have been
     * downloaded (and stored to disk) at some point.
     *
     * Does not imply the transactions are consensus-valid (ConnectTip might fail)
     * Does not imply the transactions are still stored on disk. (IsBlockPruned might return true)
     *///! (memory only) Maximum nTime in the chain up to and including this block.//! (memory only) Sequential id assigned to distinguish order in which blocks are received.//! block header//! @sa ActivateSnapshot//! @sa NeedsRedownload//! load to avoid the block index being spuriously rewound.//! Note: this value is modified to show BLOCK_OPT_WITNESS during UTXO snapshot//! Verification status of this block. See enum BlockStatus//! @sa AssumeutxoData//! have the underlying block data available during snapshot load.//! Note: this value is faked during use of a UTXO snapshot because we don't//! Change to 64-bit type before 2024 (assuming worst case of 60 byte transactions).//! This value will be non-zero only if and only if transactions for this block and all its parents are available.//! (memory only) Number of transactions in the chain up to and including this block.//! LoadBlockIndex() will load index entries for blocks that we lack data for.//! Note: this value is faked during UTXO snapshot load to ensure that//! Note: in a potential headers-first mode, this number cannot be relied upon//! Number of transactions in this block.//! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block//! Byte offset within rev?????.dat where this block's undo data is stored//! Byte offset within blk?????.dat where this block's data is stored//! Which # file this block is stored in (blk?????.dat)//! height of the entry in the chain. The genesis block has height 0//! pointer to the index of some further predecessor of this block//! pointer to the index of the predecessor of this block//! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex/** The block chain is a tree shaped structure starting with the
 * genesis block at the root, with each block potentially having multiple
 * candidates to be the next block. A blockindex may have multiple pprev pointing
 * to it, but at most one of them can be part of the currently active branch.
 *//**
     * If set, this indicates that the block index entry is assumed-valid.
     * Certain diagnostics will be skipped in e.g. CheckBlockIndex().
     * It almost certainly means that the block's full validation is pending
     * on a background chainstate. See `doc/design/assumeutxo.md`.
     *///!< block data in blk*.dat was received with a witness-enforcing client//!< descends from failed block//!< stage after last reached validness failed//!< undo data available in rev*.dat//!< full block available in blk*.dat//! All validity bits.//! Scripts & signatures ok. Implies all parents are also at least SCRIPTS.//! Implies all parents are also at least CHAIN.//! Outputs do not overspend inputs, no double spends, coinbase output ok, no immature coinbase spends, BIP30./**
     * Only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids,
     * sigops, size, merkle root. Implies all parents are at least TREE but not necessarily TRANSACTIONS. When all
     * parent blocks also have TRANSACTIONS, CBlockIndex::nChainTx will be set.
     *///! are also at least TREE.//! All parent headers found, difficulty matches, timestamp >= median previous, checkpoint. Implies all parents//! Reserved (was BLOCK_VALID_HEADER).//! Unused./** update statistics (does not update nSize) *///!< latest time of block in file//!< earliest time of block in file//!< highest height of block in file//!< lowest height of block in file//!< number of used bytes in the undo file//!< number of used bytes of block file//!< number of blocks stored in file/**
 * Maximum gap between node time and block time used
 * for the "Catching up..." mode in GUI.
 *
 * Ref: https://github.com/bitcoin/bitcoin/pull/1026
 *//**
 * Timestamp window used as a grace period by code that compares external
 * timestamps (such as timestamps passed to RPCs, or wallet key creation times)
 * to block timestamps. This should be set at least as high as
 * MAX_FUTURE_BLOCK_TIME.
 *//**
 * Maximum amount of time that a block timestamp is allowed to exceed the
 * current network-adjusted time before the block will be accepted.
 */papbtotip/home/tanteikg/QCVE/sources/bitcoin/src/consensus/validation.h/home/tanteikg/QCVE/sources/bitcoin/src/consensus/consensus.h/home/tanteikg/QCVE/sources/bitcoin/src/policy/policy.h/home/tanteikg/QCVE/sources/bitcoin/src/script/interpreter.h/home/tanteikg/QCVE/sources/bitcoin/src/script/script_error.h/home/tanteikg/QCVE/sources/bitcoin/src/script/standard.h/usr/include/c++/9/variant/home/tanteikg/QCVE/sources/bitcoin/src/txmempool.h/home/tanteikg/QCVE/sources/bitcoin/src/kernel/mempool_limits.h/home/tanteikg/QCVE/sources/bitcoin/src/kernel/mempool_options.h/home/tanteikg/QCVE/sources/bitcoin/src/policy/feerate.h/home/tanteikg/QCVE/sources/bitcoin/src/coins.h/home/tanteikg/QCVE/sources/bitcoin/src/compressor.h/home/tanteikg/QCVE/sources/bitcoin/src/core_memusage.h/home/tanteikg/QCVE/sources/bitcoin/src/memusage.h/home/tanteikg/QCVE/sources/bitcoin/src/indirectmap.h/home/tanteikg/QCVE/sources/bitcoin/src/support/allocators/pool.h/home/tanteikg/QCVE/sources/bitcoin/src/util/hasher.h/home/tanteikg/QCVE/sources/bitcoin/src/kernel/cs_main.h/home/tanteikg/QCVE/sources/bitcoin/src/kernel/mempool_entry.h/home/tanteikg/QCVE/sources/bitcoin/src/policy/settings.h/home/tanteikg/QCVE/sources/bitcoin/src/util/epochguard.h/home/tanteikg/QCVE/sources/bitcoin/src/policy/packages.h/home/tanteikg/QCVE/sources/bitcoin/src/util/result.h/usr/include/boost/multi_index/hashed_index.hpp/usr/include/boost/config.hpp/usr/include/boost/config/user.hpp/usr/include/boost/config/detail/select_compiler_config.hpp/usr/include/boost/config/compiler/gcc.hpp/usr/include/boost/config/detail/select_stdlib_config.hpp/usr/include/boost/config/stdlib/libstdcpp3.hpp/usr/include/boost/config/detail/select_platform_config.hpp/usr/include/boost/config/platform/linux.hpp/usr/include/boost/config/detail/posix_features.hpp/usr/include/boost/config/detail/suffix.hpp/usr/include/boost/config/helper_macros.hpp/usr/include/boost/call_traits.hpp/usr/include/boost/detail/call_traits.hpp/usr/include/boost/type_traits/is_arithmetic.hpp/usr/include/boost/type_traits/is_integral.hpp/usr/include/boost/type_traits/integral_constant.hpp/usr/include/boost/detail/workaround.hpp/usr/include/boost/config/workaround.hpp/usr/include/boost/type_traits/is_floating_point.hpp/usr/include/boost/type_traits/is_enum.hpp/usr/include/boost/type_traits/intrinsics.hpp/usr/include/boost/type_traits/detail/config.hpp/usr/include/boost/version.hpp/usr/include/boost/type_traits/is_pointer.hpp/usr/include/boost/core/addressof.hpp482/usr/include/boost/detail/no_exceptions_support.hpp483/usr/include/boost/core/no_exceptions_support.hpp484/usr/include/boost/foreach_fwd.hpp485/usr/include/boost/limits.hpp/usr/include/boost/move/core.hpp487/usr/include/boost/move/detail/config_begin.hpp488/usr/include/boost/move/detail/workaround.hpp/usr/include/boost/move/detail/config_end.hpp490/usr/include/boost/mpl/bool.hpp491/usr/include/boost/mpl/bool_fwd.hpp492/usr/include/boost/mpl/aux_/adl_barrier.hpp493/usr/include/boost/mpl/aux_/config/adl.hpp494/usr/include/boost/mpl/aux_/config/msvc.hpp495/usr/include/boost/mpl/aux_/config/intel.hpp496/usr/include/boost/mpl/aux_/config/gcc.hpp497/usr/include/boost/mpl/aux_/config/workaround.hpp/usr/include/boost/mpl/integral_c_tag.hpp499/usr/include/boost/mpl/aux_/config/static_constant.hpp500/usr/include/boost/mpl/if.hpp501/usr/include/boost/mpl/aux_/value_wknd.hpp502/usr/include/boost/mpl/aux_/static_cast.hpp503/usr/include/boost/mpl/aux_/config/integral.hpp504/usr/include/boost/mpl/aux_/config/eti.hpp505/usr/include/boost/mpl/aux_/na_spec.hpp506/usr/include/boost/mpl/lambda_fwd.hpp/usr/include/boost/mpl/void_fwd.hpp508/usr/include/boost/mpl/aux_/na.hpp509/usr/include/boost/mpl/aux_/na_fwd.hpp/usr/include/boost/mpl/aux_/config/ctps.hpp511/usr/include/boost/mpl/aux_/config/lambda.hpp/usr/include/boost/mpl/aux_/config/ttp.hpp513/usr/include/boost/mpl/int.hpp/usr/include/boost/mpl/int_fwd.hpp515/usr/include/boost/mpl/aux_/nttp_decl.hpp516/usr/include/boost/mpl/aux_/config/nttp.hpp517/usr/include/boost/mpl/aux_/integral_wrapper.hpp518/usr/include/boost/preprocessor/cat.hpp519/usr/include/boost/preprocessor/config/config.hpp/usr/include/boost/mpl/aux_/lambda_arity_param.hpp521/usr/include/boost/mpl/aux_/template_arity_fwd.hpp522/usr/include/boost/mpl/aux_/arity.hpp/usr/include/boost/mpl/aux_/config/dtp.hpp/usr/include/boost/mpl/aux_/preprocessor/params.hpp525/usr/include/boost/mpl/aux_/config/preprocessor.hpp526/usr/include/boost/preprocessor/comma_if.hpp527/usr/include/boost/preprocessor/punctuation/comma_if.hpp528529/usr/include/boost/preprocessor/control/if.hpp/usr/include/boost/preprocessor/control/iif.hpp532533/usr/include/boost/preprocessor/logical/bool.hpp534535/usr/include/boost/preprocessor/facilities/empty.hpp536/usr/include/boost/preprocessor/punctuation/comma.hpp538/usr/include/boost/preprocessor/repeat.hpp539/usr/include/boost/preprocessor/repetition/repeat.hpp540541542/usr/include/boost/preprocessor/debug/error.hpp543544/usr/include/boost/preprocessor/detail/auto_rec.hpp546548/usr/include/boost/preprocessor/tuple/eat.hpp549550/usr/include/boost/preprocessor/inc.hpp551/usr/include/boost/preprocessor/arithmetic/inc.hpp552553554/usr/include/boost/mpl/aux_/preprocessor/enum.hpp555556/usr/include/boost/mpl/aux_/preprocessor/def_params_tail.hpp558/usr/include/boost/mpl/limits/arity.hpp559560/usr/include/boost/preprocessor/logical/and.hpp561562563/usr/include/boost/preprocessor/logical/bitand.hpp564565/usr/include/boost/preprocessor/identity.hpp566/usr/include/boost/preprocessor/facilities/identity.hpp567568569/usr/include/boost/preprocessor/empty.hpp570571/usr/include/boost/preprocessor/arithmetic/add.hpp572/usr/include/boost/preprocessor/arithmetic/dec.hpp573574575576/usr/include/boost/preprocessor/control/while.hpp577578579580581582/usr/include/boost/preprocessor/list/fold_left.hpp583584585586587588/usr/include/boost/preprocessor/list/detail/fold_left.hpp589/usr/include/boost/preprocessor/control/expr_iif.hpp590591592/usr/include/boost/preprocessor/list/adt.hpp593594/usr/include/boost/preprocessor/detail/is_binary.hpp595596/usr/include/boost/preprocessor/detail/check.hpp597598599/usr/include/boost/preprocessor/logical/compl.hpp600601602603/usr/include/boost/preprocessor/list/fold_right.hpp604605606607608609/usr/include/boost/preprocessor/list/detail/fold_right.hpp610611/usr/include/boost/preprocessor/list/reverse.hpp612613614615/usr/include/boost/preprocessor/control/detail/while.hpp616617618619/usr/include/boost/preprocessor/tuple/elem.hpp620622/usr/include/boost/preprocessor/facilities/expand.hpp623624/usr/include/boost/preprocessor/facilities/overload.hpp625626/usr/include/boost/preprocessor/variadic/size.hpp627628629/usr/include/boost/preprocessor/tuple/rem.hpp630631632634/usr/include/boost/preprocessor/tuple/detail/is_single_return.hpp635636/usr/include/boost/preprocessor/variadic/elem.hpp637638639640/usr/include/boost/preprocessor/arithmetic/sub.hpp641642643644645646647648649/usr/include/boost/mpl/aux_/config/overload_resolution.hpp650/usr/include/boost/mpl/aux_/lambda_support.hpp651/usr/include/boost/mpl/push_front.hpp652/usr/include/boost/mpl/push_front_fwd.hpp/usr/include/boost/mpl/aux_/push_front_impl.hpp654/usr/include/boost/mpl/assert.hpp655/usr/include/boost/mpl/not.hpp656/usr/include/boost/mpl/aux_/nested_type_wknd.hpp/usr/include/boost/mpl/aux_/yes_no.hpp658/usr/include/boost/mpl/aux_/config/arrays.hpp659/usr/include/boost/mpl/aux_/config/gpu.hpp660/usr/include/boost/mpl/aux_/config/pp_counter.hpp661662/usr/include/boost/mpl/aux_/has_type.hpp663/usr/include/boost/mpl/has_xxx.hpp664/usr/include/boost/mpl/aux_/type_wrapper.hpp665/usr/include/boost/mpl/aux_/config/has_xxx.hpp666/usr/include/boost/mpl/aux_/config/msvc_typename.hpp/usr/include/boost/preprocessor/array/elem.hpp668/usr/include/boost/preprocessor/array/data.hpp669670671/usr/include/boost/preprocessor/array/size.hpp672673675676677678/usr/include/boost/preprocessor/repetition/enum_params.hpp679681682/usr/include/boost/preprocessor/repetition/enum_trailing_params.hpp683684685/usr/include/boost/mpl/aux_/traits_lambda_spec.hpp686/usr/include/boost/mpl/sequence_tag_fwd.hpp687/usr/include/boost/mpl/void.hpp688/usr/include/boost/mpl/aux_/config/forwarding.hpp689/usr/include/boost/type_traits/is_same.hpp690/usr/include/boost/mpl/sequence_tag.hpp691/usr/include/boost/mpl/aux_/has_tag.hpp/usr/include/boost/mpl/aux_/has_begin.hpp693/usr/include/boost/mpl/aux_/is_msvc_eti_arg.hpp694/usr/include/boost/multi_index/detail/access_specifier.hpp695/usr/include/boost/multi_index/detail/allocator_traits.hpp696/usr/include/boost/multi_index/detail/auto_space.hpp697/usr/include/boost/multi_index/detail/adl_swap.hpp698/usr/include/boost/noncopyable.hpp/usr/include/boost/core/noncopyable.hpp/usr/include/boost/multi_index/detail/bucket_array.hpp701/usr/include/boost/multi_index/detail/hash_index_node.hpp702/usr/include/boost/multi_index/detail/raw_ptr.hpp703704/usr/include/boost/preprocessor/seq/elem.hpp705706707708/usr/include/boost/preprocessor/seq/enum.hpp709710711/usr/include/boost/preprocessor/seq/size.hpp712713714715/usr/include/boost/multi_index/detail/do_not_copy_elements_tag.hpp717/usr/include/boost/multi_index/detail/hash_index_iterator.hpp718/usr/include/boost/operators.hpp720721/usr/include/boost/multi_index/detail/index_node_base.hpp722/usr/include/boost/type_traits/aligned_storage.hpp723/usr/include/boost/type_traits/alignment_of.hpp724/usr/include/boost/type_traits/type_with_alignment.hpp725/usr/include/boost/type_traits/is_pod.hpp726/usr/include/boost/type_traits/is_void.hpp727/usr/include/boost/type_traits/is_scalar.hpp728/usr/include/boost/type_traits/is_member_pointer.hpp729/usr/include/boost/type_traits/is_member_function_pointer.hpp730/usr/include/boost/type_traits/detail/is_member_function_pointer_cxx_11.hpp731/usr/include/boost/static_assert.hpp732/usr/include/boost/type_traits/conditional.hpp/usr/include/boost/multi_index/detail/ignore_wstrict_aliasing.hpp734/usr/include/boost/multi_index/detail/restore_wstrict_aliasing.hpp735736/usr/include/boost/multi_index/detail/modify_key_adaptor.hpp737/usr/include/boost/multi_index/detail/promotes_arg.hpp738/usr/include/boost/mpl/and.hpp739/usr/include/boost/mpl/aux_/config/use_preprocessed.hpp740/usr/include/boost/mpl/aux_/include_preprocessed.hpp741/usr/include/boost/mpl/aux_/config/compiler.hpp742743/usr/include/boost/preprocessor/stringize.hpp744745/usr/include/boost/mpl/aux_/preprocessed/gcc/and.hpp746/usr/include/boost/multi_index/detail/is_transparent.hpp747/usr/include/boost/mpl/or.hpp748749750751/usr/include/boost/mpl/aux_/preprocessed/gcc/or.hpp752/usr/include/boost/type_traits/function_traits.hpp753/usr/include/boost/type_traits/is_function.hpp754/usr/include/boost/type_traits/detail/is_function_cxx_11.hpp755/usr/include/boost/type_traits/add_pointer.hpp756/usr/include/boost/type_traits/remove_reference.hpp757/usr/include/boost/type_traits/is_class.hpp758/usr/include/boost/type_traits/is_final.hpp759/usr/include/boost/type_traits/remove_cv.hpp760/usr/include/boost/type_traits/remove_pointer.hpp761/usr/include/boost/utility/declval.hpp762/usr/include/boost/type_traits/declval.hpp763/usr/include/boost/type_traits/add_rvalue_reference.hpp764/usr/include/boost/type_traits/is_reference.hpp765/usr/include/boost/type_traits/is_lvalue_reference.hpp766/usr/include/boost/type_traits/is_rvalue_reference.hpp/usr/include/boost/utility/enable_if.hpp/usr/include/boost/core/enable_if.hpp769/usr/include/boost/type_traits/is_convertible.hpp770/usr/include/boost/type_traits/is_complete.hpp771/usr/include/boost/type_traits/detail/yes_no_type.hpp772/usr/include/boost/type_traits/is_array.hpp773/usr/include/boost/type_traits/is_abstract.hpp774/usr/include/boost/type_traits/add_lvalue_reference.hpp775/usr/include/boost/type_traits/add_reference.hpp776/usr/include/boost/multi_index/detail/safe_mode.hpp777/usr/include/boost/multi_index/detail/scope_guard.hpp778/usr/include/boost/multi_index/detail/vartempl_support.hpp779/usr/include/boost/multi_index/hashed_index_fwd.hpp780/usr/include/boost/multi_index/detail/hash_index_args.hpp781/usr/include/boost/functional/hash.hpp782/usr/include/boost/container_hash/hash.hpp/usr/include/boost/container_hash/hash_fwd.hpp784/usr/include/boost/container_hash/detail/hash_float.hpp785/usr/include/boost/container_hash/detail/float_functions.hpp786/usr/include/boost/config/no_tr1/cmath.hpp787789790791792793794795796797798800802803805806808809810811812813815816817818819820821822823824825826827828829830831832833/usr/include/boost/container_hash/detail/limits.hpp835/usr/include/boost/integer/static_log2.hpp836/usr/include/boost/integer_fwd.hpp837838839/usr/include/boost/cstdint.hpp840841/usr/include/boost/assert.hpp842843844845/usr/include/c++/9/typeindex/usr/include/boost/container_hash/extensions.hpp847848/usr/include/boost/detail/container_fwd.hpp849850851853/usr/include/c++/9/complex854855/usr/include/boost/mpl/eval_if.hpp856/usr/include/boost/mpl/identity.hpp857/usr/include/boost/multi_index/tag.hpp858/usr/include/boost/multi_index/detail/no_duplicate_tags.hpp859/usr/include/boost/mpl/fold.hpp860/usr/include/boost/mpl/begin_end.hpp861/usr/include/boost/mpl/begin_end_fwd.hpp862/usr/include/boost/mpl/aux_/begin_end_impl.hpp863/usr/include/boost/mpl/O1_size.hpp864/usr/include/boost/mpl/O1_size_fwd.hpp865/usr/include/boost/mpl/aux_/O1_size_impl.hpp866/usr/include/boost/mpl/long.hpp867/usr/include/boost/mpl/long_fwd.hpp868869870/usr/include/boost/mpl/aux_/has_size.hpp/usr/include/boost/mpl/aux_/fold_impl.hpp872/usr/include/boost/mpl/next_prior.hpp873/usr/include/boost/mpl/aux_/common_name_wknd.hpp874/usr/include/boost/mpl/apply.hpp875/usr/include/boost/mpl/apply_fwd.hpp876877878879/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp880/usr/include/boost/mpl/apply_wrap.hpp881/usr/include/boost/mpl/aux_/has_apply.hpp882/usr/include/boost/mpl/aux_/config/has_apply.hpp883/usr/include/boost/mpl/aux_/msvc_never_true.hpp884885886/usr/include/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp888/usr/include/boost/mpl/placeholders.hpp889/usr/include/boost/mpl/arg.hpp890/usr/include/boost/mpl/arg_fwd.hpp891/usr/include/boost/mpl/aux_/na_assert.hpp892/usr/include/boost/mpl/aux_/arity_spec.hpp893/usr/include/boost/mpl/aux_/arg_typedef.hpp894895896897/usr/include/boost/mpl/aux_/preprocessed/gcc/arg.hpp898899900901/usr/include/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp902/usr/include/boost/mpl/lambda.hpp903/usr/include/boost/mpl/bind.hpp904/usr/include/boost/mpl/bind_fwd.hpp905/usr/include/boost/mpl/aux_/config/bind.hpp906907908909/usr/include/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp910911/usr/include/boost/mpl/next.hpp912/usr/include/boost/mpl/protect.hpp913914915916917/usr/include/boost/mpl/aux_/preprocessed/gcc/bind.hpp918/usr/include/boost/mpl/aux_/full_lambda.hpp919/usr/include/boost/mpl/quote.hpp921/usr/include/boost/mpl/aux_/config/bcc.hpp922923924925/usr/include/boost/mpl/aux_/preprocessed/gcc/quote.hpp926927/usr/include/boost/mpl/aux_/template_arity.hpp928929931/usr/include/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp932933934935/usr/include/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp936937938939/usr/include/boost/mpl/aux_/preprocessed/gcc/apply.hpp940/usr/include/boost/mpl/deref.hpp941/usr/include/boost/mpl/aux_/msvc_type.hpp942943944945/usr/include/boost/mpl/aux_/preprocessed/gcc/fold_impl.hpp946/usr/include/boost/mpl/set/set0.hpp947/usr/include/boost/mpl/set/aux_/at_impl.hpp948/usr/include/boost/mpl/at_fwd.hpp949/usr/include/boost/mpl/set/aux_/has_key_impl.hpp/usr/include/boost/mpl/set/aux_/tag.hpp951/usr/include/boost/mpl/has_key_fwd.hpp952/usr/include/boost/mpl/aux_/overload_names.hpp953/usr/include/boost/mpl/aux_/ptr_to_ref.hpp954/usr/include/boost/mpl/aux_/config/operators.hpp955/usr/include/boost/mpl/set/aux_/clear_impl.hpp956/usr/include/boost/mpl/clear_fwd.hpp957/usr/include/boost/mpl/set/aux_/set0.hpp958959/usr/include/boost/mpl/set/aux_/size_impl.hpp960/usr/include/boost/mpl/size_fwd.hpp961/usr/include/boost/mpl/set/aux_/empty_impl.hpp962/usr/include/boost/mpl/empty_fwd.hpp963/usr/include/boost/mpl/set/aux_/insert_impl.hpp964/usr/include/boost/mpl/insert_fwd.hpp965/usr/include/boost/mpl/set/aux_/item.hpp966/usr/include/boost/mpl/prior.hpp967/usr/include/boost/mpl/base.hpp968/usr/include/boost/mpl/set/aux_/insert_range_impl.hpp969/usr/include/boost/mpl/insert_range_fwd.hpp970971/usr/include/boost/mpl/insert.hpp972/usr/include/boost/mpl/aux_/insert_impl.hpp973/usr/include/boost/mpl/reverse_fold.hpp974975/usr/include/boost/mpl/aux_/reverse_fold_impl.hpp976977979980/usr/include/boost/mpl/aux_/preprocessed/gcc/reverse_fold_impl.hpp981/usr/include/boost/mpl/iterator_range.hpp982/usr/include/boost/mpl/clear.hpp983/usr/include/boost/mpl/aux_/clear_impl.hpp984/usr/include/boost/mpl/set/aux_/erase_impl.hpp985/usr/include/boost/mpl/erase_fwd.hpp986/usr/include/boost/mpl/set/aux_/erase_key_impl.hpp987/usr/include/boost/mpl/erase_key_fwd.hpp988/usr/include/boost/mpl/set/aux_/key_type_impl.hpp989/usr/include/boost/mpl/key_type_fwd.hpp990/usr/include/boost/mpl/set/aux_/value_type_impl.hpp991/usr/include/boost/mpl/value_type_fwd.hpp992/usr/include/boost/mpl/set/aux_/begin_end_impl.hpp993/usr/include/boost/mpl/set/aux_/iterator.hpp994/usr/include/boost/mpl/has_key.hpp995/usr/include/boost/mpl/aux_/has_key_impl.hpp996/usr/include/boost/mpl/iterator_tags.hpp/usr/include/boost/mpl/transform.hpp/usr/include/boost/mpl/pair_view.hpp/usr/include/boost/mpl/iterator_category.hpp/usr/include/boost/mpl/advance.hpp/usr/include/boost/mpl/advance_fwd.hpp1002/usr/include/boost/mpl/less.hpp1003/usr/include/boost/mpl/aux_/comparison_op.hpp1004/usr/include/boost/mpl/aux_/numeric_op.hpp1005/usr/include/boost/mpl/numeric_cast.hpp10061007/usr/include/boost/mpl/tag.hpp1008/usr/include/boost/mpl/aux_/numeric_cast_utils.hpp10091010/usr/include/boost/mpl/aux_/msvc_eti_base.hpp1011101210131014/usr/include/boost/mpl/aux_/preprocessed/gcc/less.hpp1015/usr/include/boost/mpl/negate.hpp1016/usr/include/boost/mpl/integral_c.hpp1017/usr/include/boost/mpl/integral_c_fwd.hpp1018101910201021/usr/include/boost/mpl/aux_/advance_forward.hpp/usr/include/boost/mpl/aux_/preprocessed/gcc/advance_forward.hpp1027/usr/include/boost/mpl/aux_/advance_backward.hpp102810291030/usr/include/boost/mpl/aux_/preprocessed/gcc/advance_backward.hpp1033/usr/include/boost/mpl/distance.hpp1034/usr/include/boost/mpl/distance_fwd.hpp1035/usr/include/boost/mpl/iter_fold.hpp1036/usr/include/boost/mpl/aux_/iter_fold_impl.hpp1037103910401041/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_impl.hpp10421043/usr/include/boost/mpl/min_max.hpp1044/usr/include/boost/mpl/pair.hpp1045/usr/include/boost/mpl/is_sequence.hpp10461047/usr/include/boost/mpl/aux_/inserter_algorithm.hpp1048/usr/include/boost/mpl/back_inserter.hpp1049/usr/include/boost/mpl/push_back.hpp1050/usr/include/boost/mpl/push_back_fwd.hpp1051/usr/include/boost/mpl/aux_/push_back_impl.hpp1052/usr/include/boost/mpl/inserter.hpp1053/usr/include/boost/mpl/front_inserter.hpp1054/usr/include/boost/mpl/aux_/preprocessor/default_params.hpp1055105610571058105910601061/usr/include/boost/mpl/vector.hpp1062/usr/include/boost/mpl/limits/vector.hpp1063106410651066/usr/include/boost/mpl/vector/vector20.hpp1067/usr/include/boost/mpl/vector/vector10.hpp1068/usr/include/boost/mpl/vector/vector0.hpp1069/usr/include/boost/mpl/vector/aux_/at.hpp1070/usr/include/boost/mpl/vector/aux_/tag.hpp1071/usr/include/boost/mpl/aux_/config/typeof.hpp1072/usr/include/boost/mpl/vector/aux_/front.hpp1073/usr/include/boost/mpl/front_fwd.hpp1074/usr/include/boost/mpl/vector/aux_/push_front.hpp1075/usr/include/boost/mpl/vector/aux_/item.hpp1076/usr/include/boost/mpl/vector/aux_/pop_front.hpp1077/usr/include/boost/mpl/pop_front_fwd.hpp1078/usr/include/boost/mpl/vector/aux_/push_back.hpp1079/usr/include/boost/mpl/vector/aux_/pop_back.hpp1080/usr/include/boost/mpl/pop_back_fwd.hpp1081/usr/include/boost/mpl/vector/aux_/back.hpp1082/usr/include/boost/mpl/back_fwd.hpp1083/usr/include/boost/mpl/vector/aux_/clear.hpp1084/usr/include/boost/mpl/vector/aux_/vector0.hpp1085/usr/include/boost/mpl/vector/aux_/iterator.hpp1086/usr/include/boost/mpl/plus.hpp1087/usr/include/boost/mpl/aux_/arithmetic_op.hpp1088/usr/include/boost/mpl/aux_/largest_int.hpp108910901091109210931094/usr/include/boost/mpl/aux_/preprocessed/gcc/plus.hpp1095/usr/include/boost/mpl/minus.hpp1096109710981099110011011102/usr/include/boost/mpl/aux_/preprocessed/gcc/minus.hpp1103/usr/include/boost/mpl/vector/aux_/O1_size.hpp1104/usr/include/boost/mpl/vector/aux_/size.hpp1105/usr/include/boost/mpl/vector/aux_/empty.hpp1106/usr/include/boost/mpl/vector/aux_/begin_end.hpp1107/usr/include/boost/mpl/vector/aux_/include_preprocessed.hpp110811091110/usr/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector10.hpp1111111211131114/usr/include/boost/mpl/vector/aux_/preprocessed/typeof_based/vector20.hpp1115111611171118/usr/include/boost/mpl/aux_/preprocessed/gcc/vector.hpp1119/usr/include/boost/preprocessor/facilities/intercept.hpp1120/usr/include/boost/preprocessor/repetition/enum_binary_params.hpp11211122112311241125112611271128/usr/include/boost/type_traits/is_base_and_derived.hpp1129/usr/include/boost/tuple/tuple.hpp1130/usr/include/boost/ref.hpp1131/usr/include/boost/core/ref.hpp1132/usr/include/boost/tuple/detail/tuple_basic.hpp1133/usr/include/boost/type_traits/cv_traits.hpp1134/usr/include/boost/type_traits/add_const.hpp1135/usr/include/boost/type_traits/add_volatile.hpp1136/usr/include/boost/type_traits/add_cv.hpp1137/usr/include/boost/type_traits/is_const.hpp1138/usr/include/boost/type_traits/is_volatile.hpp1139/usr/include/boost/type_traits/remove_const.hpp1140/usr/include/boost/type_traits/remove_volatile.hpp1141/usr/include/boost/utility/swap.hpp1142/usr/include/boost/core/swap.hpp1144/usr/include/boost/multi_index/ordered_index.hpp1145/usr/include/boost/multi_index/detail/ord_index_impl.hpp1146/usr/include/boost/iterator/reverse_iterator.hpp1147/usr/include/boost/iterator/iterator_adaptor.hpp1148/usr/include/boost/core/use_default.hpp1149/usr/include/boost/iterator/iterator_categories.hpp1150/usr/include/boost/iterator/detail/config_def.hpp1151/usr/include/boost/iterator/detail/config_undef.hpp1153/usr/include/boost/iterator/iterator_facade.hpp1154/usr/include/boost/iterator/interoperable.hpp115511561157/usr/include/boost/iterator/iterator_traits.hpp1158/usr/include/boost/iterator/detail/facade_iterator_category.hpp11591160/usr/include/boost/detail/indirect_traits.hpp/usr/include/boost/detail/select_type.hpp11621163/usr/include/boost/iterator/detail/enable_if.hpp116411651166/usr/include/boost/mpl/always.hpp11671168116911711172/usr/include/boost/multi_index/detail/bidir_node_iterator.hpp1173/usr/include/boost/multi_index/detail/ord_index_node.hpp1174/usr/include/boost/multi_index/detail/uintptr_type.hpp1175/usr/include/boost/multi_index/detail/ord_index_ops.hpp1176/usr/include/boost/multi_index/detail/unbounded.hpp1177/usr/include/boost/multi_index/detail/value_compare.hpp/usr/include/boost/multi_index/detail/ord_index_impl_fwd.hpp1179/usr/include/boost/multi_index/ordered_index_fwd.hpp1180/usr/include/boost/multi_index/detail/ord_index_args.hpp1181/usr/include/boost/multi_index/sequenced_index.hpp1182/usr/include/boost/bind.hpp1183/usr/include/boost/bind/bind.hpp1184/usr/include/boost/mem_fn.hpp1185/usr/include/boost/bind/mem_fn.hpp/usr/include/boost/get_pointer.hpp1187/usr/include/boost/config/no_tr1/memory.hpp1188/usr/include/boost/bind/mem_fn_template.hpp1189/usr/include/boost/bind/mem_fn_cc.hpp1190/usr/include/boost/type.hpp1191/usr/include/boost/is_placeholder.hpp1192/usr/include/boost/bind/arg.hpp1193/usr/include/boost/visit_each.hpp1194/usr/include/boost/core/is_same.hpp/usr/include/boost/bind/storage.hpp1196/usr/include/boost/bind/bind_cc.hpp11971198/usr/include/boost/bind/bind_mf_cc.hpp1199/usr/include/boost/bind/bind_mf2_cc.hpp12001201/usr/include/boost/bind/placeholders.hpp1202/usr/include/boost/move/utility_core.hpp1203/usr/include/boost/move/detail/meta_utils.hpp12051206/usr/include/boost/move/detail/meta_utils_core.hpp120712081209/usr/include/boost/multi_index/detail/seq_index_node.hpp1210/usr/include/boost/multi_index/detail/seq_index_ops.hpp121112121214/usr/include/boost/multi_index/sequenced_index_fwd.hpp1215/usr/include/boost/multi_index_container.hpp1216/usr/include/boost/mpl/at.hpp1217/usr/include/boost/mpl/aux_/at_impl.hpp1218/usr/include/boost/mpl/contains.hpp1219/usr/include/boost/mpl/contains_fwd.hpp1220/usr/include/boost/mpl/aux_/contains_impl.hpp/usr/include/boost/mpl/find.hpp1222/usr/include/boost/mpl/find_if.hpp1223/usr/include/boost/mpl/aux_/find_if_pred.hpp1224/usr/include/boost/mpl/aux_/iter_apply.hpp122512261227/usr/include/boost/mpl/iter_fold_if.hpp1228/usr/include/boost/mpl/logical.hpp1230/usr/include/boost/mpl/aux_/iter_fold_if_impl.hpp12311232123312341235/usr/include/boost/mpl/aux_/preprocessed/gcc/iter_fold_if_impl.hpp1236/usr/include/boost/mpl/same_as.hpp1237/usr/include/boost/mpl/aux_/lambda_spec.hpp1238/usr/include/boost/mpl/size.hpp1239/usr/include/boost/mpl/aux_/size_impl.hpp1240/usr/include/boost/multi_index_container_fwd.hpp1241/usr/include/boost/multi_index/identity.hpp1242/usr/include/boost/multi_index/identity_fwd.hpp1243/usr/include/boost/multi_index/indexed_by.hpp12441245/usr/include/boost/preprocessor/control/expr_if.hpp1246124712481249/usr/include/boost/preprocessor/repetition/enum.hpp12501251125212531254125512561257125812591260/usr/include/boost/multi_index/detail/base_type.hpp12611262/usr/include/boost/multi_index/detail/index_base.hpp1263/usr/include/boost/multi_index/detail/copy_map.hpp1264/usr/include/boost/multi_index/detail/node_type.hpp12651266/usr/include/boost/mpl/reverse_iter_fold.hpp12671268/usr/include/boost/mpl/aux_/reverse_iter_fold_impl.hpp12691270127112721273/usr/include/boost/mpl/aux_/preprocessed/gcc/reverse_iter_fold_impl.hpp1274/usr/include/boost/multi_index/detail/header_holder.hpp1275/usr/include/boost/multi_index/detail/is_index_list.hpp1276/usr/include/boost/mpl/empty.hpp1277/usr/include/boost/mpl/aux_/empty_impl.hpp1278/usr/include/boost/multi_index/detail/converter.hpp1279/usr/include/boost/multi_index/detail/has_tag.hpp1280/usr/include/boost/utility/base_from_member.hpp1281128212831284/usr/include/boost/preprocessor/repetition/repeat_from_to.hpp128512861287128812891290129112921293129412951296/home/tanteikg/QCVE/sources/bitcoin/src/test/util/mining.h1297/home/tanteikg/QCVE/sources/bitcoin/src/test/util/script.h12981299130013011302130313041305130613071308130913101311131213131314131513161317/home/tanteikg/QCVE/sources/bitcoin/src/validation.h13181319132013211322/home/tanteikg/QCVE/sources/bitcoin/src/flatfile.h1323/home/tanteikg/QCVE/sources/bitcoin/src/deploymentstatus.h1324/home/tanteikg/QCVE/sources/bitcoin/src/versionbits.h13251326132713281329133013311332133313341335/home/tanteikg/QCVE/sources/bitcoin/src/kernel/chainstatemanager_opts.h1336/home/tanteikg/QCVE/sources/bitcoin/src/dbwrapper.h133713381339/home/tanteikg/QCVE/sources/bitcoin/src/leveldb/include/leveldb/db.h1340/home/tanteikg/QCVE/sources/bitcoin/src/leveldb/include/leveldb/export.h1341/home/tanteikg/QCVE/sources/bitcoin/src/leveldb/include/leveldb/iterator.h1342/home/tanteikg/QCVE/sources/bitcoin/src/leveldb/include/leveldb/slice.h134313441345/home/tanteikg/QCVE/sources/bitcoin/src/leveldb/include/leveldb/status.h1346/home/tanteikg/QCVE/sources/bitcoin/src/leveldb/include/leveldb/options.h13471348/home/tanteikg/QCVE/sources/bitcoin/src/leveldb/include/leveldb/write_batch.h1349/home/tanteikg/QCVE/sources/bitcoin/src/txdb.h1350/home/tanteikg/QCVE/sources/bitcoin/src/node/blockstorage.h1351/home/tanteikg/QCVE/sources/bitcoin/src/kernel/blockmanager_opts.h1352/home/tanteikg/QCVE/sources/bitcoin/src/shutdown.h1353/home/tanteikg/QCVE/sources/bitcoin/src/bench/block_assemble.cpp<validation.h><test/util/script.h><test/util/mining.h><node/miner.h><consensus/validation.h>BlockAssemblerAddPackageTxnstesting_setupconst unique_ptr<TestChain100Setup, default_delete<TestChain100Setup>>assembler_optionslambda [] type at line 296389, col. 15const lambda [] type at line 296389, col. 15const lambda [] type at line 296389, col. 15 &lambda [] type at line 296389, col. 15 &lambda [] type at line 296389, col. 15 &&unique_ptr<TestChain100Setup, default_delete<TestChain100Setup>> &AssembleBlockconst unique_ptr<const TestingSetup, default_delete<const TestingSetup>>test_setupwitnessNUM_BLOCKStxsarray<shared_ptr<const CTransaction>, 101UL> *shared_ptr<const CTransaction>[101]const NodeContextconst NodeContext &NodeContext &const ChainTestingSetup *ChainTestingSetup *const BasicTestingSetup *BasicTestingSetup *vector<vector<unsigned char, allocator<unsigned char>>, allocator<vector<unsigned char, allocator<unsigned char>>>> &const vector<vector<unsigned char, allocator<unsigned char>>, allocator<vector<unsigned char, allocator<unsigned char>>>>const vector<vector<unsigned char, allocator<unsigned char>>, allocator<vector<unsigned char, allocator<unsigned char>>>> &vector<vector<unsigned char, allocator<unsigned char>>, allocator<vector<unsigned char, allocator<unsigned char>>>> *COINBASE_MATURITYshared_ptr<const CTransaction> &shared_ptr<const CTransaction> &&CTransactionRef &bench/block_assemble.cppres.m_result_type == MempoolAcceptResult::ResultType::VALIDarray<shared_ptr<const CTransaction>, 101UL> &txrconst MempoolAcceptResultresconst CTransactionRefconst CTransactionRef &const ResultTypevoid AssembleBlock(ankerl::nanobench::Bench &)lambda [] type at line 296377, col. 15const lambda [] type at line 296377, col. 15const lambda [] type at line 296377, col. 15 &lambda [] type at line 296377, col. 15 &lambda [] type at line 296377, col. 15 &&const unique_ptr<const TestingSetup, default_delete<const TestingSetup>> &unique_ptr<const TestingSetup, default_delete<const TestingSetup>> &~MempoolAcceptResultMempoolAcceptResult *const optional<vector<uint256, allocator<uint256>>>optional<vector<uint256, allocator<uint256>>> *_Optional_base<vector<uint256, allocator<uint256>>, false, false> *const optional<list<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>optional<list<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>> *_Optional_base<list<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>, false, false> *const TxValidationState~TxValidationStateTxValidationState *~ValidationStateValidationState<TxValidationResult> *~arrayconst lambda [] type at line 296389, col. 15 *lambda [] type at line 296389, col. 15 *const lambda [] type at line 296377, col. 15 *lambda [] type at line 296377, col. 15 *bench_63BlockAssemblerAddPackageTxnsbenchmark::PriorityLevel::LOWPASTE2(__LINE__, BlockAssemblerAddPackageTxns)63BlockAssemblerAddPackageTxnsbench_62AssembleBlockPASTE2(__LINE__, AssembleBlock)62AssembleBlock/*submit=*//*num_transactions=*/// Collect some loose transactions that spend the coinbases of our mined blocks// Copyright (c) 2011-2022 The Bitcoin Core developersunique_ptr<const TestingSetup, default_delete<const TestingSetup>>default_delete<const TestingSetup> &unique_ptr<TestChain100Setup, default_delete<TestChain100Setup>>default_delete<TestChain100Setup> &array<shared_ptr<const CTransaction>, 101UL>array<shared_ptr<const CTransaction>, 101UL> &&const array<shared_ptr<const CTransaction>, 101UL>const array<shared_ptr<const CTransaction>, 101UL> &vector<shared_ptr<CBlock>, allocator<shared_ptr<CBlock>>>unique_ptr<const TestingSetup, default_delete<const TestingSetup>> *TestingSetup *&const TestingSetup *const default_delete<const TestingSetup>TestingSetup *&&const TestingSetup *&shared_ptr<const CTransaction>(&)[101]const unique_ptr<const TestingSetup, default_delete<const TestingSetup>> *unique_ptr<TestChain100Setup, default_delete<TestChain100Setup>> *TestChain100Setup *&const default_delete<TestChain100Setup>TestChain100Setup *&&const unique_ptr<TestChain100Setup, default_delete<TestChain100Setup>> *const TestingSetup *constconst TestingSetup *const &const default_delete<const TestingSetup> &TestChain100Setup *constTestChain100Setup *const &const default_delete<TestChain100Setup> &allocator<shared_ptr<CBlock>>__uniq_ptr_impl<TestChain100Setup, default_delete<TestChain100Setup>>__uniq_ptr_impl<TestChain100Setup, default_delete<TestChain100Setup>> &__uniq_ptr_impl<TestChain100Setup, default_delete<TestChain100Setup>> &&const __uniq_ptr_impl<TestChain100Setup, default_delete<TestChain100Setup>>const __uniq_ptr_impl<TestChain100Setup, default_delete<TestChain100Setup>> &default_delete<TestChain100Setup>default_delete<TestChain100Setup> &&__uniq_ptr_impl<const TestingSetup, default_delete<const TestingSetup>>__uniq_ptr_impl<const TestingSetup, default_delete<const TestingSetup>> &__uniq_ptr_impl<const TestingSetup, default_delete<const TestingSetup>> &&const __uniq_ptr_impl<const TestingSetup, default_delete<const TestingSetup>>const __uniq_ptr_impl<const TestingSetup, default_delete<const TestingSetup>> &default_delete<const TestingSetup>default_delete<const TestingSetup> &&__array_traits<shared_ptr<const CTransaction>, 101UL>__array_traits<shared_ptr<const CTransaction>, 101UL> &__array_traits<shared_ptr<const CTransaction>, 101UL> &&const __array_traits<shared_ptr<const CTransaction>, 101UL>const __array_traits<shared_ptr<const CTransaction>, 101UL> &const default_delete<TestChain100Setup> *default_delete<TestChain100Setup> *__uniq_ptr_impl<TestChain100Setup, default_delete<TestChain100Setup>> *__tuple_element_t<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>> &tuple<TestChain100Setup *, default_delete<TestChain100Setup>> &const default_delete<const TestingSetup> *default_delete<const TestingSetup> *__uniq_ptr_impl<const TestingSetup, default_delete<const TestingSetup>> *__tuple_element_t<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>> &tuple<const TestingSetup *, default_delete<const TestingSetup>> &__and_<is_convertible<pointer, const TestingSetup *>, __not_<is_array<_Up>>>tuple<const TestingSetup *, default_delete<const TestingSetup>>tuple<const TestingSetup *, default_delete<const TestingSetup>> &&const tuple<const TestingSetup *, default_delete<const TestingSetup>>const tuple<const TestingSetup *, default_delete<const TestingSetup>> &_Ptr<const TestingSetup, default_delete<const TestingSetup>, void>_Ptr<const TestingSetup, default_delete<const TestingSetup>, void> &_Ptr<const TestingSetup, default_delete<const TestingSetup>, void> &&const _Ptr<const TestingSetup, default_delete<const TestingSetup>, void>const _Ptr<const TestingSetup, default_delete<const TestingSetup>, void> &__and_<is_convertible<pointer, TestChain100Setup *>, __not_<is_array<_Up>>>tuple<TestChain100Setup *, default_delete<TestChain100Setup>>tuple<TestChain100Setup *, default_delete<TestChain100Setup>> &&const tuple<TestChain100Setup *, default_delete<TestChain100Setup>>const tuple<TestChain100Setup *, default_delete<TestChain100Setup>> &_Ptr<TestChain100Setup, default_delete<TestChain100Setup>, void>_Ptr<TestChain100Setup, default_delete<TestChain100Setup>, void> &_Ptr<TestChain100Setup, default_delete<TestChain100Setup>, void> &&const _Ptr<TestChain100Setup, default_delete<TestChain100Setup>, void>const _Ptr<TestChain100Setup, default_delete<TestChain100Setup>, void> &reverse_iterator<shared_ptr<const CTransaction> *>reverse_iterator<const shared_ptr<const CTransaction> *>_Tuple_impl<0UL, const TestingSetup *, default_delete<const TestingSetup>>_Tuple_impl<0UL, const TestingSetup *, default_delete<const TestingSetup>> &&const _Tuple_impl<0UL, const TestingSetup *, default_delete<const TestingSetup>>const _Tuple_impl<0UL, const TestingSetup *, default_delete<const TestingSetup>> &_Tuple_impl<0UL, const TestingSetup *, default_delete<const TestingSetup>> &_Tuple_impl<1UL, default_delete<const TestingSetup>>_Tuple_impl<1UL, default_delete<const TestingSetup>> &&const _Tuple_impl<1UL, default_delete<const TestingSetup>>const _Tuple_impl<1UL, default_delete<const TestingSetup>> &_Tuple_impl<1UL, default_delete<const TestingSetup>> &_Tuple_impl<0UL, TestChain100Setup *, default_delete<TestChain100Setup>>_Tuple_impl<0UL, TestChain100Setup *, default_delete<TestChain100Setup>> &&const _Tuple_impl<0UL, TestChain100Setup *, default_delete<TestChain100Setup>>const _Tuple_impl<0UL, TestChain100Setup *, default_delete<TestChain100Setup>> &_Tuple_impl<0UL, TestChain100Setup *, default_delete<TestChain100Setup>> &_Tuple_impl<1UL, default_delete<TestChain100Setup>>_Tuple_impl<1UL, default_delete<TestChain100Setup>> &&const _Tuple_impl<1UL, default_delete<TestChain100Setup>>const _Tuple_impl<1UL, default_delete<TestChain100Setup>> &_Tuple_impl<1UL, default_delete<TestChain100Setup>> &remove_reference<const TestingSetup *&>remove_reference<const TestingSetup *&> &remove_reference<const TestingSetup *&> &&const remove_reference<const TestingSetup *&>const remove_reference<const TestingSetup *&> &_MakeUniq<const TestingSetup>_MakeUniq<const TestingSetup> &_MakeUniq<const TestingSetup> &&const _MakeUniq<const TestingSetup>const _MakeUniq<const TestingSetup> &remove_reference<TestChain100Setup *&>remove_reference<TestChain100Setup *&> &remove_reference<TestChain100Setup *&> &&const remove_reference<TestChain100Setup *&>const remove_reference<TestChain100Setup *&> &_MakeUniq<TestChain100Setup>_MakeUniq<TestChain100Setup> &_MakeUniq<TestChain100Setup> &&const _MakeUniq<TestChain100Setup>const _MakeUniq<TestChain100Setup> &__tuple_element_t<1UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>> &const __uniq_ptr_impl<const TestingSetup, default_delete<const TestingSetup>> *const __tuple_element_t<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>>const __tuple_element_t<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>> &__tuple_element_t<1UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>> &const __uniq_ptr_impl<TestChain100Setup, default_delete<TestChain100Setup>> *const __tuple_element_t<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>>const __tuple_element_t<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>> &_Head_base<1UL, default_delete<TestChain100Setup>, true>_Head_base<1UL, default_delete<TestChain100Setup>, true> &const _Head_base<1UL, default_delete<TestChain100Setup>, true>const _Head_base<1UL, default_delete<TestChain100Setup>, true> &_Head_base<0UL, TestChain100Setup *, false>_Head_base<0UL, TestChain100Setup *, false> &const _Head_base<0UL, TestChain100Setup *, false>const _Head_base<0UL, TestChain100Setup *, false> &_Head_base<1UL, default_delete<const TestingSetup>, true>_Head_base<1UL, default_delete<const TestingSetup>, true> &const _Head_base<1UL, default_delete<const TestingSetup>, true>const _Head_base<1UL, default_delete<const TestingSetup>, true> &_Head_base<0UL, const TestingSetup *, false>_Head_base<0UL, const TestingSetup *, false> &const _Head_base<0UL, const TestingSetup *, false>const _Head_base<0UL, const TestingSetup *, false> &is_convertible<pointer, TestChain100Setup *>is_convertible<pointer, const TestingSetup *>__is_swappable<shared_ptr<const CTransaction>>__is_nothrow_swappable<shared_ptr<const CTransaction>>remove_reference<const vector<const char *, allocator<const char *>> &>remove_reference<const vector<const char *, allocator<const char *>> &> &remove_reference<const vector<const char *, allocator<const char *>> &> &&const remove_reference<const vector<const char *, allocator<const char *>> &>const remove_reference<const vector<const char *, allocator<const char *>> &> &tuple_element<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>>tuple_element<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>> &tuple_element<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>> &&const tuple_element<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>>const tuple_element<0UL, tuple<const TestingSetup *, default_delete<const TestingSetup>>> &tuple_element<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>>tuple_element<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>> &tuple_element<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>> &&const tuple_element<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>>const tuple_element<0UL, tuple<TestChain100Setup *, default_delete<TestChain100Setup>>> &_TC<value, const TestingSetup *, default_delete<const TestingSetup>>_TC<true, const TestingSetup *, default_delete<const TestingSetup>>_TC<true, const TestingSetup *, default_delete<const TestingSetup>> &_TC<true, const TestingSetup *, default_delete<const TestingSetup>> &&const _TC<true, const TestingSetup *, default_delete<const TestingSetup>>const _TC<true, const TestingSetup *, default_delete<const TestingSetup>> &_TC<value, TestChain100Setup *, default_delete<TestChain100Setup>>_TC<true, TestChain100Setup *, default_delete<TestChain100Setup>>_TC<true, TestChain100Setup *, default_delete<TestChain100Setup>> &_TC<true, TestChain100Setup *, default_delete<TestChain100Setup>> &&const _TC<true, TestChain100Setup *, default_delete<TestChain100Setup>>const _TC<true, TestChain100Setup *, default_delete<TestChain100Setup>> &tuple_element<0UL, tuple<default_delete<TestChain100Setup>>>tuple_element<0UL, tuple<default_delete<TestChain100Setup>>> &tuple_element<0UL, tuple<default_delete<TestChain100Setup>>> &&const tuple_element<0UL, tuple<default_delete<TestChain100Setup>>>const tuple_element<0UL, tuple<default_delete<TestChain100Setup>>> &tuple_element<0UL, tuple<default_delete<const TestingSetup>>>tuple_element<0UL, tuple<default_delete<const TestingSetup>>> &tuple_element<0UL, tuple<default_delete<const TestingSetup>>> &&const tuple_element<0UL, tuple<default_delete<const TestingSetup>>>const tuple_element<0UL, tuple<default_delete<const TestingSetup>>> &__is_empty_non_tuple<default_delete<TestChain100Setup>>__is_empty_non_tuple<default_delete<TestChain100Setup>> &__is_empty_non_tuple<default_delete<TestChain100Setup>> &&const __is_empty_non_tuple<default_delete<TestChain100Setup>>const __is_empty_non_tuple<default_delete<TestChain100Setup>> &__is_empty_non_tuple<TestChain100Setup *>__is_empty_non_tuple<TestChain100Setup *> &__is_empty_non_tuple<TestChain100Setup *> &&const __is_empty_non_tuple<TestChain100Setup *>const __is_empty_non_tuple<TestChain100Setup *> &__is_empty_non_tuple<default_delete<const TestingSetup>>__is_empty_non_tuple<default_delete<const TestingSetup>> &__is_empty_non_tuple<default_delete<const TestingSetup>> &&const __is_empty_non_tuple<default_delete<const TestingSetup>>const __is_empty_non_tuple<default_delete<const TestingSetup>> &__is_empty_non_tuple<const TestingSetup *>__is_empty_non_tuple<const TestingSetup *> &__is_empty_non_tuple<const TestingSetup *> &&const __is_empty_non_tuple<const TestingSetup *>const __is_empty_non_tuple<const TestingSetup *> &_Tuple_impl<0UL, TestChain100Setup *, default_delete<TestChain100Setup>> *_Tuple_impl<0UL, const TestingSetup *, default_delete<const TestingSetup>> *conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const TestingSetup *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const TestingSetup *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const TestingSetup *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const TestingSetup *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const TestingSetup *>> &is_empty<const TestingSetup *>is_empty<const TestingSetup *> &is_empty<const TestingSetup *> &&const is_empty<const TestingSetup *>const is_empty<const TestingSetup *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const TestingSetup>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const TestingSetup>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const TestingSetup>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const TestingSetup>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const TestingSetup>>> &is_empty<default_delete<const TestingSetup>>is_empty<default_delete<const TestingSetup>> &is_empty<default_delete<const TestingSetup>> &&const is_empty<default_delete<const TestingSetup>>const is_empty<default_delete<const TestingSetup>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestChain100Setup *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestChain100Setup *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestChain100Setup *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestChain100Setup *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestChain100Setup *>> &is_empty<TestChain100Setup *>is_empty<TestChain100Setup *> &is_empty<TestChain100Setup *> &&const is_empty<TestChain100Setup *>const is_empty<TestChain100Setup *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestChain100Setup>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestChain100Setup>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestChain100Setup>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestChain100Setup>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestChain100Setup>>> &is_empty<default_delete<TestChain100Setup>>is_empty<default_delete<TestChain100Setup>> &is_empty<default_delete<TestChain100Setup>> &&const is_empty<default_delete<TestChain100Setup>>const is_empty<default_delete<TestChain100Setup>> &tuple<default_delete<const TestingSetup>>tuple<default_delete<TestChain100Setup>>_Head_base<0UL, const TestingSetup *, false> *_Tuple_impl<1UL, default_delete<const TestingSetup>> *_Head_base<0UL, TestChain100Setup *, false> *_Tuple_impl<1UL, default_delete<TestChain100Setup>> *_Head_base<1UL, default_delete<TestChain100Setup>, true> *_Head_base<1UL, default_delete<const TestingSetup>, true> */home/tanteikg/QCVE/sources/bitcoin/src/script/signingprovider.h<script/standard.h><script/keyorigin.h>GetKeyForDestinationconst SigningProviderconst SigningProvider &SigningProvider &const CTxDestinationconst CTxDestination &variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown> &FillableSigningProvider &const FillableSigningProviderconst FillableSigningProvider &~FillableSigningProviderFillableSigningProvider *FillableSigningProviderSigningProviderSigningProvider *GetCScriptconst CScriptIDconst CScriptID &CScriptID &GetCScriptsHaveCScriptAddCScriptconst CKeyIDconst CKeyID &CKeyID &CKey &GetKeysHaveKeyGetPubKeyCPubKey &AddKeyconst CKeyconst CKey &const CPubKeyconst CPubKey &AddKeyPubKeyImplicitlyLearnRelatedKeyScriptsFlatSigningProvider &FlatSigningProvider &&const FlatSigningProviderconst FlatSigningProvider &~FlatSigningProviderFlatSigningProviderMergeGetTaprootBuilderconst XOnlyPubKeyconst XOnlyPubKey &XOnlyPubKey &TaprootBuilder &GetTaprootSpendDataTaprootSpendData &GetKeyOriginKeyOriginInfo &HidingSigningProvider &const HidingSigningProviderconst HidingSigningProvider &~HidingSigningProviderHidingSigningProviderHidingSigningProvider &&const SigningProvider *HidingSigningProvider *GetKeyOriginByXOnlyvector<CKeyID, allocator<CKeyID>> &&vector<CKeyID, allocator<CKeyID>> &idconst __normal_iterator<CKeyID *, vector<CKeyID, allocator<CKeyID>>>const __normal_iterator<CKeyID *, vector<CKeyID, allocator<CKeyID>>> &__normal_iterator<CKeyID *, vector<CKeyID, allocator<CKeyID>>> &GetPubKeyByXOnlyGetKeyByXOnly~SigningProvidercs_KeyStoremapScriptsmapKeystr_treesoriginspubkeysscriptsm_providerm_hide_originm_hide_secretDUMMY_SIGNING_PROVIDERBITCOIN_SCRIPT_SIGNINGPROVIDER_H// BITCOIN_SCRIPT_SIGNINGPROVIDER_H/** Return the CKeyID of the key involved in a script (if there is a unique one). *//**
     * Map of script id to scripts known by the signing provider.
     *
     * This map originally just held P2SH redeemScripts, and was used by wallet
     * code to look up script ids referenced in "OP_HASH160 <script id>
     * OP_EQUAL" P2SH outputs. Later in 605e8473a7d it was extended to hold
     * P2WSH witnessScripts as well, and used to look up nested scripts
     * referenced in "OP_0 <script hash>" P2WSH outputs. Later in commits
     * f4691ab3a9d and 248f3a76a82, it was extended once again to hold segwit
     * "OP_0 <key or script hash>" scriptPubKeys, in order to give the wallet a
     * way to distinguish between segwit outputs that it generated addresses for
     * and wanted to receive payments from, and segwit outputs that it never
     * generated addresses for, but it could spend just because of having keys.
     * (Before segwit activation it was also important to not treat segwit
     * outputs to arbitrary wallet keys as payments, because these could be
     * spent by anyone without even needing to sign with the keys.)
     *
     * Some of the scripts stored in mapScripts are memory-only and
     * intentionally not saved to disk. Specifically, scripts added by
     * ImplicitlyLearnRelatedKeyScripts(pubkey) calls are not written to disk so
     * future wallet code can have flexibility to be more selective about what
     * transaction outputs it recognizes as payments, instead of having to treat
     * all outputs spending to keys it knows as payments. By contrast,
     * mapScripts entries added by AddCScript(script),
     * LearnRelatedScripts(pubkey, type), and LearnAllRelatedScripts(pubkey)
     * calls are saved because they are all intentionally used to receive
     * payments.
     *
     * The FillableSigningProvider::mapScripts script map should not be confused
     * with LegacyScriptPubKeyMan::setWatchOnly script set. The two collections
     * can hold the same scripts, but they serve different purposes. The
     * setWatchOnly script set is intended to expand the set of outputs the
     * wallet considers payments. Every output with a script it contains is
     * considered to belong to the wallet, regardless of whether the script is
     * solvable or signable. By contrast, the scripts in mapScripts are only
     * used for solving, and to restrict which outputs are considered payments
     * by the wallet. An output with a script in mapScripts, unlike
     * setWatchOnly, is not automatically considered to belong to the wallet if
     * it can't be solved and signed for.
     *//**
     * Map of key id to unencrypted private keys known by the signing provider.
     * Map may be empty if the provider has another source of keys, like an
     * encrypted store.
     *//** Fillable signing provider that keeps keys in an address->secret map *//** Map from output key to Taproot tree (which can then make the TaprootSpendData *//** An interface to be implemented by keystores that support signing. */providerhide_secrethide_originpubkeyoutput_keybuilderspenddatakeyidscriptidscriptredeemScriptOutredeemScriptkeyOutvchPubKeyOut/home/tanteikg/QCVE/sources/bitcoin/src/script/keyorigin.h/home/tanteikg/QCVE/sources/bitcoin/src/test/util/transaction_utils.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/ccoins_caching.cpp<test/util/transaction_utils.h><script/signingprovider.h><coins.h>CCoinsCachingkeystorecoinsDummyCCoinsViewCCoinsView *coinsdummyTransactionsCCoinsViewCache &const array<signed long, 4UL>const array<signed long, 4UL> &array<signed long, 4UL> &signed long[4]110000000011 * COIN500000000050 * COIN210000000021 * COIN220000000022 * COINt1900000000090 * COINtx_1successlambda [] type at line 157209, col. 15const lambda [] type at line 157209, col. 15const lambda [] type at line 157209, col. 15 &lambda [] type at line 157209, col. 15 &lambda [] type at line 157209, col. 15 &&~CCoinsViewCacheCCoinsViewCache *unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher, equal_to<COutPoint>, PoolAllocator<pair<const COutPoint, CCoinsCacheEntry>, 128UL, 8UL>> *~CCoinsViewBackedCCoinsViewBacked *const lambda [] type at line 157209, col. 15 *lambda [] type at line 157209, col. 15 *const CCoinsViewCacheconst CCoinsViewCache &bench/ccoins_caching.cppbench_53CCoinsCachingPASTE2(__LINE__, CCoinsCaching)53CCoinsCaching// Benchmark.// (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)// every benchmark."// characteristics than e.g. reindex timings. But that's not a requirement of// many times micro-benchmarks of the database showed completely different// laanwj, "replicating the actual usage patterns of the client is hard though,// Microbenchmark for simple accesses to a CCoinsViewCache database. Note from/home/tanteikg/QCVE/sources/bitcoin/src/bench/chacha20.cppCHACHA20_1MBBUFFER_SIZE_LARGECHACHA20_256BYTESBUFFER_SIZE_SMALLCHACHA20_64BYTESBUFFER_SIZE_TINYCHACHA20lambda [] type at line 118891, col. 45const lambda [] type at line 118891, col. 45const lambda [] type at line 118891, col. 45 &lambda [] type at line 118891, col. 45 &lambda [] type at line 118891, col. 45 &&ChaCha20 &const lambda [] type at line 118891, col. 45 *lambda [] type at line 118891, col. 45 *bench_44CHACHA20_1MBPASTE2(__LINE__, CHACHA20_1MB)44CHACHA20_1MBbench_43CHACHA20_256BYTESPASTE2(__LINE__, CHACHA20_256BYTES)43CHACHA20_256BYTESbench_42CHACHA20_64BYTESPASTE2(__LINE__, CHACHA20_64BYTES)42CHACHA20_64BYTES1024*1024/* Number of bytes to process per iteration */buffersize/home/tanteikg/QCVE/sources/bitcoin/src/crypto/chacha_poly_aead.h/home/tanteikg/QCVE/sources/bitcoin/src/crypto/poly1305.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/chacha_poly_aead.cpp<crypto/poly1305.h><crypto/chacha_poly_aead.h>HASH_1MBHASH_256BYTESHASH_64BYTESHASHuint8_t[32]CHash256::OUTPUT_SIZElambda [] type at line 143629, col. 45const lambda [] type at line 143629, col. 45const lambda [] type at line 143629, col. 45 &lambda [] type at line 143629, col. 45 &lambda [] type at line 143629, col. 45 &&uint8_t(&)[32]unsigned char(&)[32]CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPTCHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPTCHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPTCHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPTCHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPTCHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPTCHACHA20_POLY1305_AEADCHACHA20_POLY1305_AEAD_AAD_LENPOLY1305_TAGLENseqnr_payloadseqnr_aadaad_poscrypt_ok_1get_length_okcrypt_ok_2lambda [] type at line 143563, col. 46const lambda [] type at line 143563, col. 46const lambda [] type at line 143563, col. 46 &lambda [] type at line 143563, col. 46 &lambda [] type at line 143563, col. 46 &&const lambda [] type at line 143629, col. 45 *lambda [] type at line 143629, col. 45 *const lambda [] type at line 143563, col. 46 *lambda [] type at line 143563, col. 46 *bench/chacha_poly_aead.cppconst uint8_t *CHACHA20_ROUND_OUTPUTinclude_decryptionbench_126HASH_1MBPASTE2(__LINE__, HASH_1MB)126HASH_1MBbench_125HASH_256BYTESPASTE2(__LINE__, HASH_256BYTES)125HASH_256BYTESbench_124HASH_64BYTESPASTE2(__LINE__, HASH_64BYTES)124HASH_64BYTESbench_123CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPTPASTE2(__LINE__, CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPT)123CHACHA20_POLY1305_AEAD_1MB_ENCRYPT_DECRYPTbench_122CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPTconst char[48]PASTE2(__LINE__, CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPT)122CHACHA20_POLY1305_AEAD_256BYTES_ENCRYPT_DECRYPTbench_121CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPTPASTE2(__LINE__, CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPT)121CHACHA20_POLY1305_AEAD_64BYTES_ENCRYPT_DECRYPTbench_120CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPTPASTE2(__LINE__, CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPT)120CHACHA20_POLY1305_AEAD_1MB_ONLY_ENCRYPTbench_119CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPTPASTE2(__LINE__, CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPT)119CHACHA20_POLY1305_AEAD_256BYTES_ONLY_ENCRYPTbench_118CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPTPASTE2(__LINE__, CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPT)118CHACHA20_POLY1305_AEAD_64BYTES_ONLY_ENCRYPTaeadk2k11024 * 1024// Add Hash() (dbl-sha256) bench for comparison// reuse of nonce+key is okay while benchmarking.// increase aad position (position in AAD keystream)// increase main sequence number// if we decrypt, include the GetLength// encrypt or decrypt the buffer with a static key// for the POLY1305_TAGLEN constant/home/tanteikg/QCVE/sources/bitcoin/src/bench/data.hblock413567BITCOIN_BENCH_DATA_H// BITCOIN_BENCH_DATA_H// namespace data// Copyright (c) 2019 The Bitcoin Core developers/home/tanteikg/QCVE/sources/bitcoin/src/bench/checkblock.cpp<bench/data.h>DeserializeAndCheckBlockTest70016PROTOCOL_VERSIONbench_argsconst unique_ptr<const CChainParams, default_delete<const CChainParams>>chainParamsrewoundcheckedlambda [] type at line 295064, col. 29const lambda [] type at line 295064, col. 29const lambda [] type at line 295064, col. 29 &lambda [] type at line 295064, col. 29 &lambda [] type at line 295064, col. 29 &&"block"const unique_ptr<const CChainParams, default_delete<const CChainParams>> &unique_ptr<const CChainParams, default_delete<const CChainParams>> &DeserializeBlockTestlambda [] type at line 295047, col. 29const lambda [] type at line 295047, col. 29const lambda [] type at line 295047, col. 29 &lambda [] type at line 295047, col. 29 &lambda [] type at line 295047, col. 29 &&const lambda [] type at line 295064, col. 29 *lambda [] type at line 295064, col. 29 *bench/checkblock.cppvalidationStateBlockValidationStateBlockValidationState *ValidationStateValidationState<BlockValidationResult> *BlockValidationState &~BlockValidationStateconst lambda [] type at line 295047, col. 29 *lambda [] type at line 295047, col. 29 *bench_54DeserializeAndCheckBlockTestPASTE2(__LINE__, DeserializeAndCheckBlockTest)54DeserializeAndCheckBlockTestbench_53DeserializeBlockTestPASTE2(__LINE__, DeserializeBlockTest)53DeserializeBlockTest// Note that CBlock caches its checked state, so we need to recreate it here// Prevent compaction// compact block relay.// a block off the wire, but before we can relay the block on to peers using// These are the two major time-sinks which happen after we have fully received__element_typeunusedlambda [] type at line 123016, col. 30lambda [] type at line 123016, col. 30 &&lambda [] type at line 123016, col. 30 &const lambda [] type at line 123016, col. 30const lambda [] type at line 123016, col. 30 &const lambda [] type at line 123016, col. 30 *lambda [] type at line 123016, col. 30 */home/tanteikg/QCVE/sources/bitcoin/src/checkqueue.h/home/tanteikg/QCVE/sources/bitcoin/src/util/syscall_sandbox.h/home/tanteikg/QCVE/sources/bitcoin/src/util/threadnames.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/checkqueue.cpp<checkqueue.h>PrevectorJobPrevectorJob &PrevectorJob &&PrevectorJob *const PrevectorJobconst PrevectorJob &~PrevectorJobCCheckQueueSpeedPrevectorJobqueueQUEUE_BATCH_SIZEvBatchesBATCHESvector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> &vector<PrevectorJob, allocator<PrevectorJob>> &vChecksconst __normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>>const __normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>> &__normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>> &BATCH_SIZElambda [] type at line 149083, col. 78const lambda [] type at line 149083, col. 78const lambda [] type at line 149083, col. 78 &lambda [] type at line 149083, col. 78 &lambda [] type at line 149083, col. 78 &&3030BATCH_SIZE * BATCHESjob"job"CCheckQueue<PrevectorJob> &const lambda [] type at line 149083, col. 78 *lambda [] type at line 149083, col. 78 *controlCCheckQueue<PrevectorJob> *const vector<PrevectorJob, allocator<PrevectorJob>>const vector<PrevectorJob, allocator<PrevectorJob>> &vector<PrevectorJob, allocator<PrevectorJob>> &&PREVECTOR_SIZEPREVECTOR_SIZE*2bench_67CCheckQueueSpeedPrevectorJobPASTE2(__LINE__, CCheckQueueSpeedPrevectorJob)67CCheckQueueSpeedPrevectorJob// it is done explicitly here for clarity// control waits for completion by RAII, but// Make insecure_rand here so that each iteration is identical.// create all the data once, then submit copies in the benchmark.// to decrease the variance of benchmark results.// The main thread should be counted to prevent thread oversubscription, and// We shouldn't ever be running with the checkqueue on a single core machine.// and there is a little bit of work done between calls to Add.// where checks all contain a prevector that is indirect 50% of the time// This Benchmark tests the CheckQueue with a slightly realistic workload,__normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>>vector<PrevectorJob, allocator<PrevectorJob>> *__normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>> &&__normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>> *CCheckQueue<PrevectorJob>const CCheckQueue<PrevectorJob>const CCheckQueue<PrevectorJob> &CCheckQueuem_control_mutexm_request_stopm_worker_threadsnBatchSizenTodofAllOknTotalnIdlem_master_cvm_worker_cvm_mutexvector<PrevectorJob, allocator<PrevectorJob>>allocator<PrevectorJob> &vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>allocator<vector<PrevectorJob, allocator<PrevectorJob>>> &CCheckQueueControl<PrevectorJob>fDoneCCheckQueue<PrevectorJob> *constpqueue_State_impl<_Invoker<tuple<lambda [] type at line 123625, col. 43>>>~_State_impl_State_impl<_Invoker<tuple<lambda [] type at line 123625, col. 43>>> *_State_impl<_Invoker<tuple<lambda [] type at line 123625, col. 43>>> &const _State_impl<_Invoker<tuple<lambda [] type at line 123625, col. 43>>>const _State_impl<_Invoker<tuple<lambda [] type at line 123625, col. 43>>> &_State_impl_State_impl<_Invoker<tuple<lambda [] type at line 123625, col. 43>>> &&_M_func__decayed_tuple_Invoker<tuple<lambda [] type at line 123625, col. 43>>_Invoker<tuple<lambda [] type at line 123625, col. 43>> &const _Invoker<tuple<lambda [] type at line 123625, col. 43>>const _Invoker<tuple<lambda [] type at line 123625, col. 43>> &_Invoker_Invoker<tuple<lambda [] type at line 123625, col. 43>> &&_Invoker<tuple<lambda [] type at line 123625, col. 43>> *_Ind__result<tuple<_Fn, _Args...>>__result<<unnamed>>_Vector_base<PrevectorJob, allocator<PrevectorJob>>_Vector_base<PrevectorJob, allocator<PrevectorJob>> &const _Vector_base<PrevectorJob, allocator<PrevectorJob>>const _Vector_base<PrevectorJob, allocator<PrevectorJob>> &_Vector_base<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>_Vector_base<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> &const _Vector_base<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>const _Vector_base<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> &allocator<PrevectorJob>allocator<vector<PrevectorJob, allocator<PrevectorJob>>>new_allocator<PrevectorJob>new_allocator<PrevectorJob> &const new_allocator<PrevectorJob>const new_allocator<PrevectorJob> &new_allocator<vector<PrevectorJob, allocator<PrevectorJob>>>new_allocator<vector<PrevectorJob, allocator<PrevectorJob>>> &const new_allocator<vector<PrevectorJob, allocator<PrevectorJob>>>const new_allocator<vector<PrevectorJob, allocator<PrevectorJob>>> &allocator_traits<allocator<PrevectorJob>>allocator_traits<allocator<PrevectorJob>> &allocator_traits<allocator<PrevectorJob>> &&const allocator_traits<allocator<PrevectorJob>>const allocator_traits<allocator<PrevectorJob>> &allocator_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>allocator_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> &allocator_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> &&const allocator_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>const allocator_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> &tuple<lambda [] type at line 123625, col. 43> &&tuple<lambda [] type at line 123625, col. 43> *_Tuple_impl<0UL, lambda [] type at line 123625, col. 43> &&_M_run~CCheckQueueControlCCheckQueueControl<PrevectorJob> *pqueue->m_control_mutex./checkqueue.hWaitfRet_Vector_base<PrevectorJob, allocator<PrevectorJob>> *const allocator<PrevectorJob>const allocator<PrevectorJob> &CCheckQueueControlfDone(false)pqueueInvector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> *_Vector_base<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>> *~CCheckQueuem_worker_threads.empty()const vector<thread, allocator<thread>>CCheckQueue<T>::~CCheckQueue() [with T = PrevectorJob]StopWorkerThreadsm_request_stop = truelambda [] type at line 123662, col. 9const lambda [] type at line 123662, col. 9const lambda [] type at line 123662, col. 9 &lambda [] type at line 123662, col. 9 &lambda [] type at line 123662, col. 9 &&vector<thread, allocator<thread>> &thread &const __normal_iterator<thread *, vector<thread, allocator<thread>>>const __normal_iterator<thread *, vector<thread, allocator<thread>>> &__normal_iterator<thread *, vector<thread, allocator<thread>>> &m_request_stop = falselambda [] type at line 123668, col. 9const lambda [] type at line 123668, col. 9const lambda [] type at line 123668, col. 9 &lambda [] type at line 123668, col. 9 &lambda [] type at line 123668, col. 9 &&const lambda [] type at line 123668, col. 9 *lambda [] type at line 123668, col. 9 *const lambda [] type at line 123662, col. 9 *lambda [] type at line 123662, col. 9 *const vector<PrevectorJob, allocator<PrevectorJob>> *const PrevectorJob *vector<PrevectorJob, allocator<PrevectorJob>> *constvector<PrevectorJob, allocator<PrevectorJob>> *const &vector<PrevectorJob, allocator<PrevectorJob>> *&const __normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>> *nBatchSizeInthreadlambda [] type at line 123625, col. 43const lambda [] type at line 123625, col. 43const lambda [] type at line 123625, col. 43 &lambda [] type at line 123625, col. 43 &lambda [] type at line 123625, col. 43 &&__dependpthread_t *const pthread_attr_t *pthread_attr_t *thread *StartWorkerThreadsvoid CCheckQueue<T>::StartWorkerThreads(int) [with T = PrevectorJob]const lambda [] type at line 123625, col. 43 *lambda [] type at line 123625, col. 43 *scriptch.%i"scriptch.%i"SyscallSandboxPolicy::VALIDATION_SCRIPT_CHECKthreads_num__make_invoker__callable_S_make_state_State *const _Vector_base<PrevectorJob, allocator<PrevectorJob>> *__alloc_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>, vector<PrevectorJob, allocator<PrevectorJob>>>__alloc_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>, vector<PrevectorJob, allocator<PrevectorJob>>> &__alloc_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>, vector<PrevectorJob, allocator<PrevectorJob>>> &&const __alloc_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>, vector<PrevectorJob, allocator<PrevectorJob>>>const __alloc_traits<allocator<vector<PrevectorJob, allocator<PrevectorJob>>>, vector<PrevectorJob, allocator<PrevectorJob>>> &__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> &__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> &&const __normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>const __normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> &__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> *_Tuple_impl<0UL, lambda [] type at line 123625, col. 43>const _Tuple_impl<0UL, lambda [] type at line 123625, col. 43>const _Tuple_impl<0UL, lambda [] type at line 123625, col. 43> &_Tuple_impl<0UL, lambda [] type at line 123625, col. 43> &__result<tuple<lambda [] type at line 123625, col. 43>>__result<tuple<lambda [] type at line 123625, col. 43>> &__result<tuple<lambda [] type at line 123625, col. 43>> &&const __result<tuple<lambda [] type at line 123625, col. 43>>const __result<tuple<lambda [] type at line 123625, col. 43>> &tuple<lambda [] type at line 123625, col. 43>tuple<lambda [] type at line 123625, col. 43> &const tuple<lambda [] type at line 123625, col. 43>const tuple<lambda [] type at line 123625, col. 43> &__alloc_traits<allocator<PrevectorJob>, PrevectorJob>__alloc_traits<allocator<PrevectorJob>, PrevectorJob> &__alloc_traits<allocator<PrevectorJob>, PrevectorJob> &&const __alloc_traits<allocator<PrevectorJob>, PrevectorJob>const __alloc_traits<allocator<PrevectorJob>, PrevectorJob> &remove_reference<vector<PrevectorJob, allocator<PrevectorJob>> &>remove_reference<vector<PrevectorJob, allocator<PrevectorJob>> &> &remove_reference<vector<PrevectorJob, allocator<PrevectorJob>> &> &&const remove_reference<vector<PrevectorJob, allocator<PrevectorJob>> &>const remove_reference<vector<PrevectorJob, allocator<PrevectorJob>> &> &allocator<PrevectorJob> *allocator<vector<PrevectorJob, allocator<PrevectorJob>>> *const new_allocator<vector<PrevectorJob, allocator<PrevectorJob>>> *new_allocator<vector<PrevectorJob, allocator<PrevectorJob>>> *const new_allocator<PrevectorJob> *new_allocator<PrevectorJob> *Loopcondition_variable &condfOkstart_itconst __normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>const __normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> &__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> &fMastervector<thread, allocator<thread>> *_Vector_base<thread, allocator<thread>> *allocator<thread> &PrevectorJob *constPrevectorJob *const &PrevectorJob *&const PrevectorJob *constconst PrevectorJob *const &_Tuple_impl<0UL, lambda [] type at line 123625, col. 43> *is_nothrow_move_constructible<lambda [] type at line 123625, col. 43>is_nothrow_move_constructible<lambda [] type at line 123625, col. 43> &is_nothrow_move_constructible<lambda [] type at line 123625, col. 43> &&const is_nothrow_move_constructible<lambda [] type at line 123625, col. 43>const is_nothrow_move_constructible<lambda [] type at line 123625, col. 43> &is_nothrow_constructible<PrevectorJob, FastRandomContext &>is_nothrow_constructible<PrevectorJob, FastRandomContext &> &is_nothrow_constructible<PrevectorJob, FastRandomContext &> &&const is_nothrow_constructible<PrevectorJob, FastRandomContext &>const is_nothrow_constructible<PrevectorJob, FastRandomContext &> &is_constructible<PrevectorJob, PrevectorJob &&>is_constructible<PrevectorJob, PrevectorJob &&> &is_constructible<PrevectorJob, PrevectorJob &&> &&const is_constructible<PrevectorJob, PrevectorJob &&>const is_constructible<PrevectorJob, PrevectorJob &&> &__is_move_constructible_impl<PrevectorJob, true>__is_move_constructible_impl<PrevectorJob, true> &__is_move_constructible_impl<PrevectorJob, true> &&const __is_move_constructible_impl<PrevectorJob, true>const __is_move_constructible_impl<PrevectorJob, true> &is_move_constructible<PrevectorJob>is_move_constructible<PrevectorJob> &is_move_constructible<PrevectorJob> &&const is_move_constructible<PrevectorJob>const is_move_constructible<PrevectorJob> &__is_move_insertable<allocator<PrevectorJob>>__is_move_insertable<allocator<PrevectorJob>> &__is_move_insertable<allocator<PrevectorJob>> &&const __is_move_insertable<allocator<PrevectorJob>>const __is_move_insertable<allocator<PrevectorJob>> &move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> &move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> &&const move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>const move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> &move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> *rebind<PrevectorJob>rebind<PrevectorJob> &rebind<PrevectorJob> &&const rebind<PrevectorJob>const rebind<PrevectorJob> &iterator_traits<vector<PrevectorJob, allocator<PrevectorJob>> *>iterator_traits<vector<PrevectorJob, allocator<PrevectorJob>> *> &iterator_traits<vector<PrevectorJob, allocator<PrevectorJob>> *> &&const iterator_traits<vector<PrevectorJob, allocator<PrevectorJob>> *>const iterator_traits<vector<PrevectorJob, allocator<PrevectorJob>> *> &__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> &&__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> *reverse_iterator<__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>reverse_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>__normal_iterator<const vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>>reverse_iterator<__normal_iterator<const vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>>>reverse_iterator<__normal_iterator<vector<PrevectorJob, allocator<PrevectorJob>> *, vector<vector<PrevectorJob, allocator<PrevectorJob>>, allocator<vector<PrevectorJob, allocator<PrevectorJob>>>>>>_TC2<void>_TC2<void> &_TC2<void> &&const _TC2<void>const _TC2<void> &__invoke_result<lambda [] type at line 123625, col. 43>__invoke_result<lambda [] type at line 123625, col. 43> &__invoke_result<lambda [] type at line 123625, col. 43> &&const __invoke_result<lambda [] type at line 123625, col. 43>const __invoke_result<lambda [] type at line 123625, col. 43> &_Head_base<0UL, lambda [] type at line 123625, col. 43, false>_Head_base<0UL, lambda [] type at line 123625, col. 43, false> &const _Head_base<0UL, lambda [] type at line 123625, col. 43, false>const _Head_base<0UL, lambda [] type at line 123625, col. 43, false> &remove_reference<lambda [] type at line 123625, col. 43>remove_reference<lambda [] type at line 123625, col. 43> &remove_reference<lambda [] type at line 123625, col. 43> &&const remove_reference<lambda [] type at line 123625, col. 43>const remove_reference<lambda [] type at line 123625, col. 43> &remove_reference<_Invoker<tuple<lambda [] type at line 123625, col. 43>>>remove_reference<_Invoker<tuple<lambda [] type at line 123625, col. 43>>> &remove_reference<_Invoker<tuple<lambda [] type at line 123625, col. 43>>> &&const remove_reference<_Invoker<tuple<lambda [] type at line 123625, col. 43>>>const remove_reference<_Invoker<tuple<lambda [] type at line 123625, col. 43>>> &rebind<vector<PrevectorJob, allocator<PrevectorJob>>>rebind<vector<PrevectorJob, allocator<PrevectorJob>>> &rebind<vector<PrevectorJob, allocator<PrevectorJob>>> &&const rebind<vector<PrevectorJob, allocator<PrevectorJob>>>const rebind<vector<PrevectorJob, allocator<PrevectorJob>>> &iterator_traits<PrevectorJob *>iterator_traits<PrevectorJob *> &iterator_traits<PrevectorJob *> &&const iterator_traits<PrevectorJob *>const iterator_traits<PrevectorJob *> &remove_reference<PrevectorJob &>remove_reference<PrevectorJob &> &remove_reference<PrevectorJob &> &&const remove_reference<PrevectorJob &>const remove_reference<PrevectorJob &> &__tuple_element_t<0UL, tuple<lambda [] type at line 123625, col. 43>> &&__tuple_element_t<0UL, tuple<lambda [] type at line 123625, col. 43>> &const __normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> *PrevectorJob *&&const allocator<vector<PrevectorJob, allocator<PrevectorJob>>>const allocator<vector<PrevectorJob, allocator<PrevectorJob>>> &const vector<thread, allocator<thread>> *thread *constthread *const &thread *&is_nothrow_constructible<thread, lambda [] type at line 123625, col. 43>is_nothrow_constructible<thread, lambda [] type at line 123625, col. 43> &is_nothrow_constructible<thread, lambda [] type at line 123625, col. 43> &&const is_nothrow_constructible<thread, lambda [] type at line 123625, col. 43>const is_nothrow_constructible<thread, lambda [] type at line 123625, col. 43> &is_assignable<PrevectorJob &, const PrevectorJob &>is_assignable<PrevectorJob &, const PrevectorJob &> &is_assignable<PrevectorJob &, const PrevectorJob &> &&const is_assignable<PrevectorJob &, const PrevectorJob &>const is_assignable<PrevectorJob &, const PrevectorJob &> &__and_<is_same<vector<PrevectorJob, allocator<PrevectorJob>> *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<const PrevectorJob *>iterator_traits<const PrevectorJob *> &iterator_traits<const PrevectorJob *> &&const iterator_traits<const PrevectorJob *>const iterator_traits<const PrevectorJob *> &_TC<value, lambda [] type at line 123625, col. 43>_TC<<expression>, lambda [] type at line 123625, col. 43>__and_<is_same<PrevectorJob *, _Ptr>, __not_<is_pointer<_Ptr>>>__is_referenceable<PrevectorJob>__is_referenceable<PrevectorJob> &__is_referenceable<PrevectorJob> &&const __is_referenceable<PrevectorJob>const __is_referenceable<PrevectorJob> &__is_nothrow_move_constructible_impl<lambda [] type at line 123625, col. 43, true>__is_nothrow_move_constructible_impl<lambda [] type at line 123625, col. 43, true> &__is_nothrow_move_constructible_impl<lambda [] type at line 123625, col. 43, true> &&const __is_nothrow_move_constructible_impl<lambda [] type at line 123625, col. 43, true>const __is_nothrow_move_constructible_impl<lambda [] type at line 123625, col. 43, true> &is_copy_assignable<_ValueType>::value__is_nothrow_invocable<_Callable, _Args...>::value__is_nothrow_invocable<lambda [] type at line 123625, col. 43>__is_nothrow_invocable__is_nothrow_invocable<lambda [] type at line 123625, col. 43> &__is_nothrow_invocable<lambda [] type at line 123625, col. 43> &&const __is_nothrow_invocable<lambda [] type at line 123625, col. 43>const __is_nothrow_invocable<lambda [] type at line 123625, col. 43> &is_nothrow_destructible<PrevectorJob>is_nothrow_destructible<PrevectorJob> &is_nothrow_destructible<PrevectorJob> &&const is_nothrow_destructible<PrevectorJob>const is_nothrow_destructible<PrevectorJob> &is_copy_assignable<vector<PrevectorJob, allocator<PrevectorJob>>>is_copy_assignable<vector<PrevectorJob, allocator<PrevectorJob>>> &is_copy_assignable<vector<PrevectorJob, allocator<PrevectorJob>>> &&const is_copy_assignable<vector<PrevectorJob, allocator<PrevectorJob>>>const is_copy_assignable<vector<PrevectorJob, allocator<PrevectorJob>>> &is_nothrow_default_constructible<allocator<PrevectorJob>>is_nothrow_default_constructible<allocator<PrevectorJob>> &is_nothrow_default_constructible<allocator<PrevectorJob>> &&const is_nothrow_default_constructible<allocator<PrevectorJob>>const is_nothrow_default_constructible<allocator<PrevectorJob>> &__is_referenceable<lambda [] type at line 123625, col. 43>__is_referenceable<lambda [] type at line 123625, col. 43> &__is_referenceable<lambda [] type at line 123625, col. 43> &&const __is_referenceable<lambda [] type at line 123625, col. 43>const __is_referenceable<lambda [] type at line 123625, col. 43> &is_nothrow_constructible<lambda [] type at line 123625, col. 43, lambda [] type at line 123625, col. 43 &&>is_nothrow_constructible<lambda [] type at line 123625, col. 43, lambda [] type at line 123625, col. 43 &&> &is_nothrow_constructible<lambda [] type at line 123625, col. 43, lambda [] type at line 123625, col. 43 &&> &&const is_nothrow_constructible<lambda [] type at line 123625, col. 43, lambda [] type at line 123625, col. 43 &&>const is_nothrow_constructible<lambda [] type at line 123625, col. 43, lambda [] type at line 123625, col. 43 &&> &iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> &iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> &&const iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>const iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> &is_same<PrevectorJob *, _Ptr>is_same<tuple<lambda [] type at line 123625, col. 43>, tuple<_UElements...>>__result_of_impl<false, false, lambda [] type at line 123625, col. 43>__result_of_impl<false, false, lambda [] type at line 123625, col. 43> &__result_of_impl<false, false, lambda [] type at line 123625, col. 43> &&const __result_of_impl<false, false, lambda [] type at line 123625, col. 43>const __result_of_impl<false, false, lambda [] type at line 123625, col. 43> &__is_empty_non_tuple<lambda [] type at line 123625, col. 43>__is_empty_non_tuple<lambda [] type at line 123625, col. 43> &__is_empty_non_tuple<lambda [] type at line 123625, col. 43> &&const __is_empty_non_tuple<lambda [] type at line 123625, col. 43>const __is_empty_non_tuple<lambda [] type at line 123625, col. 43> &is_same<vector<PrevectorJob, allocator<PrevectorJob>> *, _Ptr>remove_reference<tuple<lambda [] type at line 123625, col. 43> &>remove_reference<tuple<lambda [] type at line 123625, col. 43> &> &remove_reference<tuple<lambda [] type at line 123625, col. 43> &> &&const remove_reference<tuple<lambda [] type at line 123625, col. 43> &>const remove_reference<tuple<lambda [] type at line 123625, col. 43> &> &__iterator_traits<__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void>__iterator_traits<__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void> &__iterator_traits<__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void> &&const __iterator_traits<__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void>const __iterator_traits<__normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void> &const __normal_iterator<const PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>> *tuple_element<0UL, tuple<lambda [] type at line 123625, col. 43>>tuple_element<0UL, tuple<lambda [] type at line 123625, col. 43>> &tuple_element<0UL, tuple<lambda [] type at line 123625, col. 43>> &&const tuple_element<0UL, tuple<lambda [] type at line 123625, col. 43>>const tuple_element<0UL, tuple<lambda [] type at line 123625, col. 43>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<lambda [] type at line 123625, col. 43>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<lambda [] type at line 123625, col. 43>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<lambda [] type at line 123625, col. 43>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<lambda [] type at line 123625, col. 43>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<lambda [] type at line 123625, col. 43>> &is_empty<lambda [] type at line 123625, col. 43>is_empty<lambda [] type at line 123625, col. 43> &is_empty<lambda [] type at line 123625, col. 43> &&const is_empty<lambda [] type at line 123625, col. 43>const is_empty<lambda [] type at line 123625, col. 43> &is_member_function_pointer<lambda [] type at line 123625, col. 43>is_member_function_pointer<lambda [] type at line 123625, col. 43> &is_member_function_pointer<lambda [] type at line 123625, col. 43> &&const is_member_function_pointer<lambda [] type at line 123625, col. 43>const is_member_function_pointer<lambda [] type at line 123625, col. 43> &is_member_object_pointer<lambda [] type at line 123625, col. 43>is_member_object_pointer<lambda [] type at line 123625, col. 43> &is_member_object_pointer<lambda [] type at line 123625, col. 43> &&const is_member_object_pointer<lambda [] type at line 123625, col. 43>const is_member_object_pointer<lambda [] type at line 123625, col. 43> &conditional<true, PrevectorJob &&, PrevectorJob &>conditional<true, PrevectorJob &&, PrevectorJob &> &conditional<true, PrevectorJob &&, PrevectorJob &> &&const conditional<true, PrevectorJob &&, PrevectorJob &>const conditional<true, PrevectorJob &&, PrevectorJob &> &__iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void>__iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void> &__iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void> &&const __iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void>const __iterator_traits<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>, void> &__iterator_traits<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>, void>__iterator_traits<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>, void> &__iterator_traits<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>, void> &&const __iterator_traits<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>, void>const __iterator_traits<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>, void> &__is_copy_assignable_impl<vector<PrevectorJob, allocator<PrevectorJob>>, true>__is_copy_assignable_impl<vector<PrevectorJob, allocator<PrevectorJob>>, true> &__is_copy_assignable_impl<vector<PrevectorJob, allocator<PrevectorJob>>, true> &&const __is_copy_assignable_impl<vector<PrevectorJob, allocator<PrevectorJob>>, true>const __is_copy_assignable_impl<vector<PrevectorJob, allocator<PrevectorJob>>, true> &remove_reference<lambda [] type at line 123625, col. 43 &&>remove_reference<lambda [] type at line 123625, col. 43 &&> &remove_reference<lambda [] type at line 123625, col. 43 &&> &&const remove_reference<lambda [] type at line 123625, col. 43 &&>const remove_reference<lambda [] type at line 123625, col. 43 &&> &move_iterator<PrevectorJob *>move_iterator<PrevectorJob *> &move_iterator<PrevectorJob *> &&const move_iterator<PrevectorJob *>const move_iterator<PrevectorJob *> &move_iterator<PrevectorJob *> *__is_referenceable<vector<PrevectorJob, allocator<PrevectorJob>>>__is_referenceable<vector<PrevectorJob, allocator<PrevectorJob>>> &__is_referenceable<vector<PrevectorJob, allocator<PrevectorJob>>> &&const __is_referenceable<vector<PrevectorJob, allocator<PrevectorJob>>>const __is_referenceable<vector<PrevectorJob, allocator<PrevectorJob>>> &is_assignable<vector<PrevectorJob, allocator<PrevectorJob>> &, const vector<PrevectorJob, allocator<PrevectorJob>> &>is_assignable<vector<PrevectorJob, allocator<PrevectorJob>> &, const vector<PrevectorJob, allocator<PrevectorJob>> &> &is_assignable<vector<PrevectorJob, allocator<PrevectorJob>> &, const vector<PrevectorJob, allocator<PrevectorJob>> &> &&const is_assignable<vector<PrevectorJob, allocator<PrevectorJob>> &, const vector<PrevectorJob, allocator<PrevectorJob>> &>const is_assignable<vector<PrevectorJob, allocator<PrevectorJob>> &, const vector<PrevectorJob, allocator<PrevectorJob>> &> &is_reference<PrevectorJob &>is_referenceis_reference<PrevectorJob &> &is_reference<PrevectorJob &> &&const is_reference<PrevectorJob &>const is_reference<PrevectorJob &> &remove_reference<const PrevectorJob &>remove_reference<const PrevectorJob &> &remove_reference<const PrevectorJob &> &&const remove_reference<const PrevectorJob &>const remove_reference<const PrevectorJob &> &__is_trivially_copyable(_ValueTypeI)__is_pointer<_II>::__value__is_trivially_copyable(_ValueTypeI)
			     && __is_pointer<_II>::__value__is_pointer<_OI>::__value__is_trivially_copyable(_ValueTypeI)
			     && __is_pointer<_II>::__value
			     && __is_pointer<_OI>::__value__are_same<_ValueTypeI, _ValueTypeO>::__value__is_trivially_copyable(_ValueTypeI)
			     && __is_pointer<_II>::__value
			     && __is_pointer<_OI>::__value
			     && __are_same<_ValueTypeI, _ValueTypeO>::__value(__is_trivially_copyable(_ValueTypeI)
			     && __is_pointer<_II>::__value
			     && __is_pointer<_OI>::__value
			     && __are_same<_ValueTypeI, _ValueTypeO>::__value)const move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>> *__is_move_iterator<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>>__is_move_iterator<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>> &__is_move_iterator<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>> &&const __is_move_iterator<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>>const __is_move_iterator<move_iterator<__normal_iterator<PrevectorJob *, vector<PrevectorJob, allocator<PrevectorJob>>>>> &__are_same<PrevectorJob, PrevectorJob>__are_same<PrevectorJob, PrevectorJob> &__are_same<PrevectorJob, PrevectorJob> &&const __are_same<PrevectorJob, PrevectorJob>const __are_same<PrevectorJob, PrevectorJob> &__is_pointer<PrevectorJob *>__is_pointer<PrevectorJob *> &__is_pointer<PrevectorJob *> &&const __is_pointer<PrevectorJob *>const __is_pointer<PrevectorJob *> &is_nothrow_copy_constructible<PrevectorJob *>is_nothrow_copy_constructible<PrevectorJob *> &is_nothrow_copy_constructible<PrevectorJob *> &&const is_nothrow_copy_constructible<PrevectorJob *>const is_nothrow_copy_constructible<PrevectorJob *> &is_assignable<PrevectorJob &, PrevectorJob &&>is_assignable<PrevectorJob &, PrevectorJob &&> &is_assignable<PrevectorJob &, PrevectorJob &&> &&const is_assignable<PrevectorJob &, PrevectorJob &&>const is_assignable<PrevectorJob &, PrevectorJob &&> &__is_trivially_copyable(_ValueType1)__is_pointer<_BI1>::__value__is_trivially_copyable(_ValueType1)
			     && __is_pointer<_BI1>::__value__is_pointer<_BI2>::__value__is_trivially_copyable(_ValueType1)
			     && __is_pointer<_BI1>::__value
			     && __is_pointer<_BI2>::__value__is_trivially_copyable(_ValueType1)
			     && __is_pointer<_BI1>::__value
			     && __is_pointer<_BI2>::__value
			     && __are_same<_ValueType1, _ValueType2>::__value(__is_trivially_copyable(_ValueType1)
			     && __is_pointer<_BI1>::__value
			     && __is_pointer<_BI2>::__value
			     && __are_same<_ValueType1, _ValueType2>::__value)__is_nothrow_copy_constructible_impl<PrevectorJob *, true>__is_nothrow_copy_constructible_impl<PrevectorJob *, true> &__is_nothrow_copy_constructible_impl<PrevectorJob *, true> &&const __is_nothrow_copy_constructible_impl<PrevectorJob *, true>const __is_nothrow_copy_constructible_impl<PrevectorJob *, true> &__is_referenceable<PrevectorJob *>__is_referenceable<PrevectorJob *> &__is_referenceable<PrevectorJob *> &&const __is_referenceable<PrevectorJob *>const __is_referenceable<PrevectorJob *> &is_nothrow_constructible<PrevectorJob *, PrevectorJob *const &>is_nothrow_constructible<PrevectorJob *, PrevectorJob *const &> &is_nothrow_constructible<PrevectorJob *, PrevectorJob *const &> &&const is_nothrow_constructible<PrevectorJob *, PrevectorJob *const &>const is_nothrow_constructible<PrevectorJob *, PrevectorJob *const &> &__iterator_traits<move_iterator<PrevectorJob *>, void>__iterator_traits<move_iterator<PrevectorJob *>, void> &__iterator_traits<move_iterator<PrevectorJob *>, void> &&const __iterator_traits<move_iterator<PrevectorJob *>, void>const __iterator_traits<move_iterator<PrevectorJob *>, void> &const move_iterator<PrevectorJob *> *remove_reference<PrevectorJob>remove_reference<PrevectorJob> &remove_reference<PrevectorJob> &&const remove_reference<PrevectorJob>const remove_reference<PrevectorJob> &vector::_M_range_check: __n (which is %zu) >= this->size() (which is %zu)const char[74]char[74]__N("vector::_M_range_check: __n "
				       "(which is %zu) >= this->size() "
				       "(which is %zu)")/home/tanteikg/QCVE/sources/bitcoin/src/interfaces/chain.h<blockfilter.h>MakeChainBlockKey &BlockKey &&const BlockKeyconst BlockKey &BlockKeyChain &const Chainconst Chain &ChainNodeContext *Chain *ChainClient &const ChainClientconst ChainClient &ChainClientsetMockTimestopCScheduler &verifyregisterRpcs~ChainClientChainClient *hasAssumedValidChainrequestMempoolTransactionsNotifications &updateRwSettinggetRwSettinggetSettingsListgetSettingrpcSerializationFlagsrpcRunLaterrpcEnableDeprecatedhandleRpcconst CRPCCommandconst CRPCCommand &CRPCCommand &waitForNotificationsIfTipChangedhandleNotificationsshowProgressinitErrorinitWarninginitMessageshutdownRequestedisInitialBlockDownloadisReadyToBroadcasthavePrunedrelayDustFeerelayIncrementalFeerelayMinFeemempoolMinFeeestimateMaxBlocksestimateSmartFeeFeeCalculation *checkChainLimitsgetPackageLimitsgetTransactionAncestryCAmount *broadcastTransactionhasDescendantsInMempoolisInMempoolisRBFOptInhasBlocksguessVerificationProgressfindCoinsmap<COutPoint, Coin, less<COutPoint>, allocator<pair<const COutPoint, Coin>>> &findCommonAncestorconst FoundBlockconst FoundBlock &FoundBlock &const FoundBlock *FoundBlock *findAncestorByHashfindAncestorByHeightfindFirstBlockWithTimeAndHeightfindBlockFoundBlock &&FoundBlocknextBlocklocatorinActiveChainmtpTimemaxTimeblockFilterMatchesAnyconst ElementSetconst ElementSet &unordered_set<vector<unsigned char, allocator<unsigned char>>, ByteVectorHash, equal_to<vector<unsigned char, allocator<unsigned char>>>, allocator<vector<unsigned char, allocator<unsigned char>>>> &hasBlockFilterIndexfindLocatorForkgetActiveChainLocatorgetTipLocatorhaveBlockOnDiskgetBlockHashgetHeight~Chainconst Notificationsconst Notifications &NotificationsNotifications *chainStateFlushedupdatedBlockTipblockDisconnectedconst BlockInfoconst BlockInfo &BlockInfo &blockConnectedBlockInfoBlockInfo &&BlockInfo *const CBlockUndoconst CBlockUndo *CBlockUndo *transactionRemovedFromMempooltransactionAddedToMempool~NotificationsCSchedulerCRPCCommandRBFTransactionStateMemPoolRemovalReasonfoundm_next_blockm_locatorm_in_active_chainm_mtp_timem_max_timem_timem_heightundo_datadata_posfile_numberprev_hashBITCOIN_INTERFACES_CHAIN_HinterfacesWalletHandlerNodeContextFeeCalculationCoinCBlockUndo// BITCOIN_INTERFACES_CHAIN_H// namespace interfaces//! Return implementation of Chain interface.//! Set mock time.//! Shut down client.//! Save state to disk.//! Start client execution and provide a scheduler.//! Load saved state.//! Check for errors before loading.//! Register rpcs.//! monitoring and analysis in the future).//! Interface to let node manage chain clients (wallets, or maybe tools for//! accessible across processes.//! Get internal node context. Useful for testing, but not//! Return true if an assumed-valid chain is in use.//! removed transactions and already added new transactions.//! to be prepared to handle this by ignoring notifications about unknown//! synchronous notifications from requestMempoolTransactions. Clients need//! notifications from handleNotifications can arrive during and after//! notifications sent by handleNotifications, so out of date async//! the last one is sent. These notifications aren't coordinated with async//! current mempool transactions to the specified handler and return after//! Synchronously send transactionAddedToMempool notifications about all//! setting in memory and do not write the file.//! Write a setting to <datadir>/settings.json. Optionally just update the//! Return <datadir>/settings.json setting value.//! Get list of settings values.//! Get settings value.//! Current RPC serialization flags.//! Run function after given number of seconds. Cancel any previous calls with same name.//! Check if deprecated RPC is enabled.//! needs to remain valid until Handler is disconnected.//! Register handler for RPC. Command is not copied, so reference//! chain tip.//! Wait for pending notifications to be processed unless block hash points to the current//! Register handler for notifications.//! Chain notifications.//! Send progress indicator.//! Send init error.//! Send init warning.//! Send init message.//! Check if shutdown requested.//! Check if in IBD.//! Check if the node is ready to broadcast transactions.//! Check if any block has been pruned.//! Relay dust fee setting (-dustrelayfee), reflecting lowest rate it's economical to spend.//! Relay incremental fee setting (-incrementalrelayfee), reflecting cost of relay.//! Relay current minimum fee (from -minrelaytxfee and -incrementalrelayfee settings).//! Mempool minimum fee.//! Fee estimator max target.//! Estimate smart fee.//! Check if transaction will pass the mempool's chain limits.//! return more policy settings.//! Currently only returns the ancestor and descendant count limits, but could be enhanced to//! Get the node's package limits.//! Calculate mempool ancestor and descendant counts for the given transaction.//! Return false if the transaction could not be added due to the fee or for another reason.//! amount specified by max_tx_fee, and broadcast to all peers if relay is set to true.//! Transaction is added to memory pool, if the transaction fee is below the//! Check if transaction has descendants in mempool.//! Check if transaction is in mempool.//! Check if transaction is RBF opt in.//! the height range from min_height to max_height, inclusive.//! of blocks. This checks all blocks that are ancestors of block_hash in//! Return true if data is available for all blocks in the specified range//! the specified block hash are verified.//! Estimate fraction of total transactions verified if blocks up to//! populates the values.//! the current chain UTXO set. Iterates through all the keys in the map and//! Look up unspent output information. Returns coins in the mempool and in//! return block information.//! Find most recent common ancestor between two blocks and optionally//! optionally return ancestor information.//! Return whether block descends from a specified ancestor, and//! ancestor information.//! Find ancestor of block at specified height and optionally return//! information.//! with a high enough timestamp and height. Optionally return block//! and height >= than the given height, return false if there is no block//! Find first block in the chain with timestamp >= the given time//! or contents.//! Return whether node has the block and optionally return block metadata//! or std::nullopt if the block filter for this block couldn't be found.//! Returns whether any of the elements match the block via a BIP 157 block filter//! Returns whether a block filter index is available.//! or one of its ancestors.//! which will either be the original block used to create the locator,//! Return height of the highest block on chain in common with the locator,//! If specified block is not in the active chain, return locator for the latest ancestor that is in the chain.//! Return a locator that refers to a block in the active chain.//! Get locator for the current chain tip.//! pruned), and contains transactions.//! Check that the block is available on disk (i.e. has not been//! Get block hash. Height must be valid or this function will abort.//! any blocks)//! chain only contains genesis block, nullopt if chain does not contain//! Get current chain height, not including genesis block (returns 0 if//!   node (https://github.com/bitcoin/bitcoin/issues/11756)//!   logic moves out of the wallet, and the wallet just requests scans from the//! * `guessVerificationProgress` and similar methods can go away if rescan//!   should be the consumer.//!   wallet cache it, fee estimation being driven by node mempool, wallet//! * Move fee estimation queries to an asynchronous interface and let the//!   ports instead of registering to handle requests on the node HTTP port.//!   methods can go away if wallets listen for HTTP requests on their own//! * The handleRpc, registerRpcs, rpcEnableDeprecated methods and other RPC//!   (https://github.com/bitcoin/bitcoin/pull/15288#discussion_r253321096).//!   communicate with each other without going through the node//!   notifications to the GUI should go away when GUI and wallet can directly//! * The initMessages() and showProgress() methods which the wallet uses to send//! Chain methods should be cleaned up and simplified over time. Examples://! internal workings of the bitcoin node, and not being very convenient to use.//! TODO: Current chain methods are too low level, exposing too much of the//! estimate fees, and submit transactions.//! the future) ability to access to the chain state, receive notifications,//! Interface giving clients (wallet processes, maybe other analysis tools in//! Block data sent with blockConnected, blockDisconnected notifications.//! (for example due to pruning), the CBlock variable will be set to null.//! Read block data from disk. If the block exists but doesn't have data//! Return next block in the active chain if current block is in the active chain.//! Return locator if block is in the active chain.//! Return whether block is in the active (most-work) chain.//! is not found, output variables will keep their previous values.//! found, data will be returned by setting specified output variables. If block//! Helper for findBlock to selectively return pieces of block data. If block is//! Hash/height pair to help track and identify blocks.// For util::SettingsValue// For CTransactionRef/home/tanteikg/QCVE/sources/bitcoin/src/interfacesnext_blockin_active_chainmtp_timemax_timeschedulernotificationssecondsmethodold_tipprogressconservativecalclimit_ancestor_countlimit_descendant_counttxidancestorsdescendantsancestorsizeancestorfeesmax_tx_feerelayerr_stringblock_hashmin_heightmax_heightblock_hash1block_hash2ancestor_outblock1_outblock2_outancestor_hashancestor_heightfilter_typefilter_set<kernel/context.h>~NodeContextconst lambda [] type at line 151129, col. 52const lambda [] type at line 151129, col. 52 &lambda [] type at line 151129, col. 52 &lambda [] type at line 151129, col. 52 &&operator void (*)()const lambda [] type at line 151129, col. 52 *lambda [] type at line 151129, col. 52 *PeerManagerCTxMemPoolCConnmanInitlambda [] type at line 151129, col. 52rpc_interruption_pointWalletLoader *wallet_loaderchain_clientschainbanmanpeermanfee_estimatorconnmanInit *kernelBITCOIN_NODE_CONTEXT_HWalletLoaderCBlockPolicyEstimator// BITCOIN_NODE_CONTEXT_H//! definitions for all the unique_ptr members.//! instantiating the NodeContext struct doesn't need to #include class//! Declare default constructor and destructor that are not inline, so code//! opened by the gui.//! Reference to chain client that should used to load or create wallets//! List of all chain clients (wallet processes or other client) connected to node.// Currently a raw pointer because the memory is not managed by this struct//! Init interface for initializing current process and connecting to other processes.//! libbitcoin_kernel context//! be used without pulling in unwanted dependencies or functionality.//! any member functions. It should just be a collection of references that can//! and make code more modular and testable. The struct isn't intended to have//! references to validation objects) to eliminate use of globals//! to use globals. More variables could be added to this struct (particularly//! without needing to declare the same variables and parameters repeatedly, or//! This is used by init, rpc, and test code to pass object references around//! state.//! NodeContext struct containing references to chain state and connectionCFeeRate &&const FeeEstimateModeconst FeeEstimateMode &FeeEstimateMode &FeeEstimateMode::BTC_KVBCFeeRate *GetFeePerKconst CFeeRate *GetFeeconst ICFeeRate should be used without floatsFeeEstimateModeUNSETECONOMICALCONSERVATIVEBTC_KVBSAT_VBnSatoshisPerKCURRENCY_ATOMsat"sat"CURRENCY_UNITBTC"BTC"BITCOIN_POLICY_FEERATE_Hobj.nSatoshisPerK// BITCOIN_POLICY_FEERATE_H/**
     * Return the fee in satoshis for a vsize of 1000 vbytes
     *//**
     * Return the fee in satoshis for the given vsize in vbytes.
     * If the calculated fee would have fractional satoshis, then the
     * returned fee will always be rounded up to the nearest satoshi.
     *//**
     * Construct a fee rate from a fee in satoshis and a vsize in vB.
     *
     * param@[in]   nFeePaid    The fee paid by a transaction, in satoshis
     * param@[in]   num_bytes   The vsize of a transaction, in vbytes
     */// We've previously had bugs creep in from silent double->int conversion.../** Fee rate of 0 satoshis per kvB *//** Fee rate in sat/kvB (satoshis per 1000 virtualbytes) *//**
 * Fee rate in satoshis per kilovirtualbyte: CAmount / kvB
 *///!< Use sat/vB fee rate unit//!< Use BTC/kvB fee rate unit//!< Force estimateSmartFee to use conservative estimates//!< Force estimateSmartFee to use non-conservative estimates//!< Use default settings based on other criteria/* Used to determine type of fee estimation requested */// One indivisible minimum value unit// One formatted unit/home/tanteikg/QCVE/sources/bitcoin/src/policy_nSatoshisPerKfee_estimate_modenFeePaid<variant>ErrorStringconst Result<T>const Result<T> &Result<T> &const Result<FT>const Result<FT> &Result<FT> &FTResult<T> *const Result<T> *U &&has_value()./util/result.hError &Error &&const Errorconst Error &~ErrorError *Result<T>m_variantBITCOIN_UTIL_RESULT_H// BITCOIN_UTIL_RESULT_H//! return Result<T> with minimal changes to existing code, and vice versa.//! std::optional methods, so functions returning optional<T> can change to//! util::Error{error_string};`.//! error strings usually just replacing `return std::nullopt;` with `return//! `std::optional<T>` can be updated to return `util::Result<T>` and return//! returning `std::optional<T>` values. Existing functions returning//! general code returning `util::Result<T>` values is very similar to code//! Usage examples can be found in \example ../test/result_tests.cpp, but in//! and enum types to return function results.//! classes like std::optional, std::variant, and std::tuple, or custom structs//! only need error-handling should avoid util::Result and instead use standard//! end users. Lower-level functions that don't need this error-reporting and//! It is intended for high-level functions that need to report error strings to//! either error messages or result values.//! The util::Result class provides a standard way for functions to return// file COPYING or https://www.opensource.org/licenses/mit-license.php.// Copyright (c) 2022 The Bitcoin Core developers/home/tanteikg/QCVE/sources/bitcoin/src/policy/fees.h<policy/feerate.h>StringForFeeEstimateHorizonFeeFilterRounder &const FeeFilterRounderconst FeeFilterRounder &~FeeFilterRounderFeeFilterRounderCBlockPolicyEstimator &const CBlockPolicyEstimatorconst CBlockPolicyEstimator &_removeTxMaxUsableEstimateHistoricalBlockSpanBlockSpanestimateConservativeFeeEstimationResult *estimateCombinedFeeprocessBlockTxHighestTargetTrackedFlushUnconfirmedestimateRawFeeestimateFeeremoveTxprocessTransactionconst CTxMemPoolEntry &processBlockvector<const CTxMemPoolEntry *, allocator<const CTxMemPoolEntry *>> &~CBlockPolicyEstimatorTxStatsInfo &TxStatsInfo &&const TxStatsInfoconst TxStatsInfo &TxStatsInfoTxStatsInfo *FeeCalculation &FeeCalculation &&const FeeCalculationconst FeeCalculation &EstimationResult &EstimationResult &&const EstimationResultconst EstimationResult &EstimationResultEstimatorBucket &EstimatorBucket &&const EstimatorBucketconst EstimatorBucket &EstimatorBucketFeeEstimateHorizonSHORT_HALFLIFEMED_HALFLIFELONG_HALFLIFECTxMemPoolEntryTxConfirmStatsFeeReasonHALF_ESTIMATEFULL_ESTIMATEDOUBLE_ESTIMATEMEMPOOL_MINPAYTXFEEFALLBACKREQUIREDm_insecure_rand_mutexconst set<double, less<double>, allocator<double>>m_fee_setbucketMapbucketsuntrackedTxstrackedTxslongStatsshortStatsfeeStatsmapMemPoolTxsbucketIndexblockHeighthistoricalBesthistoricalFirstfirstRecordedHeightnBestSeenHeightm_cs_fee_estimatorm_estimation_filepathreturnedTargetdesiredTargetFeeReason::NONEestscaledecaypassleftMempoolinMempooltotalConfirmedwithinTargetconst array<FeeEstimateHorizon, 3UL>ALL_FEE_ESTIMATE_HORIZONSFeeEstimateHorizon[3]FeeEstimateHorizon::SHORT_HALFLIFEFeeEstimateHorizon::MED_HALFLIFEFeeEstimateHorizon::LONG_HALFLIFEFEE_FILTER_SPACING1.1000000000000000891.1MAX_FILTER_FEERATE10000000.01e7FEE_SPACING1.0500000000000000441.05MAX_BUCKET_FEERATEMIN_BUCKET_FEERATESUFFICIENT_TXS_SHORTSUFFICIENT_FEETXS0.1000000000000000056DOUBLE_SUCCESS_PCT0.9499999999999999556.95SUCCESS_PCT0.8499999999999999778.85HALF_SUCCESS_PCT0.5999999999999999778.6LONG_DECAY0.9993100000000000316.99931MED_DECAY0.9951999999999999735.9952SHORT_DECAY0.9619999999999999662.962OLDEST_ESTIMATE_HISTORY60486 * 1008LONG_SCALELONG_BLOCK_PERIODSMED_SCALEMED_BLOCK_PERIODSSHORT_SCALESHORT_BLOCK_PERIODSBITCOIN_POLICY_FEES_H!m_insecure_rand_mutex!m_cs_fee_estimator// BITCOIN_POLICY_FEES_H/** Quantize a minimum fee for privacy purpose before broadcast. *//** Create new FeeFilterRounder *//** FEE_FILTER_SPACING is just used to provide some quantization of fee
     * filter results.  Historically it reused FEE_SPACING, but it is completely
     * unrelated, and was made a separate constant so the two concepts are not
     * tied together *//** A non-thread-safe helper for the removeTx function *//** Calculation of highest target that reasonable estimate can be provided for *//** Number of blocks of recorded fee estimate data represented in saved data file *//** Number of blocks of data recorded while fee estimates have been running *//** Helper for estimateSmartFee *//** Process a transaction confirmed in a block*/// Map of bucket upper-bound to index into all vectors by bucket// The upper-bound of the range for the bucket (inclusive)/** Classes to track historical data on transaction confirmations */// map of txids to information about that transaction/** Drop still unconfirmed transactions and record current estimations, if the fee estimation file is present. *//** Calculation of highest target that estimates are tracked for *//** Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool *//** Read estimation data from a file *//** Write estimation data to a file *//** Return a specific fee estimate calculation with a given success
     * threshold and time horizon, and optionally return detailed data about
     * calculation
     *//** Estimate feerate needed to get be included in a block within confTarget
     *  blocks. If no answer can be given at confTarget, return an estimate at
     *  the closest target where one can be given.  'conservative' estimates are
     *  valid over longer time horizons also.
     *//** DEPRECATED. Return a feerate estimate *//** Remove a transaction from the mempool tracking stats*//** Process a transaction accepted to the mempool*//** Process all the transactions that have been included in a block *//** Create new BlockPolicyEstimator and initialize stats tracking classes with default values *//** Spacing of FeeRate buckets
     * We have to lump transactions into buckets based on feerate, but we want to be able
     * to give accurate estimates over a large range of potential feerates
     * Therefore it makes sense to exponentially space the buckets
     *//** Minimum and Maximum values for tracking feerates
     * The MIN_BUCKET_FEERATE should just be set to the lowest reasonable feerate we
     * might ever want to track.  Historically this has been 1000 since it was
     * inheriting DEFAULT_MIN_RELAY_TX_FEE and changing it is disruptive as it
     * invalidates old estimates files. So leave it at 1000 unless it becomes
     * necessary to lower it, and then lower it substantially.
     *//** Require an avg of 0.5 tx when using short decay since there are fewer blocks considered*//** Require an avg of 0.1 tx in the combined feerate bucket per block to have stat significance *//** Require greater than 95% of X feerate transactions to be confirmed within 2 * Y blocks*//** Require greater than 85% of X feerate transactions to be confirmed within Y blocks*//** Require greater than 60% of X feerate transactions to be confirmed within Y/2 blocks*//** Decay of .99931 is a half-life of 1008 blocks or about 1 week *//** Decay of .9952 is a half-life of 144 blocks or about 1 day *//** Decay of .962 is a half-life of 18 blocks or about 3 hours *//** Historical estimates that are older than this aren't valid *//** Track confirm delays up to 1008 blocks for long horizon *//** Track confirm delays up to 48 blocks for medium horizon *//** Track confirm delays up to 12 blocks for short horizon *//** \class CBlockPolicyEstimator
 * The BlockPolicyEstimator is used for estimating the feerate needed
 * for a transaction to be included in a block within a certain number of
 * blocks.
 *
 * At a high level the algorithm works by grouping transactions into buckets
 * based on having similar feerates and then tracking how long it
 * takes transactions in the various buckets to be mined.  It operates under
 * the assumption that in general transactions of higher feerate will be
 * included in blocks before transactions of lower feerate.   So for
 * example if you wanted to know what feerate you should put on a transaction to
 * be included in a block within the next 5 blocks, you would start by looking
 * at the bucket with the highest feerate transactions and verifying that a
 * sufficiently high percentage of them were confirmed within 5 blocks and
 * then you would look at the next highest feerate bucket, and so on, stopping at
 * the last bucket to pass the test.   The average feerate of transactions in this
 * bucket will give you an indication of the lowest feerate you can put on a
 * transaction and still have a sufficiently high chance of being confirmed
 * within your desired 5 blocks.
 *
 * Here is a brief description of the implementation:
 * When a transaction enters the mempool, we track the height of the block chain
 * at entry.  All further calculations are conducted only on this set of "seen"
 * transactions. Whenever a block comes in, we count the number of transactions
 * in each bucket and the total amount of feerate paid in each bucket. Then we
 * calculate how many blocks Y it took each transaction to be mined.  We convert
 * from a number of blocks to a number of periods Y' each encompassing "scale"
 * blocks.  This is tracked in 3 different data sets each up to a maximum
 * number of periods. Within each data set we have an array of counters in each
 * feerate bucket and we increment all the counters from Y' up to max periods
 * representing that a tx was successfully confirmed in less than or equal to
 * that many periods. We want to save a history of this information, so at any
 * time we have a counter of the total number of transactions that happened in a
 * given feerate bucket and the total number that were confirmed in each of the
 * periods or less for any bucket.  We save this history by keeping an
 * exponentially decaying moving average of each one of these stats.  This is
 * done for a different decay in each of the 3 data sets to keep relevant data
 * from different time horizons.  Furthermore we also keep track of the number
 * unmined (in mempool or left mempool without being included in a block)
 * transactions in each bucket and for how many blocks they have been
 * outstanding and use both of these numbers to increase the number of transactions
 * we've seen in that feerate bucket when calculating an estimate for any number
 * of confirmations below the number of blocks they've been outstanding.
 *
 *  We want to be able to estimate feerates that are needed on tx's to be included in
 * a certain number of blocks.  Every time a block is added to the best chain, this class records
 * stats on the transactions included in that block
 *//* Used to return detailed information about a fee estimate calculation *//* Used to return detailed information about a feerate bucket *//* Enumeration of reason for returned fee estimate *//* Identifier for each of the 3 different TxConfirmStats which will track
 * history over different time horizons. */currentMinFeemin_incremental_feedoubleTargetconfTargetsuccessThresholdcheckShorterHorizonnBlockHeighthorizonfeeCalcvalidFeeEstimateentriesestimation_filepath/home/tanteikg/QCVE/sources/bitcoin/src/interfaces/wallet.h<util/ui_change_type.h><util/result.h><util/message.h><support/allocators/secure.h><interfaces/chain.h>MakeWalletLoaderMakeWalletWalletContext &const shared_ptr<CWallet>const shared_ptr<CWallet> &shared_ptr<CWallet> &WalletLoader &WalletLoader &&const WalletLoaderconst WalletLoader &~WalletLoaderWalletContext *handleLoadWalletgetWalletslistWalletDirrestoreWalletvector<bilingual_str, allocator<bilingual_str>> &getWalletDirloadWalletcreateWalletconst SecureStringconst SecureString &basic_string<char, char_traits<char>, secure_allocator<char>> &Wallet &const Walletconst Wallet &CWallet *walletWallet *handleCanGetAddressesChangedhandleWatchOnlyChangedhandleTransactionChangedhandleAddressBookChangedhandleStatusChangedhandleShowProgresshandleUnloadisLegacygetDefaultMaxTxFeegetDefaultAddressTypehasExternalSignertaprootEnabledprivateKeysDisabledcanGetAddresseshdEnabledgetConfirmTargetgetMinimumFeeconst CCoinControlconst CCoinControl &CCoinControl &FeeReason *getRequiredFeegetCoinsconst vector<COutPoint, allocator<COutPoint>>const vector<COutPoint, allocator<COutPoint>> &vector<COutPoint, allocator<COutPoint>> &listCoinsgetCreditgetDebittxoutIsMinetxinIsMinegetAvailableBalancegetBalancetryGetBalancesWalletBalances &getBalancesWalletBalances &&const WalletBalancesconst WalletBalances &WalletBalancesbalanceChangedconst WalletBalances *WalletBalances *fillPSBTPartiallySignedTransaction &getWalletTxDetailsWalletTxStatus &WalletOrderForm &vector<pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &tryGetTxStatusWalletTxStatus &&const WalletTxStatusconst WalletTxStatus &getWalletTxsgetWalletTxWalletTx &WalletTx &&const WalletTxconst WalletTx &~WalletTxWalletTxconst WalletTx *WalletTx *const __shared_ptr<const CTransaction, _S_atomic>const __shared_ptr_access<const CTransaction, _S_atomic, false, false>getTxcommitBumpTransactionsignBumpTransactioncreateBumpTransactionCAmount &transactionCanBeBumpedabandonTransactiontransactionCanBeAbandonedcommitTransactioncreateTransactionconst vector<CRecipient, allocator<CRecipient>>const vector<CRecipient, allocator<CRecipient>> &vector<CRecipient, allocator<CRecipient>> &listLockedCoinsisLockedCoinunlockCoinlockCoindisplayAddresssetAddressReceiveRequestgetAddressReceiveRequestsgetAddressesWalletAddress &WalletAddress &&const WalletAddressconst WalletAddress &~WalletAddressWalletAddressWalletAddress *variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown> &&CTxDestination &AddressPurpose &&AddressPurpose &getAddressstring *isminetype *AddressPurpose *delAddressBooksetAddressBookconst optional<AddressPurpose>const optional<AddressPurpose> &optional<AddressPurpose> &haveWatchOnlyisSpendablesignMessageconst PKHashconst PKHash &PKHash &getPubKeygetNewDestinationconst OutputTypegetWalletNamebackupWalletabortRescanchangeWalletPassphraseisLockedisCryptedencryptWallet~WalletWalletTxOut &WalletTxOut &&const WalletTxOutconst WalletTxOut &~WalletTxOutWalletTxOutWalletTxStatusWalletContextCCoinControlimmature_watch_only_balanceunconfirmed_watch_only_balancewatch_only_balancehave_watch_onlyimmature_balanceunconfirmed_balancebalanceis_in_main_chainis_coinbaseis_abandonedis_trustedlock_timetime_receiveddepth_in_main_chainblocks_to_maturityblock_heightvalue_mapchangedebitcredittxout_address_is_minetxout_addresstxout_is_minetxin_is_minepurposeis_mineis_spenttxoutBITCOIN_INTERFACES_WALLET_HCRecipientCWalletPartiallySignedTransactionCKey// BITCOIN_INTERFACES_WALLET_H//! function will be undefined in builds where ENABLE_WALLET is false.//! Return implementation of ChainClient interface for a wallet loader. This//! dummywallet.cpp and throws if the wallet component is not compiled.//! Return implementation of Wallet interface. This function is defined in//! Wallet transaction output.//! Updated transaction status.// Wallet transaction information.//! Collection of wallet balances.//! Information about one wallet address.//! Return pointer to internal context, useful for testing.//! loaded at startup or by RPC.//! createWallet and loadWallet above, and also triggered when wallets are//! Register handler for load wallet messages. This callback is triggered by//! Return interfaces for accessing wallets (if any).//! Return available wallets in wallet directory.//! Restore backup wallet//! Return default wallet directory.//! Load existing wallet.//! Create new wallet.//! methods (called by the GUI) to load and create wallets.//! starting up, shutting down, and registering RPCs, also has additional//! Wallet chain client that in addition to having chain client methods for//! Return pointer to internal wallet class, useful for testing.//! Register handler for keypool changed messages.//! Register handler for watchonly changed messages.//! Register handler for transaction changed messages.//! Register handler for address book changed messages.//! Register handler for status changed messages.//! Register handler for show progress messages.//! Register handler for unload message.//! Return whether is a legacy wallet// Remove wallet.//! Get max tx fee.// Get default address type.// Return whether wallet uses an external signer.// Return whether the wallet contains a Taproot scriptPubKeyMan// Return whether private keys enabled.// Return whether the wallet is blank.// Return whether HD enabled.//! Get tx confirm target.//! Get minimum fee.//! Get required fee.//! Return wallet transaction output information.//! (put change in one group with wallet address)//! Return AvailableCoins + LockedCoins grouped by wallet address.//! Return credit amount if transaction input belongs to wallet.//! Return debit amount if transaction input belongs to wallet.//! Return whether transaction output belongs to wallet.//! Return whether transaction input belongs to wallet.//! Get available balance.//! Get balance.//! Get balances if possible without blocking.//! Get balances.//! Fill PSBT.//! Get transaction details.//! Try to get updated status for a particular transaction, if possible without blocking.//! Get list of all wallet transactions.//! Get transaction information.//! Get a transaction.//! Commit bump transaction.//! Sign bump transaction.//! Create bump transaction.//! Return whether transaction can be bumped.//! Abandon transaction.//! Return whether transaction can be abandoned.//! Commit transaction.//! Create transaction.//! List locked coins.//! Return whether coin is locked.//! Unlock coin.//! Lock coin.//! Display address on external signer//! Save or remove receive request.//! Get receive requests.//! Get wallet address list.//! Look up address in wallet, return whether exists.// Remove address.//! Add or update address.//! Return whether wallet has watch only keys.//! Return whether wallet has private key.//! Sign message//! Get public key.// Get a new address.//! Get wallet name.//! Back up wallet.//! Abort a rescan.//! Change wallet passphrase.//! Return whether wallet is locked.//! Unlock wallet.//! Lock wallet.//! Return whether wallet is encrypted.//! Encrypt wallet.//! Interface for accessing a wallet.// namespace wallet// For SecureString// For CTxDestination// For CKeyID and CScriptID (definitions needed in CTxDestination instantiation)// For ChainClientbackup_filewallet_namewarningspassphrasewallet_creation_flagstx_bytescoin_controlreturned_targetoutputsfiltertxinbalancessighash_typesignbip32derivsn_signedpsbtxcompletetx_statusorder_formin_mempoolblock_timemtxbumped_txidold_feenew_feerecipientschange_posfeewrite_to_dbpkhashstr_sigpub_keylabelfilenameold_wallet_passphrasenew_wallet_passphrasewallet_passphrase/home/tanteikg/QCVE/sources/bitcoin/src/blockfilter.h/home/tanteikg/QCVE/sources/bitcoin/src/undo.h/home/tanteikg/QCVE/sources/bitcoin/src/util/bytevectorhash.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/coinselection.h/home/tanteikg/QCVE/sources/bitcoin/src/outputtype.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/spend.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/transaction.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/types.h/home/tanteikg/QCVE/sources/bitcoin/src/util/overloaded.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/wallet.h/home/tanteikg/QCVE/sources/bitcoin/src/interfaces/handler.h/home/tanteikg/QCVE/sources/bitcoin/src/util/message.h/home/tanteikg/QCVE/sources/bitcoin/src/util/ui_change_type.h/home/tanteikg/QCVE/sources/bitcoin/src/psbt.h/home/tanteikg/QCVE/sources/bitcoin/src/node/transaction.h/home/tanteikg/QCVE/sources/bitcoin/src/util/error.h/home/tanteikg/QCVE/sources/bitcoin/src/script/sign.h/home/tanteikg/QCVE/sources/bitcoin/src/validationinterface.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/crypter.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/scriptpubkeyman.h/home/tanteikg/QCVE/sources/bitcoin/src/script/descriptor.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/walletdb.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/db.h/home/tanteikg/QCVE/sources/bitcoin/src/wallet/walletutil.h/usr/include/boost/signals2/signal.hpp/usr/include/boost/function.hpp/usr/include/boost/preprocessor/iterate.hpp/usr/include/boost/preprocessor/iteration/iterate.hpp/usr/include/boost/preprocessor/slot/slot.hpp/usr/include/boost/preprocessor/slot/detail/def.hpp/usr/include/boost/function/detail/prologue.hpp/usr/include/boost/config/no_tr1/functional.hpp/usr/include/boost/throw_exception.hpp/usr/include/boost/exception/exception.hpp/usr/include/boost/current_function.hpp/usr/include/boost/function/function_base.hpp/usr/include/boost/integer.hpp/usr/include/boost/integer_traits.hpp/usr/include/boost/type_index.hpp/usr/include/boost/type_index/stl_type_index.hpp/usr/include/boost/type_index/type_index_facade.hpp/usr/include/boost/core/demangle.hpp/usr/include/c++/9/cxxabi.h/usr/include/x86_64-linux-gnu/c++/9/bits/cxxabi_tweaks.h/usr/include/boost/type_traits/has_trivial_copy.hpp/usr/include/boost/type_traits/is_copy_constructible.hpp/usr/include/boost/type_traits/is_constructible.hpp/usr/include/boost/type_traits/is_destructible.hpp/usr/include/boost/type_traits/is_default_constructible.hpp/usr/include/boost/type_traits/has_trivial_destructor.hpp/usr/include/boost/type_traits/composite_traits.hpp/usr/include/boost/type_traits/is_union.hpp/usr/include/boost/type_traits/enable_if.hpp/usr/include/boost/function_equal.hpp/usr/include/boost/function/function_fwd.hpp/usr/include/boost/preprocessor/enum.hpp/usr/include/boost/preprocessor/enum_params.hpp/usr/include/boost/preprocessor/iteration/detail/iter/forward1.hpp/usr/include/boost/preprocessor/iteration/detail/bounds/lower1.hpp/usr/include/boost/preprocessor/slot/detail/shared.hpp/usr/include/boost/preprocessor/iteration/detail/bounds/upper1.hpp/usr/include/boost/function/detail/function_iterate.hpp/usr/include/boost/function/detail/maybe_include.hpp/usr/include/boost/function/function_template.hpp/usr/include/boost/shared_ptr.hpp/usr/include/boost/smart_ptr/shared_ptr.hpp/usr/include/boost/checked_delete.hpp/usr/include/boost/core/checked_delete.hpp/usr/include/boost/smart_ptr/detail/shared_count.hpp/usr/include/boost/smart_ptr/bad_weak_ptr.hpp/usr/include/boost/smart_ptr/detail/sp_counted_base.hpp/usr/include/boost/smart_ptr/detail/sp_has_sync.hpp/usr/include/boost/smart_ptr/detail/sp_counted_base_std_atomic.hpp/usr/include/boost/smart_ptr/detail/sp_typeinfo_.hpp/usr/include/boost/smart_ptr/detail/sp_noexcept.hpp/usr/include/boost/smart_ptr/detail/sp_counted_impl.hpp/usr/include/boost/smart_ptr/detail/sp_disable_deprecated.hpp/usr/include/boost/smart_ptr/detail/sp_convertible.hpp/usr/include/boost/smart_ptr/detail/sp_nullptr_t.hpp/usr/include/boost/smart_ptr/detail/spinlock_pool.hpp/usr/include/boost/smart_ptr/detail/spinlock.hpp/usr/include/boost/smart_ptr/detail/spinlock_std_atomic.hpp/usr/include/boost/smart_ptr/detail/yield_k.hpp/usr/include/boost/predef/platform/windows_runtime.h/usr/include/boost/predef/make.h/usr/include/boost/predef/detail/test.h/usr/include/boost/predef/os/windows.h/usr/include/boost/predef/version_number.h/usr/include/boost/predef/platform/windows_phone.h/usr/include/boost/predef/platform/windows_uwp.h/usr/include/boost/predef/platform/windows_store.h/usr/include/boost/smart_ptr/detail/operator_bool.hpp/usr/include/boost/smart_ptr/detail/local_sp_deleter.hpp/usr/include/boost/smart_ptr/detail/local_counted_base.hpp/usr/include/boost/signals2/connection.hpp/usr/include/boost/signals2/detail/auto_buffer.hpp/usr/include/boost/signals2/detail/scope_guard.hpp/usr/include/boost/swap.hpp/usr/include/boost/type_traits/has_nothrow_copy.hpp/usr/include/boost/type_traits/has_nothrow_assign.hpp/usr/include/boost/type_traits/is_assignable.hpp/usr/include/boost/type_traits/has_trivial_assign.hpp/usr/include/boost/type_traits/has_trivial_constructor.hpp/usr/include/boost/signals2/detail/null_output_iterator.hpp/usr/include/boost/function_output_iterator.hpp/usr/include/boost/iterator/function_output_iterator.hpp/usr/include/boost/signals2/detail/unique_lock.hpp/usr/include/boost/signals2/slot.hpp/usr/include/boost/signals2/detail/signals_common.hpp/usr/include/boost/signals2/signal_base.hpp/usr/include/boost/type_traits/is_base_of.hpp/usr/include/boost/signals2/detail/signals_common_macros.hpp/usr/include/boost/signals2/detail/tracked_objects_visitor.hpp/usr/include/boost/signals2/slot_base.hpp/usr/include/boost/weak_ptr.hpp/usr/include/boost/smart_ptr/weak_ptr.hpp/usr/include/boost/signals2/detail/foreign_ptr.hpp/usr/include/boost/scoped_ptr.hpp/usr/include/boost/smart_ptr/scoped_ptr.hpp/usr/include/boost/signals2/expired_slot.hpp/usr/include/boost/variant/apply_visitor.hpp/usr/include/boost/variant/detail/apply_visitor_unary.hpp/usr/include/boost/move/utility.hpp/usr/include/boost/move/traits.hpp/usr/include/boost/move/detail/type_traits.hpp/usr/include/boost/type_traits/copy_cv_ref.hpp/usr/include/boost/type_traits/copy_cv.hpp/usr/include/boost/type_traits/copy_reference.hpp/usr/include/boost/variant/detail/has_result_type.hpp/usr/include/boost/variant/detail/apply_visitor_binary.hpp/usr/include/boost/move/move.hpp/usr/include/boost/move/iterator.hpp/usr/include/boost/move/detail/iterator_traits.hpp/usr/include/boost/move/detail/std_ns_begin.hpp/usr/include/boost/move/detail/std_ns_end.hpp/usr/include/boost/move/algorithm.hpp/usr/include/boost/move/algo/move.hpp/usr/include/boost/move/detail/iterator_to_raw_pointer.hpp/usr/include/boost/move/detail/to_raw_pointer.hpp/usr/include/boost/move/detail/pointer_element.hpp/usr/include/boost/variant/detail/apply_visitor_delayed.hpp/usr/include/boost/variant/variant_fwd.hpp/usr/include/boost/variant/detail/config.hpp/usr/include/boost/blank_fwd.hpp/usr/include/boost/preprocessor/enum_shifted_params.hpp/usr/include/boost/preprocessor/repetition/enum_shifted_params.hpp/usr/include/boost/variant/detail/substitute_fwd.hpp/usr/include/boost/variant/variant.hpp/usr/include/boost/variant/detail/backup_holder.hpp/usr/include/boost/variant/detail/enable_recursive_fwd.hpp/usr/include/boost/variant/detail/forced_return.hpp/usr/include/boost/variant/detail/initializer.hpp/usr/include/boost/detail/reference_content.hpp/usr/include/boost/variant/recursive_wrapper_fwd.hpp/usr/include/boost/type_traits/is_nothrow_move_constructible.hpp/usr/include/boost/variant/detail/move.hpp/usr/include/boost/move/adl_move_swap.hpp/usr/include/boost/variant/detail/make_variant_list.hpp/usr/include/boost/mpl/list.hpp/usr/include/boost/mpl/limits/list.hpp/usr/include/boost/mpl/list/list20.hpp/usr/include/boost/mpl/list/list10.hpp/usr/include/boost/mpl/list/list0.hpp/usr/include/boost/mpl/list/aux_/push_front.hpp/usr/include/boost/mpl/list/aux_/item.hpp/usr/include/boost/mpl/list/aux_/tag.hpp/usr/include/boost/mpl/list/aux_/pop_front.hpp/usr/include/boost/mpl/list/aux_/push_back.hpp/usr/include/boost/mpl/list/aux_/front.hpp/usr/include/boost/mpl/list/aux_/clear.hpp/usr/include/boost/mpl/list/aux_/O1_size.hpp/usr/include/boost/mpl/list/aux_/size.hpp/usr/include/boost/mpl/list/aux_/empty.hpp/usr/include/boost/mpl/list/aux_/begin_end.hpp/usr/include/boost/mpl/list/aux_/iterator.hpp/usr/include/boost/mpl/list/aux_/include_preprocessed.hpp/usr/include/boost/mpl/list/aux_/preprocessed/plain/list10.hpp/usr/include/boost/mpl/list/aux_/preprocessed/plain/list20.hpp/usr/include/boost/mpl/aux_/preprocessed/gcc/list.hpp/usr/include/boost/variant/detail/over_sequence.hpp/usr/include/boost/variant/detail/visitation_impl.hpp/usr/include/boost/variant/detail/cast_storage.hpp/usr/include/boost/variant/detail/hash_variant.hpp/usr/include/boost/variant/static_visitor.hpp/usr/include/boost/functional/hash_fwd.hpp/usr/include/boost/variant/detail/std_hash.hpp/usr/include/boost/aligned_storage.hpp/usr/include/boost/blank.hpp/usr/include/boost/detail/templated_streams.hpp/usr/include/boost/type_traits/is_empty.hpp/usr/include/boost/type_traits/is_stateless.hpp/usr/include/boost/integer/common_factor_ct.hpp/usr/include/boost/type_traits/has_nothrow_constructor.hpp/usr/include/boost/type_traits/is_nothrow_move_assignable.hpp/usr/include/boost/type_traits/has_trivial_move_assign.hpp/usr/include/boost/mpl/front.hpp/usr/include/boost/mpl/aux_/front_impl.hpp/usr/include/boost/mpl/insert_range.hpp/usr/include/boost/mpl/aux_/insert_range_impl.hpp/usr/include/boost/mpl/joint_view.hpp/usr/include/boost/mpl/aux_/joint_iter.hpp135413551356135713581359136013611362/usr/include/boost/mpl/aux_/iter_push_front.hpp1363/usr/include/boost/type_traits/same_traits.hpp13641365/usr/include/boost/mpl/max_element.hpp136613671368/usr/include/boost/mpl/size_t.hpp1369/usr/include/boost/mpl/size_t_fwd.hpp137013711372/usr/include/boost/mpl/sizeof.hpp1373137413751376137713781379138013811382138313841385/usr/include/boost/variant/detail/variant_io.hpp1386/usr/include/boost/signals2/trackable.hpp138713881389/usr/include/boost/utility/addressof.hpp1390/usr/include/boost/signals2/variadic_slot.hpp1391/usr/include/boost/signals2/detail/variadic_arg_type.hpp1392/usr/include/boost/signals2/detail/slot_template.hpp1393/usr/include/boost/signals2/detail/replace_slot_function.hpp1394/usr/include/boost/signals2/detail/result_type_wrapper.hpp1395/usr/include/boost/signals2/detail/slot_groups.hpp1396/usr/include/boost/optional.hpp1397/usr/include/boost/optional/optional.hpp139813991400/usr/include/boost/core/explicit_operator_bool.hpp1401/usr/include/boost/optional/bad_optional_access.hpp1402/usr/include/boost/type_traits/decay.hpp1403/usr/include/boost/type_traits/remove_bounds.hpp1404/usr/include/boost/type_traits/remove_extent.hpp1405/usr/include/boost/none.hpp1406/usr/include/boost/none_t.hpp1407/usr/include/boost/utility/compare_pointees.hpp1408/usr/include/boost/utility/result_of.hpp14091410141114121413141414151416141714181419142014211422/usr/include/boost/type_traits/type_identity.hpp142314241425142614271428/usr/include/boost/utility/detail/result_of_iterate.hpp14291430143114321433143414351436143714381439144014411442144314441445/usr/include/boost/optional/optional_fwd.hpp1446/usr/include/boost/optional/detail/optional_config.hpp1447/usr/include/boost/optional/detail/optional_factory_support.hpp1448/usr/include/boost/optional/detail/optional_aligned_storage.hpp1449/usr/include/boost/optional/detail/optional_trivially_copyable_base.hpp1450/usr/include/boost/optional/detail/optional_reference_spec.hpp1451/usr/include/boost/optional/detail/optional_relops.hpp1452/usr/include/boost/optional/detail/optional_swap.hpp1453/usr/include/boost/signals2/detail/slot_call_iterator.hpp145414551456/usr/include/boost/signals2/optional_last_value.hpp1457/usr/include/boost/signals2/mutex.hpp1458/usr/include/boost/signals2/detail/lwm_pthreads.hpp145914601461/usr/include/boost/signals2/variadic_signal.hpp14621463146414651466/usr/include/boost/signals2/detail/variadic_slot_invoker.hpp14671468/usr/include/boost/signals2/detail/signal_template.hpp1469/home/tanteikg/QCVE/sources/bitcoin/src/bench/coin_selection.cpp<wallet/wallet.h><wallet/spend.h><wallet/coinselection.h>BnBExhaustionutxo_poollambda [] type at line 304674, col. 15const lambda [] type at line 304674, col. 15const lambda [] type at line 304674, col. 15 &lambda [] type at line 304674, col. 15 &lambda [] type at line 304674, col. 15 &&vector<OutputGroup, allocator<OutputGroup>> &make_hard_caseCAmount{1}add_coinconst shared_ptr<COutput>const shared_ptr<COutput> &shared_ptr<COutput> &COutput &~COutputCOutput *CoinSelectionconst unique_ptr<Chain, default_delete<Chain>>wtxswallet.cs_walletbench/coin_selection.cppconst CWalletconst CWallet &CWallet &vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &1000000000001000 * COIN3000000003 * COINavailable_coinsCoinsResultCoinsResult *const unique_ptr<CWalletTx, default_delete<CWalletTx>>const unique_ptr<CWalletTx, default_delete<CWalletTx>> &unique_ptr<CWalletTx, default_delete<CWalletTx>> &wtxconst __normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>>const __normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>> &__normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>> &vector<COutput, allocator<COutput>> &OutputType &&OutputType::BECH32OutputType &const CWalletTxconst CWalletTx *CWalletTx *6 * 24const CWallet *const CCoinControl *CCoinControl *const CoinEligibilityFilterfilter_standardrandconst CoinSelectionParamscoin_selection_paramsCHANGE_LOWERgroupOutputGroupTypeMapconst OutputGroupTypeMapconst OutputGroupTypeMap &OutputGroupTypeMap &OutputGroupTypeMap *Groupsconst Groupsconst Groups &Groups &Groups *CoinEligibilityFilter &const CoinsResultconst CoinsResult &CoinsResult &const CoinSelectionParams &CoinSelectionParams &const vector<SelectionFilter, allocator<SelectionFilter>>const vector<SelectionFilter, allocator<SelectionFilter>> &vector<SelectionFilter, allocator<SelectionFilter>> &const SelectionFilterconst SelectionFilter[1]SelectionFilter[1]const SelectionFilter *SelectionFilter *const CoinEligibilityFilter &result->GetSelectedValue() == 1003 * COINresult->GetInputSet().size() == 2lambda [] type at line 304638, col. 15const lambda [] type at line 304638, col. 15const lambda [] type at line 304638, col. 15 &lambda [] type at line 304638, col. 15 &lambda [] type at line 304638, col. 15 &&~CoinsResult~OutputGroupTypeMap~GroupsaddCoinnextLockTimeunique_ptr<CWalletTx, default_delete<CWalletTx>> &&TxStateInactive &&TxStateInactive &const lambda [] type at line 304674, col. 15 *lambda [] type at line 304674, col. 15 *400000MAX_STANDARD_TX_WEIGHTconst lambda [] type at line 304638, col. 15 *lambda [] type at line 304638, col. 15 *1003000000001003 * COINconst Result<SelectionResult>SelectionResult *const SelectionResultconst SelectionResult *const set<shared_ptr<COutput>, less<shared_ptr<COutput>>, allocator<shared_ptr<COutput>>>const set<shared_ptr<COutput>, less<shared_ptr<COutput>>, allocator<shared_ptr<COutput>>> &set<shared_ptr<COutput>, less<shared_ptr<COutput>>, allocator<shared_ptr<COutput>>> &Result<SelectionResult> *bench_127BnBExhaustionPASTE2(__LINE__, BnBExhaustion)127BnBExhaustionbench_126CoinSelectionPASTE2(__LINE__, CoinSelection)126CoinSelection// Cleanup// Should exhaust// Benchmark// Setup// Copied from src/wallet/test/coinselector_tests.cpp/*descendants=*//*ancestors=*//*fees=*//*from_me=*//*time=*//*safe=*//*solvable=*//*spendable=*//*input_bytes=*//*depth=*//*allow_mixed_output_types=*//*avoid_partial=*//*tx_noinputs_size=*//*discard_feerate=*//*long_term_feerate=*//*effective_feerate=*//*min_change_target=*//*change_spend_size=*//*change_output_size=*//*coin_control=*/// Create coins// Add coins.// either for measurements."// same one over and over isn't too useful. Generating random isn't useful// the hardest, as you need a wider selection of scenarios, just testing the// measurements of performance. From laanwj, "Wallet coin selection is probably// to build up more complicated scenarios in order to get meaningful// Simple benchmark for wallet coin selection. Note that it maybe be necessary// so all transactions get different hashesutxosnInput__normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>>unique_ptr<CWalletTx, default_delete<CWalletTx>> *__normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>> &&__normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>> *unique_ptr<CWalletTx, default_delete<CWalletTx>>default_delete<CWalletTx> &vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &_Vector_base<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>_Vector_base<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &const _Vector_base<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>const _Vector_base<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>new_allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>new_allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &const new_allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>const new_allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &allocator_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>allocator_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &allocator_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &&const allocator_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>const allocator_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &const TxStateconst TxState &variant<TxStateConfirmed, TxStateInMempool, TxStateConflicted, TxStateInactive, TxStateUnrecognized> &vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> *_Vector_base<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> *vector<COutput, allocator<COutput>> *_Vector_base<COutput, allocator<COutput>> *allocator<COutput> &long &&const unique_ptr<CWalletTx, default_delete<CWalletTx>> *unique_ptr<CWalletTx, default_delete<CWalletTx>> *constunique_ptr<CWalletTx, default_delete<CWalletTx>> *const &unique_ptr<CWalletTx, default_delete<CWalletTx>> *&const __normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>> *const _Vector_base<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> *const allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>const allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &const default_delete<CWalletTx>const default_delete<CWalletTx> &__alloc_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>>__alloc_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>> &__alloc_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>> &&const __alloc_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>>const __alloc_traits<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>> &_Rb_tree<OutputType, pair<const OutputType, Groups>, _Select1st<pair<const OutputType, Groups>>, less<OutputType>, allocator<pair<const OutputType, Groups>>> &__uniq_ptr_impl<CWalletTx, default_delete<CWalletTx>>__uniq_ptr_impl<CWalletTx, default_delete<CWalletTx>> &__uniq_ptr_impl<CWalletTx, default_delete<CWalletTx>> &&const __uniq_ptr_impl<CWalletTx, default_delete<CWalletTx>>const __uniq_ptr_impl<CWalletTx, default_delete<CWalletTx>> &default_delete<CWalletTx>default_delete<CWalletTx> &&default_delete<CWalletTx> *_MakeUniq<CWalletTx>_MakeUniq<CWalletTx> &_MakeUniq<CWalletTx> &&const _MakeUniq<CWalletTx>const _MakeUniq<CWalletTx> &allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>> *const new_allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>> *new_allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>> *const _Rb_tree<OutputType, pair<const OutputType, Groups>, _Select1st<pair<const OutputType, Groups>>, less<OutputType>, allocator<pair<const OutputType, Groups>>>const _Rb_tree<OutputType, pair<const OutputType, Groups>, _Select1st<pair<const OutputType, Groups>>, less<OutputType>, allocator<pair<const OutputType, Groups>>> &_Rb_tree<OutputType, pair<const OutputType, Groups>, _Select1st<pair<const OutputType, Groups>>, less<OutputType>, allocator<pair<const OutputType, Groups>>> *const _Rb_tree_impl<less<OutputType>, true>const _Rb_tree_impl<less<OutputType>, true> &_Rb_tree_impl<less<OutputType>, true> &const vector<COutput, allocator<COutput>>const vector<COutput, allocator<COutput>> *const __normal_iterator<COutput *, vector<COutput, allocator<COutput>>>const __normal_iterator<COutput *, vector<COutput, allocator<COutput>>> &__normal_iterator<COutput *, vector<COutput, allocator<COutput>>> &COutput *constCOutput *const &COutput *&is_nothrow_constructible<COutput, COutPoint, const CTxOut &, int, int, bool, bool, bool, long, bool, int>is_nothrow_constructible<COutput, COutPoint, const CTxOut &, int, int, bool, bool, bool, long, bool, int> &is_nothrow_constructible<COutput, COutPoint, const CTxOut &, int, int, bool, bool, bool, long, bool, int> &&const is_nothrow_constructible<COutput, COutPoint, const CTxOut &, int, int, bool, bool, bool, long, bool, int>const is_nothrow_constructible<COutput, COutPoint, const CTxOut &, int, int, bool, bool, bool, long, bool, int> &iterator_traits<unique_ptr<CWalletTx, default_delete<CWalletTx>> *>iterator_traits<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &iterator_traits<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &&const iterator_traits<unique_ptr<CWalletTx, default_delete<CWalletTx>> *>const iterator_traits<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &__and_<is_convertible<pointer, CWalletTx *>, __not_<is_array<_Up>>>tuple<CWalletTx *, default_delete<CWalletTx>>tuple<CWalletTx *, default_delete<CWalletTx>> &&const tuple<CWalletTx *, default_delete<CWalletTx>>const tuple<CWalletTx *, default_delete<CWalletTx>> &tuple<CWalletTx *, default_delete<CWalletTx>> &CWalletTx *constCWalletTx *const &CWalletTx *&_Ptr<CWalletTx, default_delete<CWalletTx>, void>_Ptr<CWalletTx, default_delete<CWalletTx>, void> &_Ptr<CWalletTx, default_delete<CWalletTx>, void> &&const _Ptr<CWalletTx, default_delete<CWalletTx>, void>const _Ptr<CWalletTx, default_delete<CWalletTx>, void> &__normal_iterator<const unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>>reverse_iterator<__normal_iterator<const unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>>>reverse_iterator<__normal_iterator<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>>>_Tuple_impl<0UL, CWalletTx *, default_delete<CWalletTx>>_Tuple_impl<0UL, CWalletTx *, default_delete<CWalletTx>> &&const _Tuple_impl<0UL, CWalletTx *, default_delete<CWalletTx>>const _Tuple_impl<0UL, CWalletTx *, default_delete<CWalletTx>> &_Tuple_impl<0UL, CWalletTx *, default_delete<CWalletTx>> &_Tuple_impl<1UL, default_delete<CWalletTx>>_Tuple_impl<1UL, default_delete<CWalletTx>> &&const _Tuple_impl<1UL, default_delete<CWalletTx>>const _Tuple_impl<1UL, default_delete<CWalletTx>> &_Tuple_impl<1UL, default_delete<CWalletTx>> &remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>> &>remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>> &> &remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>> &> &&const remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>> &>const remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>> &> &rebind<unique_ptr<CWalletTx, default_delete<CWalletTx>>>rebind<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &rebind<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &&const rebind<unique_ptr<CWalletTx, default_delete<CWalletTx>>>const rebind<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &__uniq_ptr_impl<CWalletTx, default_delete<CWalletTx>> *const vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>const vector<unique_ptr<CWalletTx, default_delete<CWalletTx>>, allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> *const __uniq_ptr_impl<CWalletTx, default_delete<CWalletTx>> *const __tuple_element_t<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>>const __tuple_element_t<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>> &_Rb_tree_impl<less<OutputType>, true> *const allocator<_Rb_tree_node<pair<const OutputType, Groups>>>const allocator<_Rb_tree_node<pair<const OutputType, Groups>>> &allocator<_Rb_tree_node<pair<const OutputType, Groups>>> &const _Rb_tree_key_compare<less<OutputType>>const less<OutputType>const less<OutputType> &less<OutputType> &const _Rb_tree<OutputType, pair<const OutputType, Groups>, _Select1st<pair<const OutputType, Groups>>, less<OutputType>, allocator<pair<const OutputType, Groups>>> *is_nothrow_default_constructible<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>is_nothrow_default_constructible<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &is_nothrow_default_constructible<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &&const is_nothrow_default_constructible<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>const is_nothrow_default_constructible<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>>is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>> &is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>> &&const is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>>const is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>>> &__and_<is_same<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, _Ptr>, __not_<is_pointer<_Ptr>>>_Head_base<1UL, default_delete<CWalletTx>, true>_Head_base<1UL, default_delete<CWalletTx>, true> &const _Head_base<1UL, default_delete<CWalletTx>, true>const _Head_base<1UL, default_delete<CWalletTx>, true> &_Head_base<0UL, CWalletTx *, false>_Head_base<0UL, CWalletTx *, false> &const _Head_base<0UL, CWalletTx *, false>const _Head_base<0UL, CWalletTx *, false> &is_convertible<pointer, CWalletTx *>remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>>>remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &&const remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>>>const remove_reference<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &__tuple_element_t<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>> &is_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>> &&>is_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>> &&> &is_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>> &&> &&const is_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>> &&>const is_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>, unique_ptr<CWalletTx, default_delete<CWalletTx>> &&> &__is_move_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>>, true>__is_move_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>>, true> &__is_move_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>>, true> &&const __is_move_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>>, true>const __is_move_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>>, true> &is_move_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>>is_move_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &is_move_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &&const is_move_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>>const is_move_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &__is_move_insertable<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>__is_move_insertable<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &__is_move_insertable<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &&const __is_move_insertable<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>>const __is_move_insertable<allocator<unique_ptr<CWalletTx, default_delete<CWalletTx>>>> &_TC<value, CWalletTx *, default_delete<CWalletTx>>_TC<true, CWalletTx *, default_delete<CWalletTx>>_TC<true, CWalletTx *, default_delete<CWalletTx>> &_TC<true, CWalletTx *, default_delete<CWalletTx>> &&const _TC<true, CWalletTx *, default_delete<CWalletTx>>const _TC<true, CWalletTx *, default_delete<CWalletTx>> &is_same<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, _Ptr>_Tuple_impl<0UL, CWalletTx *, default_delete<CWalletTx>> *unique_ptr<CWalletTx, default_delete<CWalletTx>> *&&const _Rb_tree_node<pair<const OutputType, Groups>>const _Rb_tree_node<pair<const OutputType, Groups>> *_Rb_tree_node<pair<const OutputType, Groups>> *is_nothrow_destructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>>is_nothrow_destructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &is_nothrow_destructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &&const is_nothrow_destructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>>const is_nothrow_destructible<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &tuple_element<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>>tuple_element<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>> &tuple_element<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>> &&const tuple_element<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>>const tuple_element<0UL, tuple<CWalletTx *, default_delete<CWalletTx>>> &__is_empty_non_tuple<default_delete<CWalletTx>>__is_empty_non_tuple<default_delete<CWalletTx>> &__is_empty_non_tuple<default_delete<CWalletTx>> &&const __is_empty_non_tuple<default_delete<CWalletTx>>const __is_empty_non_tuple<default_delete<CWalletTx>> &__is_empty_non_tuple<CWalletTx *>__is_empty_non_tuple<CWalletTx *> &__is_empty_non_tuple<CWalletTx *> &&const __is_empty_non_tuple<CWalletTx *>const __is_empty_non_tuple<CWalletTx *> &__is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>>>__is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &__is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &&const __is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>>>const __is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>>> &const pair<const OutputType, Groups>const pair<const OutputType, Groups> &pair<const OutputType, Groups> &const pair<const OutputType, Groups> *pair<const OutputType, Groups> *CWalletTx *&&_Head_base<0UL, CWalletTx *, false> *_Tuple_impl<1UL, default_delete<CWalletTx>> *conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<CWalletTx *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<CWalletTx *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<CWalletTx *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<CWalletTx *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<CWalletTx *>> &is_empty<CWalletTx *>is_empty<CWalletTx *> &is_empty<CWalletTx *> &&const is_empty<CWalletTx *>const is_empty<CWalletTx *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<CWalletTx>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<CWalletTx>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<CWalletTx>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<CWalletTx>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<CWalletTx>>> &is_empty<default_delete<CWalletTx>>is_empty<default_delete<CWalletTx>> &is_empty<default_delete<CWalletTx>> &&const is_empty<default_delete<CWalletTx>>const is_empty<default_delete<CWalletTx>> &remove_reference<default_delete<CWalletTx>>remove_reference<default_delete<CWalletTx>> &remove_reference<default_delete<CWalletTx>> &&const remove_reference<default_delete<CWalletTx>>const remove_reference<default_delete<CWalletTx>> &_Head_base<1UL, default_delete<CWalletTx>, true> *const default_delete<CWalletTx> *~CWalletTx__tuple_element_t<1UL, tuple<CWalletTx *, default_delete<CWalletTx>>> &is_nothrow_copy_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *>is_nothrow_copy_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &is_nothrow_copy_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &&const is_nothrow_copy_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *>const is_nothrow_copy_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &__is_nothrow_copy_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, true>__is_nothrow_copy_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, true> &__is_nothrow_copy_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, true> &&const __is_nothrow_copy_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, true>const __is_nothrow_copy_constructible_impl<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, true> &tuple_element<0UL, tuple<default_delete<CWalletTx>>>tuple_element<0UL, tuple<default_delete<CWalletTx>>> &tuple_element<0UL, tuple<default_delete<CWalletTx>>> &&const tuple_element<0UL, tuple<default_delete<CWalletTx>>>const tuple_element<0UL, tuple<default_delete<CWalletTx>>> &__is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>> *>__is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &__is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &&const __is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>> *>const __is_referenceable<unique_ptr<CWalletTx, default_delete<CWalletTx>> *> &is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, unique_ptr<CWalletTx, default_delete<CWalletTx>> *const &>is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, unique_ptr<CWalletTx, default_delete<CWalletTx>> *const &> &is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, unique_ptr<CWalletTx, default_delete<CWalletTx>> *const &> &&const is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, unique_ptr<CWalletTx, default_delete<CWalletTx>> *const &>const is_nothrow_constructible<unique_ptr<CWalletTx, default_delete<CWalletTx>> *, unique_ptr<CWalletTx, default_delete<CWalletTx>> *const &> &tuple<default_delete<CWalletTx>>/home/tanteikg/QCVE/sources/bitcoin/src/crypto/muhash.h/home/tanteikg/QCVE/sources/bitcoin/src/crypto/sha1.h/home/tanteikg/QCVE/sources/bitcoin/src/crypto/sha3.h/home/tanteikg/QCVE/sources/bitcoin/src/crypto/sha512.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/crypto_hash.cpp<crypto/sha512.h><crypto/sha3.h><crypto/sha1.h><crypto/muhash.h>MuHashPrecomputelambda [] type at line 130557, col. 15const lambda [] type at line 130557, col. 15const lambda [] type at line 130557, col. 15 &lambda [] type at line 130557, col. 15 &lambda [] type at line 130557, col. 15 &&MuHashDivmuhashlambda [] type at line 130546, col. 15const lambda [] type at line 130546, col. 15const lambda [] type at line 130546, col. 15 &lambda [] type at line 130546, col. 15 &lambda [] type at line 130546, col. 15 &&MuHash3072 &MuHashMullambda [] type at line 130535, col. 15const lambda [] type at line 130535, col. 15const lambda [] type at line 130535, col. 15 &lambda [] type at line 130535, col. 15 &lambda [] type at line 130535, col. 15 &&MuHashlambda [] type at line 130523, col. 15const lambda [] type at line 130523, col. 15const lambda [] type at line 130523, col. 15 &lambda [] type at line 130523, col. 15 &lambda [] type at line 130523, col. 15 &&FastRandom_1bitlambda [] type at line 130513, col. 15const lambda [] type at line 130513, col. 15const lambda [] type at line 130513, col. 15 &lambda [] type at line 130513, col. 15 &lambda [] type at line 130513, col. 15 &&FastRandom_32bitlambda [] type at line 130505, col. 15const lambda [] type at line 130505, col. 15const lambda [] type at line 130505, col. 15 &lambda [] type at line 130505, col. 15 &lambda [] type at line 130505, col. 15 &&SipHash_32blambda [] type at line 130497, col. 15const lambda [] type at line 130497, col. 15const lambda [] type at line 130497, col. 15 &lambda [] type at line 130497, col. 15 &lambda [] type at line 130497, col. 15 &&SHA512uint8_t[64]CSHA512::OUTPUT_SIZEBUFFER_SIZElambda [] type at line 130488, col. 45const lambda [] type at line 130488, col. 45const lambda [] type at line 130488, col. 45 &lambda [] type at line 130488, col. 45 &lambda [] type at line 130488, col. 45 &&uint8_t(&)[64]unsigned char(&)[64]SHA256D64_102464 * 1024lambda [] type at line 130479, col. 45const lambda [] type at line 130479, col. 45const lambda [] type at line 130479, col. 45 &lambda [] type at line 130479, col. 45 &lambda [] type at line 130479, col. 45 &&SHA256_32blambda [] type at line 130469, col. 45const lambda [] type at line 130469, col. 45const lambda [] type at line 130469, col. 45 &lambda [] type at line 130469, col. 45 &lambda [] type at line 130469, col. 45 &&SHA3_256_1MSHA3_256::OUTPUT_SIZElambda [] type at line 130461, col. 45const lambda [] type at line 130461, col. 45const lambda [] type at line 130461, col. 45 &lambda [] type at line 130461, col. 45 &lambda [] type at line 130461, col. 45 &&SHA256lambda [] type at line 130452, col. 45const lambda [] type at line 130452, col. 45const lambda [] type at line 130452, col. 45 &lambda [] type at line 130452, col. 45 &lambda [] type at line 130452, col. 45 &&SHA1uint8_t[20]unsigned char[20]CSHA1::OUTPUT_SIZElambda [] type at line 130443, col. 45const lambda [] type at line 130443, col. 45const lambda [] type at line 130443, col. 45 &lambda [] type at line 130443, col. 45 &lambda [] type at line 130443, col. 45 &&uint8_t(&)[20]unsigned char(&)[20]BenchRIPEMD160lambda [] type at line 130434, col. 45const lambda [] type at line 130434, col. 45const lambda [] type at line 130434, col. 45 &lambda [] type at line 130434, col. 45 &lambda [] type at line 130434, col. 45 &&const lambda [] type at line 130557, col. 15 *lambda [] type at line 130557, col. 15 *const lambda [] type at line 130546, col. 15 *lambda [] type at line 130546, col. 15 *const MuHash3072const MuHash3072 &const lambda [] type at line 130535, col. 15 *lambda [] type at line 130535, col. 15 *const lambda [] type at line 130523, col. 15 *lambda [] type at line 130523, col. 15 *const unsigned char(&)[32]const lambda [] type at line 130513, col. 15 *lambda [] type at line 130513, col. 15 *const lambda [] type at line 130505, col. 15 *lambda [] type at line 130505, col. 15 *const lambda [] type at line 130497, col. 15 *lambda [] type at line 130497, col. 15 *const lambda [] type at line 130488, col. 45 *lambda [] type at line 130488, col. 45 *CSHA512 &const lambda [] type at line 130479, col. 45 *lambda [] type at line 130479, col. 45 *const lambda [] type at line 130469, col. 45 *lambda [] type at line 130469, col. 45 *const lambda [] type at line 130461, col. 45 *lambda [] type at line 130461, col. 45 *SHA3_256 &const lambda [] type at line 130452, col. 45 *lambda [] type at line 130452, col. 45 *const lambda [] type at line 130443, col. 45 *lambda [] type at line 130443, col. 45 *CSHA1 &const lambda [] type at line 130434, col. 45 *lambda [] type at line 130434, col. 45 *bench_168MuHashPrecomputePASTE2(__LINE__, MuHashPrecompute)168MuHashPrecomputebench_167MuHashDivPASTE2(__LINE__, MuHashDiv)167MuHashDivbench_166MuHashMulPASTE2(__LINE__, MuHashMul)166MuHashMulbench_165MuHashPASTE2(__LINE__, MuHash)165MuHashbench_163FastRandom_1bitPASTE2(__LINE__, FastRandom_1bit)163FastRandom_1bitbench_162FastRandom_32bitPASTE2(__LINE__, FastRandom_32bit)162FastRandom_32bitbench_161SHA256D64_1024PASTE2(__LINE__, SHA256D64_1024)161SHA256D64_1024bench_160SipHash_32bPASTE2(__LINE__, SipHash_32b)160SipHash_32bbench_159SHA256_32bPASTE2(__LINE__, SHA256_32b)159SHA256_32bbench_157SHA3_256_1MPASTE2(__LINE__, SHA3_256_1M)157SHA3_256_1Mbench_156SHA512PASTE2(__LINE__, SHA512)156SHA512bench_155SHA256PASTE2(__LINE__, SHA256)155SHA256bench_154SHA1PASTE2(__LINE__, SHA1)154SHA1bench_153BenchRIPEMD160PASTE2(__LINE__, BenchRIPEMD160)153BenchRIPEMD1601000*1000/* Number of bytes to hash per iteration */__exchangemove_if_noexcept__move_if_noexcept_cond<_Tp>_GLIBCXX_FORWARD(_Tp,__val)std::forward<_Tp>(__val)_GLIBCXX_MOVE(__val)std::move(__val)__cpp_lib_addressof_constexpr_MOVE_H/* _MOVE_H *//// @} group utilities/// Swap the contents of two arrays.// DR 809. std::swap should be overloaded for array types./**
   *  @brief Swaps two values.
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  */// C++11 version of std::exchange for internal use.// 2598. addressof works on temporaries/**
   *  @brief Returns the actual address of the object or function
   *         referenced by r, even in the presence of an overloaded
   *         operator&.
   *  @param  __r  Reference to an object or function.
   *  @return   The actual address.
  */// 2296. std::addressof should be constexpr// declval, from type_traits./**
   *  @brief  Conditionally convert a value to an rvalue.
   *  @param  __x  A thing of arbitrary type.
   *  @return The parameter, possibly cast to an rvalue-reference.
   *
   *  Same as std::move unless the type's move constructor could throw and the
   *  type is copyable, in which case an lvalue-reference is returned instead.
   *//**
   *  @brief  Convert a value to an rvalue.
   *  @param  __t  A thing of arbitrary type.
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  *//**
   *  @brief  Forward an rvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   *//**
   *  @brief  Forward an lvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */// Brings in std::declval too./**
   *  @brief Same as C++11 std::addressof
   *  @ingroup utilities
   */// Used, in C++03 mode too, by allocators, etc./** @file bits/move.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{utility}
 */// Move, forward and identity for C++11 + swap -*- C++ -*-__detail/home/tanteikg/QCVE/sources/bitcoin/src/bench/data/block413567.raw.hblock413567_rawconst unsigned char[999887]unsigned char[999887]/home/tanteikg/QCVE/sources/bitcoin/src/bench/data/home/tanteikg/QCVE/sources/bitcoin/src/bench/data.cpp<bench/data/block413567.raw.h>999887const unsigned char(&)[999887]unsigned char(&)[999887]/home/tanteikg/QCVE/sources/bitcoin/src/bench/descriptors.cpp<script/descriptor.h>ExpandDescriptordesc_strsh(wsh(multi(16,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0,0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600,0362a74e399c39ed5593852a30147f2959b56bb827dfa3e60e464b02ccf87dc5e8,0261345b53de74a4d721ef877c255429961b7e43714171ac06168d7e08c542a8b8,02da72e8b46901a65d4374fe6315538d8f368557dda3a1dcf9ea903f3afe7314c8,0318c82dd0b53fd3a932d16e0ba9e278fcc937c582d5781be626ff16e201f72286,0297ccef1ef99f9d73dec9ad37476ddb232f1238aff877af19e72ba04493361009,02e502cfd5c3f972fe9a3e2a18827820638f96b6f347e54d63deb839011fd5765d,03e687710f0e3ebe81c1037074da939d409c0025f17eb86adb9427d28f0f7ae0e9,02c04d3a5274952acdbc76987f3184b346a483d43be40874624b29e3692c1df5af,02ed06e0f418b5b43a7ec01d1d7d27290fa15f75771cb69b642a51471c29c84acd,036d46073cbb9ffee90473f3da429abc8de7f8751199da44485682a989a4bebb24,02f5d1ff7c9029a80a4e36b9a5497027ef7f3e73384a4a94fbfe7c4e9164eec8bc,02e41deffd1b7cce11cde209a781adcffdabd1b91c0ba0375857a2bfd9302419f3,02d76625f7956a7fc505ab02556c23ee72d832f1bac391bcd2d3abce5710a13d06,0399eb0a5487515802dc14544cf10b3666623762fbed2ec38a3975716e2c29c232)))"sh(wsh(multi(16,03669b8afcec803a0d323e9a17f3ea8e68e8abe5a278020a929adbec52421adbd0,0260b2003c386519fc9eadf2b5cf124dd8eea4c4e68d5e154050a9346ea98ce600,0362a74e399c39ed5593852a30147f2959b56bb827dfa3e60e464b02ccf87dc5e8,0261345b53de74a4d721ef877c255429961b7e43714171ac06168d7e08c542a8b8,02da72e8b46901a65d4374fe6315538d8f368557dda3a1dcf9ea903f3afe7314c8,0318c82dd0b53fd3a932d16e0ba9e278fcc937c582d5781be626ff16e201f72286,0297ccef1ef99f9d73dec9ad37476ddb232f1238aff877af19e72ba04493361009,02e502cfd5c3f972fe9a3e2a18827820638f96b6f347e54d63deb839011fd5765d,03e687710f0e3ebe81c1037074da939d409c0025f17eb86adb9427d28f0f7ae0e9,02c04d3a5274952acdbc76987f3184b346a483d43be40874624b29e3692c1df5af,02ed06e0f418b5b43a7ec01d1d7d27290fa15f75771cb69b642a51471c29c84acd,036d46073cbb9ffee90473f3da429abc8de7f8751199da44485682a989a4bebb24,02f5d1ff7c9029a80a4e36b9a5497027ef7f3e73384a4a94fbfe7c4e9164eec8bc,02e41deffd1b7cce11cde209a781adcffdabd1b91c0ba0375857a2bfd9302419f3,02d76625f7956a7fc505ab02556c23ee72d832f1bac391bcd2d3abce5710a13d06,0399eb0a5487515802dc14544cf10b3666623762fbed2ec38a3975716e2c29c232)))"const char[1091]char[1091]const pair<signed long, signed long>FlatSigningProvider *desclambda [] type at line 157083, col. 15const lambda [] type at line 157083, col. 15const lambda [] type at line 157083, col. 15 &lambda [] type at line 157083, col. 15 &lambda [] type at line 157083, col. 15 &&const pair<signed long, signed long> &pair<signed long, signed long> &unique_ptr<Descriptor, default_delete<Descriptor>> &const lambda [] type at line 157083, col. 15 *lambda [] type at line 157083, col. 15 *vector<CScript, allocator<CScript>> &DescriptorCache *const unique_ptr<Descriptor, default_delete<Descriptor>>const Descriptorconst Descriptor *Descriptor *bench/descriptors.cppbench_35ExpandDescriptorPASTE2(__LINE__, ExpandDescriptor)35ExpandDescriptor<consensus/consensus.h>GetWitnessCommitmentIndexcommitposNO_WITNESS_COMMITMENTMINIMUM_WITNESS_COMMITMENT0x210xedGetTransactionInputWeight1073811840PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESSWITNESS_SCALE_FACTORWITNESS_SCALE_FACTOR - 1(WITNESS_SCALE_FACTOR - 1)GetBlockWeightGetTransactionWeightGetDebugMessageGetRejectReasonconst ValidationState<Result>const ValidationState<Result> *ValidationState<Result> *GetResultIsErrorIsInvalidM_VALIDInvalidBlockValidationState &&const BlockValidationStateconst BlockValidationState &TxValidationState &TxValidationState &&const TxValidationState &TxValidationStateconst ValidationState<TxValidationResult>const ValidationState<TxValidationResult> &ValidationState<TxValidationResult> &ValidationState<Result>ModeStateM_INVALIDM_ERRORBlockValidationResultBLOCK_RESULT_UNSETBLOCK_CONSENSUSBLOCK_RECENT_CONSENSUS_CHANGEBLOCK_CACHED_INVALIDBLOCK_INVALID_HEADERBLOCK_MUTATEDBLOCK_MISSING_PREVBLOCK_INVALID_PREVBLOCK_TIME_FUTUREBLOCK_CHECKPOINTBLOCK_HEADER_LOW_WORKTxValidationResultTX_RESULT_UNSETTX_CONSENSUSTX_RECENT_CONSENSUS_CHANGETX_INPUTS_NOT_STANDARDTX_NOT_STANDARDTX_MISSING_INPUTSTX_PREMATURE_SPENDTX_WITNESS_MUTATEDTX_WITNESS_STRIPPEDTX_CONFLICTTX_MEMPOOL_POLICYTX_NO_MEMPOOLm_modem_resultm_reject_reasonm_debug_messageBITCOIN_CONSENSUS_VALIDATION_H// BITCOIN_CONSENSUS_VALIDATION_H/** Compute at which vout of the block's coinbase transaction the witness commitment occurs, or -1 if not found */// scriptWitness size is added here because witnesses and txins are split up in segwit serialization.// weight = (stripped_size * 3) + total_size.// is equal to total_size - stripped_size, this formula is identical to:// using only serialization with and without witness data. As witness_size// These implement the weight = (stripped_size * 4) + witness_size formula,//!< run-time error//!< network rule violation (DoS value may be set)//!< everything ok/** Template for capturing information about block/transaction validation. This is instantiated
 *  by TxValidationState and BlockValidationState for validation information on transactions
 *  and blocks respectively. *///!< the block header may be on a too-little-work chain//!< the block failed to meet one of our checkpoints//!< block timestamp was > 2 hours in the future (or our clock is bad)//!< A block this one builds on is invalid//!< We don't have the previous block the checked one is built on//!< the block's data didn't match the data committed to by the PoW//!< invalid proof of work or time too old//!< this block was cached as being invalid and we didn't store the reason why/**
     * Invalid by a change to consensus rules more recent than SegWit.
     * Currently unused as there are no such consensus rule changes, and any download
     * sources realistically need to support SegWit in order to provide useful data,
     * so differentiating between always-invalid and invalid-by-pre-SegWit-soft-fork
     * is uninteresting.
     *///!< invalid by consensus rules (excluding any below reasons)//!< initial value. Block has not yet been rejected/** A "reason" why a block was invalid, suitable for determining whether the
  * provider of the block should be banned/ignored/disconnected/etc.
  * These are much more granular than the rejection codes, which may be more
  * useful for some other use-cases.
  *///!< this node does not have a mempool so can't validate the transaction//!< violated mempool's fee/size/descendant/RBF/etc limits/**
     * Tx already in mempool or conflicts with a tx in the chain
     * (if it conflicts with another tx in mempool, we use MEMPOOL_POLICY as it failed to reach the RBF threshold)
     * Currently this is only used if the transaction already exists in the mempool or on chain.
     *//**
     * Transaction is missing a witness.
     *//**
     * Transaction might have a witness prior to SegWit
     * activation, or witness may have been malleated (which includes
     * non-standard witnesses).
     *///!< transaction spends a coinbase too early, or violates locktime/sequence locks//!< transaction was missing some of its inputs//!< otherwise didn't meet our local policy rules//!< inputs (covered by txid) failed policy rules//!< invalid by consensus rules//!< initial value. Tx has not yet been rejected/** A "reason" why a transaction was invalid, suitable for determining whether the
  * provider of the transaction should be banned/ignored/disconnected/etc.
  *//** Minimum size of a witness commitment structure. Defined in BIP 141. **//** Index marker for when no witness commitment is present in a coinbase transaction. *//home/tanteikg/QCVE/sources/bitcoin/src/consensusreject_reasondebug_message/home/tanteikg/QCVE/sources/bitcoin/src/consensus/merkle.h/home/tanteikg/QCVE/sources/bitcoin/src/pow.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/duplicate_inputs.cpp<pow.h><consensus/merkle.h>DuplicateInputsSCRIPT_PUBcoinbaseTxnaughtyTxcs_mainbench/duplicate_inputs.cppconst ChainstateManagerconst ChainstateManager *ChainstateManager *pindexPrev != nullptrvoid DuplicateInputs(ankerl::nanobench::Bench &)n_inputs4000000MAX_BLOCK_SERIALIZED_SIZEMAX_BLOCK_SERIALIZED_SIZE / WITNESS_SCALE_FACTOR(MAX_BLOCK_SERIALIZED_SIZE / WITNESS_SCALE_FACTOR)!CheckBlock(block, cvstate, chainparams.GetConsensus(), false, false)cvstate.GetRejectReason() == "bad-txns-inputs-duplicate"lambda [] type at line 296230, col. 15const lambda [] type at line 296230, col. 15const lambda [] type at line 296230, col. 15 &lambda [] type at line 296230, col. 15 &lambda [] type at line 296230, col. 15 &&const lambda [] type at line 296230, col. 15 *lambda [] type at line 296230, col. 15 *cvstateconst ValidationState<BlockValidationResult>bad-txns-inputs-duplicateconst char[57]char[57]bench_65DuplicateInputsPASTE2(__LINE__, DuplicateInputs)65DuplicateInputs// Make a coinbase TXvector<CTxIn, allocator<CTxIn>> *_Vector_base<CTxIn, allocator<CTxIn>> *allocator<CTxIn> &const vector<CTxIn, allocator<CTxIn>> *const __normal_iterator<CTxIn *, vector<CTxIn, allocator<CTxIn>>>const __normal_iterator<CTxIn *, vector<CTxIn, allocator<CTxIn>>> &__normal_iterator<CTxIn *, vector<CTxIn, allocator<CTxIn>>> &CTxIn *constCTxIn *const &CTxIn *&is_nothrow_constructible<CTxIn, CTxIn &>is_nothrow_constructible<CTxIn, CTxIn &> &is_nothrow_constructible<CTxIn, CTxIn &> &&const is_nothrow_constructible<CTxIn, CTxIn &>const is_nothrow_constructible<CTxIn, CTxIn &> &is_nothrow_constructible<CTxIn, uint256, int, CScript, int>is_nothrow_constructible<CTxIn, uint256, int, CScript, int> &is_nothrow_constructible<CTxIn, uint256, int, CScript, int> &&const is_nothrow_constructible<CTxIn, uint256, int, CScript, int>const is_nothrow_constructible<CTxIn, uint256, int, CScript, int> &/usr/include/c++/9/math.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/examples.cppTrig 0.01lambda [] type at line 132824, col. 15const lambda [] type at line 132824, col. 15const lambda [] type at line 132824, col. 15 &lambda [] type at line 132824, col. 15 &lambda [] type at line 132824, col. 15 &&const lambda [] type at line 132824, col. 15 *lambda [] type at line 132824, col. 15 *volatile doublebench_21TrigPASTE2(__LINE__, Trig)21Trig// volatile, global so not optimized away// Extremely fast-running benchmark:const _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true>const _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true> *_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true> *_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> */home/tanteikg/QCVE/sources/bitcoin/src/bench/gcs_filter.cppGCSFilterMatchelementsBASIC_FILTER_P784931BASIC_FILTER_Mlambda [] type at line 150005, col. 15const lambda [] type at line 150005, col. 15const lambda [] type at line 150005, col. 15 &lambda [] type at line 150005, col. 15 &lambda [] type at line 150005, col. 15 &&GCSFilter &unordered_set<vector<unsigned char, allocator<unsigned char>>, ByteVectorHash, equal_to<vector<unsigned char, allocator<unsigned char>>>, allocator<vector<unsigned char, allocator<unsigned char>>>> *~GCSFilterGCSFilter *GCSFilterDecodeSkipCheckencodedconst GCSFilterlambda [] type at line 149994, col. 15const lambda [] type at line 149994, col. 15const lambda [] type at line 149994, col. 15 &lambda [] type at line 149994, col. 15 &lambda [] type at line 149994, col. 15 &&GCSFilterDecodelambda [] type at line 149982, col. 15const lambda [] type at line 149982, col. 15const lambda [] type at line 149982, col. 15 &lambda [] type at line 149982, col. 15 &lambda [] type at line 149982, col. 15 &&GCSFilterConstructsiphash_k0lambda [] type at line 149968, col. 15const lambda [] type at line 149968, col. 15const lambda [] type at line 149968, col. 15 &lambda [] type at line 149968, col. 15 &lambda [] type at line 149968, col. 15 &&ElementSet &GCSBlockFilterGetHashblock_filterBlockFilterType::BASIClambda [] type at line 149958, col. 15const lambda [] type at line 149958, col. 15const lambda [] type at line 149958, col. 15 &lambda [] type at line 149958, col. 15 &lambda [] type at line 149958, col. 15 &&BlockFilter &~BlockFilterBlockFilter *GenerateGCSTestElements100000elementElement &const lambda [] type at line 150005, col. 15 *lambda [] type at line 150005, col. 15 *const Elementconst Element &const lambda [] type at line 149994, col. 15 *lambda [] type at line 149994, col. 15 *const lambda [] type at line 149982, col. 15 *lambda [] type at line 149982, col. 15 *const lambda [] type at line 149968, col. 15 *lambda [] type at line 149968, col. 15 *const lambda [] type at line 149958, col. 15 *lambda [] type at line 149958, col. 15 *const BlockFilterbench_88GCSFilterMatchPASTE2(__LINE__, GCSFilterMatch)88GCSFilterMatchbench_87GCSFilterDecodeSkipCheckPASTE2(__LINE__, GCSFilterDecodeSkipCheck)87GCSFilterDecodeSkipCheckbench_86GCSFilterDecodePASTE2(__LINE__, GCSFilterDecode)86GCSFilterDecodebench_85GCSFilterConstructPASTE2(__LINE__, GCSFilterConstruct)85GCSFilterConstructbench_84GCSBlockFilterGetHashPASTE2(__LINE__, GCSBlockFilterGetHash)84GCSBlockFilterGetHash/*skip_decode_check=*/// filter element takes to process.// ns/op. This makes it easy to reason about how long (in nanoseconds) a single// with at least 100,000 elements results in benchmarks that have the same// Testing the benchmarks with different number of elements show that a filter_Node_const_iterator<vector<unsigned char, allocator<unsigned char>>, true, true>pair<_Node_const_iterator<vector<unsigned char, allocator<unsigned char>>, true, true>, _Node_const_iterator<vector<unsigned char, allocator<unsigned char>>, true, true>>/home/tanteikg/QCVE/sources/bitcoin/src/bench/hashpadding.cppRegularPaddednoncelambda [] type at line 129388, col. 15const lambda [] type at line 129388, col. 15const lambda [] type at line 129388, col. 15 &lambda [] type at line 129388, col. 15 &lambda [] type at line 129388, col. 15 &&PrePaddedlambda [] type at line 129371, col. 15const lambda [] type at line 129371, col. 15const lambda [] type at line 129371, col. 15 &lambda [] type at line 129371, col. 15 &lambda [] type at line 129371, col. 15 &&const lambda [] type at line 129388, col. 15 *lambda [] type at line 129388, col. 15 *const lambda [] type at line 129371, col. 15 *lambda [] type at line 129371, col. 15 *bench_47RegularPaddedPASTE2(__LINE__, RegularPadded)47RegularPaddedbench_29PrePaddedPASTE2(__LINE__, PrePadded)29PrePadded// Setup the salted hasher/home/tanteikg/QCVE/sources/bitcoin/src/bench/load_external.cppLoadExternalBlockFileblkfileblk.dat"blk.dat"paramsCChainParams *Params *BIP9Deployment[2]vector<unsigned char, allocator<unsigned char>>[5]CCheckpointDataconst CCheckpointDataconst CCheckpointData &CCheckpointData &CCheckpointData *wb+"wb+"node::MAX_BLOCKFILE_SIZEwrite to test file failed
"write to test file failed\n"blocks_with_unknown_parentlambda [] type at line 296181, col. 15const lambda [] type at line 296181, col. 15const lambda [] type at line 296181, col. 15 &lambda [] type at line 296181, col. 15 &lambda [] type at line 296181, col. 15 &&FlatFilePos &multimap<uint256, FlatFilePos, less<uint256>, allocator<pair<const uint256, FlatFilePos>>> &~CChainParams~CCheckpointData~Paramsconst lambda [] type at line 296181, col. 15 *lambda [] type at line 296181, col. 15 *FlatFilePos *multimap<uint256, FlatFilePos, less<uint256>, allocator<pair<const uint256, FlatFilePos>>> *bench_63LoadExternalBlockFilePASTE2(__LINE__, LoadExternalBlockFile)63LoadExternalBlockFile// The file will be closed by LoadExternalBlockFile().// "rb" is "binary, O_RDONLY", positioned to the start of the file.// Make the test block file about 128 MB in length.// "wb+" is "binary, O_RDWR | O_CREAT | O_TRUNC".// Create the test file.// because that first writes a compact size.// We can't use the streaming serialization (ss << benchmark::data::block413567)// block data) as a stream object.// Create a single block as in the blocks files (magic bytes, block size,/**
 * The LoadExternalBlockFile() function is used during -reindex and -loadblock.
 *
 * Create a test file that's similar to a datadir/blocks/blk?????.dat file,
 * It contains around 134 copies of the same block (typical size of real block files).
 * For each block in the file, LoadExternalBlockFile() won't find its parent,
 * and so will skip the block. (In the real system, it will re-read the block
 * from disk later when it encounters its parent.)
 *
 * This benchmark measures the performance of deserializing the block (or just
 * its header, beginning with PR 16981).
 */const map<int, const AssumeutxoData, less<int>, allocator<pair<const int, const AssumeutxoData>>>const map<int, const AssumeutxoData, less<int>, allocator<pair<const int, const AssumeutxoData>>> &map<int, const AssumeutxoData, less<int>, allocator<pair<const int, const AssumeutxoData>>> &map<int, const AssumeutxoData, less<int>, allocator<pair<const int, const AssumeutxoData>>> *const map<int, uint256, less<int>, allocator<pair<const int, uint256>>>const map<int, uint256, less<int>, allocator<pair<const int, uint256>>> &map<int, uint256, less<int>, allocator<pair<const int, uint256>>> &map<int, uint256, less<int>, allocator<pair<const int, uint256>>> *_Rb_tree<int, pair<const int, uint256>, _Select1st<pair<const int, uint256>>, less<int>, allocator<pair<const int, uint256>>> *_Rb_tree<int, pair<const int, const AssumeutxoData>, _Select1st<pair<const int, const AssumeutxoData>>, less<int>, allocator<pair<const int, const AssumeutxoData>>> *const allocator<_Rb_tree_node<pair<const int, const AssumeutxoData>>>const allocator<_Rb_tree_node<pair<const int, const AssumeutxoData>>> &allocator<_Rb_tree_node<pair<const int, const AssumeutxoData>>> &const _Rb_tree_key_compare<less<int>>const _Rb_tree<int, pair<const int, const AssumeutxoData>, _Select1st<pair<const int, const AssumeutxoData>>, less<int>, allocator<pair<const int, const AssumeutxoData>>> *const allocator<_Rb_tree_node<pair<const int, uint256>>>const allocator<_Rb_tree_node<pair<const int, uint256>>> &allocator<_Rb_tree_node<pair<const int, uint256>>> &const _Rb_tree<int, pair<const int, uint256>, _Select1st<pair<const int, uint256>>, less<int>, allocator<pair<const int, uint256>>> *const _Rb_tree_node<pair<const int, const AssumeutxoData>>const _Rb_tree_node<pair<const int, const AssumeutxoData>> *_Rb_tree_node<pair<const int, const AssumeutxoData>> *const _Rb_tree_node<pair<const int, uint256>>const _Rb_tree_node<pair<const int, uint256>> *_Rb_tree_node<pair<const int, uint256>> *const pair<const int, uint256>const pair<const int, uint256> &pair<const int, uint256> &const pair<const int, uint256> *pair<const int, uint256> *const pair<const int, const AssumeutxoData>const pair<const int, const AssumeutxoData> &pair<const int, const AssumeutxoData> &const pair<const int, const AssumeutxoData> *pair<const int, const AssumeutxoData> */home/tanteikg/QCVE/sources/bitcoin/src/bench/lockedpool.cpp<support/lockedpool.h>BenchLockedPoolsynth_base0x08000000reinterpret_cast<void*>(0x08000000)synth_sizeASIZE3054198960x12345678lambda [] type at line 125557, col. 15const lambda [] type at line 125557, col. 15const lambda [] type at line 125557, col. 15 &lambda [] type at line 125557, col. 15 &lambda [] type at line 125557, col. 15 &&vector<void *, allocator<void *>> &Arena &const __normal_iterator<void **, vector<void *, allocator<void *>>>const __normal_iterator<void **, vector<void *, allocator<void *>>> &__normal_iterator<void **, vector<void *, allocator<void *>>> &const lambda [] type at line 125557, col. 15 *lambda [] type at line 125557, col. 15 *const vector<void *, allocator<void *>>0x80000000MSIZE(MSIZE - 1)lsb40275151200xf00f00f0bench_40BenchLockedPoolPASTE2(__LINE__, BenchLockedPool)40BenchLockedPool// LFSR period 0xf7ffffe0allocator<void *> &vector<void *, allocator<void *>> *void *constvoid *const &void **constvoid **const &void **&_Vector_base<void *, allocator<void *>> *const allocator<void *>const allocator<void *> &allocator<void *> *const new_allocator<void *>const new_allocator<void *> &new_allocator<void *> &__enable_if<true, void **>__enable_if<true, void **> &__enable_if<true, void **> &&const __enable_if<true, void **>const __enable_if<true, void **> &new_allocator<void *> *is_copy_assignable<void *>is_copy_assignable<void *> &is_copy_assignable<void *> &&const is_copy_assignable<void *>const is_copy_assignable<void *> &__traitor<__is_arithmetic<void *>, __is_pointer<void *>>__traitor<__is_arithmetic<void *>, __is_pointer<void *>> &const __traitor<__is_arithmetic<void *>, __is_pointer<void *>>const __traitor<__is_arithmetic<void *>, __is_pointer<void *>> &__traitor<__is_arithmetic<void *>, __is_pointer<void *>> &&__traitor<__is_integer<void *>, __is_floating<void *>>__traitor<__is_integer<void *>, __is_floating<void *>> &const __traitor<__is_integer<void *>, __is_floating<void *>>const __traitor<__is_integer<void *>, __is_floating<void *>> &__traitor<__is_integer<void *>, __is_floating<void *>> &&__is_pointer<void *>__is_pointer<void *> &const __is_pointer<void *>const __is_pointer<void *> &__is_pointer<void *> &&__is_arithmetic<void *>__is_arithmetic__is_arithmetic<void *> &__is_arithmetic<void *> &&const __is_arithmetic<void *>const __is_arithmetic<void *> &__is_copy_assignable_impl<void *, true>__is_copy_assignable_impl<void *, true> &__is_copy_assignable_impl<void *, true> &&const __is_copy_assignable_impl<void *, true>const __is_copy_assignable_impl<void *, true> &is_assignable<void *&, void *const &>is_assignable<void *&, void *const &> &is_assignable<void *&, void *const &> &&const is_assignable<void *&, void *const &>const is_assignable<void *&, void *const &> &__is_floating<void *>__is_floating<void *> &const __is_floating<void *>const __is_floating<void *> &__is_floating<void *> &&__is_integer<void *>__is_integer<void *> &const __is_integer<void *>const __is_integer<void *> &__is_integer<void *> &&/home/tanteikg/QCVE/sources/bitcoin/src/bench/logging.cppLogWithoutWriteToFile"%s\n", "test"-debug=1"-debug=1"lambda [] type at line 153818, col. 53const lambda [] type at line 153818, col. 53const lambda [] type at line 153818, col. 53 &lambda [] type at line 153818, col. 53 &lambda [] type at line 153818, col. 53 &&const lambda [] type at line 153818, col. 53 *lambda [] type at line 153818, col. 53 *LogPrintfWithoutThreadNamesconst char *const[1]char *[1]-logthreadnames=0"-logthreadnames=0"lambda [] type at line 153812, col. 43const lambda [] type at line 153812, col. 43const lambda [] type at line 153812, col. 43 &lambda [] type at line 153812, col. 43 &lambda [] type at line 153812, col. 43 &&const lambda [] type at line 153812, col. 43 *lambda [] type at line 153812, col. 43 *LogPrintfWithThreadNames-logthreadnames=1"-logthreadnames=1"lambda [] type at line 153807, col. 43const lambda [] type at line 153807, col. 43const lambda [] type at line 153807, col. 43 &lambda [] type at line 153807, col. 43 &lambda [] type at line 153807, col. 43 &&const lambda [] type at line 153807, col. 43 *lambda [] type at line 153807, col. 43 *LogPrintfCategoryWithoutThreadNames-debug=net"-debug=net"lambda [] type at line 153800, col. 57const lambda [] type at line 153800, col. 57const lambda [] type at line 153800, col. 57 &lambda [] type at line 153800, col. 57 &lambda [] type at line 153800, col. 57 &&const lambda [] type at line 153800, col. 57 *lambda [] type at line 153800, col. 57 *LogPrintfCategoryWithThreadNameslambda [] type at line 153793, col. 57const lambda [] type at line 153793, col. 57const lambda [] type at line 153793, col. 57 &lambda [] type at line 153793, col. 57 &lambda [] type at line 153793, col. 57 &&const lambda [] type at line 153793, col. 57 *lambda [] type at line 153793, col. 57 *LogPrintWithoutCategory-debug=0"-debug=0"lambda [] type at line 153788, col. 55const lambda [] type at line 153788, col. 55const lambda [] type at line 153788, col. 55 &lambda [] type at line 153788, col. 55 &lambda [] type at line 153788, col. 55 &&const lambda [] type at line 153788, col. 55 *lambda [] type at line 153788, col. 55 *LogPrintWithCategorylambda [] type at line 153783, col. 57const lambda [] type at line 153783, col. 57const lambda [] type at line 153783, col. 57 &lambda [] type at line 153783, col. 57 &lambda [] type at line 153783, col. 57 &&const lambda [] type at line 153783, col. 57 *lambda [] type at line 153783, col. 57 *LogPrintLevelWithoutThreadNamesBCLog::Level::Errorlambda [] type at line 153777, col. 57const lambda [] type at line 153777, col. 57const lambda [] type at line 153777, col. 57 &lambda [] type at line 153777, col. 57 &lambda [] type at line 153777, col. 57 &&const lambda [] type at line 153777, col. 57 *lambda [] type at line 153777, col. 57 *LogPrintLevelWithThreadNameslambda [] type at line 153771, col. 57const lambda [] type at line 153771, col. 57const lambda [] type at line 153771, col. 57 &lambda [] type at line 153771, col. 57 &lambda [] type at line 153771, col. 57 &&const lambda [] type at line 153771, col. 57 *lambda [] type at line 153771, col. 57 *Logginglambda [] type at line 153766, col. 15const lambda [] type at line 153766, col. 15const lambda [] type at line 153766, col. 15 &lambda [] type at line 153766, col. 15 &lambda [] type at line 153766, col. 15 &&const lambda [] type at line 153766, col. 15 *lambda [] type at line 153766, col. 15 *bench/logging.cpptestbench_91LogWithoutWriteToFilePASTE2(__LINE__, LogWithoutWriteToFile)91LogWithoutWriteToFilebench_90LogPrintfWithoutThreadNamesPASTE2(__LINE__, LogPrintfWithoutThreadNames)90LogPrintfWithoutThreadNamesbench_89LogPrintfWithThreadNamesPASTE2(__LINE__, LogPrintfWithThreadNames)89LogPrintfWithThreadNamesbench_88LogPrintfCategoryWithoutThreadNamesPASTE2(__LINE__, LogPrintfCategoryWithoutThreadNames)88LogPrintfCategoryWithoutThreadNamesbench_87LogPrintfCategoryWithThreadNamesPASTE2(__LINE__, LogPrintfCategoryWithThreadNames)87LogPrintfCategoryWithThreadNamesbench_86LogPrintWithoutCategoryPASTE2(__LINE__, LogPrintWithoutCategory)86LogPrintWithoutCategorybench_85LogPrintWithCategoryPASTE2(__LINE__, LogPrintWithCategory)85LogPrintWithCategorybench_84LogPrintLevelWithoutThreadNamesPASTE2(__LINE__, LogPrintLevelWithoutThreadNames)84LogPrintLevelWithoutThreadNamesbench_83LogPrintLevelWithThreadNamesPASTE2(__LINE__, LogPrintLevelWithThreadNames)83LogPrintLevelWithThreadNames// Disable writing the log to a file, as used for unit tests and fuzzing in `MakeNoLogFileContext`.// Reset any enabled logging categories from a previous benchmark run.// LogWithoutWriteToFile should be ~2 orders of magnitude faster, as it avoids disk writes.// LogPrintWithoutCategory should be ~3 orders of magnitude faster, as nothing is logged.// All but 2 of the benchmarks should have roughly similar performance:_Base_manager<lambda [] type at line 153818, col. 53>_Base_manager<lambda [] type at line 153818, col. 53> &_Base_manager<lambda [] type at line 153818, col. 53> &&const _Base_manager<lambda [] type at line 153818, col. 53>const _Base_manager<lambda [] type at line 153818, col. 53> &_Base_manager<lambda [] type at line 153812, col. 43>_Base_manager<lambda [] type at line 153812, col. 43> &_Base_manager<lambda [] type at line 153812, col. 43> &&const _Base_manager<lambda [] type at line 153812, col. 43>const _Base_manager<lambda [] type at line 153812, col. 43> &_Base_manager<lambda [] type at line 153807, col. 43>_Base_manager<lambda [] type at line 153807, col. 43> &_Base_manager<lambda [] type at line 153807, col. 43> &&const _Base_manager<lambda [] type at line 153807, col. 43>const _Base_manager<lambda [] type at line 153807, col. 43> &_Base_manager<lambda [] type at line 153800, col. 57>_Base_manager<lambda [] type at line 153800, col. 57> &_Base_manager<lambda [] type at line 153800, col. 57> &&const _Base_manager<lambda [] type at line 153800, col. 57>const _Base_manager<lambda [] type at line 153800, col. 57> &_Base_manager<lambda [] type at line 153793, col. 57>_Base_manager<lambda [] type at line 153793, col. 57> &_Base_manager<lambda [] type at line 153793, col. 57> &&const _Base_manager<lambda [] type at line 153793, col. 57>const _Base_manager<lambda [] type at line 153793, col. 57> &_Base_manager<lambda [] type at line 153788, col. 55>_Base_manager<lambda [] type at line 153788, col. 55> &_Base_manager<lambda [] type at line 153788, col. 55> &&const _Base_manager<lambda [] type at line 153788, col. 55>const _Base_manager<lambda [] type at line 153788, col. 55> &_Base_manager<lambda [] type at line 153783, col. 57>_Base_manager<lambda [] type at line 153783, col. 57> &_Base_manager<lambda [] type at line 153783, col. 57> &&const _Base_manager<lambda [] type at line 153783, col. 57>const _Base_manager<lambda [] type at line 153783, col. 57> &_Base_manager<lambda [] type at line 153777, col. 57>_Base_manager<lambda [] type at line 153777, col. 57> &_Base_manager<lambda [] type at line 153777, col. 57> &&const _Base_manager<lambda [] type at line 153777, col. 57>const _Base_manager<lambda [] type at line 153777, col. 57> &_Base_manager<lambda [] type at line 153771, col. 57>_Base_manager<lambda [] type at line 153771, col. 57> &_Base_manager<lambda [] type at line 153771, col. 57> &&const _Base_manager<lambda [] type at line 153771, col. 57>const _Base_manager<lambda [] type at line 153771, col. 57> &lambda [] type at line 153771, col. 57 *&lambda [] type at line 153771, col. 57 **lambda [] type at line 153777, col. 57 *&lambda [] type at line 153777, col. 57 **lambda [] type at line 153783, col. 57 *&lambda [] type at line 153783, col. 57 **lambda [] type at line 153788, col. 55 *&lambda [] type at line 153788, col. 55 **lambda [] type at line 153793, col. 57 *&lambda [] type at line 153793, col. 57 **lambda [] type at line 153800, col. 57 *&lambda [] type at line 153800, col. 57 **lambda [] type at line 153807, col. 43 *&lambda [] type at line 153807, col. 43 **lambda [] type at line 153812, col. 43 *&lambda [] type at line 153812, col. 43 **lambda [] type at line 153818, col. 53 *&lambda [] type at line 153818, col. 53 **_Function_handler<..(..), lambda [] type at line 153818, col. 53>_Function_handler<..(..), lambda [] type at line 153818, col. 53> &_Function_handler<..(..), lambda [] type at line 153818, col. 53> &&const _Function_handler<..(..), lambda [] type at line 153818, col. 53>const _Function_handler<..(..), lambda [] type at line 153818, col. 53> &_Function_handler<..(..), lambda [] type at line 153812, col. 43>_Function_handler<..(..), lambda [] type at line 153812, col. 43> &_Function_handler<..(..), lambda [] type at line 153812, col. 43> &&const _Function_handler<..(..), lambda [] type at line 153812, col. 43>const _Function_handler<..(..), lambda [] type at line 153812, col. 43> &_Function_handler<..(..), lambda [] type at line 153807, col. 43>_Function_handler<..(..), lambda [] type at line 153807, col. 43> &_Function_handler<..(..), lambda [] type at line 153807, col. 43> &&const _Function_handler<..(..), lambda [] type at line 153807, col. 43>const _Function_handler<..(..), lambda [] type at line 153807, col. 43> &_Function_handler<..(..), lambda [] type at line 153800, col. 57>_Function_handler<..(..), lambda [] type at line 153800, col. 57> &_Function_handler<..(..), lambda [] type at line 153800, col. 57> &&const _Function_handler<..(..), lambda [] type at line 153800, col. 57>const _Function_handler<..(..), lambda [] type at line 153800, col. 57> &_Function_handler<..(..), lambda [] type at line 153793, col. 57>_Function_handler<..(..), lambda [] type at line 153793, col. 57> &_Function_handler<..(..), lambda [] type at line 153793, col. 57> &&const _Function_handler<..(..), lambda [] type at line 153793, col. 57>const _Function_handler<..(..), lambda [] type at line 153793, col. 57> &_Function_handler<..(..), lambda [] type at line 153788, col. 55>_Function_handler<..(..), lambda [] type at line 153788, col. 55> &_Function_handler<..(..), lambda [] type at line 153788, col. 55> &&const _Function_handler<..(..), lambda [] type at line 153788, col. 55>const _Function_handler<..(..), lambda [] type at line 153788, col. 55> &_Function_handler<..(..), lambda [] type at line 153783, col. 57>_Function_handler<..(..), lambda [] type at line 153783, col. 57> &_Function_handler<..(..), lambda [] type at line 153783, col. 57> &&const _Function_handler<..(..), lambda [] type at line 153783, col. 57>const _Function_handler<..(..), lambda [] type at line 153783, col. 57> &_Function_handler<..(..), lambda [] type at line 153777, col. 57>_Function_handler<..(..), lambda [] type at line 153777, col. 57> &_Function_handler<..(..), lambda [] type at line 153777, col. 57> &&const _Function_handler<..(..), lambda [] type at line 153777, col. 57>const _Function_handler<..(..), lambda [] type at line 153777, col. 57> &_Function_handler<..(..), lambda [] type at line 153771, col. 57>_Function_handler<..(..), lambda [] type at line 153771, col. 57> &_Function_handler<..(..), lambda [] type at line 153771, col. 57> &&const _Function_handler<..(..), lambda [] type at line 153771, col. 57>const _Function_handler<..(..), lambda [] type at line 153771, col. 57> &_Callable<lambda [] type at line 153818, col. 53, __invoke_result<lambda [] type at line 153818, col. 53 &>>_Callable<lambda [] type at line 153818, col. 53, __invoke_result<lambda [] type at line 153818, col. 53 &>> &_Callable<lambda [] type at line 153818, col. 53, __invoke_result<lambda [] type at line 153818, col. 53 &>> &&const _Callable<lambda [] type at line 153818, col. 53, __invoke_result<lambda [] type at line 153818, col. 53 &>>const _Callable<lambda [] type at line 153818, col. 53, __invoke_result<lambda [] type at line 153818, col. 53 &>> &_Callable<lambda [] type at line 153812, col. 43, __invoke_result<lambda [] type at line 153812, col. 43 &>>_Callable<lambda [] type at line 153812, col. 43, __invoke_result<lambda [] type at line 153812, col. 43 &>> &_Callable<lambda [] type at line 153812, col. 43, __invoke_result<lambda [] type at line 153812, col. 43 &>> &&const _Callable<lambda [] type at line 153812, col. 43, __invoke_result<lambda [] type at line 153812, col. 43 &>>const _Callable<lambda [] type at line 153812, col. 43, __invoke_result<lambda [] type at line 153812, col. 43 &>> &_Callable<lambda [] type at line 153807, col. 43, __invoke_result<lambda [] type at line 153807, col. 43 &>>_Callable<lambda [] type at line 153807, col. 43, __invoke_result<lambda [] type at line 153807, col. 43 &>> &_Callable<lambda [] type at line 153807, col. 43, __invoke_result<lambda [] type at line 153807, col. 43 &>> &&const _Callable<lambda [] type at line 153807, col. 43, __invoke_result<lambda [] type at line 153807, col. 43 &>>const _Callable<lambda [] type at line 153807, col. 43, __invoke_result<lambda [] type at line 153807, col. 43 &>> &_Callable<lambda [] type at line 153800, col. 57, __invoke_result<lambda [] type at line 153800, col. 57 &>>_Callable<lambda [] type at line 153800, col. 57, __invoke_result<lambda [] type at line 153800, col. 57 &>> &_Callable<lambda [] type at line 153800, col. 57, __invoke_result<lambda [] type at line 153800, col. 57 &>> &&const _Callable<lambda [] type at line 153800, col. 57, __invoke_result<lambda [] type at line 153800, col. 57 &>>const _Callable<lambda [] type at line 153800, col. 57, __invoke_result<lambda [] type at line 153800, col. 57 &>> &_Callable<lambda [] type at line 153793, col. 57, __invoke_result<lambda [] type at line 153793, col. 57 &>>_Callable<lambda [] type at line 153793, col. 57, __invoke_result<lambda [] type at line 153793, col. 57 &>> &_Callable<lambda [] type at line 153793, col. 57, __invoke_result<lambda [] type at line 153793, col. 57 &>> &&const _Callable<lambda [] type at line 153793, col. 57, __invoke_result<lambda [] type at line 153793, col. 57 &>>const _Callable<lambda [] type at line 153793, col. 57, __invoke_result<lambda [] type at line 153793, col. 57 &>> &_Callable<lambda [] type at line 153788, col. 55, __invoke_result<lambda [] type at line 153788, col. 55 &>>_Callable<lambda [] type at line 153788, col. 55, __invoke_result<lambda [] type at line 153788, col. 55 &>> &_Callable<lambda [] type at line 153788, col. 55, __invoke_result<lambda [] type at line 153788, col. 55 &>> &&const _Callable<lambda [] type at line 153788, col. 55, __invoke_result<lambda [] type at line 153788, col. 55 &>>const _Callable<lambda [] type at line 153788, col. 55, __invoke_result<lambda [] type at line 153788, col. 55 &>> &_Callable<lambda [] type at line 153783, col. 57, __invoke_result<lambda [] type at line 153783, col. 57 &>>_Callable<lambda [] type at line 153783, col. 57, __invoke_result<lambda [] type at line 153783, col. 57 &>> &_Callable<lambda [] type at line 153783, col. 57, __invoke_result<lambda [] type at line 153783, col. 57 &>> &&const _Callable<lambda [] type at line 153783, col. 57, __invoke_result<lambda [] type at line 153783, col. 57 &>>const _Callable<lambda [] type at line 153783, col. 57, __invoke_result<lambda [] type at line 153783, col. 57 &>> &_Callable<lambda [] type at line 153777, col. 57, __invoke_result<lambda [] type at line 153777, col. 57 &>>_Callable<lambda [] type at line 153777, col. 57, __invoke_result<lambda [] type at line 153777, col. 57 &>> &_Callable<lambda [] type at line 153777, col. 57, __invoke_result<lambda [] type at line 153777, col. 57 &>> &&const _Callable<lambda [] type at line 153777, col. 57, __invoke_result<lambda [] type at line 153777, col. 57 &>>const _Callable<lambda [] type at line 153777, col. 57, __invoke_result<lambda [] type at line 153777, col. 57 &>> &_Callable<lambda [] type at line 153771, col. 57, __invoke_result<lambda [] type at line 153771, col. 57 &>>_Callable<lambda [] type at line 153771, col. 57, __invoke_result<lambda [] type at line 153771, col. 57 &>> &_Callable<lambda [] type at line 153771, col. 57, __invoke_result<lambda [] type at line 153771, col. 57 &>> &&const _Callable<lambda [] type at line 153771, col. 57, __invoke_result<lambda [] type at line 153771, col. 57 &>>const _Callable<lambda [] type at line 153771, col. 57, __invoke_result<lambda [] type at line 153771, col. 57 &>> &__invoke_result<lambda [] type at line 153771, col. 57 &>__invoke_result<lambda [] type at line 153771, col. 57 &> &__invoke_result<lambda [] type at line 153771, col. 57 &> &&const __invoke_result<lambda [] type at line 153771, col. 57 &>const __invoke_result<lambda [] type at line 153771, col. 57 &> &__invoke_result<lambda [] type at line 153777, col. 57 &>__invoke_result<lambda [] type at line 153777, col. 57 &> &__invoke_result<lambda [] type at line 153777, col. 57 &> &&const __invoke_result<lambda [] type at line 153777, col. 57 &>const __invoke_result<lambda [] type at line 153777, col. 57 &> &__invoke_result<lambda [] type at line 153783, col. 57 &>__invoke_result<lambda [] type at line 153783, col. 57 &> &__invoke_result<lambda [] type at line 153783, col. 57 &> &&const __invoke_result<lambda [] type at line 153783, col. 57 &>const __invoke_result<lambda [] type at line 153783, col. 57 &> &__invoke_result<lambda [] type at line 153788, col. 55 &>__invoke_result<lambda [] type at line 153788, col. 55 &> &__invoke_result<lambda [] type at line 153788, col. 55 &> &&const __invoke_result<lambda [] type at line 153788, col. 55 &>const __invoke_result<lambda [] type at line 153788, col. 55 &> &__invoke_result<lambda [] type at line 153793, col. 57 &>__invoke_result<lambda [] type at line 153793, col. 57 &> &__invoke_result<lambda [] type at line 153793, col. 57 &> &&const __invoke_result<lambda [] type at line 153793, col. 57 &>const __invoke_result<lambda [] type at line 153793, col. 57 &> &__invoke_result<lambda [] type at line 153800, col. 57 &>__invoke_result<lambda [] type at line 153800, col. 57 &> &__invoke_result<lambda [] type at line 153800, col. 57 &> &&const __invoke_result<lambda [] type at line 153800, col. 57 &>const __invoke_result<lambda [] type at line 153800, col. 57 &> &__invoke_result<lambda [] type at line 153807, col. 43 &>__invoke_result<lambda [] type at line 153807, col. 43 &> &__invoke_result<lambda [] type at line 153807, col. 43 &> &&const __invoke_result<lambda [] type at line 153807, col. 43 &>const __invoke_result<lambda [] type at line 153807, col. 43 &> &__invoke_result<lambda [] type at line 153812, col. 43 &>__invoke_result<lambda [] type at line 153812, col. 43 &> &__invoke_result<lambda [] type at line 153812, col. 43 &> &&const __invoke_result<lambda [] type at line 153812, col. 43 &>const __invoke_result<lambda [] type at line 153812, col. 43 &> &__invoke_result<lambda [] type at line 153818, col. 53 &>__invoke_result<lambda [] type at line 153818, col. 53 &> &__invoke_result<lambda [] type at line 153818, col. 53 &> &&const __invoke_result<lambda [] type at line 153818, col. 53 &>const __invoke_result<lambda [] type at line 153818, col. 53 &> &remove_reference<lambda [] type at line 153771, col. 57 &>remove_reference<lambda [] type at line 153771, col. 57 &> &remove_reference<lambda [] type at line 153771, col. 57 &> &&const remove_reference<lambda [] type at line 153771, col. 57 &>const remove_reference<lambda [] type at line 153771, col. 57 &> &remove_reference<lambda [] type at line 153777, col. 57 &>remove_reference<lambda [] type at line 153777, col. 57 &> &remove_reference<lambda [] type at line 153777, col. 57 &> &&const remove_reference<lambda [] type at line 153777, col. 57 &>const remove_reference<lambda [] type at line 153777, col. 57 &> &remove_reference<lambda [] type at line 153783, col. 57 &>remove_reference<lambda [] type at line 153783, col. 57 &> &remove_reference<lambda [] type at line 153783, col. 57 &> &&const remove_reference<lambda [] type at line 153783, col. 57 &>const remove_reference<lambda [] type at line 153783, col. 57 &> &remove_reference<lambda [] type at line 153788, col. 55 &>remove_reference<lambda [] type at line 153788, col. 55 &> &remove_reference<lambda [] type at line 153788, col. 55 &> &&const remove_reference<lambda [] type at line 153788, col. 55 &>const remove_reference<lambda [] type at line 153788, col. 55 &> &remove_reference<lambda [] type at line 153793, col. 57 &>remove_reference<lambda [] type at line 153793, col. 57 &> &remove_reference<lambda [] type at line 153793, col. 57 &> &&const remove_reference<lambda [] type at line 153793, col. 57 &>const remove_reference<lambda [] type at line 153793, col. 57 &> &remove_reference<lambda [] type at line 153800, col. 57 &>remove_reference<lambda [] type at line 153800, col. 57 &> &remove_reference<lambda [] type at line 153800, col. 57 &> &&const remove_reference<lambda [] type at line 153800, col. 57 &>const remove_reference<lambda [] type at line 153800, col. 57 &> &remove_reference<lambda [] type at line 153807, col. 43 &>remove_reference<lambda [] type at line 153807, col. 43 &> &remove_reference<lambda [] type at line 153807, col. 43 &> &&const remove_reference<lambda [] type at line 153807, col. 43 &>const remove_reference<lambda [] type at line 153807, col. 43 &> &remove_reference<lambda [] type at line 153812, col. 43 &>remove_reference<lambda [] type at line 153812, col. 43 &> &remove_reference<lambda [] type at line 153812, col. 43 &> &&const remove_reference<lambda [] type at line 153812, col. 43 &>const remove_reference<lambda [] type at line 153812, col. 43 &> &remove_reference<lambda [] type at line 153818, col. 53 &>remove_reference<lambda [] type at line 153818, col. 53 &> &remove_reference<lambda [] type at line 153818, col. 53 &> &&const remove_reference<lambda [] type at line 153818, col. 53 &>const remove_reference<lambda [] type at line 153818, col. 53 &> &__result_of_impl<false, false, lambda [] type at line 153771, col. 57 &>__result_of_impl<false, false, lambda [] type at line 153771, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153771, col. 57 &> &&const __result_of_impl<false, false, lambda [] type at line 153771, col. 57 &>const __result_of_impl<false, false, lambda [] type at line 153771, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153777, col. 57 &>__result_of_impl<false, false, lambda [] type at line 153777, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153777, col. 57 &> &&const __result_of_impl<false, false, lambda [] type at line 153777, col. 57 &>const __result_of_impl<false, false, lambda [] type at line 153777, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153783, col. 57 &>__result_of_impl<false, false, lambda [] type at line 153783, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153783, col. 57 &> &&const __result_of_impl<false, false, lambda [] type at line 153783, col. 57 &>const __result_of_impl<false, false, lambda [] type at line 153783, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153788, col. 55 &>__result_of_impl<false, false, lambda [] type at line 153788, col. 55 &> &__result_of_impl<false, false, lambda [] type at line 153788, col. 55 &> &&const __result_of_impl<false, false, lambda [] type at line 153788, col. 55 &>const __result_of_impl<false, false, lambda [] type at line 153788, col. 55 &> &__result_of_impl<false, false, lambda [] type at line 153793, col. 57 &>__result_of_impl<false, false, lambda [] type at line 153793, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153793, col. 57 &> &&const __result_of_impl<false, false, lambda [] type at line 153793, col. 57 &>const __result_of_impl<false, false, lambda [] type at line 153793, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153800, col. 57 &>__result_of_impl<false, false, lambda [] type at line 153800, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153800, col. 57 &> &&const __result_of_impl<false, false, lambda [] type at line 153800, col. 57 &>const __result_of_impl<false, false, lambda [] type at line 153800, col. 57 &> &__result_of_impl<false, false, lambda [] type at line 153807, col. 43 &>__result_of_impl<false, false, lambda [] type at line 153807, col. 43 &> &__result_of_impl<false, false, lambda [] type at line 153807, col. 43 &> &&const __result_of_impl<false, false, lambda [] type at line 153807, col. 43 &>const __result_of_impl<false, false, lambda [] type at line 153807, col. 43 &> &__result_of_impl<false, false, lambda [] type at line 153812, col. 43 &>__result_of_impl<false, false, lambda [] type at line 153812, col. 43 &> &__result_of_impl<false, false, lambda [] type at line 153812, col. 43 &> &&const __result_of_impl<false, false, lambda [] type at line 153812, col. 43 &>const __result_of_impl<false, false, lambda [] type at line 153812, col. 43 &> &__result_of_impl<false, false, lambda [] type at line 153818, col. 53 &>__result_of_impl<false, false, lambda [] type at line 153818, col. 53 &> &__result_of_impl<false, false, lambda [] type at line 153818, col. 53 &> &&const __result_of_impl<false, false, lambda [] type at line 153818, col. 53 &>const __result_of_impl<false, false, lambda [] type at line 153818, col. 53 &> &conditional<false, is_move_assignable<const char *>, is_copy_assignable<const char *>>conditional<false, is_move_assignable<const char *>, is_copy_assignable<const char *>> &conditional<false, is_move_assignable<const char *>, is_copy_assignable<const char *>> &&const conditional<false, is_move_assignable<const char *>, is_copy_assignable<const char *>>const conditional<false, is_move_assignable<const char *>, is_copy_assignable<const char *>> &is_member_function_pointer<lambda [] type at line 153818, col. 53>is_member_function_pointer<lambda [] type at line 153818, col. 53> &is_member_function_pointer<lambda [] type at line 153818, col. 53> &&const is_member_function_pointer<lambda [] type at line 153818, col. 53>const is_member_function_pointer<lambda [] type at line 153818, col. 53> &is_member_object_pointer<lambda [] type at line 153818, col. 53>is_member_object_pointer<lambda [] type at line 153818, col. 53> &is_member_object_pointer<lambda [] type at line 153818, col. 53> &&const is_member_object_pointer<lambda [] type at line 153818, col. 53>const is_member_object_pointer<lambda [] type at line 153818, col. 53> &is_member_function_pointer<lambda [] type at line 153812, col. 43>is_member_function_pointer<lambda [] type at line 153812, col. 43> &is_member_function_pointer<lambda [] type at line 153812, col. 43> &&const is_member_function_pointer<lambda [] type at line 153812, col. 43>const is_member_function_pointer<lambda [] type at line 153812, col. 43> &is_member_object_pointer<lambda [] type at line 153812, col. 43>is_member_object_pointer<lambda [] type at line 153812, col. 43> &is_member_object_pointer<lambda [] type at line 153812, col. 43> &&const is_member_object_pointer<lambda [] type at line 153812, col. 43>const is_member_object_pointer<lambda [] type at line 153812, col. 43> &is_member_function_pointer<lambda [] type at line 153807, col. 43>is_member_function_pointer<lambda [] type at line 153807, col. 43> &is_member_function_pointer<lambda [] type at line 153807, col. 43> &&const is_member_function_pointer<lambda [] type at line 153807, col. 43>const is_member_function_pointer<lambda [] type at line 153807, col. 43> &is_member_object_pointer<lambda [] type at line 153807, col. 43>is_member_object_pointer<lambda [] type at line 153807, col. 43> &is_member_object_pointer<lambda [] type at line 153807, col. 43> &&const is_member_object_pointer<lambda [] type at line 153807, col. 43>const is_member_object_pointer<lambda [] type at line 153807, col. 43> &is_member_function_pointer<lambda [] type at line 153800, col. 57>is_member_function_pointer<lambda [] type at line 153800, col. 57> &is_member_function_pointer<lambda [] type at line 153800, col. 57> &&const is_member_function_pointer<lambda [] type at line 153800, col. 57>const is_member_function_pointer<lambda [] type at line 153800, col. 57> &is_member_object_pointer<lambda [] type at line 153800, col. 57>is_member_object_pointer<lambda [] type at line 153800, col. 57> &is_member_object_pointer<lambda [] type at line 153800, col. 57> &&const is_member_object_pointer<lambda [] type at line 153800, col. 57>const is_member_object_pointer<lambda [] type at line 153800, col. 57> &is_member_function_pointer<lambda [] type at line 153793, col. 57>is_member_function_pointer<lambda [] type at line 153793, col. 57> &is_member_function_pointer<lambda [] type at line 153793, col. 57> &&const is_member_function_pointer<lambda [] type at line 153793, col. 57>const is_member_function_pointer<lambda [] type at line 153793, col. 57> &is_member_object_pointer<lambda [] type at line 153793, col. 57>is_member_object_pointer<lambda [] type at line 153793, col. 57> &is_member_object_pointer<lambda [] type at line 153793, col. 57> &&const is_member_object_pointer<lambda [] type at line 153793, col. 57>const is_member_object_pointer<lambda [] type at line 153793, col. 57> &is_member_function_pointer<lambda [] type at line 153788, col. 55>is_member_function_pointer<lambda [] type at line 153788, col. 55> &is_member_function_pointer<lambda [] type at line 153788, col. 55> &&const is_member_function_pointer<lambda [] type at line 153788, col. 55>const is_member_function_pointer<lambda [] type at line 153788, col. 55> &is_member_object_pointer<lambda [] type at line 153788, col. 55>is_member_object_pointer<lambda [] type at line 153788, col. 55> &is_member_object_pointer<lambda [] type at line 153788, col. 55> &&const is_member_object_pointer<lambda [] type at line 153788, col. 55>const is_member_object_pointer<lambda [] type at line 153788, col. 55> &is_member_function_pointer<lambda [] type at line 153783, col. 57>is_member_function_pointer<lambda [] type at line 153783, col. 57> &is_member_function_pointer<lambda [] type at line 153783, col. 57> &&const is_member_function_pointer<lambda [] type at line 153783, col. 57>const is_member_function_pointer<lambda [] type at line 153783, col. 57> &is_member_object_pointer<lambda [] type at line 153783, col. 57>is_member_object_pointer<lambda [] type at line 153783, col. 57> &is_member_object_pointer<lambda [] type at line 153783, col. 57> &&const is_member_object_pointer<lambda [] type at line 153783, col. 57>const is_member_object_pointer<lambda [] type at line 153783, col. 57> &is_member_function_pointer<lambda [] type at line 153777, col. 57>is_member_function_pointer<lambda [] type at line 153777, col. 57> &is_member_function_pointer<lambda [] type at line 153777, col. 57> &&const is_member_function_pointer<lambda [] type at line 153777, col. 57>const is_member_function_pointer<lambda [] type at line 153777, col. 57> &is_member_object_pointer<lambda [] type at line 153777, col. 57>is_member_object_pointer<lambda [] type at line 153777, col. 57> &is_member_object_pointer<lambda [] type at line 153777, col. 57> &&const is_member_object_pointer<lambda [] type at line 153777, col. 57>const is_member_object_pointer<lambda [] type at line 153777, col. 57> &is_member_function_pointer<lambda [] type at line 153771, col. 57>is_member_function_pointer<lambda [] type at line 153771, col. 57> &is_member_function_pointer<lambda [] type at line 153771, col. 57> &&const is_member_function_pointer<lambda [] type at line 153771, col. 57>const is_member_function_pointer<lambda [] type at line 153771, col. 57> &is_member_object_pointer<lambda [] type at line 153771, col. 57>is_member_object_pointer<lambda [] type at line 153771, col. 57> &is_member_object_pointer<lambda [] type at line 153771, col. 57> &&const is_member_object_pointer<lambda [] type at line 153771, col. 57>const is_member_object_pointer<lambda [] type at line 153771, col. 57> &is_move_assignable<const char *>const lambda [] type at line 158100, col. 52const lambda [] type at line 158100, col. 52 &lambda [] type at line 158100, col. 52 &lambda [] type at line 158100, col. 52 &&const lambda [] type at line 158100, col. 52 *lambda [] type at line 158100, col. 52 *lambda [] type at line 158100, col. 52<boost/multi_index/sequenced_index.hpp><boost/multi_index/hashed_index.hpp><util/hasher.h><util/epochguard.h><policy/packages.h><kernel/mempool_entry.h><indirectmap.h><kernel/mempool_options.h><kernel/mempool_limits.h>RemovalReasonToStringconst MemPoolRemovalReasonconst MemPoolRemovalReason &MemPoolRemovalReason &TestLockPointValidityconst LockPointsconst LockPoints &LockPoints &DisconnectedBlockTransactions &const DisconnectedBlockTransactionsconst DisconnectedBlockTransactions &DisconnectedBlockTransactionsDisconnectedBlockTransactions *removeEntryconst shared_ptr<const CTransaction> &const bidir_node_iterator<sequenced_index_node<index_node_base<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>>sequenced_index<nth_layer<2, shared_ptr<const CTransaction>, indexed_by<hashed_unique<tag<txid_index, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, mempoolentry_txid, SaltedTxidHasher, na>, sequenced<tag<insertion_order, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>>, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, allocator<shared_ptr<const CTransaction>>>, v_item<insertion_order, vector0<na>, 0>> &removeForBlockconst vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>const vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>> &vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>> &const hashed_index<mempoolentry_txid, SaltedTxidHasher, equal_to<uint256>, nth_layer<1, shared_ptr<const CTransaction>, indexed_by<hashed_unique<tag<txid_index, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, mempoolentry_txid, SaltedTxidHasher, na>, sequenced<tag<insertion_order, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>>, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, allocator<shared_ptr<const CTransaction>>>, v_item<txid_index, vector0<na>, 0>, hashed_unique_tag>const __normal_iterator<const shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>const __normal_iterator<const shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>> &__normal_iterator<const shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>> &const hashed_index_iterator<hashed_index_node<sequenced_index_node<index_node_base<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>, hashed_unique_tag>, bucket_array<allocator<shared_ptr<const CTransaction>>>, hashed_index_global_iterator_tag>const hashed_index_iterator<hashed_index_node<sequenced_index_node<index_node_base<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>, hashed_unique_tag>, bucket_array<allocator<shared_ptr<const CTransaction>>>, hashed_index_global_iterator_tag> &hashed_index_iterator<hashed_index_node<sequenced_index_node<index_node_base<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>, hashed_unique_tag>, bucket_array<allocator<shared_ptr<const CTransaction>>>, hashed_index_global_iterator_tag> &addTransactionDynamicMemoryUsageconst DisconnectedBlockTransactions *sizeof(CTransactionRef)sizeof(void*)6 * sizeof(void*)sizeof(CTransactionRef) + 6 * sizeof(void*)~DisconnectedBlockTransactionsqueuedTx.empty()./txmempool.hconst char[73]char[73]DisconnectedBlockTransactions::~DisconnectedBlockTransactions() noexceptCCoinsViewMemPool &const CCoinsViewMemPoolconst CCoinsViewMemPool &~CCoinsViewMemPoolCCoinsViewMemPoolCCoinsViewMemPool &&PackageAddTransactionGetCoinCoin &CompareTxMemPoolEntryByScore &CompareTxMemPoolEntryByScore &&const CompareTxMemPoolEntryByScoreconst CompareTxMemPoolEntryByScore &const CompareTxMemPoolEntryByScore *CompareTxMemPoolEntryByScore *f1f2~CTxMemPoolvisitedm_epoch.guarded()const Epochconst char[808]char[808]bool CTxMemPool::visited(std::optional<boost::multi_index::detail::hashed_index_iterator<boost::multi_index::detail::hashed_index_node<boost::multi_index::detail::hashed_index_node<boost::multi_index::detail::ordered_index_node<boost::multi_index::detail::null_augment_policy, boost::multi_index::detail::ordered_index_node<boost::multi_index::detail::null_augment_policy, boost::multi_index::detail::ordered_index_node<boost::multi_index::detail::null_augment_policy, boost::multi_index::detail::index_node_base<CTxMemPoolEntry, std::allocator<CTxMemPoolEntry>>>>>, boost::multi_index::detail::hashed_unique_tag>, boost::multi_index::detail::hashed_unique_tag>, boost::multi_index::detail::bucket_array<std::allocator<CTxMemPoolEntry>>, boost::multi_index::detail::hashed_index_global_iterator_tag>>) constconst optional<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>Marker &removeUncheckedUpdateChildrenForRemovalUpdateForRemoveFromMempoolUpdateEntryForAncestorsUpdateAncestorsOfUpdateForDescendantscacheMap &map<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, set<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, CompareIteratorByHash, allocator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>>, CompareIteratorByHash, allocator<pair<const hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, set<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, CompareIteratorByHash, allocator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>>>>> &const set<uint256, less<uint256>, allocator<uint256>>const set<uint256, less<uint256>, allocator<uint256>> &set<uint256, less<uint256>, allocator<uint256>> &GetSequenceGetAndIncrementSequenceIsUnbroadcastTxGetUnbroadcastTxsRemoveUnbroadcastTxAddUnbroadcastTxinfoAllTxMempoolInfo &TxMempoolInfo &&const TxMempoolInfoconst TxMempoolInfo &~TxMempoolInfoTxMempoolInfoget_iter_from_wtxidhashed_index<mempoolentry_wtxid, SaltedTxidHasher, equal_to<uint256>, nth_layer<2, CTxMemPoolEntry, indexed_by<hashed_unique<mempoolentry_txid, SaltedTxidHasher, na, na>, hashed_unique<tag<index_by_wtxid, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, mempoolentry_wtxid, SaltedTxidHasher, na>, ordered_non_unique<tag<descendant_score, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, identity<CTxMemPoolEntry>, CompareTxMemPoolEntryByDescendantScore>, ordered_non_unique<tag<entry_time, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, identity<CTxMemPoolEntry>, CompareTxMemPoolEntryByEntryTime>, ordered_non_unique<tag<ancestor_score, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, identity<CTxMemPoolEntry>, CompareTxMemPoolEntryByAncestorFee>, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, allocator<CTxMemPoolEntry>>, v_item<index_by_wtxid, vector0<na>, 0>, hashed_unique_tag> &const hashed_index<mempoolentry_txid, SaltedTxidHasher, equal_to<uint256>, nth_layer<1, CTxMemPoolEntry, indexed_by<hashed_unique<mempoolentry_txid, SaltedTxidHasher, na, na>, hashed_unique<tag<index_by_wtxid, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, mempoolentry_wtxid, SaltedTxidHasher, na>, ordered_non_unique<tag<descendant_score, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, identity<CTxMemPoolEntry>, CompareTxMemPoolEntryByDescendantScore>, ordered_non_unique<tag<entry_time, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, identity<CTxMemPoolEntry>, CompareTxMemPoolEntryByEntryTime>, ordered_non_unique<tag<ancestor_score, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, identity<CTxMemPoolEntry>, CompareTxMemPoolEntryByAncestorFee>, na, na, na, na, na, na, na, na, na, na, na, na, na, na, na>, allocator<CTxMemPoolEntry>>, vector0<na>, hashed_unique_tag>GetTotalFeeGetTotalTxSizeSetLoadTriedGetLoadTriedGetTransactionAncestryExpireTrimToSizevector<COutPoint, allocator<COutPoint>> *GetMinFeeCalculateDescendantsCheckPackageLimitsconst Packageconst Package &const Limitsconst Limits &MemPoolLimits &AssumeCalculateMemPoolAncestorsCalculateMemPoolAncestorsUpdateTransactionsFromBlockconst vector<uint256, allocator<uint256>>const vector<uint256, allocator<uint256>> &RemoveStagedGetIterSetGetIterGetConflictTxClearPrioritisationApplyDeltaPrioritiseTransactionHasNoInputsOfAddTransactionsUpdatedGetTransactionsUpdatedisSpentqueryHashesCompareDepthAndScoreremoveConflictsremoveForReorgremoveRecursiveaddUncheckedMemPoolOptions &CalculateAncestorsAndCheckLimitsParents &set<reference_wrapper<const CTxMemPoolEntry>, CompareIteratorByHash, allocator<reference_wrapper<const CTxMemPoolEntry>>> &GetSortedDepthAndScoreUpdateChildUpdateParentCalculateDescendantMaximumtrackPackageRemovedentry_time &entry_time &&const entry_timeconst entry_time &index_by_wtxid &index_by_wtxid &&const index_by_wtxidconst index_by_wtxid &txid_index &txid_index &&const txid_indexconst txid_index &insertion_order &insertion_order &&const insertion_orderconst insertion_order &CompareTxMemPoolEntryByAncestorFee &CompareTxMemPoolEntryByAncestorFee &&const CompareTxMemPoolEntryByAncestorFeeconst CompareTxMemPoolEntryByAncestorFee &GetModFeeAndSizeCompareTxMemPoolEntryByEntryTime &wtxidgtxidCompareTxMemPoolEntryByEntryTime &&const CompareTxMemPoolEntryByEntryTimeconst CompareTxMemPoolEntryByEntryTime &const CompareTxMemPoolEntryByEntryTime *CompareTxMemPoolEntryByEntryTime *descendant_score &descendant_score &&const descendant_scoreconst descendant_score &mempoolentry_wtxid &mempoolentry_wtxid &&const mempoolentry_wtxidconst mempoolentry_wtxid &const mempoolentry_wtxid *mempoolentry_wtxid *ancestor_score &ancestor_score &&const ancestor_scoreconst ancestor_score &mempoolentry_txid &mempoolentry_txid &&const mempoolentry_txidconst mempoolentry_txid &const mempoolentry_txid *mempoolentry_txid *CompareTxMemPoolEntryByDescendantScore &CompareTxMemPoolEntryByDescendantScore &&const CompareTxMemPoolEntryByDescendantScoreconst CompareTxMemPoolEntryByDescendantScore &const CompareTxMemPoolEntryByDescendantScore *CompareTxMemPoolEntryByDescendantScore *a_mod_feea_sizeb_mod_feeb_sizeCompareTxMemPoolEntryByScoreEXPIRYSIZELIMITREORGCONFLICTREPLACEDLimitsentry_timeindex_by_wtxidtxid_indexinsertion_orderCompareTxMemPoolEntryByAncestorFeeCompareTxMemPoolEntryByEntryTimedescendant_scoremempoolentry_wtxidancestor_scoremempoolentry_txidCompareTxMemPoolEntryByDescendantScorecachedInnerUsagequeuedTxm_temp_addednFeeDeltavsizem_limitsm_full_rbfm_require_standardconst optional<unsigned int>m_max_datacarrier_bytesm_permit_bare_multisigm_dust_relay_feeratem_min_relay_feeratem_incremental_relay_feeratem_expirym_max_size_bytesmapDeltasmapNextTxm_unbroadcast_txidsvTxHashesmapTxm_load_triedm_sequence_numberm_epochrollingMinimumFeeRateblockSinceLastRollingFeeBumplastRollingFeeUpdatem_total_feetotalTxSizeCBlockPolicyEstimator *CBlockPolicyEstimator *constminerPolicyEstimatornTransactionsUpdatedm_check_ratioMEMPOOL_HEIGHT0x7FFFFFFFROLLING_FEE_HALFLIFE4320060 * 60 * 12BITCOIN_TXMEMPOOL_Hcs, m_epochcs, cs_main// BITCOIN_TXMEMPOOL_H// Remove an entry by insertion_order index, and update memory usage.// Short-circuit in the common case of a block being added to the tip// Remove entries based on txid_index, and update memory usage.// no exact formula for boost::multi_index_contained is implemented.// Estimate the overhead of queuedTx to be 6 pointers + an allocation, as// reorg, besides draining this object).// instance if there was some other way we cleaned up the mempool after a// to be refactored such that this assumption is no longer true (for// This assert() can always be removed if the reorg-processing code were// For now, assert() that we've emptied out this object on destruction.// need to re-process remaining transactions to ensure mempool consistency.// destruction, as we add to it while disconnecting blocks, and then we// It's almost certainly a logic bug if we don't clear out queuedTx before// sorted by order in the blockchain// sorted by txid// multi_index tag names/**
 * DisconnectedBlockTransactions

 * During the reorg, it's desirable to re-add previously confirmed transactions
 * to the mempool, so that anything not re-confirmed in the new chain is
 * available to be mined. However, it's more efficient to wait until the reorg
 * is complete and process all still-unconfirmed transactions at that time,
 * since we expect most confirmed transactions to (typically) still be
 * confirmed in the new chain, and re-accepting to the memory pool is expensive
 * (and therefore better to not do in the middle of reorg-processing).
 * Instead, store the disconnected transactions (in order!) as we go, remove any
 * that are included in blocks in the new chain, and then process the remaining
 * still-unconfirmed transactions at the end.
 *//** Add the coins created by this transaction. These coins are only temporarily stored in
     * m_temp_added and cannot be flushed to the back end. Only used for package validation. *//**
    * Coins made available by transactions being validated. Tracking these allows for package
    * validation, since we can access transaction outputs without submitting them to mempool.
    *//**
 * CCoinsView that brings transactions from a mempool into view.
 * It does not check for spendings by memory pool transactions.
 * Instead, it provides access to all Coins which are either unspent in the
 * base CCoinsView, are outputs from any mempool transaction, or are
 * tracked temporarily to allow transaction dependencies in package validation.
 * This allows transaction replacement to work as expected, as you want to
 * have all inputs "available" to check signatures, and any cycles in the
 * dependency graph are checked directly in AcceptToMemoryPool.
 * It also allows you to sign a double-spend directly in
 * signrawtransactionwithkey and signrawtransactionwithwallet,
 * as long as the conflicting transaction is not yet confirmed.
 */// verify guard even when it==nullopt/** visited marks a CTxMemPoolEntry as having been traversed
     * during the lifetime of the most recently created Epoch::Guard
     * and returns false if we are the first visitor, true otherwise.
     *
     * An Epoch::Guard must be held when visited is called or an assert will be
     * triggered.
     *
     *//** Before calling removeUnchecked for a given transaction,
     *  UpdateForRemoveFromMempool must be called on the entire (dependent) set
     *  of transactions being removed at the same time.  We use each
     *  CTxMemPoolEntry's setMemPoolParents in order to walk ancestors of a
     *  given transaction that is removed, so we can't remove intermediate
     *  transactions in a chain before we've updated all the state for the
     *  removal.
     *//** Sever link between specified transaction and direct children. *//** For each transaction being removed, update ancestors and any direct children.
      * If updateDescendants is true, then also update in-mempool descendants'
      * ancestor state. *//** Set ancestor state for an entry *//** Update ancestors of hash to add/remove it as a descendant transaction. *//** UpdateForDescendants is used by UpdateTransactionsFromBlock to update
     *  the descendants for a single transaction that has been added to the
     *  mempool but may have child transactions in the mempool, eg during a
     *  chain reorg.
     *
     * @pre CTxMemPoolEntry::m_children is correct for the given tx and all
     *      descendants.
     * @pre cachedDescendants is an accurate cache where each entry has all
     *      descendants of the corresponding key, including those that should
     *      be removed for violation of ancestor limits.
     * @post if updateIt has any non-excluded descendants, cachedDescendants has
     *       a new cache line for updateIt.
     * @post descendants_to_remove has a new entry for any descendant which exceeded
     *       ancestor limits relative to updateIt.
     *
     * @param[in] updateIt the entry to update for its descendants
     * @param[in,out] cachedDescendants a cache where each line corresponds to all
     *     descendants. It will be updated with the descendants of the transaction
     *     being updated, so that future invocations don't need to walk the same
     *     transaction again, if encountered in another transaction chain.
     * @param[in] setExclude the set of descendant transactions in the mempool
     *     that must not be accounted for (because any descendants in setExclude
     *     were added to the mempool after the transaction being updated and hence
     *     their state is already reflected in the parent state).
     * @param[out] descendants_to_remove Populated with the txids of entries that
     *     exceed ancestor limits. It's the responsibility of the caller to
     *     removeRecursive them.
     *//** Guards this internal counter for external reporting *//** Returns whether a txid is in the unbroadcast set *//** Returns transactions in unbroadcast set *//** Removes a transaction from the unbroadcast set */// unbroadcast set.// Sanity check the transaction is in the mempool & insert into/** Adds a transaction to the unbroadcast set *//**
     * Set whether or not we've made an attempt to load the mempool (regardless
     * of whether the attempt was successful or not)
     *//**
     * @returns true if we've made an attempt to load the mempool regardless of
     *          whether the attempt was successful or not
     *//**
     * Calculate the ancestor and descendant count for the given transaction.
     * The counts include the transaction itself.
     * When ancestors is non-zero (ie, the transaction itself is in the mempool),
     * ancestorsize and ancestorfees will also be set to the appropriate values.
     *//** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. *//** Remove transactions from the mempool until its dynamic size is <= sizelimit.
      *  pvNoSpendsRemaining, if set, will be populated with the list of outpoints
      *  which are not in mempool which no longer have any spends in this mempool.
      *//** The minimum fee to get into the mempool, which may itself not be enough
     *  for larger-sized transactions.
     *  The m_incremental_relay_feerate policy variable is used to bound the time it
     *  takes the fee rate to go back down all the way to 0. When the feerate
     *  would otherwise be half of this, it is set to 0 instead.
     *//** Populate setDescendants with all in-mempool descendants of hash.
     *  Assumes that setDescendants includes all in-mempool descendants of anything
     *  already in it.  *//** Calculate all in-mempool ancestors of a set of transactions not already in the mempool and
     * check ancestor and descendant limits. Heuristics are used to estimate the ancestor and
     * descendant count of all entries if the package were to be added to the mempool.  The limits
     * are applied to the union of all package transactions. For example, if the package has 3
     * transactions and limits.ancestor_count = 25, the union of all 3 sets of ancestors (including the
     * transactions themselves) must be <= 22.
     * @param[in]       package                 Transaction package being evaluated for acceptance
     *                                          to mempool. The transactions need not be direct
     *                                          ancestors/descendants of each other.
     * @param[in]       limits                  Maximum number and size of ancestors and descendants
     * @param[out]      errString               Populated with error reason if a limit is hit.
     *//**
     * Same as CalculateMemPoolAncestors, but always returns a (non-optional) setEntries.
     * Should only be used when it is assumed CalculateMemPoolAncestors would not fail. If
     * CalculateMemPoolAncestors does unexpectedly fail, an empty setEntries is returned and the
     * error is logged to BCLog::MEMPOOL with level BCLog::Level::Error. In debug builds, failure
     * of CalculateMemPoolAncestors will lead to shutdown due to assertion failure.
     *
     * @param[in]   calling_fn_name     Name of calling function so we can properly log the call site
     *
     * @return a setEntries corresponding to the result of CalculateMemPoolAncestors or an empty
     *         setEntries if it failed
     *
     * @see CTXMemPool::CalculateMemPoolAncestors()
     *//**
     * Try to calculate all in-mempool ancestors of entry.
     * (these are all calculated including the tx itself)
     *
     * @param[in]   entry               CTxMemPoolEntry of which all in-mempool ancestors are calculated
     * @param[in]   limits              Maximum number and size of ancestors and descendants
     * @param[in]   fSearchForParents   Whether to search a tx's vin for in-mempool parents, or look
     *                                  up parents from mapLinks. Must be true for entries not in
     *                                  the mempool
     *
     * @return all in-mempool ancestors, or an error if any ancestor or descendant limits were hit
     *//** UpdateTransactionsFromBlock is called when adding transactions from a
     * disconnected block back to the mempool, new mempool entries may have
     * children in the mempool (which is generally not the case when otherwise
     * adding transactions).
     *  @post updated descendant state for descendants of each transaction in
     *        vHashesToUpdate (excluding any child transactions present in
     *        vHashesToUpdate, which are already accounted for). Updated state
     *        includes add fee/size information for such descendants to the
     *        parent and updated ancestor state to include the parent.
     *
     * @param[in] vHashesToUpdate          The set of txids from the
     *     disconnected block that have been accepted back into the mempool.
     *//** Remove a set of transactions from the mempool.
     *  If a transaction is in this set, then all in-mempool descendants must
     *  also be in the set, unless this transaction is being removed for being
     *  in a block.
     *  Set updateDescendants to true when removing a tx that was in a block, so
     *  that any in-mempool descendants have their ancestor state updated.
     *//** Translate a set of hashes into a set of pool iterators to avoid repeated lookups *//** Returns an iterator to the given hash, if found *//** Get the transaction in the pool that spends the same prevout *//** Affect CreateNewBlock prioritisation of transactions *//**
     * Check that none of this transactions inputs are in the mempool, and thus
     * the tx is not dependent on other mempool transactions to be included in a block.
     *//** After reorg, filter the entries that would no longer be valid in the next block, and update
     * the entries' cached LockPoints if needed.  The mempool does not have any knowledge of
     * consensus rules. It just appplies the callable function and removes the ones for which it
     * returns true.
     * @param[in]   filter_final_and_mature   Predicate that checks the relevant validation rules
     *                                        and updates an entry's LockPoints.
     * */// lack of CValidationInterface::TransactionAddedToMempool callbacks).// and any other callers may break wallet's in-mempool tracking (due to// Note that addUnchecked is ONLY called from ATMP outside of tests// then invoke the second version.// addUnchecked can be used to have it call CalculateMemPoolAncestors(), and// to track size/count of descendant transactions.  First version of// addUnchecked must updated state for all ancestors of a given transaction,/**
     * If sanity-checking is turned on, check makes sure the pool is
     * consistent (does not contain two transactions that spend the same inputs,
     * all inputs are in the mapNextTx array). If sanity-checking is turned off,
     * check does nothing.
     *//** Create a new CTxMemPool.
     * Sanity checks will be off by default for performance, because otherwise
     * accepting transactions becomes O(N^2) where N is the number of transactions
     * in the pool.
     *//**
     * Helper function to calculate all in-mempool ancestors of staged_ancestors and apply ancestor
     * and descendant limits (including staged_ancestors themselves, entry_size and entry_count).
     *
     * @param[in]   entry_size          Virtual size to include in the limits.
     * @param[in]   entry_count         How many entries to include in the limits.
     * @param[in]   staged_ancestors    Should contain entries in the mempool.
     * @param[in]   limits              Maximum number and size of ancestors and descendants
     *
     * @return all in-mempool ancestors, or an error if any ancestor or descendant limits were hit
     *//**
     * Track locally submitted transactions to periodically retry initial broadcast.
     *///!< All tx witness hashes/entries in mapTx, in random order/**
     * This mutex needs to be locked when accessing `mapTx` or other members
     * that are guarded by it.
     *
     * @par Consistency guarantees
     *
     * By design, it is guaranteed that:
     *
     * 1. Locking both `cs_main` and `mempool.cs` will give a view of mempool
     *    that is consistent with current chain tip (`ActiveChain()` and
     *    `CoinsTip()`) and is fully populated. Fully populated means that if the
     *    current active chain is missing transactions that were present in a
     *    previously active chain, all the missing transactions will have been
     *    re-added to the mempool and should be present if they meet size and
     *    consistency constraints.
     *
     * 2. Locking `mempool.cs` without `cs_main` will give a view of a mempool
     *    consistent with some chain that was active since `cs_main` was last
     *    locked, and that is fully populated as described above. It is ok for
     *    code that only needs to query or remove transactions from the mempool
     *    to lock just `mempool.cs` without `cs_main`.
     *
     * To provide these guarantees, it is necessary to lock both `cs_main` and
     * `mempool.cs` whenever adding transactions to the mempool and whenever
     * changing the chain tip. It's necessary to keep both mutexes locked until
     * the mempool is consistent with the new chain tip and fully populated.
     */// sorted by fee rate with ancestors// sorted by entry time// sorted by fee rate// sorted by wtxid// public only for testing// is added or removed from the mempool for any reason.// This number is incremented once every time a transaction// In-memory counter for external mempool tracking purposes.//!< minimum fee to get into the pool, decreases exponentially//!< sum of dynamic memory usage of all the map elements (NOT the maps themselves)//!< sum of all mempool tx's fees (NOT modified fee)//!< sum of all mempool tx's virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141.//!< Used by getblocktemplate to trigger CreateNewBlock() invocation//!< Value n means that 1 times in n we check./**
 * CTxMemPool stores valid-according-to-the-current-best-chain transactions
 * that may be included in the next block.
 *
 * Transactions are added when they are seen on the network (or created by the
 * local node), but not all transactions seen are added to the pool. For
 * example, the following new transactions will not be added to the mempool:
 * - a transaction which doesn't meet the minimum fee requirements.
 * - a new transaction that double-spends an input of a transaction already in
 * the pool where the new transaction does not meet the Replace-By-Fee
 * requirements as defined in doc/policy/mempool-replacements.md.
 * - a non-standard transaction.
 *
 * CTxMemPool::mapTx, and CTxMemPoolEntry bookkeeping:
 *
 * mapTx is a boost::multi_index that sorts the mempool on 5 criteria:
 * - transaction hash (txid)
 * - witness-transaction hash (wtxid)
 * - descendant feerate [we use max(feerate of tx, feerate of tx with all descendants)]
 * - time in mempool
 * - ancestor feerate [we use min(feerate of tx, feerate of tx with all unconfirmed ancestors)]
 *
 * Note: the term "descendant" refers to in-mempool transactions that depend on
 * this one, while "ancestor" refers to in-mempool transactions that a given
 * transaction depends on.
 *
 * In order for the feerate sort to remain correct, we must update transactions
 * in the mempool when new descendants arrive.  To facilitate this, we track
 * the set of in-mempool direct parents and direct children in mapLinks.  Within
 * each CTxMemPoolEntry, we track the size and fees of all descendants.
 *
 * Usually when a new transaction is added to the mempool, it has no in-mempool
 * children (because any such children would be an orphan).  So in
 * addUnchecked(), we:
 * - update a new entry's setMemPoolParents to include all in-mempool parents
 * - update the new entry's direct parents to include the new tx as a child
 * - update all ancestors of the transaction to include the new tx's size/fee
 *
 * When a transaction is removed from the mempool, we must:
 * - update all in-mempool parents to not track the tx in setMemPoolChildren
 * - update all ancestors to not include the tx's size/fees in descendant state
 * - update all in-mempool children to not include it as a parent
 *
 * These happen in UpdateForRemoveFromMempool().  (Note that when removing a
 * transaction along with its descendants, we must calculate that set of
 * transactions to be removed before doing the removal, or else the mempool can
 * be in an inconsistent state where it's impossible to walk the ancestors of
 * a transaction.)
 *
 * In the event of a reorg, the assumption that a newly added tx has no
 * in-mempool children is false.  In particular, the mempool is in an
 * inconsistent state while new transactions are being added, because there may
 * be descendant transactions of a tx coming from a disconnected block that are
 * unreachable from just looking at transactions in the mempool (the linking
 * transactions may also be in the disconnected block, waiting to be added).
 * Because of this, there's not much benefit in trying to search for in-mempool
 * children in addUnchecked().  Instead, in the special case of transactions
 * being added from a disconnected block, we require the caller to clean up the
 * state, to account for in-mempool, out-of-block descendants for all the
 * in-block transactions by calling UpdateTransactionsFromBlock().  Note that
 * until this is called, the mempool state is not consistent, and in particular
 * mapLinks may not be correct (and therefore functions like
 * CalculateMemPoolAncestors() and CalculateDescendants() that rely
 * on them to walk the mempool are not generally safe to use).
 *
 * Computational limits:
 *
 * Updating all in-mempool ancestors of a newly added transaction can be slow,
 * if no bound exists on how many in-mempool ancestors there may be.
 * CalculateMemPoolAncestors() takes configurable limits that are designed to
 * prevent these calculations from being too CPU intensive.
 *
 *///!< Removed for replacement//!< Removed for conflict with in-block transaction//!< Removed for block//!< Removed for reorganization//!< Removed in size limiting//!< Expired from mempool/** Reason why a transaction was removed from the mempool,
 * this is passed to the notification signal.
 *//** The fee delta. *//** Virtual size of the transaction. *//** Fee of the transaction. *//** Time the transaction entered the mempool. *//** The transaction itself *//**
 * Information about a mempool transaction.
 */// Multi_index tag names// return the fee/size for the min.// Compare feerate with ancestors to feerate of the transaction, and// Return the fee/size we're using for sorting this entry.// Avoid division by rewriting (a/b > c/d) as (a*d > c*b)./** \class CompareTxMemPoolEntryByAncestorScore
 *
 *  Sort an entry by min(score/size of entry's tx, score/size with all ancestors).
 *//** \class CompareTxMemPoolEntryByScore
 *
 *  Sort by feerate of entry (fee/size) in descending order
 *  This is only used for transaction relay, so we use GetFee()
 *  instead of GetModifiedFee() to avoid leaking prioritization
 *  information via the sort order.
 */// return the fee/size for the max.// Compare feerate with descendants to feerate of the transaction, and/** \class CompareTxMemPoolEntryByDescendantScore
 *
 *  Sort an entry by max(score/size of entry's tx, score/size with all descendants).
 */// extracts a transaction witness-hash from CTxMemPoolEntry or CTransactionRef// extracts a transaction hash from CTxMemPoolEntry or CTransactionRef/**
 * Test whether the LockPoints height and time are still valid on the current chain
 *//** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */mod_feecoinbaseInmempoolInentriesToRemoveupdateDescendantssetAncestorsupdateItcachedDescendantssetExcludedescendants_to_removeuncheckedload_triedsizelimitpvNoSpendsRemainingsetDescendantslimitserrStringcalling_fn_namefSearchForParentsvHashesToUpdatestagehashesvtxidhashahashbfilter_final_and_matureactive_coins_tipspendheightoptsentry_sizeentry_countstaged_ancestorschildparentrateactive_chainlp/home/tanteikg/QCVE/sources/bitcoin/src/bench/mempool_eviction.cppMempoolEvictiontx110 * COINtx2tx3tx4tx5tx6tx7testing_setup->m_node.mempoolpoolconst unique_ptr<CTxMemPool, default_delete<CTxMemPool>>const unique_ptr<CTxMemPool, default_delete<CTxMemPool>> &unique_ptr<CTxMemPool, default_delete<CTxMemPool>> &bench/mempool_eviction.cpppool.cstx1_rtx2_rtx3_rtx4_rtx5_rtx6_rtx7_rlambda [] type at line 287125, col. 15const lambda [] type at line 287125, col. 15const lambda [] type at line 287125, col. 15 &lambda [] type at line 287125, col. 15 &lambda [] type at line 287125, col. 15 &&AddTxspendsCoinbasesigOpCostLockPointsLockPoints *const lambda [] type at line 287125, col. 15 *lambda [] type at line 287125, col. 15 *10000LL5000LL2000020000LL70007000LLnFee1000LL1100LL90009000LLbench_136MempoolEvictionPASTE2(__LINE__, MempoolEviction)136MempoolEvictioncs_main, pool.cs// Create transaction references outside the "hot loop"// unique transactions for a more meaningful performance measurement.// mempool. Code needs to be written to generate a much wider variety of// Right now this is only testing eviction performance in an extremely smallinline_assertion_checkIS_ASSERTassertionremove_reference<const unique_ptr<CTxMemPool, default_delete<CTxMemPool>> &>remove_reference<const unique_ptr<CTxMemPool, default_delete<CTxMemPool>> &> &remove_reference<const unique_ptr<CTxMemPool, default_delete<CTxMemPool>> &> &&const remove_reference<const unique_ptr<CTxMemPool, default_delete<CTxMemPool>> &>const remove_reference<const unique_ptr<CTxMemPool, default_delete<CTxMemPool>> &> &/home/tanteikg/QCVE/sources/bitcoin/src/bench/mempool_stress.cppMempoolCheck-checkmempool=1"-checkmempool=1"bench/mempool_stress.cppcoins_tipconst unique_ptr<ChainstateManager, default_delete<ChainstateManager>>lambda [] type at line 296177, col. 15const lambda [] type at line 296177, col. 15const lambda [] type at line 296177, col. 15 &lambda [] type at line 296177, col. 15 &lambda [] type at line 296177, col. 15 &&ComplexMemPoolchildTxs 800ordered_coinslambda [] type at line 296159, col. 15const lambda [] type at line 296159, col. 15const lambda [] type at line 296159, col. 15 &lambda [] type at line 296159, col. 15 &lambda [] type at line 296159, col. 15 &&CreateOrderedCoinstx_countervector<CTxOut, allocator<CTxOut>> &const __normal_iterator<CTxOut *, vector<CTxOut, allocator<CTxOut>>>const __normal_iterator<CTxOut *, vector<CTxOut, allocator<CTxOut>>> &__normal_iterator<CTxOut *, vector<CTxOut, allocator<CTxOut>>> &const vector<Available, allocator<Available>>n_ancestorsancestorAvailableconst Availableconst Available &Available &Available *n_to_takeCTransactionRef *~Availableconst lambda [] type at line 296177, col. 15 *lambda [] type at line 296177, col. 15 *const lambda [] type at line 296159, col. 15 *lambda [] type at line 296159, col. 15 *const __normal_iterator<shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>const __normal_iterator<shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>> &__normal_iterator<shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>> &Available &&tx_countvin_leftrefbench_119MempoolCheckPASTE2(__LINE__, MempoolCheck)119MempoolCheckbench_118ComplexMemPoolPASTE2(__LINE__, ComplexMemPool)118ComplexMemPool/*spendheight=*/// Bump up the spendheight so we don't hit premature coinbase spend errors./*min_ancestors=*/// biased towards taking min_ancestors parents, but maybe more// Create some base transactionsmin_ancestorsvector<Available, allocator<Available>>allocator<Available> &_Vector_base<Available, allocator<Available>>_Vector_base<Available, allocator<Available>> &const _Vector_base<Available, allocator<Available>>const _Vector_base<Available, allocator<Available>> &allocator<Available>new_allocator<Available>new_allocator<Available> &const new_allocator<Available>const new_allocator<Available> &allocator_traits<allocator<Available>>allocator_traits<allocator<Available>> &allocator_traits<allocator<Available>> &&const allocator_traits<allocator<Available>>const allocator_traits<allocator<Available>> &vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>> *vector<Available, allocator<Available>> *_Vector_base<Available, allocator<Available>> *const __normal_iterator<Available *, vector<Available, allocator<Available>>>const vector<Available, allocator<Available>> *const _Vector_base<Available, allocator<Available>> *const __normal_iterator<const Available *, vector<Available, allocator<Available>>>const __normal_iterator<const Available *, vector<Available, allocator<Available>>> &__normal_iterator<const Available *, vector<Available, allocator<Available>>> &const allocator<Available>const allocator<Available> &__normal_iterator<const Available *, vector<Available, allocator<Available>>>const Available *__normal_iterator<const Available *, vector<Available, allocator<Available>>> &&__normal_iterator<Available *, vector<Available, allocator<Available>>>__normal_iterator<Available *, vector<Available, allocator<Available>>> &__normal_iterator<Available *, vector<Available, allocator<Available>>> &&const __normal_iterator<Available *, vector<Available, allocator<Available>>> &__alloc_traits<allocator<Available>, Available>__alloc_traits<allocator<Available>, Available> &__alloc_traits<allocator<Available>, Available> &&const __alloc_traits<allocator<Available>, Available>const __alloc_traits<allocator<Available>, Available> &allocator<Available> *const new_allocator<Available> *new_allocator<Available> *Available *constAvailable *const &Available *&const Available *constconst Available *const &const __normal_iterator<Available *, vector<Available, allocator<Available>>> *__normal_iterator<Available *, vector<Available, allocator<Available>>> *is_nothrow_constructible<Available, shared_ptr<const CTransaction> &, unsigned long>is_nothrow_constructible<Available, shared_ptr<const CTransaction> &, unsigned long> &is_nothrow_constructible<Available, shared_ptr<const CTransaction> &, unsigned long> &&const is_nothrow_constructible<Available, shared_ptr<const CTransaction> &, unsigned long>const is_nothrow_constructible<Available, shared_ptr<const CTransaction> &, unsigned long> &rebind<Available>rebind<Available> &rebind<Available> &&const rebind<Available>const rebind<Available> &reverse_iterator<__normal_iterator<const Available *, vector<Available, allocator<Available>>>>reverse_iterator<__normal_iterator<Available *, vector<Available, allocator<Available>>>>const __normal_iterator<const Available *, vector<Available, allocator<Available>>> *__normal_iterator<const Available *, vector<Available, allocator<Available>>> *is_nothrow_default_constructible<allocator<Available>>is_nothrow_default_constructible<allocator<Available>> &is_nothrow_default_constructible<allocator<Available>> &&const is_nothrow_default_constructible<allocator<Available>>const is_nothrow_default_constructible<allocator<Available>> &is_constructible<Available, Available &&>is_constructible<Available, Available &&> &is_constructible<Available, Available &&> &&const is_constructible<Available, Available &&>const is_constructible<Available, Available &&> &__is_move_constructible_impl<Available, true>__is_move_constructible_impl<Available, true> &__is_move_constructible_impl<Available, true> &&const __is_move_constructible_impl<Available, true>const __is_move_constructible_impl<Available, true> &is_move_constructible<Available>is_move_constructible<Available> &is_move_constructible<Available> &&const is_move_constructible<Available>const is_move_constructible<Available> &__is_move_insertable<allocator<Available>>__is_move_insertable<allocator<Available>> &__is_move_insertable<allocator<Available>> &&const __is_move_insertable<allocator<Available>>const __is_move_insertable<allocator<Available>> &is_nothrow_destructible<Available>is_nothrow_destructible<Available> &is_nothrow_destructible<Available> &&const is_nothrow_destructible<Available>const is_nothrow_destructible<Available> &iterator_traits<const Available *>iterator_traits<const Available *> &iterator_traits<const Available *> &&const iterator_traits<const Available *>const iterator_traits<const Available *> &iterator_traits<Available *>iterator_traits<Available *> &iterator_traits<Available *> &&const iterator_traits<Available *>const iterator_traits<Available *> &__and_<is_same<Available *, _Ptr>, __not_<is_pointer<_Ptr>>>Available *&&is_same<Available *, _Ptr>__is_referenceable<Available>__is_referenceable<Available> &__is_referenceable<Available> &&const __is_referenceable<Available>const __is_referenceable<Available> &is_nothrow_copy_constructible<Available *>is_nothrow_copy_constructible<Available *> &is_nothrow_copy_constructible<Available *> &&const is_nothrow_copy_constructible<Available *>const is_nothrow_copy_constructible<Available *> &__is_nothrow_copy_constructible_impl<Available *, true>__is_nothrow_copy_constructible_impl<Available *, true> &__is_nothrow_copy_constructible_impl<Available *, true> &&const __is_nothrow_copy_constructible_impl<Available *, true>const __is_nothrow_copy_constructible_impl<Available *, true> &is_nothrow_constructible<Available, Available>is_nothrow_constructible<Available, Available> &is_nothrow_constructible<Available, Available> &&const is_nothrow_constructible<Available, Available>const is_nothrow_constructible<Available, Available> &__is_referenceable<Available *>__is_referenceable<Available *> &__is_referenceable<Available *> &&const __is_referenceable<Available *>const __is_referenceable<Available *> &is_nothrow_constructible<Available *, Available *const &>is_nothrow_constructible<Available *, Available *const &> &is_nothrow_constructible<Available *, Available *const &> &&const is_nothrow_constructible<Available *, Available *const &>const is_nothrow_constructible<Available *, Available *const &> &remove_reference<Available &>remove_reference<Available &> &remove_reference<Available &> &&const remove_reference<Available &>const remove_reference<Available &> &remove_reference<Available>remove_reference<Available> &remove_reference<Available> &&const remove_reference<Available>const remove_reference<Available> &/home/tanteikg/QCVE/sources/bitcoin/src/bench/merkle_root.cppMerkleRootleaves9001const __normal_iterator<uint256 *, vector<uint256, allocator<uint256>>>const __normal_iterator<uint256 *, vector<uint256, allocator<uint256>>> &__normal_iterator<uint256 *, vector<uint256, allocator<uint256>>> &lambda [] type at line 143229, col. 49const lambda [] type at line 143229, col. 49const lambda [] type at line 143229, col. 49 &lambda [] type at line 143229, col. 49 &lambda [] type at line 143229, col. 49 &&leaf"leaf"const lambda [] type at line 143229, col. 49 *lambda [] type at line 143229, col. 49 *mutationbench_26MerkleRootPASTE2(__LINE__, MerkleRoot)26MerkleRootliterals<bits/string_view.tcc><bits/char_traits.h>operator ""sv__sv_limit__sv_check"%s: __pos (which is %zu) > __size " "(which is %zu)"%s: __pos (which is %zu) > __size (which is %zu)__N("%s: __pos (which is %zu) > __size "
				   "(which is %zu)")__is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>> &__is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>> &&const __is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>>const __is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>> &hash<basic_string_view<char32_t, char_traits<char32_t>>> &hash<basic_string_view<char32_t, char_traits<char32_t>>> &&const hash<basic_string_view<char32_t, char_traits<char32_t>>>const hash<basic_string_view<char32_t, char_traits<char32_t>>> &const u32string_viewconst u32string_view &basic_string_view<char32_t, char_traits<char32_t>> &const hash<basic_string_view<char32_t, char_traits<char32_t>>> *hash<basic_string_view<char32_t, char_traits<char32_t>>> *__is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>> &__is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>> &&const __is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>>const __is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>> &hash<basic_string_view<char16_t, char_traits<char16_t>>> &hash<basic_string_view<char16_t, char_traits<char16_t>>> &&const hash<basic_string_view<char16_t, char_traits<char16_t>>>const hash<basic_string_view<char16_t, char_traits<char16_t>>> &const u16string_viewconst u16string_view &basic_string_view<char16_t, char_traits<char16_t>> &const hash<basic_string_view<char16_t, char_traits<char16_t>>> *hash<basic_string_view<char16_t, char_traits<char16_t>>> *__is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>> &__is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>> &&const __is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>>const __is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>> &hash<basic_string_view<wchar_t, char_traits<wchar_t>>> &hash<basic_string_view<wchar_t, char_traits<wchar_t>>> &&const hash<basic_string_view<wchar_t, char_traits<wchar_t>>>const hash<basic_string_view<wchar_t, char_traits<wchar_t>>> &const wstring_viewconst wstring_view &basic_string_view<wchar_t, char_traits<wchar_t>> &const hash<basic_string_view<wchar_t, char_traits<wchar_t>>> *hash<basic_string_view<wchar_t, char_traits<wchar_t>>> *__is_fast_hash<hash<basic_string_view<char, char_traits<char>>>> &__is_fast_hash<hash<basic_string_view<char, char_traits<char>>>> &&const __is_fast_hash<hash<basic_string_view<char, char_traits<char>>>>const __is_fast_hash<hash<basic_string_view<char, char_traits<char>>>> &hash<basic_string_view<char, char_traits<char>>> &hash<basic_string_view<char, char_traits<char>>> &&const hash<basic_string_view<char, char_traits<char>>>const hash<basic_string_view<char, char_traits<char>>> &const string_viewconst string_view &const hash<basic_string_view<char, char_traits<char>>> *hash<basic_string_view<char, char_traits<char>>> *basic_string_view<_CharT, _Traits> &remove_suffixremove_prefixconst basic_string_view<_CharT, _Traits>const basic_string_view<_CharT, _Traits> *basic_string_view<_CharT, _Traits> *const basic_string_view<_CharT, _Traits> &basic_string_view__idt__is_fast_hash<hash<basic_string_view<char32_t, char_traits<char32_t>>>>hash<basic_string_view<char32_t, char_traits<char32_t>>>__is_fast_hash<hash<basic_string_view<char16_t, char_traits<char16_t>>>>hash<basic_string_view<char16_t, char_traits<char16_t>>>__is_fast_hash<hash<basic_string_view<wchar_t, char_traits<wchar_t>>>>hash<basic_string_view<wchar_t, char_traits<wchar_t>>>__is_fast_hash<hash<basic_string_view<char, char_traits<char>>>>hash<basic_string_view<char, char_traits<char>>>basic_string_view<_CharT, _Traits>size_type(-1)__cpp_lib_string_view201803_GLIBCXX_STRING_VIEWstring_view_literalsthis->_M_len >= __nthis->_M_len > 0"basic_string_view::at: __pos " "(which is %zu) >= this->size() " "(which is %zu)"__pos < this->_M_len// _GLIBCXX_EXPERIMENTAL_STRING_VIEW// __cplusplus <= 201402L// namespace literals// namespace string_literals// [string.view.hash], hash support:// basic_string_view typedef names// [string.view.io], Inserters and extractors// argument gets implicitly converted to the deduced type. See n3766.html.// argument participates in template argument deduction and the other// Identity transform to create a non-deduced context, so that only one// [string.view.comparison], non-member basic_string_view comparison function// [string.view.find], searching// 2777. basic_string_view::copy should use char_traits::copy// [string.view.ops], string operations:// [string.view.modifiers], modifiers:// [string.view.access], element access// [string.view.capacity], capacity// [string.view.iterators], iterator support// [string.view.cons], construction and assignment/**
   *  @class basic_string_view <string_view>
   *  @brief  A non-owning reference to a string.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  @tparam _CharT  Type of character
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  A basic_string_view looks like this:
   *
   *  @code
   *    _CharT*    _M_str
   *    size_t     _M_len
   *  @endcode
   */// NB: __sv_limit doesn't check for a bad __pos value.// Helper for basic_string members.// Helper for basic_string and basic_string_view members.// N3762 basic_string_view library/** @file include/string_view
 *  This is a Standard C++ Library header.
 */// Components for manipulating non-owning sequences of characters -*- C++ -*-const _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>const _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true> *const __hashtable *_Map_base::at__N("_Map_base::at")lambda [] type at line 59925, col. 9lambda [] type at line 59925, col. 9 &const lambda [] type at line 59925, col. 9const lambda [] type at line 59925, col. 9 &const lambda [] type at line 59925, col. 9 *lambda [] type at line 59925, col. 9 *lambda [] type at line 59871, col. 8lambda [] type at line 59871, col. 8 &const lambda [] type at line 59871, col. 8const lambda [] type at line 59871, col. 8 &const lambda [] type at line 59871, col. 8 *lambda [] type at line 59871, col. 8 *lambda [] type at line 59888, col. 2lambda [] type at line 59888, col. 2 &const lambda [] type at line 59888, col. 2const lambda [] type at line 59888, col. 2 &const lambda [] type at line 59888, col. 2 *lambda [] type at line 59888, col. 2 *lambda [] type at line 60083, col. 3lambda [] type at line 60083, col. 3 &const lambda [] type at line 60083, col. 3const lambda [] type at line 60083, col. 3 &const lambda [] type at line 60083, col. 3 *lambda [] type at line 60083, col. 3 *do_hashdo_transformdo_compare_M_transformuse_facethas_facetconst basic_string<_Char, _Traits, _Alloc>const basic_string<_Char, _Traits, _Alloc> &basic_string<_Char, _Traits, _Alloc> &_Charcombinelocale *const _Implconst _Impl &_Impl &const idconst id *id *const facetconst facet *facet *operator delete[]locale_LOCALE_CLASSES_TCC// correct size.// If the buffer was not large enough, try again with the// First try a buffer perhaps big enough.// to strxfrm.// the string into zero-terminated substrings and pass those// strxfrm stops when it sees a nul character so we break// strxfrm assumes zero-terminated strings so we make a copy// to strcoll.// the strings into zero-terminated substrings and pass those// strcoll stops when it sees a nul character so we break// and then put a zero at the end.// strcoll assumes zero-terminated strings so we make a copy// Generic version does nothing./**
   *  @brief  Return a facet.
   *  @ingroup locales
   *
   *  use_facet looks for and returns a reference to a facet of type Facet
   *  where Facet is the template parameter.  If has_facet(locale) is true,
   *  there is a suitable facet to return.  It throws std::bad_cast if the
   *  locale doesn't contain a facet of type Facet.
   *
   *  @tparam  _Facet  The facet type to access.
   *  @param  __loc  The locale to use.
   *  @return  Reference to facet of type Facet.
   *  @throw  std::bad_cast if @p __loc doesn't contain a facet of type _Facet.
  *//**
   *  @brief  Test for the presence of a facet.
   *  @ingroup locales
   *
   *  has_facet tests the locale argument for the presence of the facet type
   *  provided as the template parameter.  Facets derived from the facet
   *  parameter will also return true.
   *
   *  @tparam  _Facet  The facet type to test the presence of.
   *  @param  __loc  The locale to test.
   *  @return  true if @p __loc contains a facet of type _Facet, else false.
  */// Unnamed.// ISO C++ 14882: 22.1  Locales/** @file bits/locale_classes.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */// Locale support -*- C++ -*-__lo1__hi1__lo2__hi2<bits/locale_facets.tcc><bits/ctype_inline.h><streambuf><bits/ios_base.h><bits/ctype_base.h><cctype><cwctype>~numpunct_bynamenumpunct_byname_M_initialize_numpunctdo_falsenameconst numpunct<_CharT>const numpunct<_CharT> *numpunct<_CharT> *__cache_type *__numpunct_cache<_CharT> *_M_falsenamedo_truename_M_truenamedo_grouping_M_groupingdo_thousands_sep_M_thousands_sepdo_decimal_point_M_decimal_point~numpunctfalsenametruenamegroupingthousands_sepdecimal_pointnumpunct_OutIter__write__convert_to_viostate &_Ios_Iostate &const __c_locale__locale_struct *const __c_locale &__locale_struct *&toupperisblankisgraphisalnumisxdigitispunctisdigitisalphaislowerisupperiscntrlisprintisspace__numpunct_cacheconst __numpunct_cache<_CharT>const __numpunct_cache<_CharT> &__numpunct_cache<_CharT> &~__numpunct_cachectype_byname<wchar_t> &const ctype_byname<wchar_t>const ctype_byname<wchar_t> &ctype_byname~ctype_bynamectype_byname<char> &const ctype_byname<char>const ctype_byname<char> &do_narrowdo_widendo_tolowerdo_toupperdo_scan_notdo_scan_isdo_ismask *~__ctype_abstract_base__ctype_abstract_basescan_notscan_isdo_put~num_putnum_putdo_get_M_findconst _CharT2const _CharT2 *~num_getnum_get~ctypectypectype<wchar_t> &const ctype<wchar_t>const ctype<wchar_t> &_M_initialize_ctype__refs__cloc__io__fill__err_M_convert_to_wmaskctype<char> &const ctype<char>const ctype<char> &_M_widen_init_M_narrow_initconst ctype<char> *ctype<char> *__builtin_memcpyconst mask *classic_tabletablechar[256]static_cast<unsigned char>(-1)1 + static_cast<unsigned char>(-1)_S_format_floatconst ios_base &__num_base &const __num_baseconst __num_base &__num_base &&numpunct_byname<_CharT>numpunct<_CharT>__numpunct_cache<_CharT>ctype_byname<wchar_t>ctype_byname<char>__ctype_abstract_base<_CharT>__pad<_CharT, _Traits>num_put<_CharT, _OutIter>iter_typenum_get<_CharT, _InIter>_InIterctype_byname<_CharT>ctype<_CharT>ctype<wchar_t>__wmask_typectype<char>_S_ominus_S_oplus_S_ox_S_oX_S_odigits_S_odigits_end_S_odigits + 16_S_oudigits_S_oudigits_end_S_oudigits + 16_S_oe_S_odigits + 14_S_oE_S_oudigits + 14_S_oend_S_iminus_S_iplus_S_ix_S_iX_S_izero_S_ie_S_izero + 14_S_iE_S_izero + 20_S_iend__num_base__add_grouping_M_insert_int_M_insert_float_M_extract_int_M_allocated_CharT[26]__num_base::_S_iend_M_atoms_in_CharT[36]__num_base::_S_oend_M_atoms_out_M_falsename_size_M_truename_size_M_use_grouping_M_grouping_size__wmask_type[16]unsigned long[16]_M_wmaskmask[16]unsigned short[16]_M_bitwint_t[256]unsigned int[256]_M_widenchar[128]_M_narrow_M_narrow_ok_M_c_locale_ctype_M_widen_ok_M_table_M_tolower_M_touppertable_size_S_atoms_in_S_atoms_out_GLIBCXX_NUM_UNICODE_FACETS_GLIBCXX_NUM_CXX11_FACETS_GLIBCXX_NUM_FACETS_LOCALE_FACETS_Hdefined _GLIBCXX_LONG_DOUBLE_COMPAT && defined __LONG_DOUBLE_128___M_pad_M_group_int_M_group_float_M_extract_float__ws__sep__gbeg__gsize__zero__new__cs__grouping__grouping_size_M_cache_S_pad/// Convenience interface to ctype.tolower(__c)./// Convenience interface to ctype.toupper(__c)./// Convenience interface to ctype.is(ctype_base::blank, __c)./// Convenience interface to ctype.is(ctype_base::graph, __c)./// Convenience interface to ctype.is(ctype_base::alnum, __c)./// Convenience interface to ctype.is(ctype_base::xdigit, __c)./// Convenience interface to ctype.is(ctype_base::punct, __c)./// Convenience interface to ctype.is(ctype_base::digit, __c)./// Convenience interface to ctype.is(ctype_base::alpha, __c)./// Convenience interface to ctype.is(ctype_base::lower, __c)./// Convenience interface to ctype.is(ctype_base::upper, __c)./// Convenience interface to ctype.is(ctype_base::cntrl, __c)./// Convenience interface to ctype.is(ctype_base::print, __c)./// Convenience interface to ctype.is(ctype_base::space, __c).// C is*() function.// can hoist the body out of the loop; then it's just as fast as the// NB: These are inline because, when used in a loop, some compilers// Subclause convenience interfaces, inlines.// XXX GLIBCXX_ABI Deprecated/**
       *  @brief  Numeric formatting.
       *
       *  These functions do the work of formatting numeric values and
       *  inserting them into a stream. This function is a hook for derived
       *  classes to change the value returned.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//// Destructor./**
       *  @brief  Numeric formatting.
       *
       *  Formats the pointer value @a v and inserts it into a stream.  It
       *  does so by calling num_put::do_put().
       *
       *  This function formats @a v as an unsigned long with ios_base::hex
       *  and ios_base::showbase set.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Numeric formatting.
       *
       *  Formats the floating point value @a v and inserts it into a stream.
       *  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::floatfield.  If equal to ios_base::fixed, formats like the
       *  printf %f specifier.  Else if equal to ios_base::scientific, formats
       *  like %e or %E with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %g or %G depending on uppercase.  Note that
       *  if both fixed and scientific are set, the effect will also be like
       *  %g or %G.
       *
       *  The output precision is given by io.precision().  This precision is
       *  capped at numeric_limits::digits10 + 2 (different for double and
       *  long double).  The default precision is 6.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showpoint is set, a decimal point will always be
       *  output.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Thousands separators are inserted according to
       *  numpunct::grouping() and numpunct::thousands_sep().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Numeric formatting.
       *
       *  Formats the integral value @a v and inserts it into a
       *  stream.  It does so by calling num_put::do_put().
       *
       *  Formatting is affected by the flag settings in @a io.
       *
       *  The basic format is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, formats like the
       *  printf %o specifier.  Else if equal to ios_base::hex, formats like
       *  %x or %X with ios_base::uppercase unset or set respectively.
       *  Otherwise, formats like %d, %ld, %lld for signed and %u, %lu, %llu
       *  for unsigned values.  Note that if both oct and hex are set, neither
       *  will take effect.
       *
       *  If ios_base::showpos is set, '+' is output before positive values.
       *  If ios_base::showbase is set, '0' precedes octal values (except 0)
       *  and '0[xX]' precedes hex values.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Thousands separators are inserted according to
       *  numpunct::grouping() and numpunct::thousands_sep().
       *
       *  If io.width() is non-zero, enough @a fill characters are inserted to
       *  make the result at least that wide.  If
       *  (io.flags() & ios_base::adjustfield) == ios_base::left, result is
       *  padded at the end.  If ios_base::internal, then padding occurs
       *  immediately after either a '+' or '-' or after '0x' or '0X'.
       *  Otherwise, padding occurs at the beginning.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Numeric formatting.
       *
       *  Formats the boolean @a v and inserts it into a stream.  It does so
       *  by calling num_put::do_put().
       *
       *  If ios_base::boolalpha is set, writes ctype<CharT>::truename() or
       *  ctype<CharT>::falsename().  Otherwise formats @a v as an int.
       *
       *  @param  __s  Stream to write to.
       *  @param  __io  Source of locale and flags.
       *  @param  __fill  Char_type to use for filling.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after writing.
      *//**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __refs  Passed to the base facet class.
      *//// Numpunct facet id./// Public typedefs/**
   *  @brief  Primary class template num_put.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to convert a number to a string.  It is
   *  used by the ostream numeric insertion operators.
   *
   *  The num_put template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_put facet.
  *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the variable @a v.  This function is a
       *  hook for derived classes to change the value returned.  @see get()
       *  for more details.
       *
       *  @param  __beg  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the pointer variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %p specifier.
       *
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  Note that the digit grouping effect for pointers is a bit ambiguous
       *  in the standard and shouldn't be relied on.  See DR 344.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  The input characters are parsed like the scanf %g specifier.  The
       *  matching type length modifier is also used.
       *
       *  The decimal point character used is numpunct::decimal_point().
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the integral variable @a v.  It does so
       *  by calling num_get::do_get().
       *
       *  Parsing is affected by the flag settings in @a io.
       *
       *  The basic parse is affected by the value of io.flags() &
       *  ios_base::basefield.  If equal to ios_base::oct, parses like the
       *  scanf %o specifier.  Else if equal to ios_base::hex, parses like %X
       *  specifier.  Else if basefield equal to 0, parses like the %i
       *  specifier.  Otherwise, parses like %d for signed and %u for unsigned
       *  types.  The matching type length modifier is also used.
       *
       *  Digit grouping is interpreted according to
       *  numpunct::grouping() and numpunct::thousands_sep().  If the
       *  pattern of digit groups isn't consistent, sets err to
       *  ios_base::failbit.
       *
       *  If parsing the string yields a valid value for @a v, @a v is set.
       *  Otherwise, sets err to ios_base::failbit and leaves @a v unaltered.
       *  Sets err to ios_base::eofbit if the stream is emptied.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
       *  @brief  Numeric parsing.
       *
       *  Parses the input stream into the bool @a v.  It does so by calling
       *  num_get::do_get().
       *
       *  If ios_base::boolalpha is set, attempts to read
       *  ctype<CharT>::truename() or ctype<CharT>::falsename().  Sets
       *  @a v to true or false if successful.  Sets err to
       *  ios_base::failbit if reading the string fails.  Sets err to
       *  ios_base::eofbit if the stream is emptied.
       *
       *  If ios_base::boolalpha is not set, proceeds as with reading a long,
       *  except if the value is 1, sets @a v to true, if the value is 0, sets
       *  @a v to false, and otherwise set err to ios_base::failbit.
       *
       *  @param  __in  Start of input stream.
       *  @param  __end  End of input stream.
       *  @param  __io  Source of locale and flags.
       *  @param  __err  Error flags to set.
       *  @param  __v  Value to format and insert.
       *  @return  Iterator after reading.
      *//**
   *  @brief  Primary class template num_get.
   *  @ingroup locales
   *
   *  This facet encapsulates the code to parse and return a number
   *  from a string.  It is used by the istream numeric extraction
   *  operators.
   *
   *  The num_get template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from the num_get facet.
  *//// class numpunct_byname [22.2.3.2].// For use at construction time only./**
       *  @brief  Return string representation of bool false.
       *
       *  Returns a string_type containing the text representation for false
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of false.
      *//**
       *  @brief  Return string representation of bool true.
       *
       *  Returns a string_type containing the text representation for true
       *  bool variables.  This function is a hook for derived classes to
       *  change the value returned.
       *
       *  @return  string_type representing printed form of true.
      *//**
       *  @brief  Return grouping specification.
       *
       *  Returns a string representing groupings for the integer part of a
       *  number.  This function is a hook for derived classes to change the
       *  value returned.  @see grouping() for details.
       *
       *  @return  String representing grouping specification.
      *//**
       *  @brief  Return thousands separator character.
       *
       *  Returns a char_type to use as a thousands separator.  This function
       *  is a hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a thousands separator.
      *//**
       *  @brief  Return decimal point character.
       *
       *  Returns a char_type to use as a decimal point.  This function is a
       *  hook for derived classes to change the value returned.
       *
       *  @return  @a char_type representing a decimal point.
      *//**
       *  @brief  Return string representation of bool false.
       *
       *  This function returns a string_type containing the text
       *  representation for false bool variables.  It does so by calling
       *  numpunct<char_type>::do_falsename().
       *
       *  @return  string_type representing printed form of false.
      *//**
       *  @brief  Return string representation of bool true.
       *
       *  This function returns a string_type containing the text
       *  representation for true bool variables.  It does so by calling
       *  numpunct<char_type>::do_truename().
       *
       *  @return  string_type representing printed form of true.
      *//**
       *  @brief  Return grouping specification.
       *
       *  This function returns a string representing groupings for the
       *  integer part of a number.  Groupings indicate where thousands
       *  separators should be inserted in the integer part of a number.
       *
       *  Each char in the return string is interpret as an integer
       *  rather than a character.  These numbers represent the number
       *  of digits in a group.  The first char in the string
       *  represents the number of digits in the least significant
       *  group.  If a char is negative, it indicates an unlimited
       *  number of digits for the group.  If more chars from the
       *  string are required to group a number, the last char is used
       *  repeatedly.
       *
       *  For example, if the grouping() returns "\003\002" and is
       *  applied to the number 123456789, this corresponds to
       *  12,34,56,789.  Note that if the string was "32", this would
       *  put more than 50 digits into the least significant group if
       *  the character set is ASCII.
       *
       *  The string is returned by calling
       *  numpunct<char_type>::do_grouping().
       *
       *  @return  string representing grouping specification.
      *//**
       *  @brief  Return thousands separator character.
       *
       *  This function returns a char_type to use as a thousands
       *  separator.  It does so by returning returning
       *  numpunct<char_type>::do_thousands_sep().
       *
       *  @return  char_type representing a thousands separator.
      *//**
       *  @brief  Return decimal point character.
       *
       *  This function returns a char_type to use as a decimal point.  It
       *  does so by returning returning
       *  numpunct<char_type>::do_decimal_point().
       *
       *  @return  @a char_type representing a decimal point.
      *//**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up new
       *  locales.
       *
       *  @param  __cloc  The C locale.
       *  @param  __refs  Refcount to pass to the base class.
       *//**
       *  @brief  Internal constructor.  Not for general use.
       *
       *  This is a constructor for use by the library itself to set up the
       *  predefined locale facets.
       *
       *  @param  __cache  __numpunct_cache object.
       *  @param  __refs  Refcount to pass to the base class.
       *//**
       *  @brief  Numpunct constructor.
       *
       *  @param  __refs  Refcount to pass to the base class.
       *//**
   *  @brief  Primary class template numpunct.
   *  @ingroup locales
   *
   *  This facet stores several pieces of information related to printing and
   *  scanning numbers, such as the decimal point character.  It takes a
   *  template parameter specifying the char type.  The numpunct facet is
   *  used by streams for many I/O operations involving numbers.
   *
   *  The numpunct template uses protected virtual functions to provide the
   *  actual results.  The public accessors forward the call to the virtual
   *  functions.  These virtual functions are hooks for developers to
   *  implement the behavior they require from a numpunct facet.
  */// through the current locale's ctype<_CharT>.widen().// This array contains the chars after having been passed// "C" locale, this is "-+xX0123456789abcdefABCDEF"// A list of valid numeric literals for input: in the standard// "C" locale, this is "-+xX0123456789abcdef0123456789ABCDEF".// A list of valid numeric literals for output: in the standard// Construct and return valid scanf format for floating point types.// num_put// "-+xX0123456789abcdefABCDEF"// String literal of acceptable (narrow) input, for num_get.// "-+xX0123456789abcdef0123456789ABCDEF".// For the standard "C" locale, this is// ctype<_CharT>.widen() and then used to render numbers.// contains chars that will be passed through the current locale's// A list of valid numeric literals for output.  This array// For scientific notation, 'E'// For scientific notation, 'e'// Below are the indices into _S_atoms_out.// NB: Code depends on the order of _S_atoms_out elements.// 22.2.2  The numeric category.// Include host and configuration specific ctype inlines./// 22.2.1.4  Class ctype_byname specializations./// class ctype_byname [22.2.1.2].//_GLIBCXX_USE_WCHAR_T/**
       *  @brief  Narrow wchar_t array to char array
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any wchar_t in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<wchar_t> facet, the argument will be copied, casting each
       *  element to char.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow wchar_t to char
       *
       *  This virtual function converts the argument to char using
       *  the simplest reasonable transformation.  If the conversion
       *  fails, dfault is returned instead.  For an underived
       *  ctype<wchar_t> facet, @a c will be cast to char and
       *  returned.
       *
       *  do_narrow() is a hook for a derived facet to change the
       *  behavior of narrowing.  do_narrow() must always return the
       *  same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The wchar_t to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen char array to wchar_t array
       *
       *  This function converts each char in the input to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be copied, casting each element to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char to wchar_t
       *
       *  This virtual function converts the char to wchar_t using the
       *  simplest reasonable transformation.  For an underived ctype<wchar_t>
       *  facet, the argument will be cast to wchar_t.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted wchar_t.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The wchar_t to convert.
       *  @return  The lowercase wchar_t if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each wchar_t in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the wchar_t argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The wchar_t to convert.
       *  @return  The uppercase wchar_t if convertible, else @a __c.
      *//**
       *  @brief  Find wchar_t not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  wchar_t c of [__lo,__hi) for which is(__m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching wchar_t if found, else @a __hi.
      *//**
       *  @brief  Find wchar_t matching mask
       *
       *  This function searches for and returns the first wchar_t c in
       *  [__lo,__hi) for which is(__m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching wchar_t if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each wchar_t in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test wchar_t classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __c  The wchar_t to find the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      *//// Destructor/**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param __cloc  Handle to C locale data.
       *  @param __refs  Passed to the base facet class.
      *//// The facet id for ctype<wchar_t>// Pre-computed elements for do_is.// Pre-computed narrowed and widened chars./// Typedef for the template parameter wchar_t./**
   *  @brief  The ctype<wchar_t> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for the
   *  wchar_t type.  It gets used by wchar_t streams for many I/O operations.
   *  The wchar_t specialization provides a number of optimizations as well.
   *
   *  ctype<wchar_t> inherits its public methods from
   *  __ctype_abstract_base<wchar_t>.
  *//**
       *  @brief  Narrow char array to char array
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  char using the simplest reasonable transformation and writes the
       *  results to the destination array.  For any char in the input that
       *  cannot be converted, @a dfault is used instead.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c will be
       *  returned unchanged.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen char array
       *
       *  This function converts each char in the range [lo,hi) to char using
       *  the simplest reasonable transformation.  For an underived
       *  ctype<char> facet, the argument will be copied unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted character.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  lowercase if possible.  Other chars remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the char argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The lowercase char if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char in the range [lo,hi) to
       *  uppercase if possible.  Other chars remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char argument to uppercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The uppercase char if convertible, else @a __c.
      *//**
       *  @brief  Destructor.
       *
       *  This function deletes table() if @a del was true in the
       *  constructor.
      *//// Returns a pointer to the C locale mask table./// the default from classic_table() if none was provided./// Returns a pointer to the mask table provided to the constructor, or// DR 695. ctype<char>::classic_table() not accessible./**
       *  @brief  Narrow char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char in the input that cannot be
       *  converted, @a dfault is used instead.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(lo, hi,
       *  dfault, to).  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char
       *
       *  This function converts the char to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  For an underived ctype<char> facet, @a c
       *  will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_narrow(c).
       *  do_narrow() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted character.
      *//**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char using the
       *  simplest reasonable transformation.  For an underived ctype<char>
       *  facet, the argument will be copied unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char
       *
       *  This function converts the char to char_type using the simplest
       *  reasonable transformation.  For an underived ctype<char> facet, the
       *  argument will be returned unchanged.
       *
       *  This function works as if it returns ctype<char>::do_widen(c).
       *  do_widen() must always return the same result for the same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted character.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char in the range [lo,hi) to lowercase
       *  if possible.  Other chars remain untouched.
       *
       *  tolower() acts as if it returns ctype<char>:: do_tolower(__lo, __hi).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the char argument to lowercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  tolower() acts as if it returns ctype<char>::do_tolower(__c).
       *  do_tolower() must always return the same result for the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The lowercase char if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char in the range [__lo,__hi) to uppercase
       *  if possible.  Other chars remain untouched.
       *
       *  toupper() acts as if it returns ctype<char>:: do_toupper(__lo, __hi).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the char argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.
       *
       *  toupper() acts as if it returns ctype<char>::do_toupper(c).
       *  do_toupper() must always return the same result for the same input.
       *
       *  @param __c  The char to convert.
       *  @return  The uppercase char if convertible, else @a __c.
      *//**
       *  @brief  Find char not matching a mask
       *
       *  This function searches for and returns a pointer to the first char
       *  in [__lo,__hi) for which is(m,char) is false.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char if found, else @a __hi.
      *//**
       *  @brief  Find char matching a mask
       *
       *  This function searches for and returns the first char in [lo,hi) for
       *  which is(m,char) is true.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching char if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char in the range [lo, hi) and
       *  successively writes it to vec.  vec must have as many elements as
       *  the char array.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test char classification.
       *
       *  This function compares the mask table[c] to @a __m.
       *
       *  @param __c  The char to compare the mask of.
       *  @param __m  The mask to compare against.
       *  @return  True if __m & table[__c] is true, false otherwise.
      *//**
       *  @brief  Constructor performs static initialization.
       *
       *  This constructor is used to construct the initial C locale facet.
       *
       *  @param __cloc  Handle to C locale data.
       *  @param __table If non-zero, table is used as the per-char mask.
       *  @param __del   If true, passes ownership of table to this facet.
       *  @param __refs  Passed to the base facet class.
      *//**
       *  @brief  Constructor performs initialization.
       *
       *  This is the constructor provided by the standard.
       *
       *  @param __table If non-zero, table is used as the per-char mask.
       *               Else classic_table() is used.
       *  @param __del   If true, passes ownership of table to this facet.
       *  @param __refs  Passed to the base facet class.
      *//// The size of the mask table.  It is SCHAR_MAX + 1./// The facet id for ctype<char>// 2 memcpy can't be used// 0 uninitialized, 1 init,/// Typedef for the template parameter char./**
   *  @brief  The ctype<char> specialization.
   *  @ingroup locales
   *
   *  This class defines classification and conversion functions for
   *  the char type.  It gets used by char streams for many I/O
   *  operations.  The char specialization provides a number of
   *  optimizations as well.
  *//// The facet id for ctype<char_type>/**
   *  @brief  Primary class template ctype facet.
   *  @ingroup locales
   *
   *  This template class defines classification and conversion functions for
   *  character sets.  It wraps cctype functionality.  Ctype gets used by
   *  streams for many I/O operations.
   *
   *  This template provides the protected virtual functions the developer
   *  will have to replace in a derived class or specialization to make a
   *  working facet.  The public functions that access them are defined in
   *  __ctype_abstract_base, to allow for implementation flexibility.  See
   *  ctype<wchar_t> for an example.  The functions are documented in
   *  __ctype_abstract_base.
   *
   *  Note: implementations are provided for all the protected virtual
   *  functions, but will likely not be useful.
  *//**
       *  @brief  Narrow char_type array to char
       *
       *  This virtual function converts each char_type in the range
       *  [__lo,__hi) to char using the simplest reasonable
       *  transformation and writes the results to the destination
       *  array.  For any element in the input that cannot be
       *  converted, @a __dfault is used instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char_type to char
       *
       *  This virtual function converts the argument to char using the
       *  simplest reasonable transformation.  If the conversion fails, dfault
       *  is returned instead.
       *
       *  do_narrow() is a hook for a derived facet to change the behavior of
       *  narrowing.  do_narrow() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char_type to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen char array
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char
       *
       *  This virtual function converts the char to char_type using the
       *  simplest reasonable transformation.
       *
       *  do_widen() is a hook for a derived facet to change the behavior of
       *  widening.  do_widen() must always return the same result for the
       *  same input.
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted char_type
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This virtual function converts each char_type in the range [__lo,__hi)
       *  to lowercase if possible.  Other elements remain untouched.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This virtual function converts the argument to lowercase if
       *  possible.  If not possible (for example, '2'), returns the argument.
       *
       *  do_tolower() is a hook for a derived facet to change the behavior of
       *  lowercasing.  do_tolower() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This virtual function converts each char_type in the range [__lo,__hi)
       *  to uppercase if possible.  Other elements remain untouched.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This virtual function converts the char_type argument to uppercase
       *  if possible.  If not possible (for example, '2'), returns the
       *  argument.
       *
       *  do_toupper() is a hook for a derived facet to change the behavior of
       *  uppercasing.  do_toupper() must always return the same result for
       *  the same input.
       *
       *  @param __c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Find char_type not matching mask
       *
       *  This function searches for and returns a pointer to the first
       *  char_type c of [lo,hi) for which is(m,c) is false.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a non-matching char_type if found, else @a __hi.
      *//**
       *  @brief  Find char_type matching mask
       *
       *  This function searches for and returns the first char_type c in
       *  [__lo,__hi) for which is(__m,c) is true.
       *
       *  do_scan_is() is a hook for a derived facet to change the behavior of
       *  match searching.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to a matching char_type if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the input.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a c and compares it to mask @a m.
       *
       *  do_is() is a hook for a derived facet to change the behavior of
       *  classifying.  do_is() must always return the same result for the
       *  same input.
       *
       *  @param __c  The char_type to find the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      *//**
       *  @brief  Narrow array to char array
       *
       *  This function converts each char_type in the input to char using the
       *  simplest reasonable transformation and writes the results to the
       *  destination array.  For any char_type in the input that cannot be
       *  converted, @a dfault is used instead.  It does so by returning
       *  ctype<char_type>::do_narrow(__lo, __hi, __dfault, __to).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __dfault  Char to use if conversion fails.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Narrow char_type to char
       *
       *  This function converts the char_type to char using the simplest
       *  reasonable transformation.  If the conversion fails, dfault is
       *  returned instead.  It does so by returning
       *  ctype<char_type>::do_narrow(__c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char_type to convert.
       *  @param __dfault  Char to return if conversion fails.
       *  @return  The converted char.
      *//**
       *  @brief  Widen array to char_type
       *
       *  This function converts each char in the input to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __to  Pointer to the destination array.
       *  @return  @a __hi.
      *//**
       *  @brief  Widen char to char_type
       *
       *  This function converts the char argument to char_type using the
       *  simplest reasonable transformation.  It does so by returning
       *  ctype<char_type>::do_widen(c).
       *
       *  Note: this is not what you want for codepage conversions.  See
       *  codecvt for that.
       *
       *  @param __c  The char to convert.
       *  @return  The converted char_type.
      *//**
       *  @brief  Convert array to lowercase.
       *
       *  This function converts each char_type in the range [__lo,__hi) to
       *  lowercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_tolower(__lo, __hi).
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to lowercase.
       *
       *  This function converts the argument to lowercase if possible.  If
       *  not possible (for example, '2'), returns the argument.  It does so
       *  by returning ctype<char_type>::do_tolower(c).
       *
       *  @param __c  The char_type to convert.
       *  @return  The lowercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Convert array to uppercase.
       *
       *  This function converts each char_type in the range [lo,hi) to
       *  uppercase if possible.  Other elements remain untouched.  It does so
       *  by returning ctype<char_type>:: do_toupper(lo, hi).
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  @a __hi.
      *//**
       *  @brief  Convert to uppercase.
       *
       *  This function converts the argument to uppercase if possible.
       *  If not possible (for example, '2'), returns the argument.  It does
       *  so by returning ctype<char_type>::do_toupper().
       *
       *  @param __c  The char_type to convert.
       *  @return  The uppercase char_type if convertible, else @a __c.
      *//**
       *  @brief  Find char_type not matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is false.  It does so by returning
       *  ctype<char_type>::do_scan_not().
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to first char in range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to non-matching char if found, else @a __hi.
      *//**
       *  @brief  Find char_type matching a mask
       *
       *  This function searches for and returns the first char_type c in
       *  [lo,hi) for which is(m,c) is true.  It does so by returning
       *  ctype<char_type>::do_scan_is().
       *
       *  @param __m  The mask to compare against.
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @return  Pointer to matching char_type if found, else @a __hi.
      *//**
       *  @brief  Return a mask array.
       *
       *  This function finds the mask for each char_type in the range [lo,hi)
       *  and successively writes it to vec.  vec must have as many elements
       *  as the char array.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param __lo  Pointer to start of range.
       *  @param __hi  Pointer to end of range.
       *  @param __vec  Pointer to an array of mask storage.
       *  @return  @a __hi.
      *//**
       *  @brief  Test char_type classification.
       *
       *  This function finds a mask M for @a __c and compares it to
       *  mask @a __m.  It does so by returning the value of
       *  ctype<char_type>::do_is().
       *
       *  @param __c  The char_type to compare the mask of.
       *  @param __m  The mask to compare against.
       *  @return  (M & __m) != 0.
      *//// Typedef for the template parameter/**
   *  @brief  Common base for ctype facet
   *
   *  This template class provides implementations of the public functions
   *  that forward to the protected virtual functions.
   *
   *  This template also provides abstract stubs for the protected virtual
   *  functions.
  */// Include host and configuration specific ctype enums for ctype_base.// 22.2.1.1  Template class ctype// This is the unspecialized form of the template.// significantly more efficient than incrementing iterators.// ostreambuf_iterator.  For ostreambuf_iterator, sputn is// This template permits specializing facet output code for// only with __gsize != 0.// in the buffer this way: "xxxx12345" -> "12,345xxx".  Call this// It's recursive, one iteration per group.  It moves the characters// Inserts "group separator" characters into an array of characters.// Used by both numeric and monetary facets.// partially-specialized.// NB: __pad is a struct, rather than a function, so it can be// Explicit specializations for required types.// generic definition.// NB: This is specialized for all required types, there is no// Convert string to numeric value of type _Tp and store results.// NB: Don't instantiate required wchar_t facets if no wchar_t support.// For ios_base, ios_base::iostate// For wctype_t/** @file bits/locale_facets.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{locale}
 */__fptr__table__news__olds__newlen__oldlenbasic_ifstream<_CharT, _Traits> *ios_base::in<bits/quoted_string.h>quotedget_timeput_time_MoneyTput_moneyconst _MoneyTconst _MoneyT &_MoneyT &get_moneysetwsetprecisionsetfillsetbasesetiosflagsresetiosflags_Setw &_Setw &&const _Setwconst _Setw &_Setprecision &_Setprecision &&const _Setprecisionconst _Setprecision &_Setbase &_Setbase &&const _Setbaseconst _Setbase &_Setiosflags &_Setiosflags &&const _Setiosflagsconst _Setiosflags &_Resetiosflags &_Resetiosflags &&const _Resetiosflagsconst _Resetiosflags &_Get_time<_CharT>_Put_time<_CharT>_Put_money<_MoneyT>_Get_money<_MoneyT>_Setw_Setprecision_Setfill<_CharT>_Setbase_Setiosflags_Resetiosflags_M_fmt_M_tmb_M_intl_M_mon_M_c__cpp_lib_quoted_string_io_GLIBCXX_IOMANIP__cxxabiv1::__forced_unwind&/* _GLIBCXX_IOMANIP */// NB:  This syntax is a GNU extension.// 2785. quoted should work with basic_string_view/**
   * @brief Manipulator for quoted strings.
   * @param __string String to quote.
   * @param __delim  Character to quote string with.
   * @param __escape Escape character to escape itself or quote character.
   *//**
   *  @brief  Extended manipulator for extracting time.
   *
   *  This manipulator uses time_get::get to extract time.
   *  [ext.manip]
   *
   *  @param __tmb  struct to extract the time data to.
   *  @param __fmt  format string.
   *//**
   *  @brief  Extended manipulator for formatting time.
   *
   *  This manipulator uses time_put::put to format time.
   *  [ext.manip]
   *
   *  @param __tmb  struct tm time data to format.
   *  @param __fmt  format string.
   *//**
   *  @brief  Extended manipulator for inserting money.
   *  @param  __mon  Either long double or a specialization of @c basic_string.
   *  @param  __intl A bool indicating whether international format
   *                 is to be used.
   *
   *  Sent to a stream object, this manipulator inserts @a __mon.
  *//**
   *  @brief  Extended manipulator for extracting money.
   *  @param  __mon  Either long double or a specialization of @c basic_string.
   *  @param  __intl A bool indicating whether international format
   *                 is to be used.
   *
   *  Sent to a stream object, this manipulator extracts @a __mon.
  *//**
   *  @brief  Manipulator for @c width.
   *  @param  __n  The new width.
   *
   *  Sent to a stream object, this manipulator calls @c width(__n) for
   *  that object.
  *//**
   *  @brief  Manipulator for @c precision.
   *  @param  __n  The new precision.
   *
   *  Sent to a stream object, this manipulator calls @c precision(__n) for
   *  that object.
  *//**
   *  @brief  Manipulator for @c fill.
   *  @param  __c  The new fill character.
   *
   *  Sent to a stream object, this manipulator calls @c fill(__c) for that
   *  object.
  *//**
   *  @brief  Manipulator for @c setf.
   *  @param  __base  A numeric base.
   *
   *  Sent to a stream object, this manipulator changes the
   *  @c ios_base::basefield flags to @c oct, @c dec, or @c hex when @a base
   *  is 8, 10, or 16, accordingly, and to 0 if @a __base is any other value.
  *//**
   *  @brief  Manipulator for @c setf.
   *  @param  __mask  A format flags mask.
   *
   *  Sent to a stream object, this manipulator sets the format flags
   *  to @a __mask.
  *//**
   *  @brief  Manipulator for @c setf.
   *  @param  __mask  A format flags mask.
   *
   *  Sent to a stream object, this manipulator resets the specified flags,
   *  via @e stream.setf(0,__mask).
  */// Also see DR 183.// [27.6.3] standard manipulators// ISO C++ 14882: 27.6.3  Standard manipulators/** @file include/iomanip
 *  This is a Standard C++ Library header.
 */// Standard stream manipulators -*- C++ -*-__escape__tmb__mon__intladjacent_differencepartial_suminner_product_BinaryOperation1_BinaryOperation2accumulate__initiota_GLIBCXX_MOVE_IF_20_GLIBCXX_MOVE_IF_20(_E)_STL_NUMERIC_H_OutputIteratorConcept<_OutputIterator, _ValueType>/* _STL_NUMERIC_H *//// @} group numeric_ops/**
   *  @brief  Return differences between adjacent values.
   *
   *  Computes the difference between adjacent values in the range
   *  [__first,__last) using the function object @p __binary_op and writes the
   *  result to @p __result.
   *
   *  @param  __first  Start of input range.
   *  @param  __last  End of input range.
   *  @param  __result  Output sum.
   *  @param  __binary_op Function object.
   *  @return  Iterator pointing just beyond the values written to result.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 539. partial_sum and adjacent_difference should mention requirements
   *//**
   *  @brief  Return differences between adjacent values.
   *
   *  Computes the difference between adjacent values in the range
   *  [first,last) using operator-() and writes the result to @p __result.
   *
   *  @param  __first  Start of input range.
   *  @param  __last  End of input range.
   *  @param  __result  Output sums.
   *  @return  Iterator pointing just beyond the values written to result.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 539. partial_sum and adjacent_difference should mention requirements
   *//**
   *  @brief  Return list of partial sums
   *
   *  Accumulates the values in the range [first,last) using @p __binary_op.
   *  As each successive input value is added into the total, that partial sum
   *  is written to @p __result.  Therefore, the first value in @p __result is
   *  the first value of the input, the second value in @p __result is the sum
   *  of the first and second input values, and so on.
   *
   *  @param  __first  Start of input range.
   *  @param  __last  End of input range.
   *  @param  __result  Output sum.
   *  @param  __binary_op  Function object.
   *  @return  Iterator pointing just beyond the values written to __result.
   *//**
   *  @brief  Return list of partial sums
   *
   *  Accumulates the values in the range [first,last) using the @c + operator.
   *  As each successive input value is added into the total, that partial sum
   *  is written to @p __result.  Therefore, the first value in @p __result is
   *  the first value of the input, the second value in @p __result is the sum
   *  of the first and second input values, and so on.
   *
   *  @param  __first  Start of input range.
   *  @param  __last  End of input range.
   *  @param  __result  Output sum.
   *  @return  Iterator pointing just beyond the values written to __result.
   *//**
   *  @brief  Compute inner product of two ranges.
   *
   *  Starting with an initial value of @p __init, applies @p __binary_op2 to
   *  successive elements from the two ranges and accumulates each result into
   *  the accumulated value using @p __binary_op1.  The values in the ranges are
   *  processed in order.
   *
   *  @param  __first1  Start of range 1.
   *  @param  __last1  End of range 1.
   *  @param  __first2  Start of range 2.
   *  @param  __init  Starting value to add other values to.
   *  @param  __binary_op1  Function object to accumulate with.
   *  @param  __binary_op2  Function object to apply to pairs of input values.
   *  @return  The final inner product.
   *//**
   *  @brief  Compute inner product of two ranges.
   *
   *  Starting with an initial value of @p __init, multiplies successive
   *  elements from the two ranges and adds each product into the accumulated
   *  value using operator+().  The values in the ranges are processed in
   *  order.
   *
   *  @param  __first1  Start of range 1.
   *  @param  __last1  End of range 1.
   *  @param  __first2  Start of range 2.
   *  @param  __init  Starting value to add other values to.
   *  @return  The final inner product.
   *//**
   *  @brief  Accumulate values in a range with operation.
   *
   *  Accumulates the values in the range `[first,last)` using the function
   *  object `__binary_op`.  The initial value is `__init`.  The values are
   *  processed in order.
   *
   *  @param  __first  Start of range.
   *  @param  __last  End of range.
   *  @param  __init  Starting value to add other values to.
   *  @param  __binary_op  Function object to accumulate with.
   *  @return  The final sum.
   *//**
   *  @brief  Accumulate values in a range.
   *
   *  Accumulates the values in the range [first,last) using operator+().  The
   *  initial value is @a init.  The values are processed in order.
   *
   *  @param  __first  Start of range.
   *  @param  __last  End of range.
   *  @param  __init  Starting value to add other values to.
   *  @return  The final sum.
   *//// @{/// @addtogroup numeric_ops// DR 2055. std::move in std::accumulate and other algorithms/**
   *  @brief  Create a range of sequentially increasing values.
   *
   *  For each element in the range @p [first,last) assigns @p value and
   *  increments @p value as if by @p ++value.
   *
   *  @param  __first  Start of range.
   *  @param  __last  End of range.
   *  @param  __value  Starting value.
   *  @return  Nothing.
   *  @ingroup numeric_ops
   *//** @defgroup numeric_ops Generalized Numeric operations
   *  @ingroup algorithms
   */// For _GLIBCXX_MOVE/** @file bits/stl_numeric.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{numeric}
 */// Numeric functions implementation -*- C++ -*-__binary_op1__binary_op2socklen_t_Rb_tree_const_iterator<pair<const unsigned long, Target>> &_Rb_tree_iterator<pair<const unsigned long, Target>> &const _Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, less<unsigned long>, allocator<pair<const unsigned long, Target>>>const _Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, less<unsigned long>, allocator<pair<const unsigned long, Target>>> &_Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, less<unsigned long>, allocator<pair<const unsigned long, Target>>> &/usr/include/x86_64-linux-gnu/asm/swab.h<linux/types.h>__arch_swab64__arch_swab32_ASM_X86_SWAB_H/* _ASM_X86_SWAB_H *//* __i386__ *//* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note *//usr/include/x86_64-linux-gnu/asm/usr/include/linux/swab.h<asm/swab.h><asm/bitsperlong.h>__swahb32s__u32 *const __u32const __u32 *__swahw32s__swab64s__u64 *unsigned long long *const __u64const __u64 *__swab32s__swab16s__u16 *const __u16const __u16 *__swahb32p*p167119354278255360__swahw32p__swab64p6528016711680427819008010952166604802803754650828807177611906121728018374686479671623680__swab32p__swab16p__swab__fswahb32__fswahw32__fswab64__fswab32__fswab16__swahb32(x)(__builtin_constant_p((__u32)(x)) ? ___constant_swahb32(x) : __fswahb32(x))__swahw32(x)(__builtin_constant_p((__u32)(x)) ? ___constant_swahw32(x) : __fswahw32(x))__swab64(x)(__builtin_constant_p((__u64)(x)) ? ___constant_swab64(x) : __fswab64(x))__swab32(x)(__builtin_constant_p((__u32)(x)) ? ___constant_swab32(x) : __fswab32(x))__swab16(x)(__builtin_constant_p((__u16)(x)) ? ___constant_swab16(x) : __fswab16(x))___constant_swahb32(x)((__u32)( (((__u32)(x) & (__u32)0x00ff00ffUL) << 8) | (((__u32)(x) & (__u32)0xff00ff00UL) >> 8)))___constant_swahw32(x)((__u32)( (((__u32)(x) & (__u32)0x0000ffffUL) << 16) | (((__u32)(x) & (__u32)0xffff0000UL) >> 16)))___constant_swab64(x)((__u64)( (((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | (((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | (((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | (((__u64)(x) & (__u64)0x00000000ff000000ULL) << 8) | (((__u64)(x) & (__u64)0x000000ff00000000ULL) >> 8) | (((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | (((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | (((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56)))___constant_swab32(x)((__u32)( (((__u32)(x) & (__u32)0x000000ffUL) << 24) | (((__u32)(x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(x) & (__u32)0xff000000UL) >> 24)))___constant_swab16(x)((__u16)( (((__u16)(x) & (__u16)0x00ffU) << 8) | (((__u16)(x) & (__u16)0xff00U) >> 8)))_LINUX_SWAB_Hdefined (__arch_swab16)defined(__arch_swab32)defined (__arch_swab64)defined(__SWAB_64_THRU_32__)__arch_swahw32__arch_swahb32__HAVE_BUILTIN_BSWAP16____HAVE_BUILTIN_BSWAP32____HAVE_BUILTIN_BSWAP64____BITS_PER_LONG == 64__arch_swab16p__arch_swab32p__arch_swab64p__arch_swahw32p__arch_swahb32p__arch_swab16s__arch_swab32s__arch_swab64s__arch_swahw32s__arch_swahb32s/* _LINUX_SWAB_H *//**
 * __swahb32s - high and low byteswap a 32-bit value in-place
 * @p: pointer to a naturally-aligned 32-bit value
 *
 * See __swahb32() for details of high and low byte swapping
 *//**
 * __swahw32s - wordswap a 32-bit value in-place
 * @p: pointer to a naturally-aligned 32-bit value
 *
 * See __swahw32() for details of wordswapping
 *//**
 * __swab64s - byteswap a 64-bit value in-place
 * @p: pointer to a naturally-aligned 64-bit value
 *//**
 * __swab32s - byteswap a 32-bit value in-place
 * @p: pointer to a naturally-aligned 32-bit value
 *//**
 * __swab16s - byteswap a 16-bit value in-place
 * @p: pointer to a naturally-aligned 16-bit value
 *//**
 * __swahb32p - return a high and low byteswapped 32-bit value from a pointer
 * @p: pointer to a naturally-aligned 32-bit value
 *
 * See __swahb32() for details of high/low byteswapping.
 *//**
 * __swahw32p - return a wordswapped 32-bit value from a pointer
 * @p: pointer to a naturally-aligned 32-bit value
 *
 * See __swahw32() for details of wordswapping.
 *//**
 * __swab64p - return a byteswapped 64-bit value from a pointer
 * @p: pointer to a naturally-aligned 64-bit value
 *//**
 * __swab32p - return a byteswapped 32-bit value from a pointer
 * @p: pointer to a naturally-aligned 32-bit value
 *//**
 * __swab16p - return a byteswapped 16-bit value from a pointer
 * @p: pointer to a naturally-aligned 16-bit value
 *//**
 * __swahb32 - return a high and low byte-swapped 32-bit value
 * @x: value to byteswap
 *
 * __swahb32(0x12345678) is 0x34127856
 *//**
 * __swahw32 - return a word-swapped 32-bit value
 * @x: value to wordswap
 *
 * __swahw32(0x12340000) is 0x00001234
 *//* __BITS_PER_LONG == 32 *//**
 * __swab64 - return a byteswapped 64-bit value
 * @x: value to byteswap
 *//**
 * __swab32 - return a byteswapped 32-bit value
 * @x: value to byteswap
 *//**
 * __swab16 - return a byteswapped 16-bit value
 * @x: value to byteswap
 *//*
 * Implement the following as inlines, but define the interface using
 * macros to allow constant folding when possible:
 * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
 *//*
 * casts are necessary for constants, because we never know how for sure
 * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.
 *//usr/include/linux/usr/include/linux/byteorder/little_endian.h<linux/swab.h>__be16_to_cpupconst __be16const __be16 *__cpu_to_be16p__be32_to_cpupconst __be32const __be32 *__cpu_to_be32p__be64_to_cpupconst __be64const __be64 *__cpu_to_be64p__le16_to_cpupconst __le16const __le16 *__cpu_to_le16p__le32_to_cpupconst __le32const __le32 *__cpu_to_le32p__le64_to_cpupconst __le64const __le64 *__cpu_to_le64p__be16_to_cpus(x)__swab16s((x))__cpu_to_be16s(x)__be32_to_cpus(x)__swab32s((x))__cpu_to_be32s(x)__be64_to_cpus(x)__swab64s((x))__cpu_to_be64s(x)__le16_to_cpus(x)do { (void)(x); } while (0)__cpu_to_le16s(x)__le32_to_cpus(x)__cpu_to_le32s(x)__le64_to_cpus(x)__cpu_to_le64s(x)__be16_to_cpu(x)__swab16((__u16)(__be16)(x))__cpu_to_be16(x)((__be16)__swab16((x)))__be32_to_cpu(x)__swab32((__u32)(__be32)(x))__cpu_to_be32(x)((__be32)__swab32((x)))__be64_to_cpu(x)__swab64((__u64)(__be64)(x))__cpu_to_be64(x)((__be64)__swab64((x)))__le16_to_cpu(x)((__u16)(__le16)(x))__cpu_to_le16(x)((__le16)(__u16)(x))__le32_to_cpu(x)((__u32)(__le32)(x))__cpu_to_le32(x)((__le32)(__u32)(x))__le64_to_cpu(x)((__u64)(__le64)(x))__cpu_to_le64(x)((__le64)(__u64)(x))__constant_be16_to_cpu(x)___constant_swab16((__u16)(__be16)(x))__constant_cpu_to_be16(x)((__be16)___constant_swab16((x)))__constant_be32_to_cpu(x)___constant_swab32((__u32)(__be32)(x))__constant_cpu_to_be32(x)((__be32)___constant_swab32((x)))__constant_be64_to_cpu(x)___constant_swab64((__u64)(__be64)(x))__constant_cpu_to_be64(x)((__be64)___constant_swab64((x)))__constant_le16_to_cpu(x)__constant_cpu_to_le16(x)__constant_le32_to_cpu(x)__constant_cpu_to_le32(x)__constant_le64_to_cpu(x)__constant_cpu_to_le64(x)__constant_ntohs(x)___constant_swab16((__be16)(x))__constant_htons(x)__constant_ntohl(x)___constant_swab32((__be32)(x))__constant_htonl(x)__LITTLE_ENDIAN_BITFIELD_LINUX_BYTEORDER_LITTLE_ENDIAN_H__LITTLE_ENDIAN/* _LINUX_BYTEORDER_LITTLE_ENDIAN_H *//usr/include/linux/byteorder/usr/include/x86_64-linux-gnu/asm/byteorder.h<linux/byteorder/little_endian.h>_ASM_X86_BYTEORDER_H/* _ASM_X86_BYTEORDER_H *//usr/include/linux/perf_event.h<asm/byteorder.h><linux/ioctl.h>perf_branch_entry &perf_branch_entry &&const perf_branch_entryconst perf_branch_entry &perf_mem_data_src &perf_mem_data_src &&const perf_mem_data_srcconst perf_mem_data_src &perf_ns_link_info &perf_ns_link_info &&const perf_ns_link_infoconst perf_ns_link_info &perf_event_header &perf_event_header &&const perf_event_headerconst perf_event_header &perf_event_mmap_page &perf_event_mmap_page &&const perf_event_mmap_pageconst perf_event_mmap_page &perf_event_query_bpf &perf_event_query_bpf &&const perf_event_query_bpfconst perf_event_query_bpf &perf_event_attr &perf_event_attr &&const perf_event_attrconst perf_event_attr &perf_branch_entryperf_mem_data_srcperf_callchain_contextPERF_CONTEXT_HV18446744073709551584(__u64)-32PERF_CONTEXT_KERNEL18446744073709551488(__u64)-128PERF_CONTEXT_USER18446744073709551104(__u64)-512PERF_CONTEXT_GUEST18446744073709549568(__u64)-2048PERF_CONTEXT_GUEST_KERNEL217618446744073709549440(__u64)-2176PERF_CONTEXT_GUEST_USER256018446744073709549056(__u64)-2560PERF_CONTEXT_MAX18446744073709547521(__u64)-4095perf_bpf_event_typePERF_BPF_EVENT_UNKNOWNPERF_BPF_EVENT_PROG_LOADPERF_BPF_EVENT_PROG_UNLOADPERF_BPF_EVENT_MAXperf_record_ksymbol_typePERF_RECORD_KSYMBOL_TYPE_UNKNOWNPERF_RECORD_KSYMBOL_TYPE_BPFPERF_RECORD_KSYMBOL_TYPE_MAXperf_event_typePERF_RECORD_MMAPPERF_RECORD_LOSTPERF_RECORD_COMMPERF_RECORD_EXITPERF_RECORD_THROTTLEPERF_RECORD_UNTHROTTLEPERF_RECORD_FORKPERF_RECORD_READPERF_RECORD_SAMPLEPERF_RECORD_MMAP2PERF_RECORD_AUXPERF_RECORD_ITRACE_STARTPERF_RECORD_LOST_SAMPLESPERF_RECORD_SWITCHPERF_RECORD_SWITCH_CPU_WIDEPERF_RECORD_NAMESPACESPERF_RECORD_KSYMBOLPERF_RECORD_BPF_EVENTPERF_RECORD_MAXNET_NS_INDEXUTS_NS_INDEXIPC_NS_INDEXPID_NS_INDEXUSER_NS_INDEXMNT_NS_INDEXCGROUP_NS_INDEXNR_NAMESPACESperf_ns_link_infoperf_event_headerperf_event_mmap_pageperf_event_ioc_flagsPERF_IOC_FLAG_GROUPperf_event_query_bpfperf_event_attrperf_event_read_formatPERF_FORMAT_TOTAL_TIME_ENABLEDPERF_FORMAT_TOTAL_TIME_RUNNINGPERF_FORMAT_ID1U << 2PERF_FORMAT_GROUP1U << 3PERF_FORMAT_MAX1U << 4PERF_TXN_ELISIONPERF_TXN_TRANSACTIONPERF_TXN_SYNCPERF_TXN_ASYNCPERF_TXN_RETRY1 << 4(1 << 4)PERF_TXN_CONFLICT1 << 5(1 << 5)PERF_TXN_CAPACITY_WRITEPERF_TXN_CAPACITY_READ1 << 7(1 << 7)PERF_TXN_MAX1 << 8(1 << 8)PERF_TXN_ABORT_MASK0xffffffffULL184467440694145843200xffffffffULL << 32(0xffffffffULL << 32)PERF_TXN_ABORT_SHIFTperf_sample_regs_abiPERF_SAMPLE_REGS_ABI_NONEPERF_SAMPLE_REGS_ABI_32PERF_SAMPLE_REGS_ABI_64PERF_BR_UNKNOWNPERF_BR_CONDPERF_BR_UNCONDPERF_BR_INDPERF_BR_CALLPERF_BR_IND_CALLPERF_BR_RETPERF_BR_SYSCALLPERF_BR_SYSRETPERF_BR_COND_CALLPERF_BR_COND_RETPERF_BR_MAXperf_branch_sample_typePERF_SAMPLE_BRANCH_USERPERF_SAMPLE_BRANCH_USER_SHIFT1U << PERF_SAMPLE_BRANCH_USER_SHIFTPERF_SAMPLE_BRANCH_KERNELPERF_SAMPLE_BRANCH_KERNEL_SHIFT1U << PERF_SAMPLE_BRANCH_KERNEL_SHIFTPERF_SAMPLE_BRANCH_HVPERF_SAMPLE_BRANCH_HV_SHIFT1U << PERF_SAMPLE_BRANCH_HV_SHIFTPERF_SAMPLE_BRANCH_ANYPERF_SAMPLE_BRANCH_ANY_SHIFT1U << PERF_SAMPLE_BRANCH_ANY_SHIFTPERF_SAMPLE_BRANCH_ANY_CALLPERF_SAMPLE_BRANCH_ANY_CALL_SHIFT1U << PERF_SAMPLE_BRANCH_ANY_CALL_SHIFTPERF_SAMPLE_BRANCH_ANY_RETURNPERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT1U << PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFTPERF_SAMPLE_BRANCH_IND_CALLPERF_SAMPLE_BRANCH_IND_CALL_SHIFT1U << PERF_SAMPLE_BRANCH_IND_CALL_SHIFTPERF_SAMPLE_BRANCH_ABORT_TXPERF_SAMPLE_BRANCH_ABORT_TX_SHIFT1U << PERF_SAMPLE_BRANCH_ABORT_TX_SHIFTPERF_SAMPLE_BRANCH_IN_TXPERF_SAMPLE_BRANCH_IN_TX_SHIFT1U << PERF_SAMPLE_BRANCH_IN_TX_SHIFTPERF_SAMPLE_BRANCH_NO_TXPERF_SAMPLE_BRANCH_NO_TX_SHIFT1U << PERF_SAMPLE_BRANCH_NO_TX_SHIFTPERF_SAMPLE_BRANCH_CONDPERF_SAMPLE_BRANCH_COND_SHIFT1U << PERF_SAMPLE_BRANCH_COND_SHIFTPERF_SAMPLE_BRANCH_CALL_STACKPERF_SAMPLE_BRANCH_CALL_STACK_SHIFT1U << PERF_SAMPLE_BRANCH_CALL_STACK_SHIFTPERF_SAMPLE_BRANCH_IND_JUMPPERF_SAMPLE_BRANCH_IND_JUMP_SHIFT1U << PERF_SAMPLE_BRANCH_IND_JUMP_SHIFTPERF_SAMPLE_BRANCH_CALLPERF_SAMPLE_BRANCH_CALL_SHIFT1U << PERF_SAMPLE_BRANCH_CALL_SHIFTPERF_SAMPLE_BRANCH_NO_FLAGSPERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT1U << PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFTPERF_SAMPLE_BRANCH_NO_CYCLESPERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT1U << PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFTPERF_SAMPLE_BRANCH_TYPE_SAVEPERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT1U << PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFTPERF_SAMPLE_BRANCH_MAXPERF_SAMPLE_BRANCH_MAX_SHIFT1U << PERF_SAMPLE_BRANCH_MAX_SHIFTperf_branch_sample_type_shiftperf_event_sample_formatPERF_SAMPLE_IPPERF_SAMPLE_TIDPERF_SAMPLE_TIMEPERF_SAMPLE_ADDRPERF_SAMPLE_READPERF_SAMPLE_CALLCHAIN1U << 5PERF_SAMPLE_ID1U << 6PERF_SAMPLE_CPU1U << 7PERF_SAMPLE_PERIOD1U << 8PERF_SAMPLE_STREAM_ID1U << 9PERF_SAMPLE_RAW1U << 10PERF_SAMPLE_BRANCH_STACK1U << 11PERF_SAMPLE_REGS_USER1U << 12PERF_SAMPLE_STACK_USER1U << 13PERF_SAMPLE_WEIGHT1U << 14PERF_SAMPLE_DATA_SRC1U << 15PERF_SAMPLE_IDENTIFIER1U << 16PERF_SAMPLE_TRANSACTION1U << 17PERF_SAMPLE_REGS_INTR1U << 18PERF_SAMPLE_PHYS_ADDR1U << 19PERF_SAMPLE_MAX1U << 20__PERF_SAMPLE_CALLCHAIN_EARLY1ULL << 63perf_hw_cache_op_result_idPERF_COUNT_HW_CACHE_RESULT_ACCESSPERF_COUNT_HW_CACHE_RESULT_MISSPERF_COUNT_HW_CACHE_RESULT_MAXperf_hw_cache_op_idPERF_COUNT_HW_CACHE_OP_READPERF_COUNT_HW_CACHE_OP_WRITEPERF_COUNT_HW_CACHE_OP_PREFETCHPERF_COUNT_HW_CACHE_OP_MAXperf_hw_cache_idPERF_COUNT_HW_CACHE_L1DPERF_COUNT_HW_CACHE_L1IPERF_COUNT_HW_CACHE_LLPERF_COUNT_HW_CACHE_DTLBPERF_COUNT_HW_CACHE_ITLBPERF_COUNT_HW_CACHE_BPUPERF_COUNT_HW_CACHE_NODEPERF_COUNT_HW_CACHE_MAXperf_type_idPERF_TYPE_HARDWAREPERF_TYPE_SOFTWAREPERF_TYPE_TRACEPOINTPERF_TYPE_HW_CACHEPERF_TYPE_RAWPERF_TYPE_BREAKPOINTPERF_TYPE_MAXperf_hw_idPERF_COUNT_HW_CPU_CYCLESPERF_COUNT_HW_INSTRUCTIONSPERF_COUNT_HW_CACHE_REFERENCESPERF_COUNT_HW_CACHE_MISSESPERF_COUNT_HW_BRANCH_INSTRUCTIONSPERF_COUNT_HW_BRANCH_MISSESPERF_COUNT_HW_BUS_CYCLESPERF_COUNT_HW_STALLED_CYCLES_FRONTENDPERF_COUNT_HW_STALLED_CYCLES_BACKENDPERF_COUNT_HW_REF_CPU_CYCLESPERF_COUNT_HW_MAXperf_sw_idsPERF_COUNT_SW_CPU_CLOCKPERF_COUNT_SW_TASK_CLOCKPERF_COUNT_SW_PAGE_FAULTSPERF_COUNT_SW_CONTEXT_SWITCHESPERF_COUNT_SW_CPU_MIGRATIONSPERF_COUNT_SW_PAGE_FAULTS_MINPERF_COUNT_SW_PAGE_FAULTS_MAJPERF_COUNT_SW_ALIGNMENT_FAULTSPERF_COUNT_SW_EMULATION_FAULTSPERF_COUNT_SW_DUMMYPERF_COUNT_SW_BPF_OUTPUTPERF_COUNT_SW_MAXreservedcyclesabortin_txpredictedmispredmem_rsvdmem_snoopxmem_remotemem_lvl_nummem_dtlbmem_lockmem_snoopmem_lvlmem_opinodevmiscaux_sizeaux_offsetaux_tailaux_headdata_sizedata_offsetdata_taildata_head__u8[948]unsigned char[948]118*8118*8+4__reservedtime_zerotime_offsettime_multtime_shiftpmc_widthcap_____rescap_user_time_zerocap_user_timecap_user_rdpmccap_bit0_is_deprecatedcap_bit0capabilitiestime_runningtime_enabledcompat_version__u32[0]unsigned int[0]idsprog_cntids_len__reserved_2sample_max_stackaux_watermarksample_regs_intrclockidsample_stack_usersample_regs_userbranch_sample_typeconfig2probe_offsetkprobe_addrbp_lenconfig1uprobe_pathkprobe_funcbp_addrbp_typewakeup_watermarkwakeup_events__reserved_1aux_outputbpf_eventksymbolnamespaceswrite_backwardcontext_switchuse_clockidcomm_execmmap2exclude_callchain_userexclude_callchain_kernelexclude_guestexclude_hostsample_id_allmmap_dataprecise_ipwatermarktaskenable_on_execinherit_statfreqcommmmapexclude_idleexclude_hvexclude_kernelexclude_userexclusivepinnedinheritdisabledread_formatsample_typesample_freqsample_periodPERF_MEM_S(a,s)(((__u64)PERF_MEM_ ## a ## _ ## s) << PERF_MEM_ ## a ## _SHIFT)PERF_MEM_TLB_SHIFTPERF_MEM_TLB_OSPERF_MEM_TLB_WKPERF_MEM_TLB_L20x10PERF_MEM_TLB_L10x08PERF_MEM_TLB_MISS0x04PERF_MEM_TLB_HIT0x02PERF_MEM_TLB_NAPERF_MEM_LOCK_SHIFTPERF_MEM_LOCK_LOCKEDPERF_MEM_LOCK_NAPERF_MEM_SNOOPX_SHIFTPERF_MEM_SNOOPX_FWDPERF_MEM_SNOOP_SHIFTPERF_MEM_SNOOP_HITMPERF_MEM_SNOOP_MISSPERF_MEM_SNOOP_HITPERF_MEM_SNOOP_NONEPERF_MEM_SNOOP_NAPERF_MEM_LVLNUM_SHIFTPERF_MEM_LVLNUM_NA0x0fPERF_MEM_LVLNUM_PMEM0x0ePERF_MEM_LVLNUM_RAMPERF_MEM_LVLNUM_LFB0x0cPERF_MEM_LVLNUM_ANY_CACHE0x0bPERF_MEM_LVLNUM_L4PERF_MEM_LVLNUM_L30x03PERF_MEM_LVLNUM_L2PERF_MEM_LVLNUM_L1PERF_MEM_REMOTE_SHIFTPERF_MEM_REMOTE_REMOTEPERF_MEM_LVL_SHIFTPERF_MEM_LVL_UNC0x2000PERF_MEM_LVL_IO0x1000PERF_MEM_LVL_REM_CCE2PERF_MEM_LVL_REM_CCE1PERF_MEM_LVL_REM_RAM2PERF_MEM_LVL_REM_RAM1PERF_MEM_LVL_LOC_RAMPERF_MEM_LVL_L3PERF_MEM_LVL_L2PERF_MEM_LVL_LFBPERF_MEM_LVL_L1PERF_MEM_LVL_MISSPERF_MEM_LVL_HITPERF_MEM_LVL_NAPERF_MEM_OP_SHIFTPERF_MEM_OP_EXECPERF_MEM_OP_PFETCHPERF_MEM_OP_STOREPERF_MEM_OP_LOADPERF_MEM_OP_NAPERF_FLAG_FD_CLOEXEC(1UL << 3)PERF_FLAG_PID_CGROUP(1UL << 2)PERF_FLAG_FD_OUTPUT(1UL << 1)PERF_FLAG_FD_NO_GROUP(1UL << 0)PERF_AUX_FLAG_COLLISIONPERF_AUX_FLAG_PARTIALPERF_AUX_FLAG_OVERWRITEPERF_AUX_FLAG_TRUNCATEDPERF_MAX_CONTEXTS_PER_STACKPERF_MAX_STACK_DEPTHPERF_RECORD_KSYMBOL_FLAGS_UNREGISTERPERF_RECORD_MISC_EXT_RESERVEDPERF_RECORD_MISC_SWITCH_OUT_PREEMPTPERF_RECORD_MISC_EXACT_IPPERF_RECORD_MISC_SWITCH_OUTPERF_RECORD_MISC_FORK_EXECPERF_RECORD_MISC_COMM_EXECPERF_RECORD_MISC_MMAP_DATAPERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUTPERF_RECORD_MISC_GUEST_USER(5 << 0)PERF_RECORD_MISC_GUEST_KERNEL(4 << 0)PERF_RECORD_MISC_HYPERVISOR(3 << 0)PERF_RECORD_MISC_USER(2 << 0)PERF_RECORD_MISC_KERNELPERF_RECORD_MISC_CPUMODE_UNKNOWN(0 << 0)PERF_RECORD_MISC_CPUMODE_MASK(7 << 0)PERF_EVENT_IOC_MODIFY_ATTRIBUTES_IOW('$', 11, struct perf_event_attr *)PERF_EVENT_IOC_QUERY_BPF_IOWR('$', 10, struct perf_event_query_bpf *)PERF_EVENT_IOC_PAUSE_OUTPUT_IOW('$', 9, __u32)PERF_EVENT_IOC_SET_BPF_IOW('$', 8, __u32)PERF_EVENT_IOC_ID_IOR('$', 7, __u64 *)PERF_EVENT_IOC_SET_FILTER_IOW('$', 6, char *)PERF_EVENT_IOC_SET_OUTPUT_IO ('$', 5)PERF_EVENT_IOC_PERIOD_IOW('$', 4, __u64)PERF_EVENT_IOC_RESET_IO ('$', 3)PERF_EVENT_IOC_REFRESH_IO ('$', 2)PERF_EVENT_IOC_DISABLE_IO ('$', 1)PERF_EVENT_IOC_ENABLE_IO ('$', 0)PERF_ATTR_SIZE_VER5PERF_ATTR_SIZE_VER4PERF_ATTR_SIZE_VER3PERF_ATTR_SIZE_VER2PERF_ATTR_SIZE_VER1PERF_ATTR_SIZE_VER0PERF_SAMPLE_BRANCH_PLM_ALL(PERF_SAMPLE_BRANCH_USER| PERF_SAMPLE_BRANCH_KERNEL| PERF_SAMPLE_BRANCH_HV)_LINUX_PERF_EVENT_Hdefined(__LITTLE_ENDIAN_BITFIELD)defined(__BIG_ENDIAN_BITFIELD)/* _LINUX_PERF_EVENT_H *//* branch type *//* cycle count to last branch *//* transaction abort *//* in transaction *//* target predicted *//* target mispredicted *//*
 * single taken branch record layout:
 *
 *      from: source instruction (may not always be a branch insn)
 *        to: branch target
 *   mispred: branch target was mispredicted
 * predicted: branch target was predicted
 *
 * support for mispred, predicted is optional. In case it
 * is not supported mispred = predicted = 0.
 *
 *     in_tx: running in a hardware transaction
 *     abort: aborting a hardware transaction
 *    cycles: cycles from last branch (or 0 if not supported)
 *      type: branch type
 *//* OS fault handler *//* Hardware Walker*//* L2 *//* L1 *//* miss level *//* hit level *//* not available *//* TLB access *//* locked transaction *//* locked instruction *//* 1 free *//* forward *//* snoop hit modified *//* snoop miss *//* snoop hit *//* no snoop *//* snoop mode *//* N/A *//* PMEM *//* RAM *//* LFB *//* Any cache *//* 5-0xa available *//* L4 *//* L3 *//* Remote *//* Uncached memory *//* I/O memory *//* Remote Cache (2 hops) *//* Remote Cache (1 hop) *//* Remote DRAM (2 hops) *//* Remote DRAM (1 hop) *//* Local DRAM *//* Line Fill Buffer *//* miss level  *//* memory hierarchy (memory level, hit or miss) *//* code (execution) *//* prefetch *//* store instruction *//* load instruction *//* type of opcode (load/store/prefetch,code) *//* type of opcode *//* memory hierarchy level *//* lock instr *//* tlb access *//* memory hierarchy level number *//* remote *//* snoop mode, ext *//* O_CLOEXEC *//* pid=cgroup id, per-cpu mode only *//* sample collided with another *//* record contains gaps *//* snapshot from overwrite mode *//* record was truncated to fit *//**
 * PERF_RECORD_AUX::flags bits
 *//* non-ABI *//*
	 * Record bpf events:
	 *  enum perf_bpf_event_type {
	 *	PERF_BPF_EVENT_UNKNOWN		= 0,
	 *	PERF_BPF_EVENT_PROG_LOAD	= 1,
	 *	PERF_BPF_EVENT_PROG_UNLOAD	= 2,
	 *  };
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *	u16				type;
	 *	u16				flags;
	 *	u32				id;
	 *	u8				tag[BPF_TAG_SIZE];
	 *	struct sample_id		sample_id;
	 * };
	 *//*
	 * Record ksymbol register/unregister events:
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *	u64				addr;
	 *	u32				len;
	 *	u16				ksym_type;
	 *	u16				flags;
	 *	char				name[];
	 *	struct sample_id		sample_id;
	 * };
	 *//*
	 * struct {
	 *	struct perf_event_header	header;
	 *	u32				pid;
	 *	u32				tid;
	 *	u64				nr_namespaces;
	 *	{ u64				dev, inode; } [nr_namespaces];
	 *	struct sample_id		sample_id;
	 * };
	 *//*
	 * CPU-wide version of PERF_RECORD_SWITCH with next_prev_pid and
	 * next_prev_tid that are the next (switching out) or previous
	 * (switching in) pid/tid.
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *	u32				next_prev_pid;
	 *	u32				next_prev_tid;
	 *	struct sample_id		sample_id;
	 * };
	 *//*
	 * Records a context switch in or out (flagged by
	 * PERF_RECORD_MISC_SWITCH_OUT). See also
	 * PERF_RECORD_SWITCH_CPU_WIDE.
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *	struct sample_id		sample_id;
	 * };
	 *//*
	 * Records the dropped/lost sample number.
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *
	 *	u64				lost;
	 *	struct sample_id		sample_id;
	 * };
	 *//*
	 * Indicates that instruction trace has started
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *	u32				pid;
	 *	u32				tid;
	 *	struct sample_id		sample_id;
	 * };
	 *//*
	 * Records that new data landed in the AUX buffer part.
	 *
	 * struct {
	 * 	struct perf_event_header	header;
	 *
	 * 	u64				aux_offset;
	 * 	u64				aux_size;
	 *	u64				flags;
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * The MMAP2 records are an augmented version of MMAP, they add
	 * maj, min, ino numbers to be used to uniquely identify each mapping
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *
	 *	u32				pid, tid;
	 *	u64				addr;
	 *	u64				len;
	 *	u64				pgoff;
	 *	u32				maj;
	 *	u32				min;
	 *	u64				ino;
	 *	u64				ino_generation;
	 *	u32				prot, flags;
	 *	char				filename[];
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * struct {
	 *	struct perf_event_header	header;
	 *
	 *	#
	 *	# Note that PERF_SAMPLE_IDENTIFIER duplicates PERF_SAMPLE_ID.
	 *	# The advantage of PERF_SAMPLE_IDENTIFIER is that its position
	 *	# is fixed relative to header.
	 *	#
	 *
	 *	{ u64			id;	  } && PERF_SAMPLE_IDENTIFIER
	 *	{ u64			ip;	  } && PERF_SAMPLE_IP
	 *	{ u32			pid, tid; } && PERF_SAMPLE_TID
	 *	{ u64			time;     } && PERF_SAMPLE_TIME
	 *	{ u64			addr;     } && PERF_SAMPLE_ADDR
	 *	{ u64			id;	  } && PERF_SAMPLE_ID
	 *	{ u64			stream_id;} && PERF_SAMPLE_STREAM_ID
	 *	{ u32			cpu, res; } && PERF_SAMPLE_CPU
	 *	{ u64			period;   } && PERF_SAMPLE_PERIOD
	 *
	 *	{ struct read_format	values;	  } && PERF_SAMPLE_READ
	 *
	 *	{ u64			nr,
	 *	  u64			ips[nr];  } && PERF_SAMPLE_CALLCHAIN
	 *
	 *	#
	 *	# The RAW record below is opaque data wrt the ABI
	 *	#
	 *	# That is, the ABI doesn't make any promises wrt to
	 *	# the stability of its content, it may vary depending
	 *	# on event, hardware, kernel version and phase of
	 *	# the moon.
	 *	#
	 *	# In other words, PERF_SAMPLE_RAW contents are not an ABI.
	 *	#
	 *
	 *	{ u32			size;
	 *	  char                  data[size];}&& PERF_SAMPLE_RAW
	 *
	 *	{ u64                   nr;
	 *        { u64 from, to, flags } lbr[nr];} && PERF_SAMPLE_BRANCH_STACK
	 *
	 * 	{ u64			abi; # enum perf_sample_regs_abi
	 * 	  u64			regs[weight(mask)]; } && PERF_SAMPLE_REGS_USER
	 *
	 * 	{ u64			size;
	 * 	  char			data[size];
	 * 	  u64			dyn_size; } && PERF_SAMPLE_STACK_USER
	 *
	 *	{ u64			weight;   } && PERF_SAMPLE_WEIGHT
	 *	{ u64			data_src; } && PERF_SAMPLE_DATA_SRC
	 *	{ u64			transaction; } && PERF_SAMPLE_TRANSACTION
	 *	{ u64			abi; # enum perf_sample_regs_abi
	 *	  u64			regs[weight(mask)]; } && PERF_SAMPLE_REGS_INTR
	 *	{ u64			phys_addr;} && PERF_SAMPLE_PHYS_ADDR
	 * };
	 *//*
	 * struct {
	 *	struct perf_event_header	header;
	 *	u32				pid, tid;
	 *
	 *	struct read_format		values;
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * struct {
	 *	struct perf_event_header	header;
	 *	u32				pid, ppid;
	 *	u32				tid, ptid;
	 *	u64				time;
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * struct {
	 *	struct perf_event_header	header;
	 *	u64				time;
	 *	u64				id;
	 *	u64				stream_id;
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * struct {
	 *	struct perf_event_header	header;
	 *
	 *	u32				pid, tid;
	 *	char				comm[];
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * struct {
	 *	struct perf_event_header	header;
	 *	u64				id;
	 *	u64				lost;
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * The MMAP events record the PROT_EXEC mappings so that we can
	 * correlate userspace IPs to code. They have the following structure:
	 *
	 * struct {
	 *	struct perf_event_header	header;
	 *
	 *	u32				pid, tid;
	 *	u64				addr;
	 *	u64				len;
	 *	u64				pgoff;
	 *	char				filename[];
	 * 	struct sample_id		sample_id;
	 * };
	 *//*
	 * If perf_event_attr.sample_id_all is set then all event types will
	 * have the sample_type selected fields related to where/when
	 * (identity) an event took place (TID, TIME, ID, STREAM_ID, CPU,
	 * IDENTIFIER) described in PERF_RECORD_SAMPLE below, it will be stashed
	 * just after the perf_event_header and the fields already present for
	 * the existing fields, i.e. at the end of the payload. That way a newer
	 * perf.data file will be supported by older perf tools, with these new
	 * optional fields being ignored.
	 *
	 * struct sample_id {
	 * 	{ u32			pid, tid; } && PERF_SAMPLE_TID
	 * 	{ u64			time;     } && PERF_SAMPLE_TIME
	 * 	{ u64			id;       } && PERF_SAMPLE_ID
	 * 	{ u64			stream_id;} && PERF_SAMPLE_STREAM_ID
	 * 	{ u32			cpu, res; } && PERF_SAMPLE_CPU
	 *	{ u64			id;	  } && PERF_SAMPLE_IDENTIFIER
	 * } && perf_event_attr::sample_id_all
	 *
	 * Note that PERF_SAMPLE_IDENTIFIER duplicates PERF_SAMPLE_ID.  The
	 * advantage of PERF_SAMPLE_IDENTIFIER is that its position is fixed
	 * relative to header.size.
	 *//* number of available namespaces *//*
 * Reserve the last bit to indicate some extended misc field
 *//*
 * These PERF_RECORD_MISC_* flags below are safely reused
 * for the following events:
 *
 *   PERF_RECORD_MISC_EXACT_IP           - PERF_RECORD_SAMPLE of precise events
 *   PERF_RECORD_MISC_SWITCH_OUT_PREEMPT - PERF_RECORD_SWITCH* events
 *
 *
 * PERF_RECORD_MISC_EXACT_IP:
 *   Indicates that the content of PERF_SAMPLE_IP points to
 *   the actual instruction that triggered the event. See also
 *   perf_event_attr::precise_ip.
 *
 * PERF_RECORD_MISC_SWITCH_OUT_PREEMPT:
 *   Indicates that thread was preempted in TASK_RUNNING state.
 *//*
 * Following PERF_RECORD_MISC_* are used on different
 * events, so can reuse the same bit position:
 *
 *   PERF_RECORD_MISC_MMAP_DATA  - PERF_RECORD_MMAP* events
 *   PERF_RECORD_MISC_COMM_EXEC  - PERF_RECORD_COMM event
 *   PERF_RECORD_MISC_FORK_EXEC  - PERF_RECORD_FORK event (perf internal)
 *   PERF_RECORD_MISC_SWITCH_OUT - PERF_RECORD_SWITCH* events
 *//*
 * Indicates that /proc/PID/maps parsing are truncated by time out.
 *//*
	 * AUX area is defined by aux_{offset,size} fields that should be set
	 * by the userspace, so that
	 *
	 *   aux_offset >= data_offset + data_size
	 *
	 * prior to mmap()ing it. Size of the mmap()ed area should be aux_size.
	 *
	 * Ring buffer pointers aux_{head,tail} have the same semantics as
	 * data_{head,tail} and same ordering rules apply.
	 *//* data buffer size *//* where the buffer starts *//* user-space written tail *//* head in the data section *//*
	 * Control data for the mmap() data buffer.
	 *
	 * User-space reading the @data_head value should issue an smp_rmb(),
	 * after reading this value.
	 *
	 * When the mapping is PROT_WRITE the @data_tail value should be
	 * written by userspace to reflect the last read data, after issueing
	 * an smp_mb() to separate the data read from the ->data_tail store.
	 * In this case the kernel will not over-write unread data.
	 *
	 * See perf_output_put_handle() for the data ordering.
	 *
	 * data_{offset,size} indicate the location and size of the perf record
	 * buffer within the mmapped area.
	 *//* align to 1k. *//*
		 * Hole for extension of the self monitor capabilities
		 *//* Header size up to __reserved[] fields. *//*
	 * If cap_usr_time_zero, the hardware clock (e.g. TSC) can be calculated
	 * from sample timestamps.
	 *
	 *   time = timestamp - time_zero;
	 *   quot = time / time_mult;
	 *   rem  = time % time_mult;
	 *   cyc = (quot << time_shift) + (rem << time_shift) / time_mult;
	 *
	 * And vice versa:
	 *
	 *   quot = cyc >> time_shift;
	 *   rem  = cyc & (((u64)1 << time_shift) - 1);
	 *   timestamp = time_zero + quot * time_mult +
	 *               ((rem * time_mult) >> time_shift);
	 *//*
	 * If cap_usr_time the below fields can be used to compute the time
	 * delta since time_enabled (in ns) using rdtsc or similar.
	 *
	 *   u64 quot, rem;
	 *   u64 delta;
	 *
	 *   quot = (cyc >> time_shift);
	 *   rem = cyc & (((u64)1 << time_shift) - 1);
	 *   delta = time_offset + quot * time_mult +
	 *              ((rem * time_mult) >> time_shift);
	 *
	 * Where time_offset,time_mult,time_shift and cyc are read in the
	 * seqcount loop described above. This delta can then be added to
	 * enabled and possible running (if index), improving the scaling:
	 *
	 *   enabled += delta;
	 *   if (index)
	 *     running += delta;
	 *
	 *   quot = count / running;
	 *   rem  = count % running;
	 *   count = quot * enabled + (rem * enabled) / running;
	 *//*
	 * If cap_user_rdpmc this field provides the bit-width of the value
	 * read using the rdpmc() or equivalent instruction. This can be used
	 * to sign extend the result like:
	 *
	 *   pmc <<= 64 - width;
	 *   pmc >>= 64 - width; // signed shift right
	 *   count += pmc;
	 *//* The time_zero field is used *//* The time_* fields are used *//* The RDPMC instruction can be used to read counts *//* Always 1, signals that bit 0 is zero *//* Always 0, deprecated, see commit 860f085b74e9 *//* time event on cpu *//* time event active *//* add to hardware event value *//* hardware event identifier *//* seqlock for synchronization *//*
	 * Bits needed to read the hw events in user-space.
	 *
	 *   u32 seq, time_mult, time_shift, index, width;
	 *   u64 count, enabled, running;
	 *   u64 cyc, time_offset;
	 *   s64 pmc = 0;
	 *
	 *   do {
	 *     seq = pc->lock;
	 *     barrier()
	 *
	 *     enabled = pc->time_enabled;
	 *     running = pc->time_running;
	 *
	 *     if (pc->cap_usr_time && enabled != running) {
	 *       cyc = rdtsc();
	 *       time_offset = pc->time_offset;
	 *       time_mult   = pc->time_mult;
	 *       time_shift  = pc->time_shift;
	 *     }
	 *
	 *     index = pc->index;
	 *     count = pc->offset;
	 *     if (pc->cap_user_rdpmc && index) {
	 *       width = pc->pmc_width;
	 *       pmc = rdpmc(index - 1);
	 *     }
	 *
	 *     barrier();
	 *   } while (pc->lock != seq);
	 *
	 * NOTE: for obvious reason this only works on self-monitoring
	 *       processes.
	 *//* lowest version this is compat with *//* version number of this structure *//*
 * Structure of the page that can be mapped via mmap
 *//*
 * Ioctls that can be done on a perf event fd:
 *//*
	 * User provided buffer to store program ids
	 *//*
	 * Set by the kernel to indicate the number of
	 * available programs
	 *//*
	 * The below ids array length
	 *//*
 * Structure used by below PERF_EVENT_IOC_QUERY_BPF command
 * to query bpf programs attached to the same perf tracepoint
 * as the given perf event.
 *//* align to __u64 *//*
	 * Wakeup watermark for AUX area
	 *//*
	 * Defines set of regs to dump for each sample
	 * state captured on:
	 *  - precise = 0: PMU interrupt
	 *  - precise > 0: sampled instruction
	 *
	 * See asm/perf_regs.h for details.
	 *//*
	 * Defines size of the user stack to dump on samples.
	 *//*
	 * Defines set of user regs to dump on samples.
	 * See asm/perf_regs.h for details.
	 *//* enum perf_branch_sample_type *//* extension of config1 *//* for perf_[k,u]probe *//* when kprobe_func == NULL *//* extension of config *//* for perf_uprobe *//* for perf_kprobe *//* bytes before wakeup   *//* wakeup every n events *//* generate AUX records instead of events *//* include bpf events *//* include ksymbol events *//* include namespaces data *//* Write ring buffer from end to beginning *//* context switch data *//* use @clockid for time fields *//* flag comm events that are due to an exec *//* include mmap with inode data     *//* exclude user callchains *//* exclude kernel callchains *//* don't count in guest  *//* don't count in host   *//* sample_type all events *//* non-exec mmap data    *//* skid constraint       *//*
				 * precise_ip:
				 *
				 *  0 - SAMPLE_IP can have arbitrary skid
				 *  1 - SAMPLE_IP must have constant skid
				 *  2 - SAMPLE_IP requested to have 0 skid
				 *  3 - SAMPLE_IP must have 0 skid
				 *
				 *  See also PERF_RECORD_MISC_EXACT_IP
				 *//* wakeup_watermark      *//* trace fork/exit       *//* next exec enables     *//* per task counts       *//* use freq, not period  *//* include comm data     *//* include mmap data     *//* don't count when idle *//* ditto hypervisor      *//* ditto kernel          *//* don't count user      *//* only group on PMU     *//* must always be on PMU *//* children inherit it   *//* off by default        *//*
	 * Type specific configuration information.
	 *//*
	 * Size of the attr structure, for fwd/bwd compat.
	 *//*
	 * Major type: hardware/software/tracepoint/etc.
	 *//*
 * Hardware event_id to monitor via a performance monitoring event:
 *
 * @sample_max_stack: Max number of frame pointers in a callchain,
 *		      should be < /proc/sys/kernel/perf_event_max_stack
 *//* add: aux_watermark *//* add: sample_regs_intr *//* add: sample_stack_user *//* add: sample_regs_user *//* add: branch_sample_type *//* add: config2 *//* sizeof first published struct *//*
 * The format of the data returned by read() on a perf event fd,
 * as specified by attr.read_format:
 *
 * struct read_format {
 *	{ u64		value;
 *	  { u64		time_enabled; } && PERF_FORMAT_TOTAL_TIME_ENABLED
 *	  { u64		time_running; } && PERF_FORMAT_TOTAL_TIME_RUNNING
 *	  { u64		id;           } && PERF_FORMAT_ID
 *	} && !PERF_FORMAT_GROUP
 *
 *	{ u64		nr;
 *	  { u64		time_enabled; } && PERF_FORMAT_TOTAL_TIME_ENABLED
 *	  { u64		time_running; } && PERF_FORMAT_TOTAL_TIME_RUNNING
 *	  { u64		value;
 *	    { u64	id;           } && PERF_FORMAT_ID
 *	  }		cntr[nr];
 *	} && PERF_FORMAT_GROUP
 * };
 *//* bits 32..63 are reserved for the abort code *//* Capacity read abort *//* Capacity write abort *//* Conflict abort *//* Retry possible *//* Instruction not related *//* Instruction is related *//* From transaction *//* From elision *//*
 * Values for the memory transaction event qualifier, mostly for
 * abort events. Multiple bits can be set.
 *//*
 * Values to determine ABI of the registers dump.
 *//* conditional function return *//* conditional function call *//* syscall return *//* syscall *//* function return *//* indirect function call *//* function call *//* indirect *//* unconditional  *//* conditional *//* unknown *//*
 * Common flow change classification
 *//* save branch type *//* no cycles *//* no flags *//* direct call *//* indirect jumps *//* call/ret stack *//* conditional branches *//* not in transaction *//* transaction aborts *//* indirect calls *//* any return branch *//* any call branch *//* any branch types *//* hypervisor branches *//* kernel branches *//* user branches *//*
 * values to program into branch_sample_type when PERF_SAMPLE_BRANCH is set
 *
 * If the user does not pass priv level information via branch_sample_type,
 * the kernel uses the event's priv level. Branch and event priv levels do
 * not have to match. Branch priv level is checked for permissions.
 *
 * The branch types can be combined, however BRANCH_ANY covers all types
 * of branches and therefore it supersedes all the other types.
 *//* non-ABI; internal use *//*
 * Bits that can be set in attr.sample_type to request information
 * in the overflow packets.
 *//*
 * Special "software" events provided by the kernel, even if the hardware
 * does not support performance events. These events measure various
 * physical and sw events of the kernel (and allow the profiling of them as
 * well):
 *//*
 * Generalized hardware cache events:
 *
 *       { L1-D, L1-I, LLC, ITLB, DTLB, BPU, NODE } x
 *       { read, write, prefetch } x
 *       { accesses, misses }
 *//*
	 * Common hardware events, generalized by the kernel:
	 *//*
 * Generalized performance event event_id types, used by the
 * attr.event_id parameter of the sys_perf_event_open()
 * syscall:
 *//*
 * attr.type
 *//*
 * User-space ABI bits:
 *//*
 * Performance events:
 *
 *    Copyright (C) 2008-2009, Thomas Gleixner <tglx@linutronix.de>
 *    Copyright (C) 2008-2011, Red Hat, Inc., Ingo Molnar
 *    Copyright (C) 2008-2011, Red Hat, Inc., Peter Zijlstra
 *
 * Data type definitions, declarations, prototypes.
 *
 *    Started by: Thomas Gleixner and Ingo Molnar
 *
 * For licencing details see kernel-base/COPYING
 */<sys/syscall.h><sys/ioctl.h><linux/perf_event.h><unistd.h><random><iomanip>const tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>const tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &sumRangeMeasuresumRangeRangeconst pair<double, double>const pair<double, double> &pair<double, double> &rmconst __normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>const __normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> &__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> &sumMeasurediffmeandouble &&Result::Measure::elapsedRangeMeasure &const __normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>const __normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> &__normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> &"elapsed"Measure::elapsed"iterations"Measure::iterations"pagefaults"Measure::pagefaults"cpucycles"Measure::cpucycles"contextswitches"Measure::contextswitches"instructions"Measure::instructions"branchinstructions"Measure::branchinstructions"branchmisses"Measure::branchmissesMeasure::_sizedetail::u(Measure::elapsed)0Udata1data2medconst __normal_iterator<double *, vector<double, allocator<double>>>const __normal_iterator<double *, vector<double, allocator<double>>> &__normal_iterator<double *, vector<double, allocator<double>>> &dItersResult::Measure::iterationsu(Result::Measure::iterations)u(Result::Measure::elapsed)Result::Measure::pagefaultsu(Result::Measure::pagefaults)Result::Measure::cpucyclesu(Result::Measure::cpucycles)Result::Measure::contextswitchesu(Result::Measure::contextswitches)Result::Measure::instructionsu(Result::Measure::instructions)Result::Measure::branchinstructionsu(Result::Measure::branchinstructions)Result::Measure::branchmissesu(Result::Measure::branchmisses)Config *vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &&vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> *const vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>const vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &Result::Measure::_sizedetail::u(Result::Measure::_size)unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &&const nanosecondsconst unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>const unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &const MarkDownCodeconst MarkDownCode &MarkDownCode &const Numberconst Number &Number &to_sMarkDownCode &&~MarkDownCodeMarkDownCode *MarkDownCodeconst MarkDownCode *'`'MarkDownColumn &MarkDownColumn &&const MarkDownColumnconst MarkDownColumn &~MarkDownColumnMarkDownColumn *MarkDownColumnconst MarkDownColumn *'|'const basic_stringstream<char, char_traits<char>, allocator<char>>invalid':'Number &&Numberconst Number *Number *const StreamStateRestorerrestorerNumSep *StreamStateRestorer &StreamStateRestorer &&StreamStateRestorerconst StreamStateRestorer &restoreStreamStateRestorer *const streamsize~StreamStateRestorerclockResolutionsResolutioncalcClockResolutionbestDurationtBegintEndhash_combine0x9e3779b926544357696U2UsingletonHeaderHashsHeaderHashprintStabilityInformationOnceshouldPrintrecommendationsWarning, results might be unstable:"Warning, results might be unstable:"* "* "Recommendations"Recommendations"mdCodeprectitsuffnumEvaluationsoutStreamgatherStabilityInformationrecommendCheckFlagsrecommendPyPerfnprocs_SC_NPROCESSORS_CONFconst char(&)[77]char(&)[77]couldn't figure out number of processors - no governor, turbo check possible"couldn't figure out number of processors - no governor, turbo check possible"currentGovernor/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"idStrsysCpu/sys/devices/system/cpu/cpu"/sys/devices/system/cpu/cpu"minFreq/cpufreq/scaling_min_freq"/cpufreq/scaling_min_freq"maxFreq/cpufreq/scaling_max_freq"/cpufreq/scaling_max_freq"minMHzmaxMHzCPU frequency scaling enabled: CPU "CPU frequency scaling enabled: CPU " between " between " and " and " MHz" MHz"performance"performance"CPU governor is '"CPU governor is '"' but should be 'performance'"' but should be 'performance'"/sys/devices/system/cpu/intel_pstate/no_turbo"/sys/devices/system/cpu/intel_pstate/no_turbo"const char(&)[47]char(&)[47]Turbo is enabled, CPU frequency will fluctuate"Turbo is enabled, CPU frequency will fluctuate"const char(&)[34]char(&)[34]Make sure you compile for Release"Make sure you compile for Release"const char[80]char[80]const char(&)[80]char(&)[80]Use 'pyperf system tune' before benchmarking. See https://github.com/psf/pyperf"Use 'pyperf system tune' before benchmarking. See https://github.com/psf/pyperf"isWarningsEnabledsuppressionNANOBENCH_SUPPRESS_WARNINGS"NANOBENCH_SUPPRESS_WARNINGS"const auto *auto *const auto *const"0"isEndlessRunningendlessNANOBENCH_ENDLESS"NANOBENCH_ENDLESS"getEnvfinparseFileIterationLogic *const IterationLogic *mPimpl->mBench.name() << ": mNumIters=" << mPimpl->mNumIters~ImplImpl &const Implconst Impl &Impl &&isCloseEnoughForMeasurementsconst Impl *const nanoseconds &showResulterrorMessagecolumnsrMedianrErrorMedianrInsMedianrCycMedian 100.0const char(&)[9]char(&)[9]"relative"%"%""complexityN""/"/s"/s"err%"err%"ins/"ins/"cyc/"cyc/""IPC"rBraMedianbra/"bra/"1.000000000000000062e-091e-9const char(&)[6]char(&)[6]miss%"miss%"total"total"vector<MarkDownColumn, allocator<MarkDownColumn>> &colconst __normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>>const __normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>> &__normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>> &| "| "|:"|:"| :boom: "| :boom: " (" ("')'showUnstable0.050000000000000002780.05:wavy_dash: ":wavy_dash: "avgIterssuggestedIters (Unstable with ~" (Unstable with ~" iters. Increase `minEpochIterations` to e.g. " iters. Increase `minEpochIterations` to e.g. "")"State::warmupState::measuringState::upscaling_runtimeState::endlessmBench.name() << ": " << detail::fmt::Number(20, 3, static_cast<double>(elapsed.count())) << " elapsed, " << detail::fmt::Number(20, 3, static_cast<double>(mTargetRuntimePerEpoch.count())) << " target. oldIters=" << oldIters << ", mNumIters=" << mNumIters << ", mState=" << static_cast<int>(mState)const PerformanceCounters *PerformanceCounters *lambda [] type at line 149358, col. 20const lambda [] type at line 149358, col. 20const lambda [] type at line 149358, col. 20 &lambda [] type at line 149358, col. 20 &const lambda [] type at line 149358, col. 20 *lambda [] type at line 149358, col. 20 *lambda [] type at line 149358, col. 20 &&const LinuxPerformanceCountersconst LinuxPerformanceCounters *PerfCountSet<unsigned long> *PerfCountSet<bool> *monitorpeaperf_event_attr *sizeof(perf_event_attr)PERF_FORMAT_GROUP | PERF_FORMAT_IDPERF_FORMAT_GROUP | PERF_FORMAT_ID | PERF_FORMAT_TOTAL_TIME_ENABLEDPERF_FORMAT_GROUP | PERF_FORMAT_ID | PERF_FORMAT_TOTAL_TIME_ENABLED | PERF_FORMAT_TOTAL_TIME_RUNNINGpidcpufd__NR_perf_event_open_IOC_READ('$')(7)(_IOC_TYPECHECK(__u64 *))((sizeof(__u64 *)))9216214749286421474928712148017159Target &const map<unsigned long, Target, less<unsigned long>, allocator<pair<const unsigned long, Target>>>const __normal_iterator<unsigned long *, vector<unsigned long, allocator<unsigned long>>>const __normal_iterator<unsigned long *, vector<unsigned long, allocator<unsigned long>>> &__normal_iterator<unsigned long *, vector<unsigned long, allocator<unsigned long>>> &newCalibrationvector<unsigned long, allocator<unsigned long>> &&100000U3U1234567measure1measure2overheadcalibratemix13Ueventid17U5UdivRoundedmap<unsigned long, Target, less<unsigned long>, allocator<pair<const unsigned long, Target>>> &pair<const unsigned long, Target> &id_valueconst _Rb_tree_iterator<pair<const unsigned long, Target>>tgtcorrectionVal_IOC_NONE9217numBytes(3)9219(0)hasError~LinuxPerformanceCountersLinuxPerformanceCounters &LinuxPerformanceCounters &&const LinuxPerformanceCounters &upscaleiterations overflow. Maybe your code got optimized away?"iterations overflow. Maybe your code got optimized away?"calcBestNumItersdoubleElapseddoubleTargetRuntimePerEpochdoubleNewItersdoubleMinEpochIters0.2000000000000000111NANOBENCH_ENDLESS set: running '"NANOBENCH_ENDLESS set: running '"' endlessly"' endlessly"generateResultconst vector<Node, allocator<Node>>const vector<Node, allocator<Node>> &vector<Node, allocator<Node>> &"n.type=" << static_cast<int>(n.type)const Nodeconst Node &Node &const __normal_iterator<const Node *, vector<Node, allocator<Node>>>const __normal_iterator<const Node *, vector<Node, allocator<Node>>> &__normal_iterator<const Node *, vector<Node, allocator<Node>>> &Node::Type::contentNode::Type::inverted_sectiongot a inverted section inside result"got a inverted section inside result"Node::Type::sectionmeasurement"measurement"got a section inside result"got a section inside result"Node::Type::taggenerateResultMeasurementgot a inverted section inside measurement"got a inverted section inside measurement"got a section inside measurement"got a section inside measurement"generateResultTagmatchResulthwIdswIdnodes"context""median""average""medianAbsolutePercentError""sum""minimum""maximum""sumProduct"command '"command '"' not understood"' not understood"generateConfigTag"title""name""unit""batch"const char(&)[7]char(&)[7]"epochs""clockResolution"const char(&)[24]char(&)[24]"clockResolutionMultiple""maxEpochTime""minEpochTime"const char(&)[19]char(&)[19]"minEpochIterations""epochIterations""warmup"matchCmdArgsidxOpen'('idxClosegenerateFirstLastmatchFirst-first"-first"matchLast-last"-last"doWriteparseMustacheTemplate{{"{{"}}"}}"Node &&'/''^'{
    "results": [
{{#result}}        {
            "title": "{{title}}",
            "name": "{{name}}",
            "unit": "{{unit}}",
            "batch": {{batch}},
            "complexityN": {{complexityN}},
            "epochs": {{epochs}},
            "clockResolution": {{clockResolution}},
            "clockResolutionMultiple": {{clockResolutionMultiple}},
            "maxEpochTime": {{maxEpochTime}},
            "minEpochTime": {{minEpochTime}},
            "minEpochIterations": {{minEpochIterations}},
            "epochIterations": {{epochIterations}},
            "warmup": {{warmup}},
            "relative": {{relative}},
            "median(elapsed)": {{median(elapsed)}},
            "medianAbsolutePercentError(elapsed)": {{medianAbsolutePercentError(elapsed)}},
            "median(instructions)": {{median(instructions)}},
            "medianAbsolutePercentError(instructions)": {{medianAbsolutePercentError(instructions)}},
            "median(cpucycles)": {{median(cpucycles)}},
            "median(contextswitches)": {{median(contextswitches)}},
            "median(pagefaults)": {{median(pagefaults)}},
            "median(branchinstructions)": {{median(branchinstructions)}},
            "median(branchmisses)": {{median(branchmisses)}},
            "totalTime": {{sumProduct(iterations, elapsed)}},
            "measurements": [
{{#measurement}}                {
                    "iterations": {{iterations}},
                    "elapsed": {{elapsed}},
                    "pagefaults": {{pagefaults}},
                    "cpucycles": {{cpucycles}},
                    "contextswitches": {{contextswitches}},
                    "instructions": {{instructions}},
                    "branchinstructions": {{branchinstructions}},
                    "branchmisses": {{branchmisses}}
                }{{^-last}},{{/-last}}
{{/measurement}}            ]
        }{{^-last}},{{/-last}}
{{/result}}    ]
}R"DELIM({
    "results": [
{{#result}}        {
            "title": "{{title}}",
            "name": "{{name}}",
            "unit": "{{unit}}",
            "batch": {{batch}},
            "complexityN": {{complexityN}},
            "epochs": {{epochs}},
            "clockResolution": {{clockResolution}},
            "clockResolutionMultiple": {{clockResolutionMultiple}},
            "maxEpochTime": {{maxEpochTime}},
            "minEpochTime": {{minEpochTime}},
            "minEpochIterations": {{minEpochIterations}},
            "epochIterations": {{epochIterations}},
            "warmup": {{warmup}},
            "relative": {{relative}},
            "median(elapsed)": {{median(elapsed)}},
            "medianAbsolutePercentError(elapsed)": {{medianAbsolutePercentError(elapsed)}},
            "median(instructions)": {{median(instructions)}},
            "medianAbsolutePercentError(instructions)": {{medianAbsolutePercentError(instructions)}},
            "median(cpucycles)": {{median(cpucycles)}},
            "median(contextswitches)": {{median(contextswitches)}},
            "median(pagefaults)": {{median(pagefaults)}},
            "median(branchinstructions)": {{median(branchinstructions)}},
            "median(branchmisses)": {{median(branchmisses)}},
            "totalTime": {{sumProduct(iterations, elapsed)}},
            "measurements": [
{{#measurement}}                {
                    "iterations": {{iterations}},
                    "elapsed": {{elapsed}},
                    "pagefaults": {{pagefaults}},
                    "cpucycles": {{cpucycles}},
                    "contextswitches": {{contextswitches}},
                    "instructions": {{instructions}},
                    "branchinstructions": {{branchinstructions}},
                    "branchmisses": {{branchmisses}}
                }{{^-last}},{{/-last}}
{{/measurement}}            ]
        }{{^-last}},{{/-last}}
{{/result}}    ]
})DELIM"const char[1938]char[1938]{
    "benchmarks": [
        {
            "runs": [
                {
                    "values": [
{{#measurement}}                        {{elapsed}}{{^-last}},
{{/last}}{{/measurement}}
                    ]
                }
            ]
        }
    ],
    "metadata": {
        "loops": {{sum(iterations)}},
        "inner_loops": {{batch}},
        "name": "{{title}}",
        "unit": "second"
    },
    "version": "1.0"
}R"DELIM({
    "benchmarks": [
        {
            "runs": [
                {
                    "values": [
{{#measurement}}                        {{elapsed}}{{^-last}},
{{/last}}{{/measurement}}
                    ]
                }
            ]
        }
    ],
    "metadata": {
        "loops": {{sum(iterations)}},
        "inner_loops": {{batch}},
        "name": "{{title}}",
        "unit": "second"
    },
    "version": "1.0"
})DELIM"const char[438]char[438]<html>

<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>

<body>
    <div id="myDiv"></div>
    <script>
        var data = [
            {{#result}}{
                name: '{{name}}',
                y: [{{#measurement}}{{elapsed}}{{^-last}}, {{/last}}{{/measurement}}],
            },
            {{/result}}
        ];
        var title = '{{title}}';

        data = data.map(a => Object.assign(a, { boxpoints: 'all', pointpos: 0, type: 'box' }));
        var layout = { title: { text: title }, showlegend: false, yaxis: { title: 'time per unit', rangemode: 'tozero', autorange: true } }; Plotly.newPlot('myDiv', data, layout, {responsive: true});
    </script>
</body>

</html>R"DELIM(<html>

<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>

<body>
    <div id="myDiv"></div>
    <script>
        var data = [
            {{#result}}{
                name: '{{name}}',
                y: [{{#measurement}}{{elapsed}}{{^-last}}, {{/last}}{{/measurement}}],
            },
            {{/result}}
        ];
        var title = '{{title}}';

        data = data.map(a => Object.assign(a, { boxpoints: 'all', pointpos: 0, type: 'box' }));
        var layout = { title: { text: title }, showlegend: false, yaxis: { title: 'time per unit', rangemode: 'tozero', autorange: true } }; Plotly.newPlot('myDiv', data, layout, {responsive: true});
    </script>
</body>

</html>)DELIM"const char[718]char[718]"title";"name";"unit";"batch";"elapsed";"error %";"instructions";"branches";"branch misses";"total"
{{#result}}"{{title}}";"{{name}}";"{{unit}}";{{batch}};{{median(elapsed)}};{{medianAbsolutePercentError(elapsed)}};{{median(instructions)}};{{median(branchinstructions)}};{{median(branchmisses)}};{{sumProduct(iterations, elapsed)}}
{{/result}}R"DELIM("title";"name";"unit";"batch";"elapsed";"error %";"instructions";"branches";"branch misses";"total"
{{#result}}"{{title}}";"{{name}}";"{{unit}}";{{batch}};{{median(elapsed)}};{{medianAbsolutePercentError(elapsed)}};{{median(instructions)}};{{median(branchinstructions)}};{{median(branchmisses)}};{{sumProduct(iterations, elapsed)}}
{{/result}})DELIM"const char[344]char[344]~NodeNode *Nodeconst Node *|   coefficient |   err% | complexity"|   coefficient |   err% | complexity"|--------------:|-------:|------------"|--------------:|-------:|------------"const __normal_iterator<const BigO *, vector<BigO, allocator<BigO>>>const __normal_iterator<const BigO *, vector<BigO, allocator<BigO>>> &__normal_iterator<const BigO *, vector<BigO, allocator<BigO>>> &|"|" " "% "% " * " * ", rms=", rms="splitMix640x9e3779b97f4a7c15114007148193231984850xbf58476d1ce4e5b930U137878487931565439290x94d049bb133111eb27U1072315178059884593131UcalcMedianmidIdxstd::numeric_limits<double>::digits10const __normal_iterator<Node *, vector<Node, allocator<Node>>>const __normal_iterator<Node *, vector<Node, allocator<Node>>> &__normal_iterator<Node *, vector<Node, allocator<Node>>> &templates::Node::Type::contenttemplates::Node::Type::inverted_sectionunknown list '"unknown list '"'"'"templates::Node::Type::section"result"nbResultsrender: can only use section 'measurement' here if there is a single result, but there are "render: can only use section 'measurement' here if there is a single result, but there are "const char[92]char[92]render: unknown section '"render: unknown section '"templates::Node::Type::tagunknown tag '"unknown tag '"const Bench *lambda [] type at line 149969, col. 46const lambda [] type at line 149969, col. 46const lambda [] type at line 149969, col. 46 &lambda [] type at line 149969, col. 46 &lambda [] type at line 149969, col. 46 *operator double (*)(double)const lambda [] type at line 149969, col. 46 *lambda [] type at line 149969, col. 46 &&O(1)"O(1)"lambda [] type at line 149972, col. 46const lambda [] type at line 149972, col. 46const lambda [] type at line 149972, col. 46 &lambda [] type at line 149972, col. 46 &lambda [] type at line 149972, col. 46 *const lambda [] type at line 149972, col. 46 *lambda [] type at line 149972, col. 46 &&O(n)"O(n)"lambda [] type at line 149975, col. 50const lambda [] type at line 149975, col. 50const lambda [] type at line 149975, col. 50 &lambda [] type at line 149975, col. 50 &lambda [] type at line 149975, col. 50 *const lambda [] type at line 149975, col. 50 *lambda [] type at line 149975, col. 50 &&O(log n)"O(log n)"const char(&)[11]char(&)[11]lambda [] type at line 149978, col. 52const lambda [] type at line 149978, col. 52const lambda [] type at line 149978, col. 52 &lambda [] type at line 149978, col. 52 &lambda [] type at line 149978, col. 52 *const lambda [] type at line 149978, col. 52 *lambda [] type at line 149978, col. 52 &&O(n log n)"O(n log n)"lambda [] type at line 149981, col. 48const lambda [] type at line 149981, col. 48const lambda [] type at line 149981, col. 48 &lambda [] type at line 149981, col. 48 &lambda [] type at line 149981, col. 48 *const lambda [] type at line 149981, col. 48 *lambda [] type at line 149981, col. 48 &&O(n^2)"O(n^2)"lambda [] type at line 149984, col. 48const lambda [] type at line 149984, col. 48const lambda [] type at line 149984, col. 48 &lambda [] type at line 149984, col. 48 &lambda [] type at line 149984, col. 48 *const lambda [] type at line 149984, col. 48 *lambda [] type at line 149984, col. 48 &&O(n^3)"O(n^3)"NumSep &const NumSepconst NumSep &~NumSepNumSepconst NumSep *"\003"vector<Result, allocator<Result>> &&const Rng *ankerl::nanobench::Rng::Rng: needed exactly 2 entries in data, but got "ankerl::nanobench::Rng::Rng: needed exactly 2 entries in data, but got "rddistrandom_device &Target &&const Targetconst Target &TargetTarget *TableInfoStateupscaling_runtimemeasuringcontentinverted_sectionmWhatmValuemSuffixmTitlemPrecisionmWidthmFmtFlagsmFillmLocalemStreammHasErrormFdmTimeRunningNanosmTimeEnabledNanosmLoopOverheadconst unsigned long[1]unsigned long[1]mCalibratedOverheadmCountersmIdToTargetmStatemTotalNumItersmTotalElapsedmRngmResultmTargetRuntimePerEpochmBenchmNumIterschildrenmSepcorrectLoopOverheadcorrectMeasuringOverheadtargetValuetargetValue_correctMeasuringOverhead_correctLoopOverhead_divisor/usr/include/c++/9/random/usr/include/c++/9/bits/random.h/usr/include/x86_64-linux-gnu/c++/9/bits/opt_random.h/usr/include/c++/9/bits/random.tcc/usr/include/linux/types.h/usr/include/x86_64-linux-gnu/asm/types.h/usr/include/asm-generic/types.h/usr/include/asm-generic/int-ll64.h/usr/include/linux/ioctl.h/usr/include/x86_64-linux-gnu/asm/ioctl.h/usr/include/asm-generic/ioctl.h/usr/include/x86_64-linux-gnu/sys/ioctl.h/usr/include/x86_64-linux-gnu/bits/ioctls.h/usr/include/x86_64-linux-gnu/asm/ioctls.h/usr/include/asm-generic/ioctls.h/usr/include/x86_64-linux-gnu/bits/ioctl-types.h/usr/include/x86_64-linux-gnu/sys/ttydefaults.h/usr/include/x86_64-linux-gnu/sys/syscall.h/usr/include/x86_64-linux-gnu/asm/unistd.h/usr/include/x86_64-linux-gnu/asm/unistd_64.h/usr/include/x86_64-linux-gnu/bits/syscall.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/nanobench.cppANKERL_NANOBENCH_IMPLEMENT// Copyright (c) 2019-2020 The Bitcoin Core developers__normal_iterator<BigO *, vector<BigO, allocator<BigO>>> &__normal_iterator<BigO *, vector<BigO, allocator<BigO>>> &&const __normal_iterator<BigO *, vector<BigO, allocator<BigO>>>const __normal_iterator<BigO *, vector<BigO, allocator<BigO>>> &__normal_iterator<BigO *, vector<BigO, allocator<BigO>>> *__normal_iterator<Node *, vector<Node, allocator<Node>>>__normal_iterator<Node *, vector<Node, allocator<Node>>> &&__normal_iterator<Node *, vector<Node, allocator<Node>>> *__normal_iterator<const BigO *, vector<BigO, allocator<BigO>>> &&__normal_iterator<const BigO *, vector<BigO, allocator<BigO>>> *__normal_iterator<const Node *, vector<Node, allocator<Node>>>__normal_iterator<const Node *, vector<Node, allocator<Node>>> &&__normal_iterator<const Node *, vector<Node, allocator<Node>>> *pair<const unsigned long, Target> *pair<const unsigned long, Target>const pair<const unsigned long, Target>const pair<const unsigned long, Target> &pair<_Rb_tree_iterator<pair<const unsigned long, Target>>, bool>const _Rb_tree_iterator<pair<const unsigned long, Target>> &__normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>>__normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>> &&__normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>> *fmtflags__normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>pair<double, double> *__normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> &&__normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> *__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>const pair<double, double> *__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> &&__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> *tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &&allocator<pair<double, double>> &vector<Node, allocator<Node>>allocator<Node> &vector<MarkDownColumn, allocator<MarkDownColumn>>allocator<MarkDownColumn> &map<unsigned long, Target, less<unsigned long>, allocator<pair<const unsigned long, Target>>>const map<unsigned long, Target, less<unsigned long>, allocator<pair<const unsigned long, Target>>> *map<unsigned long, Target, less<unsigned long>, allocator<pair<const unsigned long, Target>>> *multimap<unsigned long, Target, _C2, allocator<pair<const unsigned long, Target>>> &&multimap<unsigned long, Target, _C2, allocator<pair<const unsigned long, Target>>> &map<unsigned long, Target, _C2, allocator<pair<const unsigned long, Target>>> &&map<unsigned long, Target, _C2, allocator<pair<const unsigned long, Target>>> &const less<unsigned long>const less<unsigned long> &less<unsigned long> &allocator<pair<const unsigned long, Target>> &underlying_type<T>_Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, less<unsigned long>, allocator<pair<const unsigned long, Target>>>_Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, _Compare2, allocator<pair<const unsigned long, Target>>> &_Rb_tree_iterator<pair<const unsigned long, Target>>_Rb_tree_iterator<pair<const unsigned long, Target>> &&_Rb_tree_iterator<pair<const unsigned long, Target>> *_Rb_tree_const_iterator<pair<const unsigned long, Target>>_Rb_tree_const_iterator<pair<const unsigned long, Target>> &&const _Rb_tree_const_iterator<pair<const unsigned long, Target>>const _Rb_tree_const_iterator<pair<const unsigned long, Target>> &initializer_list<double>initializer_list<double> &initializer_list<double> &&const initializer_list<double>const initializer_list<double> &_Vector_base<pair<double, double>, allocator<pair<double, double>>>_Vector_base<pair<double, double>, allocator<pair<double, double>>> &const _Vector_base<pair<double, double>, allocator<pair<double, double>>>const _Vector_base<pair<double, double>, allocator<pair<double, double>>> &_Vector_base<Node, allocator<Node>>_Vector_base<Node, allocator<Node>> &const _Vector_base<Node, allocator<Node>>const _Vector_base<Node, allocator<Node>> &_Vector_base<MarkDownColumn, allocator<MarkDownColumn>>_Vector_base<MarkDownColumn, allocator<MarkDownColumn>> &const _Vector_base<MarkDownColumn, allocator<MarkDownColumn>>const _Vector_base<MarkDownColumn, allocator<MarkDownColumn>> &allocator_traits<allocator<pair<double, double>>>allocator_traits<allocator<pair<double, double>>> &allocator_traits<allocator<pair<double, double>>> &&const allocator_traits<allocator<pair<double, double>>>const allocator_traits<allocator<pair<double, double>>> &allocator_traits<allocator<Node>>allocator_traits<allocator<Node>> &allocator_traits<allocator<Node>> &&const allocator_traits<allocator<Node>>const allocator_traits<allocator<Node>> &allocator_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>>allocator_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>>const allocator_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>> &allocator<_Rb_tree_node<pair<const unsigned long, Target>>> &allocator_traits<allocator<pair<const unsigned long, Target>>>allocator_traits<allocator<pair<const unsigned long, Target>>> &allocator_traits<allocator<pair<const unsigned long, Target>>> &&const allocator_traits<allocator<pair<const unsigned long, Target>>>const allocator_traits<allocator<pair<const unsigned long, Target>>> &allocator_traits<allocator<MarkDownColumn>>allocator_traits<allocator<MarkDownColumn>> &allocator_traits<allocator<MarkDownColumn>> &&const allocator_traits<allocator<MarkDownColumn>>const allocator_traits<allocator<MarkDownColumn>> &allocator<Node>allocator<MarkDownColumn>allocator<pair<const unsigned long, Target>>allocator<_Rb_tree_node<pair<const unsigned long, Target>>>new_allocator<Node>new_allocator<Node> &const new_allocator<Node>const new_allocator<Node> &new_allocator<MarkDownColumn>new_allocator<MarkDownColumn> &const new_allocator<MarkDownColumn>const new_allocator<MarkDownColumn> &new_allocator<pair<const unsigned long, Target>>new_allocator<pair<const unsigned long, Target>> &const new_allocator<pair<const unsigned long, Target>>const new_allocator<pair<const unsigned long, Target>> &new_allocator<_Rb_tree_node<pair<const unsigned long, Target>>>new_allocator<_Rb_tree_node<pair<const unsigned long, Target>>> &const new_allocator<_Rb_tree_node<pair<const unsigned long, Target>>>const new_allocator<_Rb_tree_node<pair<const unsigned long, Target>>> &new_allocator<pair<double, double>>new_allocator<pair<double, double>> &const new_allocator<pair<double, double>>const new_allocator<pair<double, double>> &const initializer_list<unsigned long>_Vector_base<Result, allocator<Result>> &&!_Alloc_traits::_S_always_equal()
	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator()numpunct<char> *__numpunct_cache<char> *vector<BigO, allocator<BigO>> *vector<BigO, allocator<BigO>> &&_Vector_base<BigO, allocator<BigO>> &&BigO *constBigO *const &BigO *&..(*)(..))[7]..(*)(..))[11]..(*)(..))[9]Node *constNode *const &Node *&const __normal_iterator<Node *, vector<Node, allocator<Node>>> *vector<Node, allocator<Node>> *_Vector_base<Node, allocator<Node>> *const BigO *constconst BigO *const &const __normal_iterator<const BigO *, vector<BigO, allocator<BigO>>> *const vector<BigO, allocator<BigO>> *const _Vector_base<BigO, allocator<BigO>> *vector<Node, allocator<Node>> &&_Vector_base<Node, allocator<Node>> &&N - 1const Node *constconst Node *const &const __normal_iterator<const Node *, vector<Node, allocator<Node>>> *const vector<Node, allocator<Node>> *const _Vector_base<Node, allocator<Node>> *const _Rb_tree_iterator<pair<const unsigned long, Target>> *_Rb_tree_node<pair<const unsigned long, Target>> *vector<MarkDownColumn, allocator<MarkDownColumn>> *_Vector_base<MarkDownColumn, allocator<MarkDownColumn>> *MarkDownColumn *constMarkDownColumn *const &MarkDownColumn *&const __normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>> *..(*)(..))[6]..(*)(..))[2]basic_ifstream<char, char_traits<char>> *basic_streambuf<char, char_traits<char>> *basic_ios<char, char_traits<char>> *basic_filebuf<char, char_traits<char>> *..(*)(..))[80]..(*)(..))[47]..(*)(..))[77]duration_values<rep>::max()const __normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>>const __normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<char *, basic_string<char, char_traits<char>, allocator<char>>> &_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &&_Hashtable &const vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> *const allocator<vector<double, allocator<double>>>const allocator<vector<double, allocator<double>>> &_Vector_base<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> *const _Vector_base<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>_Vector_base<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &&__normal_iterator<double *, vector<double, allocator<double>>> *double *constdouble *const &const allocator<double>const allocator<double> &const unordered_map<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> *pair<double, double> *constpair<double, double> *const &pair<double, double> *&const __normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> *vector<pair<double, double>, allocator<pair<double, double>>> *_Vector_base<pair<double, double>, allocator<pair<double, double>>> *vector<pair<double, double>, allocator<pair<double, double>>> &&_Vector_base<pair<double, double>, allocator<pair<double, double>>> &&const vector<pair<double, double>, allocator<pair<double, double>>>const vector<pair<double, double>, allocator<pair<double, double>>> *const _Vector_base<pair<double, double>, allocator<pair<double, double>>> *const pair<double, double> *constconst pair<double, double> *const &const __normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>> *const numpunct<char>const numpunct<char> *const allocator<pair<double, double>>const allocator<pair<double, double>> &const _Vector_base<unsigned long, allocator<unsigned long>>const _Vector_base<unsigned long, allocator<unsigned long>> *const allocator<BigO>const allocator<BigO> &const allocator<Node>const allocator<Node> &const _Vector_base<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> *const _Vector_base<MarkDownColumn, allocator<MarkDownColumn>> *const allocator<MarkDownColumn>const allocator<MarkDownColumn> &const _Hash_code_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true> *_Hash_code_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, true> *noexcept(declval<const _H2&>()((__hash_code)0,
						 (std::size_t)0))__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 0UL, 2UL>__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 0UL, 2UL> &__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 0UL, 2UL> &&const __tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 0UL, 2UL>const __tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 0UL, 2UL> &const _Rb_tree_node<pair<const unsigned long, Target>>const _Rb_tree_node<pair<const unsigned long, Target>> &_Rb_tree_node<pair<const unsigned long, Target>> &const _Rb_tree_node<pair<const unsigned long, Target>> *const pair<const unsigned long, Target> *_Rb_tree_node<pair<const unsigned long, Target>>_Rb_tree_node<pair<const unsigned long, Target>> &&_Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, _Compare2, allocator<pair<const unsigned long, Target>>>_Select1st<pair<const unsigned long, Target>>_Select1st<pair<const unsigned long, Target>> &_Select1st<pair<const unsigned long, Target>> &&const _Select1st<pair<const unsigned long, Target>>const _Select1st<pair<const unsigned long, Target>> &_Rb_tree_impl<less<unsigned long>, true>_Rb_tree_impl<less<unsigned long>, true> &const _Rb_tree_impl<less<unsigned long>, true>const _Rb_tree_impl<less<unsigned long>, true> &_Rb_tree_impl<less<unsigned long>, true> *map<unsigned long, Target, _C2, allocator<pair<const unsigned long, Target>>>multimap<unsigned long, Target, _C2, allocator<pair<const unsigned long, Target>>>pair<_Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>>pair<_Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>>__pair_base<double, double>_Tuple_impl<0UL, const double &, const basic_string<char, char_traits<char>, allocator<char>> &>_Tuple_impl<0UL, const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &&const _Tuple_impl<0UL, const double &, const basic_string<char, char_traits<char>, allocator<char>> &>const _Tuple_impl<0UL, const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &_Tuple_impl<0UL, const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &__alloc_traits<allocator<pair<double, double>>, pair<double, double>>__alloc_traits<allocator<pair<double, double>>, pair<double, double>> &__alloc_traits<allocator<pair<double, double>>, pair<double, double>> &&const __alloc_traits<allocator<pair<double, double>>, pair<double, double>>const __alloc_traits<allocator<pair<double, double>>, pair<double, double>> &__underlying_type_impl<Measure, true>__underlying_type_impl<Measure, true> &__underlying_type_impl<Measure, true> &&const __underlying_type_impl<Measure, true>const __underlying_type_impl<Measure, true> &remove_reference<Config &>remove_reference<Config &> &remove_reference<Config &> &&const remove_reference<Config &>const remove_reference<Config &> &__alloc_traits<allocator<MarkDownColumn>, MarkDownColumn>__alloc_traits<allocator<MarkDownColumn>, MarkDownColumn> &__alloc_traits<allocator<MarkDownColumn>, MarkDownColumn> &&const __alloc_traits<allocator<MarkDownColumn>, MarkDownColumn>const __alloc_traits<allocator<MarkDownColumn>, MarkDownColumn> &__pair_base<_Rb_tree_iterator<pair<const unsigned long, Target>>, bool>__pair_base<const unsigned long, Target>__alloc_traits<allocator<Node>, Node>__alloc_traits<allocator<Node>, Node> &__alloc_traits<allocator<Node>, Node> &&const __alloc_traits<allocator<Node>, Node>const __alloc_traits<allocator<Node>, Node> &allocator<_Rb_tree_node<pair<const unsigned long, Target>>> *allocator<pair<double, double>> *allocator<Node> *allocator<MarkDownColumn> *const __normal_iterator<BigO *, vector<BigO, allocator<BigO>>> *const new_allocator<MarkDownColumn> *new_allocator<MarkDownColumn> *115292150460684697const new_allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> *new_allocator<_Rb_tree_node<pair<const unsigned long, Target>>> *const new_allocator<_Rb_tree_node<pair<const unsigned long, Target>>> *const new_allocator<Node> *new_allocator<Node> *const new_allocator<BigO> *const new_allocator<pair<double, double>> *new_allocator<pair<double, double>> *allocator<vector<double, allocator<double>>> *const new_allocator<vector<double, allocator<double>>>const new_allocator<vector<double, allocator<double>>> &new_allocator<vector<double, allocator<double>>> &const _Map_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> *_Map_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>, true> *const _Hashtable_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true>> *_Hashtable_base<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true>> *_Hash_node_value_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> *_S_nothrow_move()allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &&lambda [] type at line 60083, col. 3 &&const allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>const allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> *constconst _Hash_node_value_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> *is_nothrow_move_assignable<_H1>::valueis_nothrow_move_assignable<_Equal>::value__node_alloc_traits::_S_nothrow_move()
	       && is_nothrow_move_assignable<_H1>::value
	       && is_nothrow_move_assignable<_Equal>::value__node_alloc_traits::_S_propagate_on_move_assign()__node_alloc_traits::_S_propagate_on_move_assign()
	  || __node_alloc_traits::_S_always_equal()const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> *lambda [] type at line 59871, col. 8 &&lambda [] type at line 59888, col. 2 &&_ReuseOrAllocNode<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &operator std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>, true> *(*)(const std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>, true>>> &, const std::__detail::_Hash_node<std::pair<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>, true> *)const vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *basic_string<char, char_traits<char>, allocator<char>> *constbasic_string<char, char_traits<char>, allocator<char>> *const &basic_string<char, char_traits<char>, allocator<char>> *&ios_base::failbitconst vector<MarkDownColumn, allocator<MarkDownColumn>>const vector<MarkDownColumn, allocator<MarkDownColumn>> *_Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, less<unsigned long>, allocator<pair<const unsigned long, Target>>> *const _Rb_tree<unsigned long, pair<const unsigned long, Target>, _Select1st<pair<const unsigned long, Target>>, less<unsigned long>, allocator<pair<const unsigned long, Target>>> *tuple<const basic_string<char, char_traits<char>, allocator<char>> &> &&tuple<const basic_string<char, char_traits<char>, allocator<char>> &> &const _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true>const vector<pair<double, double>, allocator<pair<double, double>>> &is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149984, col. 48>is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149984, col. 48> &is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149984, col. 48> &&const is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149984, col. 48>const is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149984, col. 48> &is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149981, col. 48>is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149981, col. 48> &is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149981, col. 48> &&const is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149981, col. 48>const is_nothrow_constructible<BigO, const char(&)[7], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149981, col. 48> &is_nothrow_constructible<BigO, const char(&)[11], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149978, col. 52>is_nothrow_constructible<BigO, const char(&)[11], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149978, col. 52> &is_nothrow_constructible<BigO, const char(&)[11], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149978, col. 52> &&const is_nothrow_constructible<BigO, const char(&)[11], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149978, col. 52>const is_nothrow_constructible<BigO, const char(&)[11], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149978, col. 52> &is_nothrow_constructible<BigO, const char(&)[9], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149975, col. 50>is_nothrow_constructible<BigO, const char(&)[9], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149975, col. 50> &is_nothrow_constructible<BigO, const char(&)[9], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149975, col. 50> &&const is_nothrow_constructible<BigO, const char(&)[9], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149975, col. 50>const is_nothrow_constructible<BigO, const char(&)[9], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149975, col. 50> &is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149972, col. 46>is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149972, col. 46> &is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149972, col. 46> &&const is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149972, col. 46>const is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149972, col. 46> &is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149969, col. 46>is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149969, col. 46> &is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149969, col. 46> &&const is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149969, col. 46>const is_nothrow_constructible<BigO, const char(&)[5], vector<pair<double, double>, allocator<pair<double, double>>> &, lambda [] type at line 149969, col. 46> &is_nothrow_constructible<Node, Node>is_nothrow_constructible<Node, Node> &is_nothrow_constructible<Node, Node> &&const is_nothrow_constructible<Node, Node>const is_nothrow_constructible<Node, Node> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[1], double>is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[1], double> &&const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[1], double>const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[2], double &>is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[2], double &> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[2], double &> &&const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[2], double &>const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[6], const char(&)[2], double &> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[4], const char(&)[1], double>is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[4], const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[4], const char(&)[1], double> &&const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[4], const char(&)[1], double>const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[4], const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[5], const char(&)[2], double>is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[5], const char(&)[2], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[5], const char(&)[2], double> &&const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[5], const char(&)[2], double>const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[5], const char(&)[2], double> &is_nothrow_constructible<MarkDownColumn, int, int, basic_string<char, char_traits<char>, allocator<char>>, const char(&)[1], double>is_nothrow_constructible<MarkDownColumn, int, int, basic_string<char, char_traits<char>, allocator<char>>, const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, basic_string<char, char_traits<char>, allocator<char>>, const char(&)[1], double> &&const is_nothrow_constructible<MarkDownColumn, int, int, basic_string<char, char_traits<char>, allocator<char>>, const char(&)[1], double>const is_nothrow_constructible<MarkDownColumn, int, int, basic_string<char, char_traits<char>, allocator<char>>, const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[12], const char(&)[1], double>is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[12], const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[12], const char(&)[1], double> &&const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[12], const char(&)[1], double>const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[12], const char(&)[1], double> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[9], const char(&)[2], double &>is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[9], const char(&)[2], double &> &is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[9], const char(&)[2], double &> &&const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[9], const char(&)[2], double &>const is_nothrow_constructible<MarkDownColumn, int, int, const char(&)[9], const char(&)[2], double &> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[80]>is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[80]> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[80]> &&const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[80]>const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[80]> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[47]>is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[47]> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[47]> &&const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[47]>const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[47]> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[77]>is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[77]> &is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[77]> &&const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[77]>const is_nothrow_constructible<basic_string<char, char_traits<char>, allocator<char>>, const char(&)[77]> &const _ReuseOrAllocNode<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>const _ReuseOrAllocNode<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &is_nothrow_constructible<pair<double, double>, const double &, double>is_nothrow_constructible<pair<double, double>, const double &, double> &is_nothrow_constructible<pair<double, double>, const double &, double> &&const is_nothrow_constructible<pair<double, double>, const double &, double>const is_nothrow_constructible<pair<double, double>, const double &, double> &__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 1UL, 2UL>__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 1UL, 2UL> &__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 1UL, 2UL> &&const __tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 1UL, 2UL>const __tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 1UL, 2UL> &iterator_traits<Node *>iterator_traits<Node *> &iterator_traits<Node *> &&const iterator_traits<Node *>const iterator_traits<Node *> &iterator_traits<const BigO *>iterator_traits<const BigO *> &iterator_traits<const BigO *> &&const iterator_traits<const BigO *>const iterator_traits<const BigO *> &rebind<Node>rebind<Node> &rebind<Node> &&const rebind<Node>const rebind<Node> &iterator_traits<const Node *>iterator_traits<const Node *> &iterator_traits<const Node *> &&const iterator_traits<const Node *>const iterator_traits<const Node *> &_PCC<true, const unsigned long, Target>_PCC<true, const unsigned long, Target> &_PCC<true, const unsigned long, Target> &&const _PCC<true, const unsigned long, Target>const _PCC<true, const unsigned long, Target> &_PCC<<expression>, const unsigned long, Target>_PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, bool>_PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, bool> &_PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, bool> &&const _PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, bool>const _PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, bool> &_PCC<<expression>, _Rb_tree_iterator<pair<const unsigned long, Target>>, bool>iterator_traits<MarkDownColumn *>iterator_traits<MarkDownColumn *> &iterator_traits<MarkDownColumn *> &&const iterator_traits<MarkDownColumn *>const iterator_traits<MarkDownColumn *> &rebind<MarkDownColumn>rebind<MarkDownColumn> &rebind<MarkDownColumn> &&const rebind<MarkDownColumn>const rebind<MarkDownColumn> &is_enum<Measure>is_enum<Measure> &is_enum<Measure> &&const is_enum<Measure>const is_enum<Measure> &iterator_traits<pair<double, double> *>iterator_traits<pair<double, double> *> &iterator_traits<pair<double, double> *> &&const iterator_traits<pair<double, double> *>const iterator_traits<pair<double, double> *> &rebind<pair<double, double>>rebind<pair<double, double>> &rebind<pair<double, double>> &&const rebind<pair<double, double>>const rebind<pair<double, double>> &iterator_traits<const pair<double, double> *>iterator_traits<const pair<double, double> *> &iterator_traits<const pair<double, double> *> &&const iterator_traits<const pair<double, double> *>const iterator_traits<const pair<double, double> *> &_TC<value, const double &, const basic_string<char, char_traits<char>, allocator<char>> &>_TC<true, const double &, const basic_string<char, char_traits<char>, allocator<char>> &>_TC<true, const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &_TC<true, const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &&const _TC<true, const double &, const basic_string<char, char_traits<char>, allocator<char>> &>const _TC<true, const double &, const basic_string<char, char_traits<char>, allocator<char>> &> &_Tuple_impl<1UL, const basic_string<char, char_traits<char>, allocator<char>> &>_Tuple_impl<1UL, const basic_string<char, char_traits<char>, allocator<char>> &> &&const _Tuple_impl<1UL, const basic_string<char, char_traits<char>, allocator<char>> &>const _Tuple_impl<1UL, const basic_string<char, char_traits<char>, allocator<char>> &> &_Tuple_impl<1UL, const basic_string<char, char_traits<char>, allocator<char>> &> &_PCC<true, double, double>_PCC<true, double, double> &_PCC<true, double, double> &&const _PCC<true, double, double>const _PCC<true, double, double> &_PCC<<expression>, double, double>reverse_iterator<__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>>reverse_iterator<__normal_iterator<pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>>reverse_iterator<__normal_iterator<const Node *, vector<Node, allocator<Node>>>>reverse_iterator<__normal_iterator<Node *, vector<Node, allocator<Node>>>>__normal_iterator<const MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>>reverse_iterator<__normal_iterator<const MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>>>reverse_iterator<__normal_iterator<MarkDownColumn *, vector<MarkDownColumn, allocator<MarkDownColumn>>>>__alloc_traits<allocator<pair<const unsigned long, Target>>, pair<const unsigned long, Target>>__alloc_traits<allocator<pair<const unsigned long, Target>>, pair<const unsigned long, Target>> &__alloc_traits<allocator<pair<const unsigned long, Target>>, pair<const unsigned long, Target>> &&const __alloc_traits<allocator<pair<const unsigned long, Target>>, pair<const unsigned long, Target>>const __alloc_traits<allocator<pair<const unsigned long, Target>>, pair<const unsigned long, Target>> &__pair_base<_Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>>__pair_base<_Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>>__alloc_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>, _Rb_tree_node<pair<const unsigned long, Target>>>__alloc_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>, _Rb_tree_node<pair<const unsigned long, Target>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>, _Rb_tree_node<pair<const unsigned long, Target>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>, _Rb_tree_node<pair<const unsigned long, Target>>>const __alloc_traits<allocator<_Rb_tree_node<pair<const unsigned long, Target>>>, _Rb_tree_node<pair<const unsigned long, Target>>> &reverse_iterator<_Rb_tree_iterator<pair<const unsigned long, Target>>>reverse_iterator<_Rb_tree_const_iterator<pair<const unsigned long, Target>>>_Node_handle<unsigned long, pair<const unsigned long, Target>, allocator<_Rb_tree_node<pair<const unsigned long, Target>>>>_Node_insert_return<_Rb_tree_iterator<pair<const unsigned long, Target>>, _Node_handle<unsigned long, pair<const unsigned long, Target>, allocator<_Rb_tree_node<pair<const unsigned long, Target>>>>>is_same<pair<const unsigned long, Target>, value_type>unary_function<pair<const unsigned long, Target>, const unsigned long>unary_function<pair<const unsigned long, Target>, const unsigned long> &unary_function<pair<const unsigned long, Target>, const unsigned long> &&const unary_function<pair<const unsigned long, Target>, const unsigned long>const unary_function<pair<const unsigned long, Target>, const unsigned long> &_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true> &_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true> &&const _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true> &__aligned_membuf<pair<const unsigned long, Target>>__aligned_membuf<pair<const unsigned long, Target>> &__aligned_membuf<pair<const unsigned long, Target>> &&const __aligned_membuf<pair<const unsigned long, Target>>const __aligned_membuf<pair<const unsigned long, Target>> &remove_reference<vector<Result, allocator<Result>> &>remove_reference<vector<Result, allocator<Result>> &> &remove_reference<vector<Result, allocator<Result>> &> &&const remove_reference<vector<Result, allocator<Result>> &>const remove_reference<vector<Result, allocator<Result>> &> &remove_reference<vector<pair<double, double>, allocator<pair<double, double>>> &>remove_reference<vector<pair<double, double>, allocator<pair<double, double>>> &> &remove_reference<vector<pair<double, double>, allocator<pair<double, double>>> &> &&const remove_reference<vector<pair<double, double>, allocator<pair<double, double>>> &>const remove_reference<vector<pair<double, double>, allocator<pair<double, double>>> &> &remove_reference<lambda [] type at line 149984, col. 48>remove_reference<lambda [] type at line 149984, col. 48> &remove_reference<lambda [] type at line 149984, col. 48> &&const remove_reference<lambda [] type at line 149984, col. 48>const remove_reference<lambda [] type at line 149984, col. 48> &remove_reference<lambda [] type at line 149981, col. 48>remove_reference<lambda [] type at line 149981, col. 48> &remove_reference<lambda [] type at line 149981, col. 48> &&const remove_reference<lambda [] type at line 149981, col. 48>const remove_reference<lambda [] type at line 149981, col. 48> &remove_reference<lambda [] type at line 149978, col. 52>remove_reference<lambda [] type at line 149978, col. 52> &remove_reference<lambda [] type at line 149978, col. 52> &&const remove_reference<lambda [] type at line 149978, col. 52>const remove_reference<lambda [] type at line 149978, col. 52> &remove_reference<lambda [] type at line 149975, col. 50>remove_reference<lambda [] type at line 149975, col. 50> &remove_reference<lambda [] type at line 149975, col. 50> &&const remove_reference<lambda [] type at line 149975, col. 50>const remove_reference<lambda [] type at line 149975, col. 50> &remove_reference<lambda [] type at line 149972, col. 46>remove_reference<lambda [] type at line 149972, col. 46> &remove_reference<lambda [] type at line 149972, col. 46> &&const remove_reference<lambda [] type at line 149972, col. 46>const remove_reference<lambda [] type at line 149972, col. 46> &remove_reference<lambda [] type at line 149969, col. 46>remove_reference<lambda [] type at line 149969, col. 46> &remove_reference<lambda [] type at line 149969, col. 46> &&const remove_reference<lambda [] type at line 149969, col. 46>const remove_reference<lambda [] type at line 149969, col. 46> &remove_reference<Node>remove_reference<Node> &remove_reference<Node> &&const remove_reference<Node>const remove_reference<Node> &remove_reference<Target &>remove_reference<Target &> &remove_reference<Target &> &&const remove_reference<Target &>const remove_reference<Target &> &remove_reference<const char(&)[80]>remove_reference<const char(&)[80]> &remove_reference<const char(&)[80]> &&const remove_reference<const char(&)[80]>const remove_reference<const char(&)[80]> &remove_reference<const char(&)[77]>remove_reference<const char(&)[77]> &remove_reference<const char(&)[77]> &&const remove_reference<const char(&)[77]>const remove_reference<const char(&)[77]> &remove_reference<vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &>remove_reference<vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &> &remove_reference<vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &> &&const remove_reference<vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &>const remove_reference<vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>> &> &tuple_element<0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>tuple_element<0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &tuple_element<0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &&const tuple_element<0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>const tuple_element<0UL, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &>remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &&const remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &>const remove_reference<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &iterator_traits<BigO *>iterator_traits<BigO *> &iterator_traits<BigO *> &&const iterator_traits<BigO *>const iterator_traits<BigO *> &remove_reference<BigO &>remove_reference<BigO &> &remove_reference<BigO &> &&const remove_reference<BigO &>const remove_reference<BigO &> &const _Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true> *_Node_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, false, true> *const _Node_iterator_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>const _Node_iterator_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *_Node_iterator_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *int(_S_threshold)__aligned_membuf<pair<const unsigned long, Target>> *_Rb_tree_node<pair<const unsigned long, Target>> *&char *const &const _ReuseOrAllocNode<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> *_ReuseOrAllocNode<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> *lambda [] type at line 59925, col. 9 &&const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *const _Hashtable_alloc<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> *const __is_nothrow_copy_constructible_impl<hash<basic_string<char, char_traits<char>, allocator<char>>>, true>const is_nothrow_constructible<hash<basic_string<char, char_traits<char>, allocator<char>>>, const hash<basic_string<char, char_traits<char>, allocator<char>>> &>const __is_nothrow_copy_constructible_impl<equal_to<basic_string<char, char_traits<char>, allocator<char>>>, true>const is_nothrow_constructible<equal_to<basic_string<char, char_traits<char>, allocator<char>>>, const equal_to<basic_string<char, char_traits<char>, allocator<char>>> &>vector<double, allocator<double>> *constvector<double, allocator<double>> *const &vector<double, allocator<double>> *&_Tuple_impl<0UL, const double &, const basic_string<char, char_traits<char>, allocator<char>> &> *new_allocator<vector<double, allocator<double>>> *unsigned long *constunsigned long *const &unsigned long *&__is_move_iterator<const unsigned long *>__is_move_iterator<const unsigned long *> &__is_move_iterator<const unsigned long *> &&const __is_move_iterator<const unsigned long *>const __is_move_iterator<const unsigned long *> &__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 2UL, 2UL>__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 2UL, 2UL> &__tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 2UL, 2UL> &&const __tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 2UL, 2UL>const __tuple_compare<tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>, 2UL, 2UL> &is_nothrow_default_constructible<allocator<pair<double, double>>>is_nothrow_default_constructible<allocator<pair<double, double>>> &is_nothrow_default_constructible<allocator<pair<double, double>>> &&const is_nothrow_default_constructible<allocator<pair<double, double>>>const is_nothrow_default_constructible<allocator<pair<double, double>>> &is_constructible<pair<double, double>, pair<double, double> &&>pair<double, double> &&is_constructible<pair<double, double>, pair<double, double> &&> &is_constructible<pair<double, double>, pair<double, double> &&> &&const is_constructible<pair<double, double>, pair<double, double> &&>const is_constructible<pair<double, double>, pair<double, double> &&> &__is_move_constructible_impl<pair<double, double>, true>__is_move_constructible_impl<pair<double, double>, true> &__is_move_constructible_impl<pair<double, double>, true> &&const __is_move_constructible_impl<pair<double, double>, true>const __is_move_constructible_impl<pair<double, double>, true> &is_move_constructible<pair<double, double>>is_move_constructible<pair<double, double>> &is_move_constructible<pair<double, double>> &&const is_move_constructible<pair<double, double>>const is_move_constructible<pair<double, double>> &__is_move_insertable<allocator<pair<double, double>>>__is_move_insertable<allocator<pair<double, double>>> &__is_move_insertable<allocator<pair<double, double>>> &&const __is_move_insertable<allocator<pair<double, double>>>const __is_move_insertable<allocator<pair<double, double>>> &is_assignable<vector<double, allocator<double>> &, vector<double, allocator<double>> &>is_assignable<vector<double, allocator<double>> &, vector<double, allocator<double>> &> &is_assignable<vector<double, allocator<double>> &, vector<double, allocator<double>> &> &&const is_assignable<vector<double, allocator<double>> &, vector<double, allocator<double>> &>const is_assignable<vector<double, allocator<double>> &, vector<double, allocator<double>> &> &__is_move_iterator<vector<double, allocator<double>> *>__is_move_iterator<vector<double, allocator<double>> *> &__is_move_iterator<vector<double, allocator<double>> *> &&const __is_move_iterator<vector<double, allocator<double>> *>const __is_move_iterator<vector<double, allocator<double>> *> &__is_move_iterator<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>>__is_move_iterator<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>> &__is_move_iterator<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>> &&const __is_move_iterator<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>>const __is_move_iterator<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>> &is_nothrow_default_constructible<allocator<MarkDownColumn>>is_nothrow_default_constructible<allocator<MarkDownColumn>> &is_nothrow_default_constructible<allocator<MarkDownColumn>> &&const is_nothrow_default_constructible<allocator<MarkDownColumn>>const is_nothrow_default_constructible<allocator<MarkDownColumn>> &is_constructible<MarkDownColumn, MarkDownColumn &&>is_constructible<MarkDownColumn, MarkDownColumn &&> &is_constructible<MarkDownColumn, MarkDownColumn &&> &&const is_constructible<MarkDownColumn, MarkDownColumn &&>const is_constructible<MarkDownColumn, MarkDownColumn &&> &__is_move_constructible_impl<MarkDownColumn, true>__is_move_constructible_impl<MarkDownColumn, true> &__is_move_constructible_impl<MarkDownColumn, true> &&const __is_move_constructible_impl<MarkDownColumn, true>const __is_move_constructible_impl<MarkDownColumn, true> &is_move_constructible<MarkDownColumn>is_move_constructible<MarkDownColumn> &is_move_constructible<MarkDownColumn> &&const is_move_constructible<MarkDownColumn>const is_move_constructible<MarkDownColumn> &__is_move_insertable<allocator<MarkDownColumn>>__is_move_insertable<allocator<MarkDownColumn>> &__is_move_insertable<allocator<MarkDownColumn>> &&const __is_move_insertable<allocator<MarkDownColumn>>const __is_move_insertable<allocator<MarkDownColumn>> &is_nothrow_default_constructible<allocator<Node>>is_nothrow_default_constructible<allocator<Node>> &is_nothrow_default_constructible<allocator<Node>> &&const is_nothrow_default_constructible<allocator<Node>>const is_nothrow_default_constructible<allocator<Node>> &is_constructible<Node, Node &&>is_constructible<Node, Node &&> &is_constructible<Node, Node &&> &&const is_constructible<Node, Node &&>const is_constructible<Node, Node &&> &__is_move_constructible_impl<Node, true>__is_move_constructible_impl<Node, true> &__is_move_constructible_impl<Node, true> &&const __is_move_constructible_impl<Node, true>const __is_move_constructible_impl<Node, true> &is_move_constructible<Node>is_move_constructible<Node> &is_move_constructible<Node> &&const is_move_constructible<Node>const is_move_constructible<Node> &__is_move_insertable<allocator<Node>>__is_move_insertable<allocator<Node>> &__is_move_insertable<allocator<Node>> &&const __is_move_insertable<allocator<Node>>const __is_move_insertable<allocator<Node>> &is_nothrow_default_constructible<allocator<BigO>>is_nothrow_default_constructible<allocator<BigO>> &is_nothrow_default_constructible<allocator<BigO>> &&const is_nothrow_default_constructible<allocator<BigO>>const is_nothrow_default_constructible<allocator<BigO>> &is_constructible<BigO, BigO &&>is_constructible<BigO, BigO &&> &is_constructible<BigO, BigO &&> &&const is_constructible<BigO, BigO &&>const is_constructible<BigO, BigO &&> &__is_move_constructible_impl<BigO, true>__is_move_constructible_impl<BigO, true> &__is_move_constructible_impl<BigO, true> &&const __is_move_constructible_impl<BigO, true>const __is_move_constructible_impl<BigO, true> &is_move_constructible<BigO>is_move_constructible<BigO> &is_move_constructible<BigO> &&const is_move_constructible<BigO>const is_move_constructible<BigO> &__is_move_insertable<allocator<BigO>>__is_move_insertable<allocator<BigO>> &__is_move_insertable<allocator<BigO>> &&const __is_move_insertable<allocator<BigO>>const __is_move_insertable<allocator<BigO>> &is_assignable<Result &, Result &>is_assignable<Result &, Result &> &is_assignable<Result &, Result &> &&const is_assignable<Result &, Result &>const is_assignable<Result &, Result &> &__is_move_iterator<Result *>__is_move_iterator<Result *> &__is_move_iterator<Result *> &&const __is_move_iterator<Result *>const __is_move_iterator<Result *> &__is_move_iterator<__normal_iterator<const Result *, vector<Result, allocator<Result>>>>__is_move_iterator<__normal_iterator<const Result *, vector<Result, allocator<Result>>>> &__is_move_iterator<__normal_iterator<const Result *, vector<Result, allocator<Result>>>> &&const __is_move_iterator<__normal_iterator<const Result *, vector<Result, allocator<Result>>>>const __is_move_iterator<__normal_iterator<const Result *, vector<Result, allocator<Result>>>> &is_assignable<Result &, const Result &>is_assignable<Result &, const Result &> &is_assignable<Result &, const Result &> &&const is_assignable<Result &, const Result &>const is_assignable<Result &, const Result &> &_Node_iterator_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>_Node_iterator_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> &_Node_iterator_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> &&const _Node_iterator_base<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> &_PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>>_PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>> &_PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>> &&const _PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>>const _PCC<true, _Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const unsigned long, Target>>, _Rb_tree_iterator<pair<const unsigned long, Target>>>_PCC<true, _Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>>_PCC<true, _Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>> &_PCC<true, _Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>>const _PCC<true, _Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>, _Rb_tree_const_iterator<pair<const unsigned long, Target>>>rebind<_Rb_tree_node<pair<const unsigned long, Target>>>rebind<_Rb_tree_node<pair<const unsigned long, Target>>> &rebind<_Rb_tree_node<pair<const unsigned long, Target>>> &&const rebind<_Rb_tree_node<pair<const unsigned long, Target>>>const rebind<_Rb_tree_node<pair<const unsigned long, Target>>> &rebind<pair<const unsigned long, Target>>rebind<pair<const unsigned long, Target>> &rebind<pair<const unsigned long, Target>> &&const rebind<pair<const unsigned long, Target>>const rebind<pair<const unsigned long, Target>> &is_same<double, _U2>is_same<double, _U1>__and_<is_same<pair<double, double> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<MarkDownColumn *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_iterator<pair<const unsigned long, Target>>, _U1>is_same<Target, _U2>__and_<is_same<Node *, _Ptr>, __not_<is_pointer<_Ptr>>>remove_reference<_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &>remove_reference<_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &> &remove_reference<_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &> &&const remove_reference<_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &>const remove_reference<_Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &> &remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &>remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &> &remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &> &&const remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &>const remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &> &_Tuple_impl<1UL, const basic_string<char, char_traits<char>, allocator<char>> &> *pair<double, double> *&&const _Hashtable_ebo_helper<1, hash<basic_string<char, char_traits<char>, allocator<char>>>, true>const _Hashtable_ebo_helper<1, hash<basic_string<char, char_traits<char>, allocator<char>>>, true> &_Hashtable_ebo_helper<1, hash<basic_string<char, char_traits<char>, allocator<char>>>, true> &const __normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>const __normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>> &__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>> &allocator<vector<double, allocator<double>>> &&const __normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>const vector<double, allocator<double>> *constconst vector<double, allocator<double>> *const &const __normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>> &__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>> &__make_not_void<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &MarkDownColumn *&&const _Select1st<pair<const unsigned long, Target>> *_Select1st<pair<const unsigned long, Target>> *unsigned char(*)[24]Node *&&BigO *&&allocator<Result> &&is_assignable<pair<double, double> &, const pair<double, double> &>is_assignable<pair<double, double> &, const pair<double, double> &> &is_assignable<pair<double, double> &, const pair<double, double> &> &&const is_assignable<pair<double, double> &, const pair<double, double> &>const is_assignable<pair<double, double> &, const pair<double, double> &> &__is_pointer<const Result *>__is_pointer<const Result *> &__is_pointer<const Result *> &&const __is_pointer<const Result *>const __is_pointer<const Result *> &is_nothrow_copy_constructible<const Result *>is_nothrow_copy_constructible<const Result *> &is_nothrow_copy_constructible<const Result *> &&const is_nothrow_copy_constructible<const Result *>const is_nothrow_copy_constructible<const Result *> &__are_same<Result, Result>__are_same<Result, Result> &__are_same<Result, Result> &&const __are_same<Result, Result>const __are_same<Result, Result> &__is_pointer<Result *>__is_pointer<Result *> &__is_pointer<Result *> &&const __is_pointer<Result *>const __is_pointer<Result *> &is_nothrow_destructible<BigO>is_nothrow_destructible<BigO> &is_nothrow_destructible<BigO> &&const is_nothrow_destructible<BigO>const is_nothrow_destructible<BigO> &is_nothrow_destructible<Node>is_nothrow_destructible<Node> &is_nothrow_destructible<Node> &&const is_nothrow_destructible<Node>const is_nothrow_destructible<Node> &is_nothrow_destructible<MarkDownColumn>is_nothrow_destructible<MarkDownColumn> &is_nothrow_destructible<MarkDownColumn> &&const is_nothrow_destructible<MarkDownColumn>const is_nothrow_destructible<MarkDownColumn> &pointer_traits<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *>pointer_traits<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *> &pointer_traits<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *> &&const pointer_traits<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *>const pointer_traits<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true> *> &__is_pointer<const vector<double, allocator<double>> *>__is_pointer<const vector<double, allocator<double>> *> &__is_pointer<const vector<double, allocator<double>> *> &&const __is_pointer<const vector<double, allocator<double>> *>const __is_pointer<const vector<double, allocator<double>> *> &is_nothrow_copy_constructible<const vector<double, allocator<double>> *>is_nothrow_copy_constructible<const vector<double, allocator<double>> *> &is_nothrow_copy_constructible<const vector<double, allocator<double>> *> &&const is_nothrow_copy_constructible<const vector<double, allocator<double>> *>const is_nothrow_copy_constructible<const vector<double, allocator<double>> *> &__are_same<vector<double, allocator<double>>, vector<double, allocator<double>>>__are_same<vector<double, allocator<double>>, vector<double, allocator<double>>> &__are_same<vector<double, allocator<double>>, vector<double, allocator<double>>> &&const __are_same<vector<double, allocator<double>>, vector<double, allocator<double>>>const __are_same<vector<double, allocator<double>>, vector<double, allocator<double>>> &__is_pointer<vector<double, allocator<double>> *>__is_pointer<vector<double, allocator<double>> *> &__is_pointer<vector<double, allocator<double>> *> &&const __is_pointer<vector<double, allocator<double>> *>const __is_pointer<vector<double, allocator<double>> *> &is_nothrow_destructible<pair<double, double>>is_nothrow_destructible<pair<double, double>> &is_nothrow_destructible<pair<double, double>> &&const is_nothrow_destructible<pair<double, double>>const is_nothrow_destructible<pair<double, double>> &conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *>conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *> &conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *> &&const conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *>const conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> *> &tuple_element<0UL, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>>tuple_element<0UL, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>> &tuple_element<0UL, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>> &&const tuple_element<0UL, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>>const tuple_element<0UL, tuple<const double &, const basic_string<char, char_traits<char>, allocator<char>> &>> &is_same<Node *, _Ptr>is_same<MarkDownColumn *, _Ptr>is_same<pair<double, double> *, _Ptr>__and_<is_same<pair<const unsigned long, Target> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const unsigned long, Target>>, _U2>is_same<_Rb_tree_const_iterator<pair<const unsigned long, Target>>, _U1>is_same<_Rb_tree_iterator<pair<const unsigned long, Target>>, _U2>__and_<is_same<_Rb_tree_node<pair<const unsigned long, Target>> *, _Ptr>, __not_<is_pointer<_Ptr>>>_Equal_helper<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, unsigned long, true> &_Equal_helper<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, unsigned long, true> &&const _Equal_helper<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, unsigned long, true>const _Equal_helper<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, unsigned long, true> &__iterator_traits<__normal_iterator<const Result *, vector<Result, allocator<Result>>>, void>__iterator_traits<__normal_iterator<const Result *, vector<Result, allocator<Result>>>, void> &__iterator_traits<__normal_iterator<const Result *, vector<Result, allocator<Result>>>, void> &&const __iterator_traits<__normal_iterator<const Result *, vector<Result, allocator<Result>>>, void>const __iterator_traits<__normal_iterator<const Result *, vector<Result, allocator<Result>>>, void> &__iterator_traits<__normal_iterator<Result *, vector<Result, allocator<Result>>>, void>__iterator_traits<__normal_iterator<Result *, vector<Result, allocator<Result>>>, void> &__iterator_traits<__normal_iterator<Result *, vector<Result, allocator<Result>>>, void> &&const __iterator_traits<__normal_iterator<Result *, vector<Result, allocator<Result>>>, void>const __iterator_traits<__normal_iterator<Result *, vector<Result, allocator<Result>>>, void> &__is_referenceable<BigO>__is_referenceable<BigO> &__is_referenceable<BigO> &&const __is_referenceable<BigO>const __is_referenceable<BigO> &__is_referenceable<Node>__is_referenceable<Node> &__is_referenceable<Node> &&const __is_referenceable<Node>const __is_referenceable<Node> &remove_reference<_Rb_tree_iterator<pair<const unsigned long, Target>>>remove_reference<_Rb_tree_iterator<pair<const unsigned long, Target>>> &remove_reference<_Rb_tree_iterator<pair<const unsigned long, Target>>> &&const remove_reference<_Rb_tree_iterator<pair<const unsigned long, Target>>>const remove_reference<_Rb_tree_iterator<pair<const unsigned long, Target>>> &__is_referenceable<MarkDownColumn>__is_referenceable<MarkDownColumn> &__is_referenceable<MarkDownColumn> &&const __is_referenceable<MarkDownColumn>const __is_referenceable<MarkDownColumn> &remove_reference<const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &>remove_reference<const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &> &remove_reference<const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &> &&const remove_reference<const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &>const remove_reference<const _Hashtable<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, _Select1st, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, hash<basic_string<char, char_traits<char>, allocator<char>>>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<true, false, true>> &> &remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &&const remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>>const remove_reference<allocator<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>> &__iterator_traits<__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void>__iterator_traits<__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void> &__iterator_traits<__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void> &&const __iterator_traits<__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void>const __iterator_traits<__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void> &__iterator_traits<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void>__iterator_traits<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void> &__iterator_traits<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void> &&const __iterator_traits<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void>const __iterator_traits<__normal_iterator<const vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>>, void> &__is_referenceable<pair<double, double>>__is_referenceable<pair<double, double>> &__is_referenceable<pair<double, double>> &&const __is_referenceable<pair<double, double>>const __is_referenceable<pair<double, double>> &__aligned_buffer<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> *__sort_heapconst __aligned_membuf<pair<const unsigned long, Target>> *const __aligned_buffer<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> *__normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>> *const __normal_iterator<vector<double, allocator<double>> *, vector<vector<double, allocator<double>>, allocator<vector<double, allocator<double>>>>> *const _Head_base<0UL, const double &, false>const _Head_base<0UL, const double &, false> &_Head_base<0UL, const double &, false> &conditional<false, is_move_assignable<double>, is_copy_assignable<double>>conditional<false, is_move_assignable<double>, is_copy_assignable<double>> &conditional<false, is_move_assignable<double>, is_copy_assignable<double>> &&const conditional<false, is_move_assignable<double>, is_copy_assignable<double>>const conditional<false, is_move_assignable<double>, is_copy_assignable<double>> &is_nothrow_constructible<pair<const unsigned long, Target>, unsigned long &, Target &>is_nothrow_constructible<pair<const unsigned long, Target>, unsigned long &, Target &> &is_nothrow_constructible<pair<const unsigned long, Target>, unsigned long &, Target &> &&const is_nothrow_constructible<pair<const unsigned long, Target>, unsigned long &, Target &>const is_nothrow_constructible<pair<const unsigned long, Target>, unsigned long &, Target &> &conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &>conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &&const conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &>const conditional<false, const pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>> &> &is_same<_Rb_tree_node<pair<const unsigned long, Target>> *, _Ptr>is_same<pair<const unsigned long, Target> *, _Ptr>remove_reference<allocator<vector<double, allocator<double>>> &>remove_reference<allocator<vector<double, allocator<double>>> &> &remove_reference<allocator<vector<double, allocator<double>>> &> &&const remove_reference<allocator<vector<double, allocator<double>>> &>const remove_reference<allocator<vector<double, allocator<double>>> &> &__is_nothrow_copy_constructible_impl<const vector<double, allocator<double>> *, true>__is_nothrow_copy_constructible_impl<const vector<double, allocator<double>> *, true> &__is_nothrow_copy_constructible_impl<const vector<double, allocator<double>> *, true> &&const __is_nothrow_copy_constructible_impl<const vector<double, allocator<double>> *, true>const __is_nothrow_copy_constructible_impl<const vector<double, allocator<double>> *, true> &remove_reference<_Rb_tree_node<pair<const unsigned long, Target>> *&>remove_reference<_Rb_tree_node<pair<const unsigned long, Target>> *&> &remove_reference<_Rb_tree_node<pair<const unsigned long, Target>> *&> &&const remove_reference<_Rb_tree_node<pair<const unsigned long, Target>> *&>const remove_reference<_Rb_tree_node<pair<const unsigned long, Target>> *&> &__iterator_traits<__normal_iterator<BigO *, vector<BigO, allocator<BigO>>>, void>__iterator_traits<__normal_iterator<BigO *, vector<BigO, allocator<BigO>>>, void> &__iterator_traits<__normal_iterator<BigO *, vector<BigO, allocator<BigO>>>, void> &&const __iterator_traits<__normal_iterator<BigO *, vector<BigO, allocator<BigO>>>, void>const __iterator_traits<__normal_iterator<BigO *, vector<BigO, allocator<BigO>>>, void> &__is_nothrow_copy_constructible_impl<const Result *, true>__is_nothrow_copy_constructible_impl<const Result *, true> &__is_nothrow_copy_constructible_impl<const Result *, true> &&const __is_nothrow_copy_constructible_impl<const Result *, true>const __is_nothrow_copy_constructible_impl<const Result *, true> &remove_reference<allocator<Result> &>remove_reference<allocator<Result> &> &remove_reference<allocator<Result> &> &&const remove_reference<allocator<Result> &>const remove_reference<allocator<Result> &> &__iterator_traits<__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>, void>__iterator_traits<__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>, void> &__iterator_traits<__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>, void> &&const __iterator_traits<__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>, void>const __iterator_traits<__normal_iterator<const pair<double, double> *, vector<pair<double, double>, allocator<pair<double, double>>>>, void> &const _Head_base<1UL, const basic_string<char, char_traits<char>, allocator<char>> &, false>const _Head_base<1UL, const basic_string<char, char_traits<char>, allocator<char>> &, false> &_Head_base<1UL, const basic_string<char, char_traits<char>, allocator<char>> &, false> &const _Hashtable_ebo_helper<0, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, true>const _Hashtable_ebo_helper<0, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, true> &_Hashtable_ebo_helper<0, equal_to<basic_string<char, char_traits<char>, allocator<char>>>, true> &const unsigned char[24]const unsigned char(*)[24]__make_heapconst _DistanceType__parent*(__first + __parent)_ValueType &__pop_heap*__result_DistanceType(0)is_nothrow_copy_constructible<BigO *>is_nothrow_copy_constructible<BigO *> &is_nothrow_copy_constructible<BigO *> &&const is_nothrow_copy_constructible<BigO *>const is_nothrow_copy_constructible<BigO *> &is_nothrow_copy_constructible<Node *>is_nothrow_copy_constructible<Node *> &is_nothrow_copy_constructible<Node *> &&const is_nothrow_copy_constructible<Node *>const is_nothrow_copy_constructible<Node *> &is_nothrow_destructible<pair<const unsigned long, Target>>is_nothrow_destructible<pair<const unsigned long, Target>> &is_nothrow_destructible<pair<const unsigned long, Target>> &&const is_nothrow_destructible<pair<const unsigned long, Target>>const is_nothrow_destructible<pair<const unsigned long, Target>> &is_nothrow_copy_constructible<MarkDownColumn *>is_nothrow_copy_constructible<MarkDownColumn *> &is_nothrow_copy_constructible<MarkDownColumn *> &&const is_nothrow_copy_constructible<MarkDownColumn *>const is_nothrow_copy_constructible<MarkDownColumn *> &is_nothrow_copy_constructible<pair<double, double> *>is_nothrow_copy_constructible<pair<double, double> *> &is_nothrow_copy_constructible<pair<double, double> *> &&const is_nothrow_copy_constructible<pair<double, double> *>const is_nothrow_copy_constructible<pair<double, double> *> &__is_referenceable<const Result *>__is_referenceable<const Result *> &__is_referenceable<const Result *> &&const __is_referenceable<const Result *>const __is_referenceable<const Result *> &is_nothrow_constructible<const Result *, const Result *const &>is_nothrow_constructible<const Result *, const Result *const &> &is_nothrow_constructible<const Result *, const Result *const &> &&const is_nothrow_constructible<const Result *, const Result *const &>const is_nothrow_constructible<const Result *, const Result *const &> &conditional<false, __undefined, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>conditional<false, __undefined, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &conditional<false, __undefined, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &&const conditional<false, __undefined, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>const conditional<false, __undefined, _Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &__is_referenceable<const vector<double, allocator<double>> *>__is_referenceable<const vector<double, allocator<double>> *> &__is_referenceable<const vector<double, allocator<double>> *> &&const __is_referenceable<const vector<double, allocator<double>> *>const __is_referenceable<const vector<double, allocator<double>> *> &is_nothrow_constructible<const vector<double, allocator<double>> *, const vector<double, allocator<double>> *const &>is_nothrow_constructible<const vector<double, allocator<double>> *, const vector<double, allocator<double>> *const &> &is_nothrow_constructible<const vector<double, allocator<double>> *, const vector<double, allocator<double>> *const &> &&const is_nothrow_constructible<const vector<double, allocator<double>> *, const vector<double, allocator<double>> *const &>const is_nothrow_constructible<const vector<double, allocator<double>> *, const vector<double, allocator<double>> *const &> &remove_reference<const vector<double, allocator<double>> &>remove_reference<const vector<double, allocator<double>> &> &remove_reference<const vector<double, allocator<double>> &> &&const remove_reference<const vector<double, allocator<double>> &>const remove_reference<const vector<double, allocator<double>> &> &is_move_assignable<double>is_move_assignable<double> &is_move_assignable<double> &&const is_move_assignable<double>const is_move_assignable<double> &__adjust_heap__topIndex__secondChild*(__first + __secondChild)*(__first + (__secondChild - 1))__cmp__holeIndex__and_<is_nothrow_move_constructible<double>, is_nothrow_move_assignable<double>>__and_<is_nothrow_move_constructible<double>, is_nothrow_move_assignable<double>> &__and_<is_nothrow_move_constructible<double>, is_nothrow_move_assignable<double>> &&const __and_<is_nothrow_move_constructible<double>, is_nothrow_move_assignable<double>>const __and_<is_nothrow_move_constructible<double>, is_nothrow_move_assignable<double>> &__and_<is_nothrow_move_constructible<BigO>, is_nothrow_move_assignable<BigO>>__and_<is_nothrow_move_constructible<BigO>, is_nothrow_move_assignable<BigO>> &__and_<is_nothrow_move_constructible<BigO>, is_nothrow_move_assignable<BigO>> &&const __and_<is_nothrow_move_constructible<BigO>, is_nothrow_move_assignable<BigO>>const __and_<is_nothrow_move_constructible<BigO>, is_nothrow_move_assignable<BigO>> &__are_same<BigO, BigO>__are_same<BigO, BigO> &__are_same<BigO, BigO> &&const __are_same<BigO, BigO>const __are_same<BigO, BigO> &__is_pointer<BigO *>__is_pointer<BigO *> &__is_pointer<BigO *> &&const __is_pointer<BigO *>const __is_pointer<BigO *> &__is_move_assignable_impl<double, true>__is_move_assignable_impl<double, true> &__is_move_assignable_impl<double, true> &&const __is_move_assignable_impl<double, true>const __is_move_assignable_impl<double, true> &is_void<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>is_void<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &is_void<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &&const is_void<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>>const is_void<_Hash_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, true>> &__is_nothrow_copy_constructible_impl<pair<double, double> *, true>__is_nothrow_copy_constructible_impl<pair<double, double> *, true> &__is_nothrow_copy_constructible_impl<pair<double, double> *, true> &&const __is_nothrow_copy_constructible_impl<pair<double, double> *, true>const __is_nothrow_copy_constructible_impl<pair<double, double> *, true> &__is_nothrow_copy_constructible_impl<MarkDownColumn *, true>__is_nothrow_copy_constructible_impl<MarkDownColumn *, true> &__is_nothrow_copy_constructible_impl<MarkDownColumn *, true> &&const __is_nothrow_copy_constructible_impl<MarkDownColumn *, true>const __is_nothrow_copy_constructible_impl<MarkDownColumn *, true> &__is_nothrow_copy_constructible_impl<Node *, true>__is_nothrow_copy_constructible_impl<Node *, true> &__is_nothrow_copy_constructible_impl<Node *, true> &&const __is_nothrow_copy_constructible_impl<Node *, true>const __is_nothrow_copy_constructible_impl<Node *, true> &__is_nothrow_copy_constructible_impl<BigO *, true>__is_nothrow_copy_constructible_impl<BigO *, true> &__is_nothrow_copy_constructible_impl<BigO *, true> &&const __is_nothrow_copy_constructible_impl<BigO *, true>const __is_nothrow_copy_constructible_impl<BigO *, true> &remove_reference<const pair<double, double> &>remove_reference<const pair<double, double> &> &remove_reference<const pair<double, double> &> &&const remove_reference<const pair<double, double> &>const remove_reference<const pair<double, double> &> &__push_heapis_nothrow_constructible<BigO, BigO>is_nothrow_constructible<BigO, BigO> &is_nothrow_constructible<BigO, BigO> &&const is_nothrow_constructible<BigO, BigO>const is_nothrow_constructible<BigO, BigO> &conditional<true, is_move_assignable<double>, is_copy_assignable<double>>conditional<true, is_move_assignable<double>, is_copy_assignable<double>> &conditional<true, is_move_assignable<double>, is_copy_assignable<double>> &&const conditional<true, is_move_assignable<double>, is_copy_assignable<double>>const conditional<true, is_move_assignable<double>, is_copy_assignable<double>> &is_nothrow_constructible<MarkDownColumn, MarkDownColumn>is_nothrow_constructible<MarkDownColumn, MarkDownColumn> &is_nothrow_constructible<MarkDownColumn, MarkDownColumn> &&const is_nothrow_constructible<MarkDownColumn, MarkDownColumn>const is_nothrow_constructible<MarkDownColumn, MarkDownColumn> &is_nothrow_constructible<pair<double, double>, pair<double, double>>is_nothrow_constructible<pair<double, double>, pair<double, double>> &is_nothrow_constructible<pair<double, double>, pair<double, double>> &&const is_nothrow_constructible<pair<double, double>, pair<double, double>>const is_nothrow_constructible<pair<double, double>, pair<double, double>> &__is_referenceable<BigO *>__is_referenceable<BigO *> &__is_referenceable<BigO *> &&const __is_referenceable<BigO *>const __is_referenceable<BigO *> &is_nothrow_constructible<BigO *, BigO *const &>is_nothrow_constructible<BigO *, BigO *const &> &is_nothrow_constructible<BigO *, BigO *const &> &&const is_nothrow_constructible<BigO *, BigO *const &>const is_nothrow_constructible<BigO *, BigO *const &> &__is_referenceable<Node *>__is_referenceable<Node *> &__is_referenceable<Node *> &&const __is_referenceable<Node *>const __is_referenceable<Node *> &is_nothrow_constructible<Node *, Node *const &>is_nothrow_constructible<Node *, Node *const &> &is_nothrow_constructible<Node *, Node *const &> &&const is_nothrow_constructible<Node *, Node *const &>const is_nothrow_constructible<Node *, Node *const &> &__is_referenceable<MarkDownColumn *>__is_referenceable<MarkDownColumn *> &__is_referenceable<MarkDownColumn *> &&const __is_referenceable<MarkDownColumn *>const __is_referenceable<MarkDownColumn *> &is_nothrow_constructible<MarkDownColumn *, MarkDownColumn *const &>is_nothrow_constructible<MarkDownColumn *, MarkDownColumn *const &> &is_nothrow_constructible<MarkDownColumn *, MarkDownColumn *const &> &&const is_nothrow_constructible<MarkDownColumn *, MarkDownColumn *const &>const is_nothrow_constructible<MarkDownColumn *, MarkDownColumn *const &> &__is_referenceable<pair<double, double> *>__is_referenceable<pair<double, double> *> &__is_referenceable<pair<double, double> *> &&const __is_referenceable<pair<double, double> *>const __is_referenceable<pair<double, double> *> &is_nothrow_constructible<pair<double, double> *, pair<double, double> *const &>is_nothrow_constructible<pair<double, double> *, pair<double, double> *const &> &is_nothrow_constructible<pair<double, double> *, pair<double, double> *const &> &&const is_nothrow_constructible<pair<double, double> *, pair<double, double> *const &>const is_nothrow_constructible<pair<double, double> *, pair<double, double> *const &> &is_assignable<double &, double &&>is_assignable<double &, double &&> &is_assignable<double &, double &&> &&const is_assignable<double &, double &&>const is_assignable<double &, double &&> &is_nothrow_move_assignable<BigO>is_nothrow_move_assignable<BigO> &is_nothrow_move_assignable<BigO> &&const is_nothrow_move_assignable<BigO>const is_nothrow_move_assignable<BigO> &is_nothrow_move_constructible<BigO>is_nothrow_move_constructible<BigO> &is_nothrow_move_constructible<BigO> &&const is_nothrow_move_constructible<BigO>const is_nothrow_move_constructible<BigO> &is_nothrow_move_assignable<double>is_nothrow_move_assignable<double> &is_nothrow_move_assignable<double> &&const is_nothrow_move_assignable<double>const is_nothrow_move_assignable<double> &is_nothrow_move_constructible<double>is_nothrow_move_constructible<double> &is_nothrow_move_constructible<double> &&const is_nothrow_move_constructible<double>const is_nothrow_move_constructible<double> &remove_reference<Node &>remove_reference<Node &> &remove_reference<Node &> &&const remove_reference<Node &>const remove_reference<Node &> &remove_reference<MarkDownColumn &>remove_reference<MarkDownColumn &> &remove_reference<MarkDownColumn &> &&const remove_reference<MarkDownColumn &>const remove_reference<MarkDownColumn &> &remove_reference<pair<double, double> &>remove_reference<pair<double, double> &> &remove_reference<pair<double, double> &> &&const remove_reference<pair<double, double> &>const remove_reference<pair<double, double> &> &conditional<true, is_nothrow_move_assignable<double>, is_nothrow_move_constructible<double>>conditional<true, is_nothrow_move_assignable<double>, is_nothrow_move_constructible<double>> &conditional<true, is_nothrow_move_assignable<double>, is_nothrow_move_constructible<double>> &&const conditional<true, is_nothrow_move_assignable<double>, is_nothrow_move_constructible<double>>const conditional<true, is_nothrow_move_assignable<double>, is_nothrow_move_constructible<double>> &__is_nothrow_move_constructible_impl<double, true>__is_nothrow_move_constructible_impl<double, true> &__is_nothrow_move_constructible_impl<double, true> &&const __is_nothrow_move_constructible_impl<double, true>const __is_nothrow_move_constructible_impl<double, true> &__is_nt_move_assignable_impl<double, true>__is_nt_move_assignable_impl<double, true> &__is_nt_move_assignable_impl<double, true> &&const __is_nt_move_assignable_impl<double, true>const __is_nt_move_assignable_impl<double, true> &conditional<true, is_nothrow_move_assignable<BigO>, is_nothrow_move_constructible<BigO>>conditional<true, is_nothrow_move_assignable<BigO>, is_nothrow_move_constructible<BigO>> &conditional<true, is_nothrow_move_assignable<BigO>, is_nothrow_move_constructible<BigO>> &&const conditional<true, is_nothrow_move_assignable<BigO>, is_nothrow_move_constructible<BigO>>const conditional<true, is_nothrow_move_assignable<BigO>, is_nothrow_move_constructible<BigO>> &__is_nothrow_move_constructible_impl<BigO, true>__is_nothrow_move_constructible_impl<BigO, true> &__is_nothrow_move_constructible_impl<BigO, true> &&const __is_nothrow_move_constructible_impl<BigO, true>const __is_nothrow_move_constructible_impl<BigO, true> &__is_nt_move_assignable_impl<BigO, true>__is_nt_move_assignable_impl<BigO, true> &__is_nt_move_assignable_impl<BigO, true> &&const __is_nt_move_assignable_impl<BigO, true>const __is_nt_move_assignable_impl<BigO, true> &remove_reference<pair<double, double>>remove_reference<pair<double, double>> &remove_reference<pair<double, double>> &&const remove_reference<pair<double, double>>const remove_reference<pair<double, double>> &remove_reference<MarkDownColumn>remove_reference<MarkDownColumn> &remove_reference<MarkDownColumn> &&const remove_reference<MarkDownColumn>const remove_reference<MarkDownColumn> &remove_reference<BigO>remove_reference<BigO> &remove_reference<BigO> &&const remove_reference<BigO>const remove_reference<BigO> &is_nothrow_assignable<BigO &, BigO &&>is_nothrow_assignable<BigO &, BigO &&> &is_nothrow_assignable<BigO &, BigO &&> &&const is_nothrow_assignable<BigO &, BigO &&>const is_nothrow_assignable<BigO &, BigO &&> &is_nothrow_constructible<BigO, BigO &&>is_nothrow_constructible<BigO, BigO &&> &is_nothrow_constructible<BigO, BigO &&> &&const is_nothrow_constructible<BigO, BigO &&>const is_nothrow_constructible<BigO, BigO &&> &is_nothrow_assignable<double &, double &&>is_nothrow_assignable<double &, double &&> &is_nothrow_assignable<double &, double &&> &&const is_nothrow_assignable<double &, double &&>const is_nothrow_assignable<double &, double &&> &is_nothrow_constructible<double, double &&>is_nothrow_constructible<double, double &&> &is_nothrow_constructible<double, double &&> &&const is_nothrow_constructible<double, double &&>const is_nothrow_constructible<double, double &&> &__and_<is_assignable<double &, double &&>, __is_nt_assignable_impl<double &, double &&>>__and_<is_assignable<double &, double &&>, __is_nt_assignable_impl<double &, double &&>> &__and_<is_assignable<double &, double &&>, __is_nt_assignable_impl<double &, double &&>> &&const __and_<is_assignable<double &, double &&>, __is_nt_assignable_impl<double &, double &&>>const __and_<is_assignable<double &, double &&>, __is_nt_assignable_impl<double &, double &&>> &__and_<is_assignable<BigO &, BigO &&>, __is_nt_assignable_impl<BigO &, BigO &&>>__and_<is_assignable<BigO &, BigO &&>, __is_nt_assignable_impl<BigO &, BigO &&>> &__and_<is_assignable<BigO &, BigO &&>, __is_nt_assignable_impl<BigO &, BigO &&>> &&const __and_<is_assignable<BigO &, BigO &&>, __is_nt_assignable_impl<BigO &, BigO &&>>const __and_<is_assignable<BigO &, BigO &&>, __is_nt_assignable_impl<BigO &, BigO &&>> &__is_nt_assignable_impl<BigO &, BigO &&>__is_nt_assignable_impl<BigO &, BigO &&> &__is_nt_assignable_impl<BigO &, BigO &&> &&const __is_nt_assignable_impl<BigO &, BigO &&>const __is_nt_assignable_impl<BigO &, BigO &&> &is_assignable<BigO &, BigO &&>is_assignable<BigO &, BigO &&> &is_assignable<BigO &, BigO &&> &&const is_assignable<BigO &, BigO &&>const is_assignable<BigO &, BigO &&> &__is_nt_assignable_impl<double &, double &&>__is_nt_assignable_impl<double &, double &&> &__is_nt_assignable_impl<double &, double &&> &&const __is_nt_assignable_impl<double &, double &&>const __is_nt_assignable_impl<double &, double &&> &conditional<true, __is_nt_assignable_impl<double &, double &&>, is_assignable<double &, double &&>>conditional<true, __is_nt_assignable_impl<double &, double &&>, is_assignable<double &, double &&>> &conditional<true, __is_nt_assignable_impl<double &, double &&>, is_assignable<double &, double &&>> &&const conditional<true, __is_nt_assignable_impl<double &, double &&>, is_assignable<double &, double &&>>const conditional<true, __is_nt_assignable_impl<double &, double &&>, is_assignable<double &, double &&>> &conditional<true, __is_nt_assignable_impl<BigO &, BigO &&>, is_assignable<BigO &, BigO &&>>conditional<true, __is_nt_assignable_impl<BigO &, BigO &&>, is_assignable<BigO &, BigO &&>> &conditional<true, __is_nt_assignable_impl<BigO &, BigO &&>, is_assignable<BigO &, BigO &&>> &&const conditional<true, __is_nt_assignable_impl<BigO &, BigO &&>, is_assignable<BigO &, BigO &&>>const conditional<true, __is_nt_assignable_impl<BigO &, BigO &&>, is_assignable<BigO &, BigO &&>> &/home/tanteikg/QCVE/sources/bitcoin/src/net.h/home/tanteikg/QCVE/sources/bitcoin/src/node/connection_types.h/home/tanteikg/QCVE/sources/bitcoin/src/i2p.h/home/tanteikg/QCVE/sources/bitcoin/src/net_permissions.h/usr/include/c++/9/queue/usr/include/c++/9/bits/stl_queue.h/home/tanteikg/QCVE/sources/bitcoin/src/test/util/net.h/home/tanteikg/QCVE/sources/bitcoin/src/node/eviction.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/peer_eviction.cpp<test/util/net.h><net.h>CandidatesEvictionProtection3Networks250Candidateslambda [] type at line 167651, col. 9const lambda [] type at line 167651, col. 9const lambda [] type at line 167651, col. 9 &lambda [] type at line 167651, col. 9 &lambda [] type at line 167651, col. 9 &&NodeEvictionCandidate &operator void (*)(NodeEvictionCandidate &)const lambda [] type at line 167651, col. 9 *lambda [] type at line 167651, col. 9 *EvictionProtection3Networks100Candidateslambda [] type at line 167633, col. 9const lambda [] type at line 167633, col. 9const lambda [] type at line 167633, col. 9 &lambda [] type at line 167633, col. 9 &lambda [] type at line 167633, col. 9 &&const lambda [] type at line 167633, col. 9 *lambda [] type at line 167633, col. 9 *EvictionProtection3Networks050Candidateslambda [] type at line 167615, col. 9const lambda [] type at line 167615, col. 9const lambda [] type at line 167615, col. 9 &lambda [] type at line 167615, col. 9 &lambda [] type at line 167615, col. 9 &&const lambda [] type at line 167615, col. 9 *lambda [] type at line 167615, col. 9 *EvictionProtection2Networks250Candidateslambda [] type at line 167597, col. 9const lambda [] type at line 167597, col. 9const lambda [] type at line 167597, col. 9 &lambda [] type at line 167597, col. 9 &lambda [] type at line 167597, col. 9 &&const lambda [] type at line 167597, col. 9 *lambda [] type at line 167597, col. 9 *EvictionProtection1Networks250Candidateslambda [] type at line 167581, col. 9const lambda [] type at line 167581, col. 9const lambda [] type at line 167581, col. 9 &lambda [] type at line 167581, col. 9 &lambda [] type at line 167581, col. 9 &&const lambda [] type at line 167581, col. 9 *lambda [] type at line 167581, col. 9 *EvictionProtection0Networks250Candidateslambda [] type at line 167570, col. 9const lambda [] type at line 167570, col. 9const lambda [] type at line 167570, col. 9 &lambda [] type at line 167570, col. 9 &lambda [] type at line 167570, col. 9 &&const lambda [] type at line 167570, col. 9 *lambda [] type at line 167570, col. 9 *EvictionProtectionCommonrandom_contextcandidatesCandidates &vector<NodeEvictionCandidate, allocator<NodeEvictionCandidate>> &const __normal_iterator<NodeEvictionCandidate *, vector<NodeEvictionCandidate, allocator<NodeEvictionCandidate>>>const __normal_iterator<NodeEvictionCandidate *, vector<NodeEvictionCandidate, allocator<NodeEvictionCandidate>>> &__normal_iterator<NodeEvictionCandidate *, vector<NodeEvictionCandidate, allocator<NodeEvictionCandidate>>> &lambda [] type at line 167556, col. 15const lambda [] type at line 167556, col. 15const lambda [] type at line 167556, col. 15 &lambda [] type at line 167556, col. 15 &lambda [] type at line 167556, col. 15 &&const lambda [] type at line 167556, col. 15 *lambda [] type at line 167556, col. 15 *const vector<NodeEvictionCandidate, allocator<NodeEvictionCandidate>>const vector<NodeEvictionCandidate, allocator<NodeEvictionCandidate>> &bench_155EvictionProtection3Networks250CandidatesPASTE2(__LINE__, EvictionProtection3Networks250Candidates)155EvictionProtection3Networks250Candidatesbench_154EvictionProtection3Networks100CandidatesPASTE2(__LINE__, EvictionProtection3Networks100Candidates)154EvictionProtection3Networks100Candidatesbench_153EvictionProtection3Networks050CandidatesPASTE2(__LINE__, EvictionProtection3Networks050Candidates)153EvictionProtection3Networks050Candidatesbench_150EvictionProtection2Networks250CandidatesPASTE2(__LINE__, EvictionProtection2Networks250Candidates)150EvictionProtection2Networks250Candidatesbench_147EvictionProtection1Networks250CandidatesPASTE2(__LINE__, EvictionProtection1Networks250Candidates)147EvictionProtection1Networks250Candidatesbench_144EvictionProtection0Networks250CandidatesPASTE2(__LINE__, EvictionProtection0Networks250Candidates)144EvictionProtection0Networks250Candidates// 3 disadvantaged networks (I2P/localhost/Tor) with 50/100/250 eviction candidates.// 2 disadvantaged networks (I2P, Tor) with 250 eviction candidates.// 1 disadvantaged network (Tor) with 250 eviction candidates.// No disadvantaged networks, with 250 eviction candidates.// - 250 candidates is the number of peers reported by operators of busy nodes// - 100 candidates approximates an average node with default settings// -  50 candidates simulates a possible use of -maxconnections// Candidate numbers used for the benchmarks:// 50 Tor// 10 I2P// 20 localhost/*num_candidates=*/// 16 Tor//  5 localhost//  4 Tor// 17 I2P//  2 localhost// 80 I2P// 70 Tor// 110 Tor// creating a copy has an overhead of about 3%, so it does not influence the benchmark results much.num_candidatescandidate_setup_fn_Base_manager<lambda [] type at line 167651, col. 9>_Base_manager<lambda [] type at line 167651, col. 9> &_Base_manager<lambda [] type at line 167651, col. 9> &&const _Base_manager<lambda [] type at line 167651, col. 9>const _Base_manager<lambda [] type at line 167651, col. 9> &_Base_manager<lambda [] type at line 167633, col. 9>_Base_manager<lambda [] type at line 167633, col. 9> &_Base_manager<lambda [] type at line 167633, col. 9> &&const _Base_manager<lambda [] type at line 167633, col. 9>const _Base_manager<lambda [] type at line 167633, col. 9> &_Base_manager<lambda [] type at line 167615, col. 9>_Base_manager<lambda [] type at line 167615, col. 9> &_Base_manager<lambda [] type at line 167615, col. 9> &&const _Base_manager<lambda [] type at line 167615, col. 9>const _Base_manager<lambda [] type at line 167615, col. 9> &_Base_manager<lambda [] type at line 167597, col. 9>_Base_manager<lambda [] type at line 167597, col. 9> &_Base_manager<lambda [] type at line 167597, col. 9> &&const _Base_manager<lambda [] type at line 167597, col. 9>const _Base_manager<lambda [] type at line 167597, col. 9> &_Base_manager<lambda [] type at line 167581, col. 9>_Base_manager<lambda [] type at line 167581, col. 9> &_Base_manager<lambda [] type at line 167581, col. 9> &&const _Base_manager<lambda [] type at line 167581, col. 9>const _Base_manager<lambda [] type at line 167581, col. 9> &_Base_manager<lambda [] type at line 167570, col. 9>_Base_manager<lambda [] type at line 167570, col. 9> &_Base_manager<lambda [] type at line 167570, col. 9> &&const _Base_manager<lambda [] type at line 167570, col. 9>const _Base_manager<lambda [] type at line 167570, col. 9> &lambda [] type at line 167570, col. 9 *&lambda [] type at line 167570, col. 9 **lambda [] type at line 167581, col. 9 *&lambda [] type at line 167581, col. 9 **lambda [] type at line 167597, col. 9 *&lambda [] type at line 167597, col. 9 **lambda [] type at line 167615, col. 9 *&lambda [] type at line 167615, col. 9 **lambda [] type at line 167633, col. 9 *&lambda [] type at line 167633, col. 9 **lambda [] type at line 167651, col. 9 *&lambda [] type at line 167651, col. 9 **_Function_handler<..(..), lambda [] type at line 167651, col. 9>_Function_handler<..(..), lambda [] type at line 167651, col. 9> &_Function_handler<..(..), lambda [] type at line 167651, col. 9> &&const _Function_handler<..(..), lambda [] type at line 167651, col. 9>const _Function_handler<..(..), lambda [] type at line 167651, col. 9> &_Function_handler<..(..), lambda [] type at line 167633, col. 9>_Function_handler<..(..), lambda [] type at line 167633, col. 9> &_Function_handler<..(..), lambda [] type at line 167633, col. 9> &&const _Function_handler<..(..), lambda [] type at line 167633, col. 9>const _Function_handler<..(..), lambda [] type at line 167633, col. 9> &_Function_handler<..(..), lambda [] type at line 167615, col. 9>_Function_handler<..(..), lambda [] type at line 167615, col. 9> &_Function_handler<..(..), lambda [] type at line 167615, col. 9> &&const _Function_handler<..(..), lambda [] type at line 167615, col. 9>const _Function_handler<..(..), lambda [] type at line 167615, col. 9> &_Function_handler<..(..), lambda [] type at line 167597, col. 9>_Function_handler<..(..), lambda [] type at line 167597, col. 9> &_Function_handler<..(..), lambda [] type at line 167597, col. 9> &&const _Function_handler<..(..), lambda [] type at line 167597, col. 9>const _Function_handler<..(..), lambda [] type at line 167597, col. 9> &_Function_handler<..(..), lambda [] type at line 167581, col. 9>_Function_handler<..(..), lambda [] type at line 167581, col. 9> &_Function_handler<..(..), lambda [] type at line 167581, col. 9> &&const _Function_handler<..(..), lambda [] type at line 167581, col. 9>const _Function_handler<..(..), lambda [] type at line 167581, col. 9> &_Function_handler<..(..), lambda [] type at line 167570, col. 9>_Function_handler<..(..), lambda [] type at line 167570, col. 9> &_Function_handler<..(..), lambda [] type at line 167570, col. 9> &&const _Function_handler<..(..), lambda [] type at line 167570, col. 9>const _Function_handler<..(..), lambda [] type at line 167570, col. 9> &_Callable<lambda [] type at line 167651, col. 9, __invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>>_Callable<lambda [] type at line 167651, col. 9, __invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167651, col. 9, __invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>> &&const _Callable<lambda [] type at line 167651, col. 9, __invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>>const _Callable<lambda [] type at line 167651, col. 9, __invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167633, col. 9, __invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>>_Callable<lambda [] type at line 167633, col. 9, __invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167633, col. 9, __invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>> &&const _Callable<lambda [] type at line 167633, col. 9, __invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>>const _Callable<lambda [] type at line 167633, col. 9, __invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167615, col. 9, __invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>>_Callable<lambda [] type at line 167615, col. 9, __invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167615, col. 9, __invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>> &&const _Callable<lambda [] type at line 167615, col. 9, __invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>>const _Callable<lambda [] type at line 167615, col. 9, __invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167597, col. 9, __invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>>_Callable<lambda [] type at line 167597, col. 9, __invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167597, col. 9, __invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>> &&const _Callable<lambda [] type at line 167597, col. 9, __invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>>const _Callable<lambda [] type at line 167597, col. 9, __invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167581, col. 9, __invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>>_Callable<lambda [] type at line 167581, col. 9, __invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167581, col. 9, __invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>> &&const _Callable<lambda [] type at line 167581, col. 9, __invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>>const _Callable<lambda [] type at line 167581, col. 9, __invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167570, col. 9, __invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>>_Callable<lambda [] type at line 167570, col. 9, __invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>> &_Callable<lambda [] type at line 167570, col. 9, __invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>> &&const _Callable<lambda [] type at line 167570, col. 9, __invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>>const _Callable<lambda [] type at line 167570, col. 9, __invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>> &__invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>__invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &> &&const __invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>const __invoke_result<lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>__invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &> &&const __invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>const __invoke_result<lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>__invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &> &&const __invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>const __invoke_result<lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>__invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &> &&const __invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>const __invoke_result<lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>__invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &> &&const __invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>const __invoke_result<lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>__invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &> &__invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &> &&const __invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>const __invoke_result<lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &> &remove_reference<lambda [] type at line 167570, col. 9 &>remove_reference<lambda [] type at line 167570, col. 9 &> &remove_reference<lambda [] type at line 167570, col. 9 &> &&const remove_reference<lambda [] type at line 167570, col. 9 &>const remove_reference<lambda [] type at line 167570, col. 9 &> &remove_reference<lambda [] type at line 167581, col. 9 &>remove_reference<lambda [] type at line 167581, col. 9 &> &remove_reference<lambda [] type at line 167581, col. 9 &> &&const remove_reference<lambda [] type at line 167581, col. 9 &>const remove_reference<lambda [] type at line 167581, col. 9 &> &remove_reference<lambda [] type at line 167597, col. 9 &>remove_reference<lambda [] type at line 167597, col. 9 &> &remove_reference<lambda [] type at line 167597, col. 9 &> &&const remove_reference<lambda [] type at line 167597, col. 9 &>const remove_reference<lambda [] type at line 167597, col. 9 &> &remove_reference<lambda [] type at line 167615, col. 9 &>remove_reference<lambda [] type at line 167615, col. 9 &> &remove_reference<lambda [] type at line 167615, col. 9 &> &&const remove_reference<lambda [] type at line 167615, col. 9 &>const remove_reference<lambda [] type at line 167615, col. 9 &> &remove_reference<lambda [] type at line 167633, col. 9 &>remove_reference<lambda [] type at line 167633, col. 9 &> &remove_reference<lambda [] type at line 167633, col. 9 &> &&const remove_reference<lambda [] type at line 167633, col. 9 &>const remove_reference<lambda [] type at line 167633, col. 9 &> &remove_reference<lambda [] type at line 167651, col. 9 &>remove_reference<lambda [] type at line 167651, col. 9 &> &remove_reference<lambda [] type at line 167651, col. 9 &> &&const remove_reference<lambda [] type at line 167651, col. 9 &>const remove_reference<lambda [] type at line 167651, col. 9 &> &__result_of_impl<false, false, lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>__result_of_impl<false, false, lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &> &&const __result_of_impl<false, false, lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &>const __result_of_impl<false, false, lambda [] type at line 167570, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>__result_of_impl<false, false, lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &> &&const __result_of_impl<false, false, lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &>const __result_of_impl<false, false, lambda [] type at line 167581, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>__result_of_impl<false, false, lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &> &&const __result_of_impl<false, false, lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &>const __result_of_impl<false, false, lambda [] type at line 167597, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>__result_of_impl<false, false, lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &> &&const __result_of_impl<false, false, lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &>const __result_of_impl<false, false, lambda [] type at line 167615, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>__result_of_impl<false, false, lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &> &&const __result_of_impl<false, false, lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &>const __result_of_impl<false, false, lambda [] type at line 167633, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>__result_of_impl<false, false, lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &> &__result_of_impl<false, false, lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &> &&const __result_of_impl<false, false, lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &>const __result_of_impl<false, false, lambda [] type at line 167651, col. 9 &, NodeEvictionCandidate &> &conditional<false, is_move_assignable<NodeEvictionCandidate>, is_copy_assignable<NodeEvictionCandidate>>conditional<false, is_move_assignable<NodeEvictionCandidate>, is_copy_assignable<NodeEvictionCandidate>> &conditional<false, is_move_assignable<NodeEvictionCandidate>, is_copy_assignable<NodeEvictionCandidate>> &&const conditional<false, is_move_assignable<NodeEvictionCandidate>, is_copy_assignable<NodeEvictionCandidate>>const conditional<false, is_move_assignable<NodeEvictionCandidate>, is_copy_assignable<NodeEvictionCandidate>> &is_member_function_pointer<lambda [] type at line 167651, col. 9>is_member_function_pointer<lambda [] type at line 167651, col. 9> &is_member_function_pointer<lambda [] type at line 167651, col. 9> &&const is_member_function_pointer<lambda [] type at line 167651, col. 9>const is_member_function_pointer<lambda [] type at line 167651, col. 9> &is_member_object_pointer<lambda [] type at line 167651, col. 9>is_member_object_pointer<lambda [] type at line 167651, col. 9> &is_member_object_pointer<lambda [] type at line 167651, col. 9> &&const is_member_object_pointer<lambda [] type at line 167651, col. 9>const is_member_object_pointer<lambda [] type at line 167651, col. 9> &is_member_function_pointer<lambda [] type at line 167633, col. 9>is_member_function_pointer<lambda [] type at line 167633, col. 9> &is_member_function_pointer<lambda [] type at line 167633, col. 9> &&const is_member_function_pointer<lambda [] type at line 167633, col. 9>const is_member_function_pointer<lambda [] type at line 167633, col. 9> &is_member_object_pointer<lambda [] type at line 167633, col. 9>is_member_object_pointer<lambda [] type at line 167633, col. 9> &is_member_object_pointer<lambda [] type at line 167633, col. 9> &&const is_member_object_pointer<lambda [] type at line 167633, col. 9>const is_member_object_pointer<lambda [] type at line 167633, col. 9> &is_member_function_pointer<lambda [] type at line 167615, col. 9>is_member_function_pointer<lambda [] type at line 167615, col. 9> &is_member_function_pointer<lambda [] type at line 167615, col. 9> &&const is_member_function_pointer<lambda [] type at line 167615, col. 9>const is_member_function_pointer<lambda [] type at line 167615, col. 9> &is_member_object_pointer<lambda [] type at line 167615, col. 9>is_member_object_pointer<lambda [] type at line 167615, col. 9> &is_member_object_pointer<lambda [] type at line 167615, col. 9> &&const is_member_object_pointer<lambda [] type at line 167615, col. 9>const is_member_object_pointer<lambda [] type at line 167615, col. 9> &is_member_function_pointer<lambda [] type at line 167597, col. 9>is_member_function_pointer<lambda [] type at line 167597, col. 9> &is_member_function_pointer<lambda [] type at line 167597, col. 9> &&const is_member_function_pointer<lambda [] type at line 167597, col. 9>const is_member_function_pointer<lambda [] type at line 167597, col. 9> &is_member_object_pointer<lambda [] type at line 167597, col. 9>is_member_object_pointer<lambda [] type at line 167597, col. 9> &is_member_object_pointer<lambda [] type at line 167597, col. 9> &&const is_member_object_pointer<lambda [] type at line 167597, col. 9>const is_member_object_pointer<lambda [] type at line 167597, col. 9> &is_member_function_pointer<lambda [] type at line 167581, col. 9>is_member_function_pointer<lambda [] type at line 167581, col. 9> &is_member_function_pointer<lambda [] type at line 167581, col. 9> &&const is_member_function_pointer<lambda [] type at line 167581, col. 9>const is_member_function_pointer<lambda [] type at line 167581, col. 9> &is_member_object_pointer<lambda [] type at line 167581, col. 9>is_member_object_pointer<lambda [] type at line 167581, col. 9> &is_member_object_pointer<lambda [] type at line 167581, col. 9> &&const is_member_object_pointer<lambda [] type at line 167581, col. 9>const is_member_object_pointer<lambda [] type at line 167581, col. 9> &is_member_function_pointer<lambda [] type at line 167570, col. 9>is_member_function_pointer<lambda [] type at line 167570, col. 9> &is_member_function_pointer<lambda [] type at line 167570, col. 9> &&const is_member_function_pointer<lambda [] type at line 167570, col. 9>const is_member_function_pointer<lambda [] type at line 167570, col. 9> &is_member_object_pointer<lambda [] type at line 167570, col. 9>is_member_object_pointer<lambda [] type at line 167570, col. 9> &is_member_object_pointer<lambda [] type at line 167570, col. 9> &&const is_member_object_pointer<lambda [] type at line 167570, col. 9>const is_member_object_pointer<lambda [] type at line 167570, col. 9> &is_move_assignable<NodeEvictionCandidate>/home/tanteikg/QCVE/sources/bitcoin/src/bench/poly1305.cppPOLY1305_1MBPOLY1305_256BYTESPOLY1305_64BYTESPOLY1305POLY1305_KEYLENlambda [] type at line 118821, col. 45const lambda [] type at line 118821, col. 45const lambda [] type at line 118821, col. 45 &lambda [] type at line 118821, col. 45 &lambda [] type at line 118821, col. 45 &&const lambda [] type at line 118821, col. 45 *lambda [] type at line 118821, col. 45 *bench_41POLY1305_1MBPASTE2(__LINE__, POLY1305_1MB)41POLY1305_1MBbench_40POLY1305_256BYTESPASTE2(__LINE__, POLY1305_256BYTES)40POLY1305_256BYTESbench_39POLY1305_64BYTESPASTE2(__LINE__, POLY1305_64BYTES)39POLY1305_64BYTES_Hashtable_ebo_helper<_Nm, _Tp, false> *_List_iterator<byte *> &const _List_iterator<_Tp>const _List_iterator<_Tp> *const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &MAX_BLOCK_SIZE_BYTESALIGN_BYTESResourceType *PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> *resourceconst PoolAllocator<T, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>const PoolAllocator<T, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> *PoolAllocator<T, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> *DeallocateAllocateconst PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>const PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &PoolAllocatorPoolAllocator<T, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &const PoolAllocator<T, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &ChunkSizeBytesNumAllocatedChunksnum_alignmentsListNode *ListNode *&round_bytesm_nextPoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES> &&~PoolResourcelist<byte *, allocator<byte *>> &chunkconst _List_iterator<byte *>PoolResourcem_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES./support/allocators/pool.hAllocateChunkremaining_available_bytesstoragebyte[]PlacementAddToListIsFreeListUsableNumElemAlignBytesListNodePoolAllocator<T, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>rebind<U>PoolResourceTesterPoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>ELEM_ALIGN_BYTESm_resourcem_available_memory_endm_available_memory_itm_free_listsm_allocated_chunksm_chunk_size_bytesMAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.Units of size ELEM_SIZE_ALIGN need to be able to store a ListNodeELEM_ALIGN_BYTES must be a power of twoMake sure we don't need to manually call a destructorALIGN_BYTES must be a power of twoALIGN_BYTES must be nonzeroBITCOIN_SUPPORT_ALLOCATORS_POOL_H// BITCOIN_SUPPORT_ALLOCATORS_POOL_H/**
     * Forwards each call to the resource.
     *//**
     * The rebind struct here is mandatory because we use non type template arguments for
     * PoolAllocator. See https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2
     *//**
     * Not explicit so we can easily construct it with the correct resource
     *//**
 * Forwards all allocations/deallocations to the PoolResource.
 *//**
     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.
     *//**
     * Number of allocated chunks
     */// Can't use the pool => forward deallocation to ::operator delete().// into the memory since we can be sure the alignment is correct.// put the memory block into the linked list. We can placement construct the FreeList/**
     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.
     */// Can't use the pool => use operator new()// Make sure we use the right amount of bytes for that freelist (might be rounded up),// slow path, only happens when a new chunk needs to be allocated// freelist is empty: get one allocation from allocated chunk memory.// uninitialized memory.// to the unlinked memory. Since FreeList is trivially destructible we can just treat it as// we've already got data in the pool's freelist, unlink one element and return the pointer/**
     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation
     * is forwarded to ::operator new().
     *//**
     * Deallocates all memory allocated associated with the memory resource.
     *//**
     * Disable copy & move semantics, these are not supported for the resource.
     *//**
     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.
     *//**
     * Construct a new PoolResource object which allocates the first chunk.
     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.
     *//**
     * Access to internals for testing purpose only
     */// if there is still any available memory left, put it into the freelist./**
     * Allocate one full memory chunk which will be used to carve out allocations.
     * Also puts any leftover bytes into the freelist.
     *
     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist
     *//**
     * Replaces node with placement constructed ListNode that points to the previous node
     *//**
     * True when it is possible to make use of the freelist
     *//**
     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index
     * into m_free_lists. Round up for the special case when bytes==0.
     *//**
     * Points to the end of available memory for carving out allocations.
     *
     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`
     * whenever it is accessed, but `m_available_memory_end` caches this for clarity and efficiency.
     *//**
     * Points to the beginning of available memory for carving out allocations.
     *//**
     * Single linked lists of all data that came from deallocating.
     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.
     *//**
     * Contains all allocated pools of memory, used to free the data in the destructor.
     *//**
     * Size in bytes to allocate per chunk
     *//**
     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).
     *//**
     * In-place linked list of the allocations, used for the freelist.
     *//**
 * A memory resource similar to std::pmr::unsynchronized_pool_resource, but
 * optimized for node-based containers. It has the following properties:
 *
 * * Owns the allocated memory and frees it on destruction, even when deallocate
 *   has not been called on the allocated blocks.
 *
 * * Consists of a number of pools, each one for a different block size.
 *   Each pool holds blocks of uniform size in a freelist.
 *
 * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.
 *   This chunk is used to carve out blocks.
 *
 * * Block sizes or alignments that can not be served by the pools are allocated
 *   and deallocated by operator new().
 *
 * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.
 *
 * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger
 *         sizes are requested, allocation falls back to new().
 *
 * @tparam ALIGN_BYTES Required alignment for the allocations.
 *
 * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of
 * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,
 * the members will look like this:
 *
 *     m_free_lists                         m_allocated_chunks
 *                                          -------
 *             blocks                               262144 B             
 *                               -------
 *         1  8 B  8 B                 
 *                               :
 *                                             
 *                        
 *         2 16 B 16 B 16 B        
 *                                                  
 *                                              
 *         .                                                       m_available_memory_end
 *         .                                          m_available_memory_it
 *         . 
 *           
 *           
 *        16 
 *        
 *
 * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]
 * holds the 3 blocks of size 16. The blocks came from the data stored in the
 * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still
 * some memory available for the blocks, and when m_available_memory_it is at the
 * end, a new chunk will be allocated and added to the list.
 *//home/tanteikg/QCVE/sources/bitcoin/src/support/allocators/home/tanteikg/QCVE/sources/bitcoin/src/supportalignmentchunk_size_bytes/home/tanteikg/QCVE/sources/bitcoin/src/bench/pool.cpp<support/allocators/pool.h>lambda [] type at line 124726, col. 56lambda [] type at line 124726, col. 56 &const lambda [] type at line 124726, col. 56const lambda [] type at line 124726, col. 56 &const lambda [] type at line 124726, col. 56 *lambda [] type at line 124726, col. 56 *Map &PoolAllocator_StdUnorderedMapWithPoolResourcepool_resourceequal_to<unsigned long> &PoolResource<48UL, 8UL> *PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL> &unordered_map<unsigned long, unsigned long, hash<unsigned long>, equal_to<unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &unordered_map<unsigned long, unsigned long, hash<unsigned long>, equal_to<unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> *PoolAllocator_StdUnorderedMapunordered_map<unsigned long, unsigned long, hash<unsigned long>, equal_to<unsigned long>, allocator<pair<const unsigned long, unsigned long>>> &unordered_map<unsigned long, unsigned long, hash<unsigned long>, equal_to<unsigned long>, allocator<pair<const unsigned long, unsigned long>>> *batch_sizeBenchFillClearMapbench_50PoolAllocator_StdUnorderedMapWithPoolResourcePASTE2(__LINE__, PoolAllocator_StdUnorderedMapWithPoolResource)50PoolAllocator_StdUnorderedMapWithPoolResourcebench_49PoolAllocator_StdUnorderedMapPASTE2(__LINE__, PoolAllocator_StdUnorderedMap)49PoolAllocator_StdUnorderedMap// make sure the resource supports large enough pools to hold the node. We do this by adding the size of a few pointers to it.// do this at least 10 times so we get reasonable accurate results// make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.PoolResource<48UL, 8UL>unordered_map<unsigned long, unsigned long, hash<unsigned long>, equal_to<unsigned long>, allocator<pair<const unsigned long, unsigned long>>>unordered_multimap<unsigned long, unsigned long, _H2, _P2, allocator<pair<const unsigned long, unsigned long>>> &&unordered_multimap<unsigned long, unsigned long, _H2, _P2, allocator<pair<const unsigned long, unsigned long>>> &unordered_map<unsigned long, unsigned long, _H2, _P2, allocator<pair<const unsigned long, unsigned long>>> &&unordered_map<unsigned long, unsigned long, _H2, _P2, allocator<pair<const unsigned long, unsigned long>>> &allocator<pair<const unsigned long, unsigned long>> &PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>const PoolAllocator<U, 48UL, 8UL>const PoolAllocator<U, 48UL, 8UL> &PoolAllocator<U, 48UL, 8UL> &ResourceTypeunordered_map<unsigned long, unsigned long, hash<unsigned long>, equal_to<unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>unordered_multimap<unsigned long, unsigned long, _H2, _P2, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&unordered_multimap<unsigned long, unsigned long, _H2, _P2, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &unordered_map<unsigned long, unsigned long, _H2, _P2, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&unordered_map<unsigned long, unsigned long, _H2, _P2, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &_Insert_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>_Insert_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &&const _Insert_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Insert_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>_Insert_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &&const _Insert_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Insert_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>new_allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>new_allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>> &const new_allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>const new_allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>> &allocator_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>allocator_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>> &allocator_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>> &&const allocator_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>const allocator_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>> &allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>> &allocator_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>allocator_traitsallocator_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &allocator_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &&const allocator_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const allocator_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL> &_Ptr<_Func, _Tp, __void_t<_Func<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>>>__rebind<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, _Tp, void>__rebind<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Tp, void>__rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node_base *, void>__rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node_base *, void> &__rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node_base *, void> &&const __rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node_base *, void>const __rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node_base *, void> &__rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, pair<const unsigned long, unsigned long>, void>__rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, pair<const unsigned long, unsigned long>, void> &__rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, pair<const unsigned long, unsigned long>, void> &&const __rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, pair<const unsigned long, unsigned long>, void>const __rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, pair<const unsigned long, unsigned long>, void> &__rebind<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Tp, void>__rebind<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void>__rebind<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &__rebind<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &&const __rebind<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void>const __rebind<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &__rebind<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node_base *, void>__rebind<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node_base *, void> &__rebind<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node_base *, void> &&const __rebind<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node_base *, void>const __rebind<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node_base *, void> &__rebind<allocator<pair<const unsigned long, unsigned long>>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void>__rebind<allocator<pair<const unsigned long, unsigned long>>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &__rebind<allocator<pair<const unsigned long, unsigned long>>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &&const __rebind<allocator<pair<const unsigned long, unsigned long>>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void>const __rebind<allocator<pair<const unsigned long, unsigned long>>, _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &_Hashtable<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *_Hashtable_alloc<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>> *_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, true> *lambda [] type at line 124726, col. 56 &&_Hashtable<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *std::align_val_t{ELEM_ALIGN_BYTES}PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL> *_Hash_node<pair<const unsigned long, unsigned long>, false> *const _Hash_code_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false>const _Hash_code_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false> *_Hash_code_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false> *const pair<const unsigned long, unsigned long>const pair<const unsigned long, unsigned long> &pair<const unsigned long, unsigned long> &const _Hash_node_value_base<pair<const unsigned long, unsigned long>>const _Hash_node_value_base<pair<const unsigned long, unsigned long>> *_Hash_node_value_base<pair<const unsigned long, unsigned long>> *const PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>const PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL> &alignof(ListNode)(alignof(ListNode), ALIGN_BYTES);initializer_list<pair<const unsigned long, unsigned long>>initializer_list<pair<const unsigned long, unsigned long>> &initializer_list<pair<const unsigned long, unsigned long>> &&const initializer_list<pair<const unsigned long, unsigned long>>const initializer_list<pair<const unsigned long, unsigned long>> &_Hash_node_value_base<pair<const unsigned long, unsigned long>>_Hash_node_value_base<pair<const unsigned long, unsigned long>> &_Hash_node_value_base<pair<const unsigned long, unsigned long>> &&const _Hash_node_value_base<pair<const unsigned long, unsigned long>> &_Hash_code_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false>_Hash_code_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false> &_Hash_code_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false> &&const _Hash_code_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, true>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, true> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, true> &&const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, true>const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, true> &_Hashtable_alloc<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>_Hashtable_alloc<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>> &const _Hashtable_alloc<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>const _Hashtable_alloc<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>> &__construct_helper<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>>__construct_helper<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>> &__construct_helper<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>> &&const __construct_helper<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>>const __construct_helper<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>> &_Size<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, long, void>_Size<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, long, void> &_Size<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, long, void> &&const _Size<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, long, void>const _Size<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, long, void> &_Diff<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false> *, void>_Diff<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false> *, void> &_Diff<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false> *, void> &&const _Diff<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false> *, void>const _Diff<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false> *, void> &_Ptr<__cv_pointer, const void, void>_Ptr<__cv_pointer, const void, void> &_Ptr<__cv_pointer, const void, void> &&const _Ptr<__cv_pointer, const void, void>const _Ptr<__cv_pointer, const void, void> &_Ptr<__v_pointer, void, void>_Ptr<__v_pointer, void, void> &_Ptr<__v_pointer, void, void> &&const _Ptr<__v_pointer, void, void>const _Ptr<__v_pointer, void, void> &_Ptr<__c_pointer, const _Hash_node<pair<const unsigned long, unsigned long>, false>, void>const _Hash_node<pair<const unsigned long, unsigned long>, false>_Ptr<__c_pointer, const _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &_Ptr<__c_pointer, const _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &&const _Ptr<__c_pointer, const _Hash_node<pair<const unsigned long, unsigned long>, false>, void>const _Ptr<__c_pointer, const _Hash_node<pair<const unsigned long, unsigned long>, false>, void> &const _Hash_node<pair<const unsigned long, unsigned long>, false> *const _Hash_node<pair<const unsigned long, unsigned long>, false> &_Hash_node<pair<const unsigned long, unsigned long>, false> &_Hash_node<pair<const unsigned long, unsigned long>, false>_Hash_node<pair<const unsigned long, unsigned long>, false> &&rebind<_Hash_node<pair<const unsigned long, unsigned long>, false>>rebind<_Hash_node<pair<const unsigned long, unsigned long>, false>> &rebind<_Hash_node<pair<const unsigned long, unsigned long>, false>> &&const rebind<_Hash_node<pair<const unsigned long, unsigned long>, false>>const rebind<_Hash_node<pair<const unsigned long, unsigned long>, false>> &unordered_map<unsigned long, unsigned long, _H2, _P2, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>unordered_multimap<unsigned long, unsigned long, _H2, _P2, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>pair<const unsigned long, unsigned long> *PoolAllocator<U, 48UL, 8UL>PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>PoolAllocator<_Hash_node_base *, 48UL, 8UL>pair<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, bool>unordered_map<unsigned long, unsigned long, _H2, _P2, allocator<pair<const unsigned long, unsigned long>>>unordered_multimap<unsigned long, unsigned long, _H2, _P2, allocator<pair<const unsigned long, unsigned long>>>array<ListNode *, 7UL>array<ListNode *, 7UL> &array<ListNode *, 7UL> &&const array<ListNode *, 7UL>const array<ListNode *, 7UL> &ListNode &ListNode &&const ListNodeconst ListNode &_Hashtable<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const equal_to<unsigned long>const equal_to<unsigned long> &const _Hashtable<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL> *sizeof(T)alignof(T)new_allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>> *const new_allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>> *const pair<const unsigned long, unsigned long> *const _Hashtable_ebo_helper<1, hash<unsigned long>, true>const _Hashtable_ebo_helper<1, hash<unsigned long>, true> &_Hashtable_ebo_helper<1, hash<unsigned long>, true> &const char[159]char[159]PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>::PoolResource(unsigned long) [with unsigned long MAX_BLOCK_SIZE_BYTES = 48UL; unsigned long ALIGN_BYTES = 8UL]_Hashtable_alloc<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> *const _Hashtable<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>> *const _Hashtable<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *_Equality<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Equality<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Equality<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Equality<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Equality<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>_Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &&const _Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>const _Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Map_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Map_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Map_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Map_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Map_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Insert<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>_Insert<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &&const _Insert<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>const _Insert<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Hashtable_alloc<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>_Hashtable_alloc<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &const _Hashtable_alloc<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const _Hashtable_alloc<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &_Equality<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Equality<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Equality<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Equality<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Equality<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>_Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &&const _Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>const _Rehash_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Insert<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>_Insert<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &&const _Insert<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>const _Insert<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Map_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Map_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Map_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Map_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Map_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &ListNode *[7]ListNode **_Node_handle<unsigned long, pair<const unsigned long, unsigned long>, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>_Node_insert_return<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, _Node_handle<unsigned long, pair<const unsigned long, unsigned long>, allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>>rebind<pair<const unsigned long, unsigned long>>rebind<pair<const unsigned long, unsigned long>> &rebind<pair<const unsigned long, unsigned long>> &&const rebind<pair<const unsigned long, unsigned long>>const rebind<pair<const unsigned long, unsigned long>> &_Local_iterator<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Local_const_iterator<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Node_handle<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>_Node_insert_return<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, _Node_handle<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>>_AllocNode<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>_Hashtable_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>_Hashtable_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_Hashtable_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &&const _Hashtable_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>const _Hashtable_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_Node_iterator<pair<const unsigned long, unsigned long>, false, false>_Node_iterator<pair<const unsigned long, unsigned long>, false, false> &_Node_iterator<pair<const unsigned long, unsigned long>, false, false> &&const _Node_iterator<pair<const unsigned long, unsigned long>, false, false>const _Node_iterator<pair<const unsigned long, unsigned long>, false, false> &_Node_const_iterator<pair<const unsigned long, unsigned long>, false, false>_AllocNode<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>pair<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, _Node_iterator<pair<const unsigned long, unsigned long>, false, false>>pair<_Node_const_iterator<pair<const unsigned long, unsigned long>, false, false>, _Node_const_iterator<pair<const unsigned long, unsigned long>, false, false>>__detected_or_tallocator_traits<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>allocator_traits<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &allocator_traits<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&const allocator_traits<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>const allocator_traits<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &_Ptr<_Func, _Tp, __void_t<_Func<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>>>_Local_iterator_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, false>tuple_element<0UL, pair<const unsigned long, unsigned long>>tuple_element<0UL, pair<const unsigned long, unsigned long>> &tuple_element<0UL, pair<const unsigned long, unsigned long>> &&const tuple_element<0UL, pair<const unsigned long, unsigned long>>const tuple_element<0UL, pair<const unsigned long, unsigned long>> &remove_reference<const pair<const unsigned long, unsigned long> &>remove_reference<const pair<const unsigned long, unsigned long> &> &remove_reference<const pair<const unsigned long, unsigned long> &> &&const remove_reference<const pair<const unsigned long, unsigned long> &>const remove_reference<const pair<const unsigned long, unsigned long> &> &__aligned_buffer<pair<const unsigned long, unsigned long>>__aligned_buffer<pair<const unsigned long, unsigned long>> &__aligned_buffer<pair<const unsigned long, unsigned long>> &&const __aligned_buffer<pair<const unsigned long, unsigned long>>const __aligned_buffer<pair<const unsigned long, unsigned long>> &remove_reference<pair<const unsigned long, unsigned long> &>remove_reference<pair<const unsigned long, unsigned long> &> &remove_reference<pair<const unsigned long, unsigned long> &> &&const remove_reference<pair<const unsigned long, unsigned long> &>const remove_reference<pair<const unsigned long, unsigned long> &> &_Map_base<unsigned long, pair<const unsigned long, unsigned long>, allocator<pair<const unsigned long, unsigned long>>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> *_Hashtable_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *tuple<unsigned long &&> &&tuple<unsigned long &&> &_Map_base<unsigned long, pair<const unsigned long, unsigned long>, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> *operator new[]_Size<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, long, void>_Size<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, long, void> &_Size<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, long, void> &&const _Size<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, long, void>const _Size<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, long, void> &_Diff<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, pair<const unsigned long, unsigned long> *, void>_Diff<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, pair<const unsigned long, unsigned long> *, void> &_Diff<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, pair<const unsigned long, unsigned long> *, void> &&const _Diff<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, pair<const unsigned long, unsigned long> *, void>const _Diff<PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>, pair<const unsigned long, unsigned long> *, void> &_Ptr<__c_pointer, const pair<const unsigned long, unsigned long>, void>_Ptr<__c_pointer, const pair<const unsigned long, unsigned long>, void> &_Ptr<__c_pointer, const pair<const unsigned long, unsigned long>, void> &&const _Ptr<__c_pointer, const pair<const unsigned long, unsigned long>, void>const _Ptr<__c_pointer, const pair<const unsigned long, unsigned long>, void> &_Node_iterator_base<pair<const unsigned long, unsigned long>, false>_Node_iterator_base<pair<const unsigned long, unsigned long>, false> &_Node_iterator_base<pair<const unsigned long, unsigned long>, false> &&const _Node_iterator_base<pair<const unsigned long, unsigned long>, false>const _Node_iterator_base<pair<const unsigned long, unsigned long>, false> &reverse_iterator<ListNode **>reverse_iterator<ListNode *const *>ListNode *constListNode *const *__array_traits<ListNode *, 7UL>__array_traits<ListNode *, 7UL> &__array_traits<ListNode *, 7UL> &&const __array_traits<ListNode *, 7UL>const __array_traits<ListNode *, 7UL> &__alloc_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>>__alloc_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>> &__alloc_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>> &&const __alloc_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>>const __alloc_traits<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, _Hash_node<pair<const unsigned long, unsigned long>, false>> &_ReuseOrAllocNode<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>_Hashtable_ebo_helper<0, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, false>_Hashtable_ebo_helper<0, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, false> &_Hashtable_ebo_helper<0, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, false> &&const _Hashtable_ebo_helper<0, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, false>const _Hashtable_ebo_helper<0, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>, false> &__alloc_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node<pair<const unsigned long, unsigned long>, false>>__alloc_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node<pair<const unsigned long, unsigned long>, false>> &__alloc_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node<pair<const unsigned long, unsigned long>, false>> &&const __alloc_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node<pair<const unsigned long, unsigned long>, false>>const __alloc_traits<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>, _Hash_node<pair<const unsigned long, unsigned long>, false>> &_ReuseOrAllocNode<allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>>const __aligned_buffer<pair<const unsigned long, unsigned long>> *__aligned_buffer<pair<const unsigned long, unsigned long>> *array<ListNode *, 7UL> *ListNode *(&)[7]const _Hashtable_base<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *PoolAllocator<_Hash_node_base *, 48UL, 8UL> &const _Node_iterator<pair<const unsigned long, unsigned long>, false, false> *_Node_iterator<pair<const unsigned long, unsigned long>, false, false> *const _Node_iterator_base<pair<const unsigned long, unsigned long>, false> *_Node_iterator_base<pair<const unsigned long, unsigned long>, false> *const allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>>const allocator<_Hash_node<pair<const unsigned long, unsigned long>, false>> &is_constructible<pair<const unsigned long, unsigned long>, _Pair &&>allocator_traits<PoolAllocator<_Hash_node_base *, 48UL, 8UL>>allocator_traits<PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &allocator_traits<PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &&const allocator_traits<PoolAllocator<_Hash_node_base *, 48UL, 8UL>>const allocator_traits<PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &_Ptr<_Func, _Tp, __void_t<_Func<PoolAllocator<_Hash_node_base *, 48UL, 8UL>>>>tuple_element<1UL, pair<const unsigned long, unsigned long>>tuple_element<1UL, pair<const unsigned long, unsigned long>> &tuple_element<1UL, pair<const unsigned long, unsigned long>> &&const tuple_element<1UL, pair<const unsigned long, unsigned long>>const tuple_element<1UL, pair<const unsigned long, unsigned long>> &_Equal_helper<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, unsigned long, false>_Equal_helper<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, unsigned long, false> &_Equal_helper<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, unsigned long, false> &&const _Equal_helper<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, unsigned long, false>const _Equal_helper<unsigned long, pair<const unsigned long, unsigned long>, _Select1st, equal_to<unsigned long>, unsigned long, false> &conditional<true, pair<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, bool>, _Node_iterator<pair<const unsigned long, unsigned long>, false, false>>conditional<true, pair<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, bool>, _Node_iterator<pair<const unsigned long, unsigned long>, false, false>> &conditional<true, pair<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, bool>, _Node_iterator<pair<const unsigned long, unsigned long>, false, false>> &&const conditional<true, pair<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, bool>, _Node_iterator<pair<const unsigned long, unsigned long>, false, false>>const conditional<true, pair<_Node_iterator<pair<const unsigned long, unsigned long>, false, false>, bool>, _Node_iterator<pair<const unsigned long, unsigned long>, false, false>> &__detector<_Hash_node<pair<const unsigned long, unsigned long>, false> *, void, __pointer, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>__detector<_Hash_node<pair<const unsigned long, unsigned long>, false> *, void, __pointer, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<_Hash_node<pair<const unsigned long, unsigned long>, false> *, void, __pointer, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &&const __detector<_Hash_node<pair<const unsigned long, unsigned long>, false> *, void, __pointer, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const __detector<_Hash_node<pair<const unsigned long, unsigned long>, false> *, void, __pointer, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &pointer_traits<_Hash_node<pair<const unsigned long, unsigned long>, false> *>pointer_traits<_Hash_node<pair<const unsigned long, unsigned long>, false> *> &pointer_traits<_Hash_node<pair<const unsigned long, unsigned long>, false> *> &&const pointer_traits<_Hash_node<pair<const unsigned long, unsigned long>, false> *>const pointer_traits<_Hash_node<pair<const unsigned long, unsigned long>, false> *> &__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &__make_not_void<_Hash_node<pair<const unsigned long, unsigned long>, false>> &noexcept(_S_destroy(__a, __p, 0))std::is_nothrow_constructible<_Tp, _Args...>::valuenoexcept(_S_construct(__a, __p,
				       std::forward<_Args>(__args)...))PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL> &&const PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>const PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL> &__old_valListNode *&&is_nothrow_constructible<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>>is_nothrow_constructible<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>> &is_nothrow_constructible<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>> &&const is_nothrow_constructible<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>>const is_nothrow_constructible<pair<const unsigned long, unsigned long>, const piecewise_construct_t &, tuple<unsigned long &&>, tuple<>> &value_tconditional<false, const pair<const unsigned long, unsigned long> &, pair<const unsigned long, unsigned long> &>conditional<false, const pair<const unsigned long, unsigned long> &, pair<const unsigned long, unsigned long> &> &conditional<false, const pair<const unsigned long, unsigned long> &, pair<const unsigned long, unsigned long> &> &&const conditional<false, const pair<const unsigned long, unsigned long> &, pair<const unsigned long, unsigned long> &>const conditional<false, const pair<const unsigned long, unsigned long> &, pair<const unsigned long, unsigned long> &> &conditional<false, const pair<const unsigned long, unsigned long> *, pair<const unsigned long, unsigned long> *>conditional<false, const pair<const unsigned long, unsigned long> *, pair<const unsigned long, unsigned long> *> &conditional<false, const pair<const unsigned long, unsigned long> *, pair<const unsigned long, unsigned long> *> &&const conditional<false, const pair<const unsigned long, unsigned long> *, pair<const unsigned long, unsigned long> *>const conditional<false, const pair<const unsigned long, unsigned long> *, pair<const unsigned long, unsigned long> *> &__is_swappable<ListNode *>__is_nothrow_swappable<ListNode *>__and_<is_same<_Hash_node<pair<const unsigned long, unsigned long>, false> *, _Ptr>, __not_<is_pointer<_Ptr>>>_Size<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, long, void>_Size<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, long, void> &_Size<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, long, void> &&const _Size<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, long, void>const _Size<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, long, void> &_Diff<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, _Hash_node_base **, void>_Diff<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, _Hash_node_base **, void> &_Diff<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, _Hash_node_base **, void> &&const _Diff<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, _Hash_node_base **, void>const _Diff<PoolAllocator<_Hash_node_base *, 48UL, 8UL>, _Hash_node_base **, void> &_Ptr<__c_pointer, _Hash_node_base *const, void>_Hash_node_base *const_Ptr<__c_pointer, _Hash_node_base *const, void> &_Ptr<__c_pointer, _Hash_node_base *const, void> &&const _Ptr<__c_pointer, _Hash_node_base *const, void>const _Ptr<__c_pointer, _Hash_node_base *const, void> &remove_reference<ListNode *&>remove_reference<ListNode *&> &remove_reference<ListNode *&> &&const remove_reference<ListNode *&>const remove_reference<ListNode *&> &const PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL> *const PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL> *PoolAllocator<_Hash_node_base *, 48UL, 8UL> *std::is_nothrow_destructible<_Tp>::valueis_same<_Hash_node<pair<const unsigned long, unsigned long>, false> *, _Ptr>__detector<pair<const unsigned long, unsigned long> *, void, __pointer, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>__detector<pair<const unsigned long, unsigned long> *, void, __pointer, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<pair<const unsigned long, unsigned long> *, void, __pointer, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&const __detector<pair<const unsigned long, unsigned long> *, void, __pointer, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>const __detector<pair<const unsigned long, unsigned long> *, void, __pointer, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &pointer_traits<pair<const unsigned long, unsigned long> *>pointer_traits<pair<const unsigned long, unsigned long> *> &pointer_traits<pair<const unsigned long, unsigned long> *> &&const pointer_traits<pair<const unsigned long, unsigned long> *>const pointer_traits<pair<const unsigned long, unsigned long> *> &__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __equal, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __equal, PoolAllocator<pair<const unsigned long, unsigned long>, 48UL, 8UL>> &remove_reference<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>remove_reference<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &remove_reference<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &&const remove_reference<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>>const remove_reference<PoolAllocator<_Hash_node<pair<const unsigned long, unsigned long>, false>, 48UL, 8UL>> &const _Hashtable_ebo_helper<0, equal_to<unsigned long>, true>const _Hashtable_ebo_helper<0, equal_to<unsigned long>, true> &_Hashtable_ebo_helper<0, equal_to<unsigned long>, true> &conditional<false, __undefined, _Hash_node<pair<const unsigned long, unsigned long>, false>>conditional<false, __undefined, _Hash_node<pair<const unsigned long, unsigned long>, false>> &conditional<false, __undefined, _Hash_node<pair<const unsigned long, unsigned long>, false>> &&const conditional<false, __undefined, _Hash_node<pair<const unsigned long, unsigned long>, false>>const conditional<false, __undefined, _Hash_node<pair<const unsigned long, unsigned long>, false>> &__detector<_Hash_node_base **, void, __pointer, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>__detector<_Hash_node_base **, void, __pointer, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<_Hash_node_base **, void, __pointer, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &&const __detector<_Hash_node_base **, void, __pointer, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>const __detector<_Hash_node_base **, void, __pointer, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocca, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocma, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __pocs, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &__detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &&const __detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node_base *, 48UL, 8UL>>const __detector<integral_constant<bool, false>, void, __equal, PoolAllocator<_Hash_node_base *, 48UL, 8UL>> &is_void<_Hash_node<pair<const unsigned long, unsigned long>, false>>is_void<_Hash_node<pair<const unsigned long, unsigned long>, false>> &is_void<_Hash_node<pair<const unsigned long, unsigned long>, false>> &&const is_void<_Hash_node<pair<const unsigned long, unsigned long>, false>>const is_void<_Hash_node<pair<const unsigned long, unsigned long>, false>> &nontrivial_t &nontrivial_t *blk4999999/home/tanteikg/QCVE/sources/bitcoin/src/bench/prevector.cpplambda [] type at line 128570, col. 27lambda [] type at line 128570, col. 27 &const lambda [] type at line 128570, col. 27const lambda [] type at line 128570, col. 27 &const lambda [] type at line 128570, col. 27 *lambda [] type at line 128570, col. 27 *lambda [] type at line 128549, col. 24lambda [] type at line 128549, col. 24 &const lambda [] type at line 128549, col. 24const lambda [] type at line 128549, col. 24 &const lambda [] type at line 128549, col. 24 *lambda [] type at line 128549, col. 24 *prevector<28U, T, unsigned int, signed int> &lambda [] type at line 128523, col. 24lambda [] type at line 128523, col. 24 &const lambda [] type at line 128523, col. 24const lambda [] type at line 128523, col. 24 &const lambda [] type at line 128523, col. 24 *lambda [] type at line 128523, col. 24 *t0lambda [] type at line 128536, col. 24lambda [] type at line 128536, col. 24 &const lambda [] type at line 128536, col. 24const lambda [] type at line 128536, col. 24 &const lambda [] type at line 128536, col. 24 *lambda [] type at line 128536, col. 24 *PrevectorDeserializeTrivialDeserializePrevectorDeserializeNontrivialPrevectorResizeTrivialResizePrevectorResizeNontrivialPrevectorDestructorTrivialDestructorPrevectorDestructorNontrivialPrevectorClearTrivialClearPrevectorClearNontrivialPrevectorDeserializePrevectorResizePrevectorClearPrevectorDestructornontrivial_t &&const nontrivial_tconst nontrivial_t &nontrivial_tobj.xconst nontrivial_t *trivial_tbench_98PrevectorDeserializeTrivialPASTE2(__LINE__, PrevectorDeserializeTrivial)98PrevectorDeserializeTrivialbench_98PrevectorDeserializeNontrivialPASTE2(__LINE__, PrevectorDeserializeNontrivial)98PrevectorDeserializeNontrivialbench_97PrevectorResizeTrivialPASTE2(__LINE__, PrevectorResizeTrivial)97PrevectorResizeTrivialbench_97PrevectorResizeNontrivialPASTE2(__LINE__, PrevectorResizeNontrivial)97PrevectorResizeNontrivialbench_96PrevectorDestructorTrivialPASTE2(__LINE__, PrevectorDestructorTrivial)96PrevectorDestructorTrivialbench_96PrevectorDestructorNontrivialPASTE2(__LINE__, PrevectorDestructorNontrivial)96PrevectorDestructorNontrivialbench_95PrevectorClearTrivialPASTE2(__LINE__, PrevectorClearTrivial)95PrevectorClearTrivialbench_95PrevectorClearNontrivialPASTE2(__LINE__, PrevectorClearNontrivial)95PrevectorClearNontrivialstd::is_trivially_default_constructible<trivial_t>::valuestd::is_trivially_default_constructible<nontrivial_t>::value!std::is_trivially_default_constructible<nontrivial_t>::valuePREVECTOR_TEST(name)static void Prevector ## name ## Nontrivial(benchmark::Bench& bench) { Prevector ## name<nontrivial_t>(bench); } BENCHMARK(Prevector ## name ## Nontrivial, benchmark::PriorityLevel::HIGH); static void Prevector ## name ## Trivial(benchmark::Bench& bench) { Prevector ## name<trivial_t>(bench); } BENCHMARK(Prevector ## name ## Trivial, benchmark::PriorityLevel::HIGH);expected trivial_t to be trivially constructibleexpected nontrivial_t to not be trivially constructibleis_same<const nontrivial_t &, const nontrivial_t &>is_same<const nontrivial_t &, const nontrivial_t &> &is_same<const nontrivial_t &, const nontrivial_t &> &&const is_same<const nontrivial_t &, const nontrivial_t &>const is_same<const nontrivial_t &, const nontrivial_t &> &is_same<nontrivial_t &, nontrivial_t &>is_same<nontrivial_t &, nontrivial_t &> &is_same<nontrivial_t &, nontrivial_t &> &&const is_same<nontrivial_t &, nontrivial_t &>const is_same<nontrivial_t &, nontrivial_t &> &prevector<28U, T, unsigned int, signed int>is_trivially_default_constructible<nontrivial_t>is_trivially_default_constructibleis_trivially_default_constructible<nontrivial_t> &is_trivially_default_constructible<nontrivial_t> &&const is_trivially_default_constructible<nontrivial_t>const is_trivially_default_constructible<nontrivial_t> &is_trivially_default_constructible<unsigned char>is_trivially_default_constructible<unsigned char> &is_trivially_default_constructible<unsigned char> &&const is_trivially_default_constructible<unsigned char>const is_trivially_default_constructible<unsigned char> &iterator &&const_iterator &&lambda [] type at line 128536, col. 24 &&prevector<28U, nontrivial_t, unsigned int, signed int> &lambda [] type at line 128523, col. 24 &&lambda [] type at line 128549, col. 24 &&const prevector<28U, nontrivial_t, unsigned int, signed int>const prevector<28U, nontrivial_t, unsigned int, signed int> &lambda [] type at line 128570, col. 27 &&prevector<28U, nontrivial_t, unsigned int, signed int>is_Span<const nontrivial_t>is_Span<const nontrivial_t> &is_Span<const nontrivial_t> &&const is_Span<const nontrivial_t>const is_Span<const nontrivial_t> &is_Span_int<nontrivial_t>is_Span_int<nontrivial_t> &is_Span_int<nontrivial_t> &&const is_Span_int<nontrivial_t>const is_Span_int<nontrivial_t> &is_Span<nontrivial_t>is_Span<nontrivial_t> &is_Span<nontrivial_t> &&const is_Span<nontrivial_t>const is_Span<nontrivial_t> &is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>>is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>> &is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>> &&const is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>>const is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>> &is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>>is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>> &is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>> &&const is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>>const is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>> &is_Span<const prevector<28U, nontrivial_t, unsigned int, signed int>>is_Span<const prevector<28U, nontrivial_t, unsigned int, signed int>> &is_Span<const prevector<28U, nontrivial_t, unsigned int, signed int>> &&const is_Span<const prevector<28U, nontrivial_t, unsigned int, signed int>>const is_Span<const prevector<28U, nontrivial_t, unsigned int, signed int>> &is_Span_int<prevector<28U, nontrivial_t, unsigned int, signed int>>is_Span_int<prevector<28U, nontrivial_t, unsigned int, signed int>> &is_Span_int<prevector<28U, nontrivial_t, unsigned int, signed int>> &&const is_Span_int<prevector<28U, nontrivial_t, unsigned int, signed int>>const is_Span_int<prevector<28U, nontrivial_t, unsigned int, signed int>> &is_Span<prevector<28U, nontrivial_t, unsigned int, signed int>>is_Span<prevector<28U, nontrivial_t, unsigned int, signed int>> &is_Span<prevector<28U, nontrivial_t, unsigned int, signed int>> &&const is_Span<prevector<28U, nontrivial_t, unsigned int, signed int>>const is_Span<prevector<28U, nontrivial_t, unsigned int, signed int>> &prevector<28U, nontrivial_t, unsigned int, signed int> *const prevector<28U, nontrivial_t, unsigned int, signed int> *Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &> &const Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &>const Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &> &Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &> &&const direct_or_indirectconst direct_or_indirect &char[112]N + 1(size_t)sizeof(T)((size_t)sizeof(T))const char[142]char[142]void prevector<N, T, Size, Diff>::change_capacity(Size) [with unsigned int N = 28U; T = nontrivial_t; Size = unsigned int; Diff = signed int]Wrapper<VectorFormatter<DefaultFormatter>, prevector<28U, nontrivial_t, unsigned int, signed int> &> &&Wrapper<VectorFormatter<DefaultFormatter>, prevector<28U, nontrivial_t, unsigned int, signed int> &> &Wrapper<VectorFormatter<DefaultFormatter>, prevector<28U, nontrivial_t, unsigned int, signed int> &>const Wrapper<VectorFormatter<DefaultFormatter>, prevector<28U, nontrivial_t, unsigned int, signed int> &>const Wrapper<VectorFormatter<DefaultFormatter>, prevector<28U, nontrivial_t, unsigned int, signed int> &> &sizeof(T) * Nnontrivial_t *constnontrivial_t *const &nontrivial_t *&const Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &> *Wrapper<VectorFormatter<DefaultFormatter>, const prevector<28U, nontrivial_t, unsigned int, signed int> &> *Wrapper<VectorFormatter<DefaultFormatter>, prevector<28U, nontrivial_t, unsigned int, signed int> &> *is_nothrow_copy_constructible<nontrivial_t *>is_nothrow_copy_constructible<nontrivial_t *> &is_nothrow_copy_constructible<nontrivial_t *> &&const is_nothrow_copy_constructible<nontrivial_t *>const is_nothrow_copy_constructible<nontrivial_t *> &__enable_if<true, nontrivial_t *>__enable_if<true, nontrivial_t *> &__enable_if<true, nontrivial_t *> &&const __enable_if<true, nontrivial_t *>const __enable_if<true, nontrivial_t *> &1250000__traitor<__is_arithmetic<nontrivial_t>, __is_pointer<nontrivial_t>>__traitor<__is_arithmetic<nontrivial_t>, __is_pointer<nontrivial_t>> &const __traitor<__is_arithmetic<nontrivial_t>, __is_pointer<nontrivial_t>>const __traitor<__is_arithmetic<nontrivial_t>, __is_pointer<nontrivial_t>> &__traitor<__is_arithmetic<nontrivial_t>, __is_pointer<nontrivial_t>> &&__is_nothrow_copy_constructible_impl<nontrivial_t *, true>__is_nothrow_copy_constructible_impl<nontrivial_t *, true> &__is_nothrow_copy_constructible_impl<nontrivial_t *, true> &&const __is_nothrow_copy_constructible_impl<nontrivial_t *, true>const __is_nothrow_copy_constructible_impl<nontrivial_t *, true> &__is_referenceable<nontrivial_t *>__is_referenceable<nontrivial_t *> &__is_referenceable<nontrivial_t *> &&const __is_referenceable<nontrivial_t *>const __is_referenceable<nontrivial_t *> &is_nothrow_constructible<nontrivial_t *, nontrivial_t *const &>is_nothrow_constructible<nontrivial_t *, nontrivial_t *const &> &is_nothrow_constructible<nontrivial_t *, nontrivial_t *const &> &&const is_nothrow_constructible<nontrivial_t *, nontrivial_t *const &>const is_nothrow_constructible<nontrivial_t *, nontrivial_t *const &> &__traitor<__is_integer<nontrivial_t>, __is_floating<nontrivial_t>>__traitor<__is_integer<nontrivial_t>, __is_floating<nontrivial_t>> &const __traitor<__is_integer<nontrivial_t>, __is_floating<nontrivial_t>>const __traitor<__is_integer<nontrivial_t>, __is_floating<nontrivial_t>> &__traitor<__is_integer<nontrivial_t>, __is_floating<nontrivial_t>> &&__is_pointer<nontrivial_t>__is_pointer<nontrivial_t> &const __is_pointer<nontrivial_t>const __is_pointer<nontrivial_t> &__is_pointer<nontrivial_t> &&__is_arithmetic<nontrivial_t>__is_arithmetic<nontrivial_t> &__is_arithmetic<nontrivial_t> &&const __is_arithmetic<nontrivial_t>const __is_arithmetic<nontrivial_t> &__is_floating<nontrivial_t>__is_floating<nontrivial_t> &const __is_floating<nontrivial_t>const __is_floating<nontrivial_t> &__is_floating<nontrivial_t> &&__is_integer<nontrivial_t>__is_integer<nontrivial_t> &const __is_integer<nontrivial_t>const __is_integer<nontrivial_t> &__is_integer<nontrivial_t> &&/home/tanteikg/QCVE/sources/bitcoin/src/bench/rollingbloom.cppRollingBloomReset120000lambda [] type at line 127281, col. 15const lambda [] type at line 127281, col. 15const lambda [] type at line 127281, col. 15 &lambda [] type at line 127281, col. 15 &lambda [] type at line 127281, col. 15 &&RollingBloomlambda [] type at line 127268, col. 15const lambda [] type at line 127268, col. 15const lambda [] type at line 127268, col. 15 &lambda [] type at line 127268, col. 15 &lambda [] type at line 127268, col. 15 &&const lambda [] type at line 127281, col. 15 *lambda [] type at line 127281, col. 15 *const lambda [] type at line 127268, col. 15 *lambda [] type at line 127268, col. 15 *bench_36RollingBloomResetPASTE2(__LINE__, RollingBloomReset)36RollingBloomResetbench_35RollingBloomPASTE2(__LINE__, RollingBloom)35RollingBloomlambda [] type at line 131954, col. 58lambda [] type at line 131954, col. 58 &const lambda [] type at line 131954, col. 58const lambda [] type at line 131954, col. 58 &const lambda [] type at line 131954, col. 58 *lambda [] type at line 131954, col. 58 *Superfluous witness record"Superfluous witness record"Unknown transaction optional data"Unknown transaction optional data"/home/tanteikg/QCVE/sources/bitcoin/src/rpc/blockchain.h/home/tanteikg/QCVE/sources/bitcoin/src/core_io.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/rpc_blockchain.cpp<rpc/blockchain.h>BlockToJsonVerboseWriteunivalueBlockManager &TxVerbosity::SHOW_DETAILS_AND_PREVOUTlambda [] type at line 297238, col. 15const lambda [] type at line 297238, col. 15const lambda [] type at line 297238, col. 15 &lambda [] type at line 297238, col. 15 &lambda [] type at line 297238, col. 15 &&~TestBlockAndIndexTestBlockAndIndex *BlockToJsonVerboselambda [] type at line 297226, col. 15const lambda [] type at line 297226, col. 15const lambda [] type at line 297226, col. 15 &lambda [] type at line 297226, col. 15 &lambda [] type at line 297226, col. 15 &&TestBlockAndIndex &const lambda [] type at line 297238, col. 15 *lambda [] type at line 297238, col. 15 *const lambda [] type at line 297226, col. 15 *lambda [] type at line 297226, col. 15 *const TestBlockAndIndexconst TestBlockAndIndex &TestBlockAndIndex403014710blockindexblockHashbench_60BlockToJsonVerboseWritePASTE2(__LINE__, BlockToJsonVerboseWrite)60BlockToJsonVerboseWritebench_48BlockToJsonVerbosePASTE2(__LINE__, BlockToJsonVerbose)48BlockToJsonVerbose/home/tanteikg/QCVE/sources/bitcoin/src/rpc/mempool.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/rpc_mempool.cpp<rpc/mempool.h>RpcMempoolconst unique_ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>>bench/rpc_mempool.cpptx_rlambda [] type at line 288150, col. 15const lambda [] type at line 288150, col. 15const lambda [] type at line 288150, col. 15 &lambda [] type at line 288150, col. 15 &lambda [] type at line 288150, col. 15 &&const lambda [] type at line 288150, col. 15 *lambda [] type at line 288150, col. 15 *bench_45RpcMempoolPASTE2(__LINE__, RpcMempool)45RpcMempool/*verbose=*//*fee=*//*sigops_cost=*//*spends_coinbase=*//*entry_height=*/unique_ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>>default_delete<const ChainTestingSetup> &unique_ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>> *ChainTestingSetup *&const default_delete<const ChainTestingSetup>ChainTestingSetup *&&const ChainTestingSetup *&const unique_ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>> *const ChainTestingSetup *constconst ChainTestingSetup *const &const default_delete<const ChainTestingSetup> &__uniq_ptr_impl<const ChainTestingSetup, default_delete<const ChainTestingSetup>>__uniq_ptr_impl<const ChainTestingSetup, default_delete<const ChainTestingSetup>> &__uniq_ptr_impl<const ChainTestingSetup, default_delete<const ChainTestingSetup>> &&const __uniq_ptr_impl<const ChainTestingSetup, default_delete<const ChainTestingSetup>>const __uniq_ptr_impl<const ChainTestingSetup, default_delete<const ChainTestingSetup>> &default_delete<const ChainTestingSetup>default_delete<const ChainTestingSetup> &&const default_delete<const ChainTestingSetup> *default_delete<const ChainTestingSetup> *__uniq_ptr_impl<const ChainTestingSetup, default_delete<const ChainTestingSetup>> *__tuple_element_t<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>> &tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &__and_<is_convertible<pointer, const ChainTestingSetup *>, __not_<is_array<_Up>>>tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &&const tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>const tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &_Ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>, void>_Ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>, void> &_Ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>, void> &&const _Ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>, void>const _Ptr<const ChainTestingSetup, default_delete<const ChainTestingSetup>, void> &_Tuple_impl<0UL, const ChainTestingSetup *, default_delete<const ChainTestingSetup>>_Tuple_impl<0UL, const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &&const _Tuple_impl<0UL, const ChainTestingSetup *, default_delete<const ChainTestingSetup>>const _Tuple_impl<0UL, const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &_Tuple_impl<0UL, const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &_Tuple_impl<1UL, default_delete<const ChainTestingSetup>>_Tuple_impl<1UL, default_delete<const ChainTestingSetup>> &&const _Tuple_impl<1UL, default_delete<const ChainTestingSetup>>const _Tuple_impl<1UL, default_delete<const ChainTestingSetup>> &_Tuple_impl<1UL, default_delete<const ChainTestingSetup>> &remove_reference<const ChainTestingSetup *&>remove_reference<const ChainTestingSetup *&> &remove_reference<const ChainTestingSetup *&> &&const remove_reference<const ChainTestingSetup *&>const remove_reference<const ChainTestingSetup *&> &_MakeUniq<const ChainTestingSetup>_MakeUniq<const ChainTestingSetup> &_MakeUniq<const ChainTestingSetup> &&const _MakeUniq<const ChainTestingSetup>const _MakeUniq<const ChainTestingSetup> &__tuple_element_t<1UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>> &const __uniq_ptr_impl<const ChainTestingSetup, default_delete<const ChainTestingSetup>> *const __tuple_element_t<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>>const __tuple_element_t<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>> &_Head_base<1UL, default_delete<const ChainTestingSetup>, true>_Head_base<1UL, default_delete<const ChainTestingSetup>, true> &const _Head_base<1UL, default_delete<const ChainTestingSetup>, true>const _Head_base<1UL, default_delete<const ChainTestingSetup>, true> &_Head_base<0UL, const ChainTestingSetup *, false>_Head_base<0UL, const ChainTestingSetup *, false> &const _Head_base<0UL, const ChainTestingSetup *, false>const _Head_base<0UL, const ChainTestingSetup *, false> &is_convertible<pointer, const ChainTestingSetup *>tuple_element<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>>tuple_element<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>> &tuple_element<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>> &&const tuple_element<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>>const tuple_element<0UL, tuple<const ChainTestingSetup *, default_delete<const ChainTestingSetup>>> &_TC<value, const ChainTestingSetup *, default_delete<const ChainTestingSetup>>_TC<true, const ChainTestingSetup *, default_delete<const ChainTestingSetup>>_TC<true, const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &_TC<true, const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &&const _TC<true, const ChainTestingSetup *, default_delete<const ChainTestingSetup>>const _TC<true, const ChainTestingSetup *, default_delete<const ChainTestingSetup>> &tuple_element<0UL, tuple<default_delete<const ChainTestingSetup>>>tuple_element<0UL, tuple<default_delete<const ChainTestingSetup>>> &tuple_element<0UL, tuple<default_delete<const ChainTestingSetup>>> &&const tuple_element<0UL, tuple<default_delete<const ChainTestingSetup>>>const tuple_element<0UL, tuple<default_delete<const ChainTestingSetup>>> &__is_empty_non_tuple<default_delete<const ChainTestingSetup>>__is_empty_non_tuple<default_delete<const ChainTestingSetup>> &__is_empty_non_tuple<default_delete<const ChainTestingSetup>> &&const __is_empty_non_tuple<default_delete<const ChainTestingSetup>>const __is_empty_non_tuple<default_delete<const ChainTestingSetup>> &__is_empty_non_tuple<const ChainTestingSetup *>__is_empty_non_tuple<const ChainTestingSetup *> &__is_empty_non_tuple<const ChainTestingSetup *> &&const __is_empty_non_tuple<const ChainTestingSetup *>const __is_empty_non_tuple<const ChainTestingSetup *> &_Tuple_impl<0UL, const ChainTestingSetup *, default_delete<const ChainTestingSetup>> *conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const ChainTestingSetup *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const ChainTestingSetup *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const ChainTestingSetup *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const ChainTestingSetup *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const ChainTestingSetup *>> &is_empty<const ChainTestingSetup *>is_empty<const ChainTestingSetup *> &is_empty<const ChainTestingSetup *> &&const is_empty<const ChainTestingSetup *>const is_empty<const ChainTestingSetup *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const ChainTestingSetup>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const ChainTestingSetup>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const ChainTestingSetup>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const ChainTestingSetup>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<const ChainTestingSetup>>> &is_empty<default_delete<const ChainTestingSetup>>is_empty<default_delete<const ChainTestingSetup>> &is_empty<default_delete<const ChainTestingSetup>> &&const is_empty<default_delete<const ChainTestingSetup>>const is_empty<default_delete<const ChainTestingSetup>> &tuple<default_delete<const ChainTestingSetup>>_Head_base<0UL, const ChainTestingSetup *, false> *_Tuple_impl<1UL, default_delete<const ChainTestingSetup>> *_Head_base<1UL, default_delete<const ChainTestingSetup>, true> */home/tanteikg/QCVE/sources/bitcoin/src/bench/strencodings.cppHexStrBenchlambda [] type at line 121097, col. 47const lambda [] type at line 121097, col. 47const lambda [] type at line 121097, col. 47 &lambda [] type at line 121097, col. 47 &lambda [] type at line 121097, col. 47 &&const lambda [] type at line 121097, col. 47 *lambda [] type at line 121097, col. 47 *hexbench_18HexStrBenchPASTE2(__LINE__, HexStrBench)18HexStrBench/home/tanteikg/QCVE/sources/bitcoin/src/bench/util_time.cppBenchTimeMillisSyslambda [] type at line 130916, col. 15const lambda [] type at line 130916, col. 15const lambda [] type at line 130916, col. 15 &lambda [] type at line 130916, col. 15 &lambda [] type at line 130916, col. 15 &&BenchTimeMillislambda [] type at line 130909, col. 15const lambda [] type at line 130909, col. 15const lambda [] type at line 130909, col. 15 &lambda [] type at line 130909, col. 15 &lambda [] type at line 130909, col. 15 &&BenchTimeMocklambda [] type at line 130901, col. 15const lambda [] type at line 130901, col. 15const lambda [] type at line 130901, col. 15 &lambda [] type at line 130901, col. 15 &lambda [] type at line 130901, col. 15 &&BenchTimeDeprecatedlambda [] type at line 130893, col. 15const lambda [] type at line 130893, col. 15const lambda [] type at line 130893, col. 15 &lambda [] type at line 130893, col. 15 &lambda [] type at line 130893, col. 15 &&const lambda [] type at line 130916, col. 15 *lambda [] type at line 130916, col. 15 *const lambda [] type at line 130909, col. 15 *lambda [] type at line 130909, col. 15 *const lambda [] type at line 130901, col. 15 *lambda [] type at line 130901, col. 15 *const lambda [] type at line 130893, col. 15 *lambda [] type at line 130893, col. 15 *bench_42BenchTimeMockPASTE2(__LINE__, BenchTimeMock)42BenchTimeMockbench_41BenchTimeMillisSysPASTE2(__LINE__, BenchTimeMillisSys)41BenchTimeMillisSysbench_40BenchTimeMillisPASTE2(__LINE__, BenchTimeMillis)40BenchTimeMillisbench_39BenchTimeDeprecatedPASTE2(__LINE__, BenchTimeDeprecated)39BenchTimeDeprecatedSetupDummyInputsBuildSpendingTransactionBuildCreditingTransactionCCoinsViewCacheBITCOIN_TEST_UTIL_TRANSACTION_UTILS_H// BITCOIN_TEST_UTIL_TRANSACTION_UTILS_H// the second nValues[2] and nValues[3] outputs paid to a TxoutType::PUBKEYHASH.// The first has nValues[0] and nValues[1] outputs paid to a TxoutType::PUBKEY,// Helper: create two dummy transactions, each with two outputs.//  1 output with empty scriptPubKey, full value of referenced transaction]// [1 input with referenced transaction outpoint, scriptSig, scriptWitness =>// create spending transaction// [1 coinbase input => 1 output with given scriptPubkey and value]// create crediting transactionkeystoreRetcoinsRetnValuestxCredit/home/tanteikg/QCVE/sources/bitcoin/src/script/bitcoinconsensus.h/home/tanteikg/QCVE/sources/bitcoin/src/bench/verify_script.cpp<script/bitcoinconsensus.h>VerifyNestedIfScriptlambda [] type at line 141497, col. 15const lambda [] type at line 141497, col. 15const lambda [] type at line 141497, col. 15 &lambda [] type at line 141497, col. 15 &lambda [] type at line 141497, col. 15 &&VerifyScriptBenchSCRIPT_VERIFY_WITNESSSCRIPT_VERIFY_P2SH2049SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SHwitnessversionvchKeypubkeyHashwitScriptPubkeytxSpendconst PrecomputedTransactionDataconst PrecomputedTransactionData *PrecomputedTransactionData *SIGHASH_ALLSigVersion::WITNESS_V0static_cast<unsigned char>(SIGHASH_ALL)err == SCRIPT_ERR_OKcsuccess == 1lambda [] type at line 141458, col. 15const lambda [] type at line 141458, col. 15const lambda [] type at line 141458, col. 15 &lambda [] type at line 141458, col. 15 &lambda [] type at line 141458, col. 15 &&const lambda [] type at line 141497, col. 15 *lambda [] type at line 141497, col. 15 *stack_copyconst BaseSignatureCheckerconst BaseSignatureChecker &BaseSignatureChecker &ScriptError *ScriptError_t *BaseSignatureCheckerBaseSignatureChecker *SigVersion::BASEbench/verify_script.cppconst lambda [] type at line 141458, col. 15 *lambda [] type at line 141458, col. 15 *MissingDataBehavior::ASSERT_FAILcsuccessbitcoinconsensus_error *bitcoinconsensus_error_t *bench_99VerifyNestedIfScriptPASTE2(__LINE__, VerifyNestedIfScript)99VerifyNestedIfScriptbench_98VerifyScriptBenchPASTE2(__LINE__, VerifyScriptBench)98VerifyScriptBenchdefined(HAVE_CONSENSUS_LIB)// Script.// Key pair.// modified to measure performance of other types of scripts.// Microbenchmark for verification of a basic P2WPKH script. Can be easily_Rb_tree_const_iterator<CExtPubKey> &const _Rb_tree<CExtPubKey, CExtPubKey, _Identity<CExtPubKey>, less<CExtPubKey>, allocator<CExtPubKey>>const _Rb_tree<CExtPubKey, CExtPubKey, _Identity<CExtPubKey>, less<CExtPubKey>, allocator<CExtPubKey>> &_Rb_tree<CExtPubKey, CExtPubKey, _Identity<CExtPubKey>, less<CExtPubKey>, allocator<CExtPubKey>> &_Rb_tree_iterator<uint256> &_Rb_tree_const_iterator<vector<unsigned char, allocator<unsigned char>>> &const _Rb_tree<vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>, _Identity<vector<unsigned char, allocator<unsigned char>>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>const _Rb_tree<vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>, _Identity<vector<unsigned char, allocator<unsigned char>>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>> &_Rb_tree<vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>, _Identity<vector<unsigned char, allocator<unsigned char>>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>> &_Rb_tree_const_iterator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>> &_Rb_tree_iterator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>> &const _Rb_tree<pair<slot_meta_group, optional<int>>, pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>, _Select1st<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>, group_key_less<int, less<int>>, allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>>const _Rb_tree<pair<slot_meta_group, optional<int>>, pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>, _Select1st<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>, group_key_less<int, less<int>>, allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>> &_Rb_tree<pair<slot_meta_group, optional<int>>, pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>, _Select1st<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>, group_key_less<int, less<int>>, allocator<pair<const pair<slot_meta_group, optional<int>>, _List_iterator<shared_ptr<connection_body<pair<slot_meta_group, optional<int>>, slot<..(..), function<..(..)>>, mutex>>>>>> &_Rb_tree_const_iterator<COutPoint> &const _Rb_tree<COutPoint, COutPoint, _Identity<COutPoint>, less<COutPoint>, allocator<COutPoint>>const _Rb_tree<COutPoint, COutPoint, _Identity<COutPoint>, less<COutPoint>, allocator<COutPoint>> &_Rb_tree<COutPoint, COutPoint, _Identity<COutPoint>, less<COutPoint>, allocator<COutPoint>> &_Rb_tree_const_iterator<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>> &_Rb_tree_iterator<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>> &const _Rb_tree<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>, _Select1st<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>>, less<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>>, allocator<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>>>const _Rb_tree<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>, _Select1st<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>>, less<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>>, allocator<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>>> &_Rb_tree<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>, _Select1st<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>>, less<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>>, allocator<pair<const variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>, CAddressBookData>>> &_Rb_tree_const_iterator<pair<const unsigned int, CMasterKey>> &_Rb_tree_iterator<pair<const unsigned int, CMasterKey>> &const _Rb_tree<unsigned int, pair<const unsigned int, CMasterKey>, _Select1st<pair<const unsigned int, CMasterKey>>, less<unsigned int>, allocator<pair<const unsigned int, CMasterKey>>>const _Rb_tree<unsigned int, pair<const unsigned int, CMasterKey>, _Select1st<pair<const unsigned int, CMasterKey>>, less<unsigned int>, allocator<pair<const unsigned int, CMasterKey>>> &_Rb_tree<unsigned int, pair<const unsigned int, CMasterKey>, _Select1st<pair<const unsigned int, CMasterKey>>, less<unsigned int>, allocator<pair<const unsigned int, CMasterKey>>> &_Rb_tree_const_iterator<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>> &_Rb_tree_iterator<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>> &const _Rb_tree<uint256, pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>, _Select1st<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>>, less<uint256>, allocator<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>>>const _Rb_tree<uint256, pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>, _Select1st<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>>, less<uint256>, allocator<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>>> &_Rb_tree<uint256, pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>, _Select1st<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>>, less<uint256>, allocator<pair<const uint256, unique_ptr<ScriptPubKeyMan, default_delete<ScriptPubKeyMan>>>>> &_Rb_tree_const_iterator<pair<const OutputType, ScriptPubKeyMan *>> &_Rb_tree_iterator<pair<const OutputType, ScriptPubKeyMan *>> &const _Rb_tree<OutputType, pair<const OutputType, ScriptPubKeyMan *>, _Select1st<pair<const OutputType, ScriptPubKeyMan *>>, less<OutputType>, allocator<pair<const OutputType, ScriptPubKeyMan *>>>const _Rb_tree<OutputType, pair<const OutputType, ScriptPubKeyMan *>, _Select1st<pair<const OutputType, ScriptPubKeyMan *>>, less<OutputType>, allocator<pair<const OutputType, ScriptPubKeyMan *>>> &_Rb_tree<OutputType, pair<const OutputType, ScriptPubKeyMan *>, _Select1st<pair<const OutputType, ScriptPubKeyMan *>>, less<OutputType>, allocator<pair<const OutputType, ScriptPubKeyMan *>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, WalletFlags>>> &_Rb_tree_const_iterator<pair<const signed int, FlatSigningProvider>> &_Rb_tree_iterator<pair<const signed int, FlatSigningProvider>> &const _Rb_tree<signed int, pair<const signed int, FlatSigningProvider>, _Select1st<pair<const signed int, FlatSigningProvider>>, less<int>, allocator<pair<const signed int, FlatSigningProvider>>>const _Rb_tree<signed int, pair<const signed int, FlatSigningProvider>, _Select1st<pair<const signed int, FlatSigningProvider>>, less<int>, allocator<pair<const signed int, FlatSigningProvider>>> &_Rb_tree<signed int, pair<const signed int, FlatSigningProvider>, _Select1st<pair<const signed int, FlatSigningProvider>>, less<int>, allocator<pair<const signed int, FlatSigningProvider>>> &_Rb_tree_const_iterator<pair<const CPubKey, signed int>> &_Rb_tree_iterator<pair<const CPubKey, signed int>> &const _Rb_tree<CPubKey, pair<const CPubKey, signed int>, _Select1st<pair<const CPubKey, signed int>>, less<CPubKey>, allocator<pair<const CPubKey, signed int>>>const _Rb_tree<CPubKey, pair<const CPubKey, signed int>, _Select1st<pair<const CPubKey, signed int>>, less<CPubKey>, allocator<pair<const CPubKey, signed int>>> &_Rb_tree<CPubKey, pair<const CPubKey, signed int>, _Select1st<pair<const CPubKey, signed int>>, less<CPubKey>, allocator<pair<const CPubKey, signed int>>> &_Rb_tree_const_iterator<pair<const CScript, signed int>> &_Rb_tree_iterator<pair<const CScript, signed int>> &const _Rb_tree<CScript, pair<const CScript, signed int>, _Select1st<pair<const CScript, signed int>>, less<CScript>, allocator<pair<const CScript, signed int>>>const _Rb_tree<CScript, pair<const CScript, signed int>, _Select1st<pair<const CScript, signed int>>, less<CScript>, allocator<pair<const CScript, signed int>>> &_Rb_tree<CScript, pair<const CScript, signed int>, _Select1st<pair<const CScript, signed int>>, less<CScript>, allocator<pair<const CScript, signed int>>> &_Rb_tree_const_iterator<pair<const CScriptID, CKeyMetadata>> &_Rb_tree_iterator<pair<const CScriptID, CKeyMetadata>> &const _Rb_tree<CScriptID, pair<const CScriptID, CKeyMetadata>, _Select1st<pair<const CScriptID, CKeyMetadata>>, less<CScriptID>, allocator<pair<const CScriptID, CKeyMetadata>>>const _Rb_tree<CScriptID, pair<const CScriptID, CKeyMetadata>, _Select1st<pair<const CScriptID, CKeyMetadata>>, less<CScriptID>, allocator<pair<const CScriptID, CKeyMetadata>>> &_Rb_tree<CScriptID, pair<const CScriptID, CKeyMetadata>, _Select1st<pair<const CScriptID, CKeyMetadata>>, less<CScriptID>, allocator<pair<const CScriptID, CKeyMetadata>>> &_Rb_tree_const_iterator<pair<const CKeyID, CKeyMetadata>> &_Rb_tree_iterator<pair<const CKeyID, CKeyMetadata>> &const _Rb_tree<CKeyID, pair<const CKeyID, CKeyMetadata>, _Select1st<pair<const CKeyID, CKeyMetadata>>, less<CKeyID>, allocator<pair<const CKeyID, CKeyMetadata>>>const _Rb_tree<CKeyID, pair<const CKeyID, CKeyMetadata>, _Select1st<pair<const CKeyID, CKeyMetadata>>, less<CKeyID>, allocator<pair<const CKeyID, CKeyMetadata>>> &_Rb_tree<CKeyID, pair<const CKeyID, CKeyMetadata>, _Select1st<pair<const CKeyID, CKeyMetadata>>, less<CKeyID>, allocator<pair<const CKeyID, CKeyMetadata>>> &_Rb_tree_const_iterator<pair<const signed long, CKeyID>> &_Rb_tree_iterator<pair<const signed long, CKeyID>> &const _Rb_tree<signed long, pair<const signed long, CKeyID>, _Select1st<pair<const signed long, CKeyID>>, less<signed long>, allocator<pair<const signed long, CKeyID>>>const _Rb_tree<signed long, pair<const signed long, CKeyID>, _Select1st<pair<const signed long, CKeyID>>, less<signed long>, allocator<pair<const signed long, CKeyID>>> &_Rb_tree<signed long, pair<const signed long, CKeyID>, _Select1st<pair<const signed long, CKeyID>>, less<signed long>, allocator<pair<const signed long, CKeyID>>> &_Rb_tree_const_iterator<pair<const CKeyID, signed long>> &_Rb_tree_iterator<pair<const CKeyID, signed long>> &const _Rb_tree<CKeyID, pair<const CKeyID, signed long>, _Select1st<pair<const CKeyID, signed long>>, less<CKeyID>, allocator<pair<const CKeyID, signed long>>>const _Rb_tree<CKeyID, pair<const CKeyID, signed long>, _Select1st<pair<const CKeyID, signed long>>, less<CKeyID>, allocator<pair<const CKeyID, signed long>>> &_Rb_tree<CKeyID, pair<const CKeyID, signed long>, _Select1st<pair<const CKeyID, signed long>>, less<CKeyID>, allocator<pair<const CKeyID, signed long>>> &_Rb_tree_const_iterator<signed long> &const _Rb_tree<signed long, signed long, _Identity<signed long>, less<signed long>, allocator<signed long>>const _Rb_tree<signed long, signed long, _Identity<signed long>, less<signed long>, allocator<signed long>> &_Rb_tree<signed long, signed long, _Identity<signed long>, less<signed long>, allocator<signed long>> &_Rb_tree_const_iterator<CScript> &const _Rb_tree<CScript, CScript, _Identity<CScript>, less<CScript>, allocator<CScript>>const _Rb_tree<CScript, CScript, _Identity<CScript>, less<CScript>, allocator<CScript>> &_Rb_tree<CScript, CScript, _Identity<CScript>, less<CScript>, allocator<CScript>> &_Rb_tree_const_iterator<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>> &_Rb_tree_iterator<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>> &const _Rb_tree<KeyOriginInfo, pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>, _Select1st<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>>, less<KeyOriginInfo>, allocator<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>>>const _Rb_tree<KeyOriginInfo, pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>, _Select1st<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>>, less<KeyOriginInfo>, allocator<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>>> &_Rb_tree<KeyOriginInfo, pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>, _Select1st<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>>, less<KeyOriginInfo>, allocator<pair<const KeyOriginInfo, set<CExtPubKey, less<CExtPubKey>, allocator<CExtPubKey>>>>> &_Rb_tree_const_iterator<PSBTProprietary> &const _Rb_tree<PSBTProprietary, PSBTProprietary, _Identity<PSBTProprietary>, less<PSBTProprietary>, allocator<PSBTProprietary>>const _Rb_tree<PSBTProprietary, PSBTProprietary, _Identity<PSBTProprietary>, less<PSBTProprietary>, allocator<PSBTProprietary>> &_Rb_tree<PSBTProprietary, PSBTProprietary, _Identity<PSBTProprietary>, less<PSBTProprietary>, allocator<PSBTProprietary>> &_Rb_tree_const_iterator<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>> &_Rb_tree_iterator<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>> &const _Rb_tree<uint256, pair<const uint256, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>>, less<uint256>, allocator<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>>>const _Rb_tree<uint256, pair<const uint256, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>>, less<uint256>, allocator<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree<uint256, pair<const uint256, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>>, less<uint256>, allocator<pair<const uint256, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree_const_iterator<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>> &_Rb_tree_iterator<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>> &const _Rb_tree<uint160, pair<const uint160, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>>, less<uint160>, allocator<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>>>const _Rb_tree<uint160, pair<const uint160, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>>, less<uint160>, allocator<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree<uint160, pair<const uint160, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>>, less<uint160>, allocator<pair<const uint160, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree_const_iterator<pair<const CPubKey, KeyOriginInfo>> &_Rb_tree_iterator<pair<const CPubKey, KeyOriginInfo>> &const _Rb_tree<CPubKey, pair<const CPubKey, KeyOriginInfo>, _Select1st<pair<const CPubKey, KeyOriginInfo>>, less<CPubKey>, allocator<pair<const CPubKey, KeyOriginInfo>>>const _Rb_tree<CPubKey, pair<const CPubKey, KeyOriginInfo>, _Select1st<pair<const CPubKey, KeyOriginInfo>>, less<CPubKey>, allocator<pair<const CPubKey, KeyOriginInfo>>> &_Rb_tree<CPubKey, pair<const CPubKey, KeyOriginInfo>, _Select1st<pair<const CPubKey, KeyOriginInfo>>, less<CPubKey>, allocator<pair<const CPubKey, KeyOriginInfo>>> &_Rb_tree_const_iterator<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>> &_Rb_tree_iterator<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>> &const _Rb_tree<vector<unsigned char, allocator<unsigned char>>, pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>>, less<vector<unsigned char, allocator<unsigned char>>>, allocator<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>>>const _Rb_tree<vector<unsigned char, allocator<unsigned char>>, pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>>, less<vector<unsigned char, allocator<unsigned char>>>, allocator<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree<vector<unsigned char, allocator<unsigned char>>, pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>>, less<vector<unsigned char, allocator<unsigned char>>>, allocator<pair<const vector<unsigned char, allocator<unsigned char>>, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree_const_iterator<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>> &_Rb_tree_iterator<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>> &const _Rb_tree<XOnlyPubKey, pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>, _Select1st<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>>, less<XOnlyPubKey>, allocator<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>>>const _Rb_tree<XOnlyPubKey, pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>, _Select1st<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>>, less<XOnlyPubKey>, allocator<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>>> &_Rb_tree<XOnlyPubKey, pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>, _Select1st<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>>, less<XOnlyPubKey>, allocator<pair<const XOnlyPubKey, pair<set<uint256, less<uint256>, allocator<uint256>>, KeyOriginInfo>>>> &_Rb_tree_const_iterator<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>> &_Rb_tree_iterator<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>> &const _Rb_tree<pair<XOnlyPubKey, uint256>, pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>>, less<pair<XOnlyPubKey, uint256>>, allocator<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>>>const _Rb_tree<pair<XOnlyPubKey, uint256>, pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>>, less<pair<XOnlyPubKey, uint256>>, allocator<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree<pair<XOnlyPubKey, uint256>, pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>, _Select1st<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>>, less<pair<XOnlyPubKey, uint256>>, allocator<pair<const pair<XOnlyPubKey, uint256>, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree_const_iterator<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>> &_Rb_tree_iterator<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>> &const _Rb_tree<CKeyID, pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>, _Select1st<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>>, less<CKeyID>, allocator<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>>>const _Rb_tree<CKeyID, pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>, _Select1st<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>>, less<CKeyID>, allocator<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>>> &_Rb_tree<CKeyID, pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>, _Select1st<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>>, less<CKeyID>, allocator<pair<const CKeyID, pair<CPubKey, vector<unsigned char, allocator<unsigned char>>>>>> &_Rb_tree_const_iterator<pair<const XOnlyPubKey, TaprootBuilder>> &_Rb_tree_iterator<pair<const XOnlyPubKey, TaprootBuilder>> &const _Rb_tree<XOnlyPubKey, pair<const XOnlyPubKey, TaprootBuilder>, _Select1st<pair<const XOnlyPubKey, TaprootBuilder>>, less<XOnlyPubKey>, allocator<pair<const XOnlyPubKey, TaprootBuilder>>>const _Rb_tree<XOnlyPubKey, pair<const XOnlyPubKey, TaprootBuilder>, _Select1st<pair<const XOnlyPubKey, TaprootBuilder>>, less<XOnlyPubKey>, allocator<pair<const XOnlyPubKey, TaprootBuilder>>> &_Rb_tree<XOnlyPubKey, pair<const XOnlyPubKey, TaprootBuilder>, _Select1st<pair<const XOnlyPubKey, TaprootBuilder>>, less<XOnlyPubKey>, allocator<pair<const XOnlyPubKey, TaprootBuilder>>> &_Rb_tree_const_iterator<pair<const CKeyID, CKey>> &_Rb_tree_iterator<pair<const CKeyID, CKey>> &const _Rb_tree<CKeyID, pair<const CKeyID, CKey>, _Select1st<pair<const CKeyID, CKey>>, less<CKeyID>, allocator<pair<const CKeyID, CKey>>>const _Rb_tree<CKeyID, pair<const CKeyID, CKey>, _Select1st<pair<const CKeyID, CKey>>, less<CKeyID>, allocator<pair<const CKeyID, CKey>>> &_Rb_tree<CKeyID, pair<const CKeyID, CKey>, _Select1st<pair<const CKeyID, CKey>>, less<CKeyID>, allocator<pair<const CKeyID, CKey>>> &_Rb_tree_const_iterator<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>> &_Rb_tree_iterator<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>> &const _Rb_tree<CKeyID, pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>, _Select1st<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>>, less<CKeyID>, allocator<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>>>const _Rb_tree<CKeyID, pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>, _Select1st<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>>, less<CKeyID>, allocator<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>>> &_Rb_tree<CKeyID, pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>, _Select1st<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>>, less<CKeyID>, allocator<pair<const CKeyID, pair<CPubKey, KeyOriginInfo>>>> &_Rb_tree_const_iterator<pair<const CKeyID, CPubKey>> &_Rb_tree_iterator<pair<const CKeyID, CPubKey>> &const _Rb_tree<CKeyID, pair<const CKeyID, CPubKey>, _Select1st<pair<const CKeyID, CPubKey>>, less<CKeyID>, allocator<pair<const CKeyID, CPubKey>>>const _Rb_tree<CKeyID, pair<const CKeyID, CPubKey>, _Select1st<pair<const CKeyID, CPubKey>>, less<CKeyID>, allocator<pair<const CKeyID, CPubKey>>> &_Rb_tree<CKeyID, pair<const CKeyID, CPubKey>, _Select1st<pair<const CKeyID, CPubKey>>, less<CKeyID>, allocator<pair<const CKeyID, CPubKey>>> &_Rb_tree_const_iterator<pair<const CScriptID, CScript>> &_Rb_tree_iterator<pair<const CScriptID, CScript>> &const _Rb_tree<CScriptID, pair<const CScriptID, CScript>, _Select1st<pair<const CScriptID, CScript>>, less<CScriptID>, allocator<pair<const CScriptID, CScript>>>const _Rb_tree<CScriptID, pair<const CScriptID, CScript>, _Select1st<pair<const CScriptID, CScript>>, less<CScriptID>, allocator<pair<const CScriptID, CScript>>> &_Rb_tree<CScriptID, pair<const CScriptID, CScript>, _Select1st<pair<const CScriptID, CScript>>, less<CScriptID>, allocator<pair<const CScriptID, CScript>>> &_Rb_tree_const_iterator<pair<const signed long, CWalletTx *>> &_Rb_tree_iterator<pair<const signed long, CWalletTx *>> &const _Rb_tree<signed long, pair<const signed long, CWalletTx *>, _Select1st<pair<const signed long, CWalletTx *>>, less<signed long>, allocator<pair<const signed long, CWalletTx *>>>const _Rb_tree<signed long, pair<const signed long, CWalletTx *>, _Select1st<pair<const signed long, CWalletTx *>>, less<signed long>, allocator<pair<const signed long, CWalletTx *>>> &_Rb_tree<signed long, pair<const signed long, CWalletTx *>, _Select1st<pair<const signed long, CWalletTx *>>, less<signed long>, allocator<pair<const signed long, CWalletTx *>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>>>> &_Rb_tree_const_iterator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>> &const _Rb_tree<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, _Identity<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>, CompareIteratorByHash, allocator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>>const _Rb_tree<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, _Identity<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>, CompareIteratorByHash, allocator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>> &_Rb_tree<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>, _Identity<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>, CompareIteratorByHash, allocator<hashed_index_iterator<hashed_index_node<hashed_index_node<ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, ordered_index_node<null_augment_policy, index_node_base<CTxMemPoolEntry, allocator<CTxMemPoolEntry>>>>>, hashed_unique_tag>, hashed_unique_tag>, bucket_array<allocator<CTxMemPoolEntry>>, hashed_index_global_iterator_tag>>> &_Rb_tree_const_iterator<pair<const uint256, signed long>> &_Rb_tree_iterator<pair<const uint256, signed long>> &const _Rb_tree<uint256, pair<const uint256, signed long>, _Select1st<pair<const uint256, signed long>>, less<uint256>, allocator<pair<const uint256, signed long>>>const _Rb_tree<uint256, pair<const uint256, signed long>, _Select1st<pair<const uint256, signed long>>, less<uint256>, allocator<pair<const uint256, signed long>>> &_Rb_tree<uint256, pair<const uint256, signed long>, _Select1st<pair<const uint256, signed long>>, less<uint256>, allocator<pair<const uint256, signed long>>> &_Rb_tree_const_iterator<pair<const COutPoint *const, const CTransaction *>> &_Rb_tree_iterator<pair<const COutPoint *const, const CTransaction *>> &const _Rb_tree<const COutPoint *, pair<const COutPoint *const, const CTransaction *>, _Select1st<pair<const COutPoint *const, const CTransaction *>>, DereferencingComparator<const COutPoint *>, allocator<pair<const COutPoint *const, const CTransaction *>>>const _Rb_tree<const COutPoint *, pair<const COutPoint *const, const CTransaction *>, _Select1st<pair<const COutPoint *const, const CTransaction *>>, DereferencingComparator<const COutPoint *>, allocator<pair<const COutPoint *const, const CTransaction *>>> &_Rb_tree<const COutPoint *, pair<const COutPoint *const, const CTransaction *>, _Select1st<pair<const COutPoint *const, const CTransaction *>>, DereferencingComparator<const COutPoint *>, allocator<pair<const COutPoint *const, const CTransaction *>>> &_Rb_tree_const_iterator<uint256> &const _Rb_tree<uint256, uint256, _Identity<uint256>, less<uint256>, allocator<uint256>>const _Rb_tree<uint256, uint256, _Identity<uint256>, less<uint256>, allocator<uint256>> &_Rb_tree<uint256, uint256, _Identity<uint256>, less<uint256>, allocator<uint256>> &_Rb_tree_const_iterator<reference_wrapper<const CTxMemPoolEntry>> &const _Rb_tree<reference_wrapper<const CTxMemPoolEntry>, reference_wrapper<const CTxMemPoolEntry>, _Identity<reference_wrapper<const CTxMemPoolEntry>>, CompareIteratorByHash, allocator<reference_wrapper<const CTxMemPoolEntry>>>const _Rb_tree<reference_wrapper<const CTxMemPoolEntry>, reference_wrapper<const CTxMemPoolEntry>, _Identity<reference_wrapper<const CTxMemPoolEntry>>, CompareIteratorByHash, allocator<reference_wrapper<const CTxMemPoolEntry>>> &_Rb_tree<reference_wrapper<const CTxMemPoolEntry>, reference_wrapper<const CTxMemPoolEntry>, _Identity<reference_wrapper<const CTxMemPoolEntry>>, CompareIteratorByHash, allocator<reference_wrapper<const CTxMemPoolEntry>>> &_Rb_tree_const_iterator<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>> &_Rb_tree_iterator<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>> &const _Rb_tree<pair<vector<unsigned char, allocator<unsigned char>>, int>, pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>, _Select1st<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>>, less<pair<vector<unsigned char, allocator<unsigned char>>, int>>, allocator<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>>>const _Rb_tree<pair<vector<unsigned char, allocator<unsigned char>>, int>, pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>, _Select1st<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>>, less<pair<vector<unsigned char, allocator<unsigned char>>, int>>, allocator<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>>> &_Rb_tree<pair<vector<unsigned char, allocator<unsigned char>>, int>, pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>, _Select1st<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>>, less<pair<vector<unsigned char, allocator<unsigned char>>, int>>, allocator<pair<const pair<vector<unsigned char, allocator<unsigned char>>, int>, set<vector<unsigned char, allocator<unsigned char>>, ShortestVectorFirstComparator, allocator<vector<unsigned char, allocator<unsigned char>>>>>>> &<policy/settings.h><core_memusage.h>~CTxMemPoolEntryChildren &GetMemPoolChildrenGetMemPoolParentsconst Childrenconst Children &GetMemPoolChildrenConstconst Parentsconst Parents &GetMemPoolParentsConstGetSigOpCostWithAncestorsGetCountWithAncestorsGetSpendsCoinbaseGetModFeesWithDescendantsGetSizeWithDescendantsGetCountWithDescendantsUpdateLockPointsUpdateModifiedFeeUpdateAncestorStateUpdateDescendantStateGetLockPointsGetSigOpCostGetHeightGetTxWeightGetSharedTxLockPoints &&CompareIteratorByHash &CompareIteratorByHash &&const CompareIteratorByHash &const CompareIteratorByHash *CompareIteratorByHash *const reference_wrapper<T>const reference_wrapper<T> &reference_wrapper<T> &CompareIteratorByHashm_epoch_markervTxHashesIdxnCountWithAncestorsnModFeesWithDescendantsnSizeWithDescendantsnCountWithDescendantslockPointsmaxInputBlockm_modified_feeentryHeightnUsageSizenTxWeightm_childrenm_parentsBITCOIN_KERNEL_MEMPOOL_ENTRY_H// BITCOIN_KERNEL_MEMPOOL_ENTRY_H//!< epoch when last touched, useful for graph algorithms//!< Index in mempool's vTxHashes// Update the LockPoints after a reorg// Updates the modified fees with descendants/ancestors.// Adjusts the ancestor state// Adjusts the descendant state.// Analogous statistics for ancestor transactions//!< ... and total fees (all including us)//!< ... and size//!< number of descendant transactions// descendants as well.// mempool; if we remove this transaction we must remove all of these// Information about descendants of this transaction that are in the//!< Track the height and time at which tx was final//!< Used for determining the priority of the transaction for mining in a block//!< Total sigop cost//!< keep track of transactions that spend a coinbase//!< Chain height when entering the mempool//!< Local time when entering the mempool//!< ... and total memory usage//!< ... and avoid recomputing tx weight (also used for GetTxSize())//!< Cached to avoid expensive parent-transaction lookups// two aliases, should the types ever diverge/** \class CTxMemPoolEntry
 *
 * CTxMemPoolEntry stores data about the corresponding transaction, as well
 * as data about all in-mempool transactions that depend on the transaction
 * ("descendant" transactions).
 *
 * When a new entry is added to the mempool, we update the descendant state
 * (nCountWithDescendants, nSizeWithDescendants, and nModFeesWithDescendants) for
 * all ancestors of the newly added transaction.
 *
 */// (e.g. a wrapped CTxMemPoolEntry&)// SFINAE for T where T is either a pointer type (e.g., a txiter) or a reference_wrapper<T>// values are still valid even after a reorg.// containing one of the inputs used in the calculation, then the cached// As long as the current chain descends from the highest height block// constraints (BIP68) of this tx given our view of block chain history// values that would be necessary to satisfy all relative locktime// Will be set to the blockchain height and median time past/home/tanteikg/QCVE/sources/bitcoin/src/kernelfee_diffentry_heightspends_coinbasesigops_costmodifySizemodifyFeemodifyCountmodifySigOps/home/tanteikg/QCVE/sources/bitcoin/src/wallet/test/util.hgetnewaddressDuplicateMockDatabaseWalletDatabase &DatabaseOptions &CreateSyncedWalletBITCOIN_WALLET_TEST_UTIL_HWalletDatabaseDatabaseOptions// BITCOIN_WALLET_TEST_UTIL_H/** Returns a new destination, of an specific type, from the wallet *//** Returns a new encoded destination from the wallet (hardcoded to BECH32) */// Creates a copy of the provided database/home/tanteikg/QCVE/sources/bitcoin/src/wallet/test/home/tanteikg/QCVE/sources/bitcoin/src/walletoutput_typedatabasecchain/home/tanteikg/QCVE/sources/bitcoin/src/wallet/receive.h147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743/home/tanteikg/QCVE/sources/bitcoin/src/bench/wallet_balance.cpp<wallet/receive.h><validationinterface.h><wallet/test/util.h>WalletBalanceWatchWalletBalanceMineWalletBalanceCleanWalletBalanceDirtyWalletBalanceADDRESS_WATCHONLYbench/wallet_balance.cpp17179869184WALLET_FLAG_DESCRIPTORSDBErrors::LOAD_OKvoid WalletBalance(ankerl::nanobench::Bench &, bool, bool)handlerlambda [] type at line 362147, col. 76const lambda [] type at line 362147, col. 76const lambda [] type at line 362147, col. 76 &lambda [] type at line 362147, col. 76 &lambda [] type at line 362147, col. 76 &&lambda [] type at line 362147, col. 76 *operator void (*)(wallet::CWallet *)const lambda [] type at line 362147, col. 76 *const optional<basic_string<char, char_traits<char>, allocator<char>>>address_minebalbal.m_mine_trusted > 0lambda [] type at line 362159, col. 15const lambda [] type at line 362159, col. 15const lambda [] type at line 362159, col. 15 &lambda [] type at line 362159, col. 15 &lambda [] type at line 362159, col. 15 &&Balance &optional<basic_string<char, char_traits<char>, allocator<char>>> *_Optional_base<basic_string<char, char_traits<char>, allocator<char>>, false, false> *const lambda [] type at line 362159, col. 15 *lambda [] type at line 362159, col. 15 *add_mineset_dirtybench_65WalletBalanceWatchPASTE2(__LINE__, WalletBalanceWatch)65WalletBalanceWatchbench_64WalletBalanceMinePASTE2(__LINE__, WalletBalanceMine)64WalletBalanceMinebench_63WalletBalanceCleanPASTE2(__LINE__, WalletBalanceClean)63WalletBalanceCleanbench_62WalletBalanceDirtyPASTE2(__LINE__, WalletBalanceDirty)62WalletBalanceDirtyADDRESS_BCRT1_UNSPENDABLEbcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj"bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj"/*add_mine=*//*set_dirty=*/// Cacheshared_ptr<CBlock>rebind<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>rebind<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> &rebind<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> &&const rebind<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>const rebind<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> &allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>new_allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>new_allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> &const new_allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>const new_allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> &__rebind<allocator<void>, _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>, void>__rebind<allocator<void>, _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>, void> &__rebind<allocator<void>, _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>, void> &&const __rebind<allocator<void>, _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>, void>const __rebind<allocator<void>, _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>, void> &const optional<basic_string<char, char_traits<char>, allocator<char>>> *const _Optional_base<basic_string<char, char_traits<char>, allocator<char>>, false, false>const _Optional_base<basic_string<char, char_traits<char>, allocator<char>>, false, false> *const _Optional_base_impl<basic_string<char, char_traits<char>, allocator<char>>, _Optional_base<basic_string<char, char_traits<char>, allocator<char>>, false, false>>const _Optional_base_impl<basic_string<char, char_traits<char>, allocator<char>>, _Optional_base<basic_string<char, char_traits<char>, allocator<char>>, false, false>> *_Optional_base_impl<basic_string<char, char_traits<char>, allocator<char>>, _Optional_base<basic_string<char, char_traits<char>, allocator<char>>, false, false>> *CWallet *&const _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>const _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic> &_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic> &const _Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic> *_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic> *_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>__not_alloc_shared_tag<lambda [] type at line 362147, col. 76>__not_alloc_shared_tag<lambda [] type at line 362147, col. 76> &__not_alloc_shared_tag<lambda [] type at line 362147, col. 76> &&const __not_alloc_shared_tag<lambda [] type at line 362147, col. 76>const __not_alloc_shared_tag<lambda [] type at line 362147, col. 76> &__allocator_type &allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> &__shared_ptr<Notifications, _S_atomic> *__allocated_ptr<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>>__allocated_ptr<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>> &const __allocated_ptr<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>>const __allocated_ptr<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>> &allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> *_Impl &&remove_reference<lambda [] type at line 362147, col. 76 &>remove_reference<lambda [] type at line 362147, col. 76 &> &remove_reference<lambda [] type at line 362147, col. 76 &> &&const remove_reference<lambda [] type at line 362147, col. 76 &>const remove_reference<lambda [] type at line 362147, col. 76 &> &__allocated_ptr<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>> *_Sp_ebo_helper<1, allocator<void>, true> &_Sp_ebo_helper<0, lambda [] type at line 362147, col. 76, true> &allocator_traits<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>>allocator_traits<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>> &allocator_traits<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>> &&const allocator_traits<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>>const allocator_traits<allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>>> &_Sp_ebo_helper<0, lambda [] type at line 362147, col. 76, true>const _Sp_ebo_helper<0, lambda [] type at line 362147, col. 76, true>const _Sp_ebo_helper<0, lambda [] type at line 362147, col. 76, true> &_Sp_ebo_helper<0, lambda [] type at line 362147, col. 76, true> &&_Alloc_base_Del_basenew_allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> *_Sp_cd_type_Sp_cd_type *__shared_count<_S_atomic> *__allocate_guarded_Sp_ebo_helper<0, lambda [] type at line 362147, col. 76, true> *const new_allocator<_Sp_counted_deleter<CWallet *, lambda [] type at line 362147, col. 76, allocator<void>, _S_atomic>> *__is_signed_Category1_Category2__rai_type__diff1__diff2_Rb_tree_iterator<shared_ptr<COutput>> &_Rb_tree_iterator<COutPoint> &_Rb_tree_const_iterator<pair<const OutputType, vector<COutput, allocator<COutput>>>> &_Rb_tree_iterator<pair<const OutputType, vector<COutput, allocator<COutput>>>> &const _Rb_tree<OutputType, pair<const OutputType, vector<COutput, allocator<COutput>>>, _Select1st<pair<const OutputType, vector<COutput, allocator<COutput>>>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>>const _Rb_tree<OutputType, pair<const OutputType, vector<COutput, allocator<COutput>>>, _Select1st<pair<const OutputType, vector<COutput, allocator<COutput>>>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>> &_Rb_tree<OutputType, pair<const OutputType, vector<COutput, allocator<COutput>>>, _Select1st<pair<const OutputType, vector<COutput, allocator<COutput>>>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>> &_Rb_tree_const_iterator<shared_ptr<COutput>> &const _Rb_tree<shared_ptr<COutput>, shared_ptr<COutput>, _Identity<shared_ptr<COutput>>, less<shared_ptr<COutput>>, allocator<shared_ptr<COutput>>>const _Rb_tree<shared_ptr<COutput>, shared_ptr<COutput>, _Identity<shared_ptr<COutput>>, less<shared_ptr<COutput>>, allocator<shared_ptr<COutput>>> &_Rb_tree<shared_ptr<COutput>, shared_ptr<COutput>, _Identity<shared_ptr<COutput>>, less<shared_ptr<COutput>>, allocator<shared_ptr<COutput>>> &_Rb_tree_const_iterator<pair<const OutputType, Groups>> &_Rb_tree_iterator<pair<const OutputType, Groups>> &const _Rb_tree<CBlockIndex *, CBlockIndex *, _Identity<CBlockIndex *>, CBlockIndexWorkComparator, allocator<CBlockIndex *>>const _Rb_tree<CBlockIndex *, CBlockIndex *, _Identity<CBlockIndex *>, CBlockIndexWorkComparator, allocator<CBlockIndex *>> &_Rb_tree<CBlockIndex *, CBlockIndex *, _Identity<CBlockIndex *>, CBlockIndexWorkComparator, allocator<CBlockIndex *>> &_Rb_tree_const_iterator<pair<const uint256, const MempoolAcceptResult>> &_Rb_tree_iterator<pair<const uint256, const MempoolAcceptResult>> &const _Rb_tree<const uint256, pair<const uint256, const MempoolAcceptResult>, _Select1st<pair<const uint256, const MempoolAcceptResult>>, less<const uint256>, allocator<pair<const uint256, const MempoolAcceptResult>>>const _Rb_tree<const uint256, pair<const uint256, const MempoolAcceptResult>, _Select1st<pair<const uint256, const MempoolAcceptResult>>, less<const uint256>, allocator<pair<const uint256, const MempoolAcceptResult>>> &_Rb_tree<const uint256, pair<const uint256, const MempoolAcceptResult>, _Select1st<pair<const uint256, const MempoolAcceptResult>>, less<const uint256>, allocator<pair<const uint256, const MempoolAcceptResult>>> &_Rb_tree_const_iterator<pair<CBlockIndex *const, CBlockIndex *>> &_Rb_tree_iterator<pair<CBlockIndex *const, CBlockIndex *>> &const _Rb_tree<CBlockIndex *, pair<CBlockIndex *const, CBlockIndex *>, _Select1st<pair<CBlockIndex *const, CBlockIndex *>>, less<CBlockIndex *>, allocator<pair<CBlockIndex *const, CBlockIndex *>>>const _Rb_tree<CBlockIndex *, pair<CBlockIndex *const, CBlockIndex *>, _Select1st<pair<CBlockIndex *const, CBlockIndex *>>, less<CBlockIndex *>, allocator<pair<CBlockIndex *const, CBlockIndex *>>> &_Rb_tree<CBlockIndex *, pair<CBlockIndex *const, CBlockIndex *>, _Select1st<pair<CBlockIndex *const, CBlockIndex *>>, less<CBlockIndex *>, allocator<pair<CBlockIndex *const, CBlockIndex *>>> &_Rb_tree_const_iterator<CBlockIndex *> &const _Rb_tree<CBlockIndex *, CBlockIndex *, _Identity<CBlockIndex *>, less<CBlockIndex *>, allocator<CBlockIndex *>>const _Rb_tree<CBlockIndex *, CBlockIndex *, _Identity<CBlockIndex *>, less<CBlockIndex *>, allocator<CBlockIndex *>> &_Rb_tree<CBlockIndex *, CBlockIndex *, _Identity<CBlockIndex *>, less<CBlockIndex *>, allocator<CBlockIndex *>> &_Rb_tree_const_iterator<pair<const CBlockIndex *const, ThresholdState>> &_Rb_tree_iterator<pair<const CBlockIndex *const, ThresholdState>> &const _Rb_tree<const CBlockIndex *, pair<const CBlockIndex *const, ThresholdState>, _Select1st<pair<const CBlockIndex *const, ThresholdState>>, less<const CBlockIndex *>, allocator<pair<const CBlockIndex *const, ThresholdState>>>const _Rb_tree<const CBlockIndex *, pair<const CBlockIndex *const, ThresholdState>, _Select1st<pair<const CBlockIndex *const, ThresholdState>>, less<const CBlockIndex *>, allocator<pair<const CBlockIndex *const, ThresholdState>>> &_Rb_tree<const CBlockIndex *, pair<const CBlockIndex *const, ThresholdState>, _Select1st<pair<const CBlockIndex *const, ThresholdState>>, less<const CBlockIndex *>, allocator<pair<const CBlockIndex *const, ThresholdState>>> &_Rb_tree_const_iterator<pair<const COutPoint, signed long>> &_Rb_tree_iterator<pair<const COutPoint, signed long>> &const _Rb_tree<COutPoint, pair<const COutPoint, signed long>, _Select1st<pair<const COutPoint, signed long>>, less<COutPoint>, allocator<pair<const COutPoint, signed long>>>const _Rb_tree<COutPoint, pair<const COutPoint, signed long>, _Select1st<pair<const COutPoint, signed long>>, less<COutPoint>, allocator<pair<const COutPoint, signed long>>> &_Rb_tree<COutPoint, pair<const COutPoint, signed long>, _Select1st<pair<const COutPoint, signed long>>, less<COutPoint>, allocator<pair<const COutPoint, signed long>>> &_Rb_tree_const_iterator<pair<const COutPoint, CTxOut>> &_Rb_tree_iterator<pair<const COutPoint, CTxOut>> &const _Rb_tree<COutPoint, pair<const COutPoint, CTxOut>, _Select1st<pair<const COutPoint, CTxOut>>, less<COutPoint>, allocator<pair<const COutPoint, CTxOut>>>const _Rb_tree<COutPoint, pair<const COutPoint, CTxOut>, _Select1st<pair<const COutPoint, CTxOut>>, less<COutPoint>, allocator<pair<const COutPoint, CTxOut>>> &_Rb_tree<COutPoint, pair<const COutPoint, CTxOut>, _Select1st<pair<const COutPoint, CTxOut>>, less<COutPoint>, allocator<pair<const COutPoint, CTxOut>>> &_Rb_tree_const_iterator<double> &const _Rb_tree<double, double, _Identity<double>, less<double>, allocator<double>>const _Rb_tree<double, double, _Identity<double>, less<double>, allocator<double>> &_Rb_tree<double, double, _Identity<double>, less<double>, allocator<double>> &_Rb_tree_const_iterator<pair<const double, unsigned int>> &_Rb_tree_iterator<pair<const double, unsigned int>> &const _Rb_tree<double, pair<const double, unsigned int>, _Select1st<pair<const double, unsigned int>>, less<double>, allocator<pair<const double, unsigned int>>>const _Rb_tree<double, pair<const double, unsigned int>, _Select1st<pair<const double, unsigned int>>, less<double>, allocator<pair<const double, unsigned int>>> &_Rb_tree<double, pair<const double, unsigned int>, _Select1st<pair<const double, unsigned int>>, less<double>, allocator<pair<const double, unsigned int>>> &_Rb_tree_const_iterator<pair<const uint256, TxStatsInfo>> &_Rb_tree_iterator<pair<const uint256, TxStatsInfo>> &const _Rb_tree<uint256, pair<const uint256, TxStatsInfo>, _Select1st<pair<const uint256, TxStatsInfo>>, less<uint256>, allocator<pair<const uint256, TxStatsInfo>>>const _Rb_tree<uint256, pair<const uint256, TxStatsInfo>, _Select1st<pair<const uint256, TxStatsInfo>>, less<uint256>, allocator<pair<const uint256, TxStatsInfo>>> &_Rb_tree<uint256, pair<const uint256, TxStatsInfo>, _Select1st<pair<const uint256, TxStatsInfo>>, less<uint256>, allocator<pair<const uint256, TxStatsInfo>>> &map::at__N("map::at")/home/tanteikg/QCVE/sources/bitcoin/src/kernel/chain.hMakeBlockInfoBITCOIN_KERNEL_CHAIN_H// BITCOIN_KERNEL_CHAIN_H// namespace kernel//! Return data from block index.block_indexconst lambda [] type at line 158888, col. 52const lambda [] type at line 158888, col. 52 &lambda [] type at line 158888, col. 52 &lambda [] type at line 158888, col. 52 &&const lambda [] type at line 158888, col. 52 *lambda [] type at line 158888, col. 52 *lambda [] type at line 158888, col. 52/home/tanteikg/QCVE/sources/bitcoin/src/wallet/coincontrol.h1744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777/home/tanteikg/QCVE/sources/bitcoin/src/bench/wallet_create_tx.cpp<kernel/chain.h><wallet/coincontrol.h>lambda [] type at line 370398, col. 16lambda [] type at line 370398, col. 16 &&lambda [] type at line 370398, col. 16 &const lambda [] type at line 370398, col. 16const lambda [] type at line 370398, col. 16 &const lambda [] type at line 370398, col. 16 *lambda [] type at line 370398, col. 16 *return wallet::AvailableCoins(wallet).GetTotalAmount()criticalblock16bench/wallet_create_tx.cppconst CoinFilterParamsconst CoinFilterParams &CoinFilterParams &lambda [] type at line 370350, col. 27lambda [] type at line 370350, col. 27 &&lambda [] type at line 370350, col. 27 &const lambda [] type at line 370350, col. 27const lambda [] type at line 370350, col. 27 &const lambda [] type at line 370350, col. 27 *lambda [] type at line 370350, col. 27 *return wallet::AvailableCoins(wallet, nullptr, std::nullopt, filter_coins)lambda [] type at line 370339, col. 16lambda [] type at line 370339, col. 16 &&lambda [] type at line 370339, col. 16 &const lambda [] type at line 370339, col. 16const lambda [] type at line 370339, col. 16 &const lambda [] type at line 370339, col. 16 *lambda [] type at line 370339, col. 16 *lambda [] type at line 370306, col. 26lambda [] type at line 370306, col. 26 &&lambda [] type at line 370306, col. 26 &const lambda [] type at line 370306, col. 26const lambda [] type at line 370306, col. 26 &const lambda [] type at line 370306, col. 26 *lambda [] type at line 370306, col. 26 *return context.chainman->ActiveChain().Tip()lambda [] type at line 370265, col. 16lambda [] type at line 370265, col. 16 &&lambda [] type at line 370265, col. 16 &const lambda [] type at line 370265, col. 16const lambda [] type at line 370265, col. 16 &const lambda [] type at line 370265, col. 16 *lambda [] type at line 370265, col. 16 *return context.chainman->ActiveTip()WalletAvailableCoinsconst vector<OutputType, allocator<OutputType>>const vector<OutputType, allocator<OutputType>> &vector<OutputType, allocator<OutputType>> &const OutputType[1]OutputType[1]OutputType::BECH32Mconst OutputType *OutputType *WalletCreateTxUsePresetInputsAndCoinSelectionPreSelectInputs &WalletCreateTxUseOnlyPresetInputsAvailableCoinscriticalblock15const char[109]char[109]void AvailableCoins(ankerl::nanobench::Bench &, const std::vector<OutputType, std::allocator<OutputType>> &)dest_walletconst __normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>>const __normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>> &__normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>> &chain_sizeconst vector<CScript, allocator<CScript>>const __normal_iterator<CScript *, vector<CScript, allocator<CScript>>>const __normal_iterator<CScript *, vector<CScript, allocator<CScript>>> &__normal_iterator<CScript *, vector<CScript, allocator<CScript>>> &bal == 50 * COIN * (chain_size - COINBASE_MATURITY)res.All().size() == (chain_size - COINBASE_MATURITY) * 2lambda [] type at line 370401, col. 34const lambda [] type at line 370401, col. 34const lambda [] type at line 370401, col. 34 &lambda [] type at line 370401, col. 34 &lambda [] type at line 370401, col. 34 &&WalletCreateTxvoid WalletCreateTx(ankerl::nanobench::Bench &, OutputType, bool, std::optional<PreSelectInputs>)const optional<PreSelectInputs>filter_coinsCoinFilterParamsCoinFilterParams *PreSelectInputs *allow_other_inputspreset_inputsconst OutputType &const CRecipientconst CRecipient[1]CRecipient[1]const CRecipient *CRecipient *tx_reslambda [] type at line 370363, col. 34const lambda [] type at line 370363, col. 34const lambda [] type at line 370363, col. 34 &lambda [] type at line 370363, col. 34 &lambda [] type at line 370363, col. 34 &&~CCoinControlgenerateFakeBlockcoinbase_tx490000000049 * COIN1 * COINconst shared_ptr<const CTransaction>[1]shared_ptr<const CTransaction>[1]VERSIONBITS_LAST_OLD_BLOCK_VERSIONCBlockIndex *&CBlockIndex *constCBlockIndex *const &getTipTipBlock &TipBlock &&const TipBlockconst TipBlock &TipBlockTipBlock *const lambda [] type at line 370401, col. 34 *lambda [] type at line 370401, col. 34 *criticalblock17const lambda [] type at line 370363, col. 34 *lambda [] type at line 370363, col. 34 *criticalblock14const Result<CreatedTransactionResult>const Result<CreatedTransactionResult> &Result<CreatedTransactionResult> &PreSelectInputs &&const PreSelectInputsconst PreSelectInputs &PreSelectInputstip_heightprev_block_timeprev_block_hashnum_of_internal_inputsbench_184WalletAvailableCoinsPASTE2(__LINE__, WalletAvailableCoins)184WalletAvailableCoinsbench_183WalletCreateTxUsePresetInputsAndCoinSelectionPASTE2(__LINE__, WalletCreateTxUsePresetInputsAndCoinSelection)183WalletCreateTxUsePresetInputsAndCoinSelectionbench_182WalletCreateTxUseOnlyPresetInputsPASTE2(__LINE__, WalletCreateTxUseOnlyPresetInputs)182WalletCreateTxUseOnlyPresetInputs/*num_of_internal_inputs=*//*allow_other_inputs=*/// Check available balance// Generate chain; each coinbase will have two outputs to fill-up the wallet// Generate destinations// If automatic coin selection is enabled, add the value of another UTXO to the target/*feerate=*//*coinControl=*/// Select inputs, each has 49 BTC// 5k blocks means 10k UTXO for the wallet (minus 200 due COINBASE_MATURITY)// future: this could have external inputs as well.// How many coins from the wallet the process should select// notify wallet// add it to the chain// Add it to the index// extra output// Create blockcoinbase_out_script__normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>>__normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>> &&__normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>> *optional<PreSelectInputs>optional<PreSelectInputs> &optional<PreSelectInputs> &&const optional<PreSelectInputs> &vector<OutputType, allocator<OutputType>>allocator<OutputType> &_Vector_base<OutputType, allocator<OutputType>>_Vector_base<OutputType, allocator<OutputType>> &const _Vector_base<OutputType, allocator<OutputType>>const _Vector_base<OutputType, allocator<OutputType>> &_Optional_payload_base<PreSelectInputs>const map<OutputType, vector<COutput, allocator<COutput>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>>const map<OutputType, vector<COutput, allocator<COutput>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>> *map<OutputType, vector<COutput, allocator<COutput>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>> *const _Rb_tree_const_iterator<pair<const OutputType, vector<COutput, allocator<COutput>>>>const pair<const OutputType, vector<COutput, allocator<COutput>>>const vector<COutput, allocator<COutput>> &optional<PreSelectInputs> *_Optional_base<PreSelectInputs, true, true> *_Optional_base_impl<PreSelectInputs, _Optional_base<PreSelectInputs, true, true>> *const optional<PreSelectInputs> *const _Optional_base<PreSelectInputs, true, true>const _Optional_base<PreSelectInputs, true, true> *const _Optional_base_impl<PreSelectInputs, _Optional_base<PreSelectInputs, true, true>>const _Optional_base_impl<PreSelectInputs, _Optional_base<PreSelectInputs, true, true>> *const OutputType *constconst OutputType *const &OutputType *&const __normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>> *const vector<OutputType, allocator<OutputType>> *vector<OutputType, allocator<OutputType>> *const _Vector_base<OutputType, allocator<OutputType>> *_Vector_base<OutputType, allocator<OutputType>> *const initializer_list<OutputType>const new_allocator<OutputType>__alloc_traits<allocator<OutputType>, OutputType>__alloc_traits<allocator<OutputType>, OutputType> &__alloc_traits<allocator<OutputType>, OutputType> &&const __alloc_traits<allocator<OutputType>, OutputType>const __alloc_traits<allocator<OutputType>, OutputType> &_Optional_base_impl<PreSelectInputs, _Optional_base<PreSelectInputs, true, true>>_Optional_base_impl<PreSelectInputs, _Optional_base<PreSelectInputs, true, true>> &_Optional_base_impl<PreSelectInputs, _Optional_base<PreSelectInputs, true, true>> &&const _Optional_base_impl<PreSelectInputs, _Optional_base<PreSelectInputs, true, true>> &_Storage<PreSelectInputs, true>_Storage<PreSelectInputs, true> &_Storage<PreSelectInputs, true> &&const _Storage<PreSelectInputs, true>const _Storage<PreSelectInputs, true> &_Enable_copy_move<true, true, true, true, optional<PreSelectInputs>>_Enable_copy_move<true, true, true, true, optional<PreSelectInputs>> &_Enable_copy_move<true, true, true, true, optional<PreSelectInputs>> &&const _Enable_copy_move<true, true, true, true, optional<PreSelectInputs>>const _Enable_copy_move<true, true, true, true, optional<PreSelectInputs>> &_Optional_base<PreSelectInputs, true, true>allocator<OutputType> *const new_allocator<OutputType> *new_allocator<OutputType> *const _Optional_payload_base<PreSelectInputs>is_trivially_destructible<PreSelectInputs>is_trivially_destructible<PreSelectInputs> &is_trivially_destructible<PreSelectInputs> &&const is_trivially_destructible<PreSelectInputs>const is_trivially_destructible<PreSelectInputs> &is_copy_assignable<PreSelectInputs>is_copy_assignable<PreSelectInputs> &is_copy_assignable<PreSelectInputs> &&const is_copy_assignable<PreSelectInputs>const is_copy_assignable<PreSelectInputs> &is_copy_constructible<PreSelectInputs>is_copy_constructible<PreSelectInputs> &is_copy_constructible<PreSelectInputs> &&const is_copy_constructible<PreSelectInputs>const is_copy_constructible<PreSelectInputs> &__and_<is_copy_constructible<PreSelectInputs>, is_copy_assignable<PreSelectInputs>>__and_<is_copy_constructible<PreSelectInputs>, is_copy_assignable<PreSelectInputs>> &__and_<is_copy_constructible<PreSelectInputs>, is_copy_assignable<PreSelectInputs>> &&const __and_<is_copy_constructible<PreSelectInputs>, is_copy_assignable<PreSelectInputs>>const __and_<is_copy_constructible<PreSelectInputs>, is_copy_assignable<PreSelectInputs>> &is_move_assignable<PreSelectInputs>is_move_assignable<PreSelectInputs> &is_move_assignable<PreSelectInputs> &&const is_move_assignable<PreSelectInputs>const is_move_assignable<PreSelectInputs> &is_move_constructible<PreSelectInputs>is_move_constructible<PreSelectInputs> &is_move_constructible<PreSelectInputs> &&const is_move_constructible<PreSelectInputs>const is_move_constructible<PreSelectInputs> &__and_<is_move_constructible<PreSelectInputs>, is_move_assignable<PreSelectInputs>>__and_<is_move_constructible<PreSelectInputs>, is_move_assignable<PreSelectInputs>> &__and_<is_move_constructible<PreSelectInputs>, is_move_assignable<PreSelectInputs>> &&const __and_<is_move_constructible<PreSelectInputs>, is_move_assignable<PreSelectInputs>>const __and_<is_move_constructible<PreSelectInputs>, is_move_assignable<PreSelectInputs>> &is_trivially_copy_constructible<PreSelectInputs>is_trivially_copy_constructible<PreSelectInputs> &is_trivially_copy_constructible<PreSelectInputs> &&const is_trivially_copy_constructible<PreSelectInputs>const is_trivially_copy_constructible<PreSelectInputs> &is_trivially_move_constructible<PreSelectInputs>is_trivially_move_constructible<PreSelectInputs> &is_trivially_move_constructible<PreSelectInputs> &&const is_trivially_move_constructible<PreSelectInputs>const is_trivially_move_constructible<PreSelectInputs> &__not_<is_same<optional<PreSelectInputs>, type>>_Optional_payload<PreSelectInputs, true, true, true>const _Optional_payload_base<PreSelectInputs> &_Optional_payload_base<PreSelectInputs> &_Optional_payload_base<PreSelectInputs> &&_Optional_payload<PreSelectInputs, true, true, true> &_Optional_payload<PreSelectInputs, true, true, true> &&const _Optional_payload<PreSelectInputs, true, true, true>const _Optional_payload<PreSelectInputs, true, true, true> &__normal_iterator<OutputType *, vector<OutputType, allocator<OutputType>>>reverse_iterator<__normal_iterator<const OutputType *, vector<OutputType, allocator<OutputType>>>>reverse_iterator<__normal_iterator<OutputType *, vector<OutputType, allocator<OutputType>>>>remove_reference<PreSelectInputs>remove_reference<PreSelectInputs> &remove_reference<PreSelectInputs> &&const remove_reference<PreSelectInputs>const remove_reference<PreSelectInputs> &rebind<OutputType>rebind<OutputType> &rebind<OutputType> &&const rebind<OutputType>const rebind<OutputType> &const _Rb_tree<OutputType, pair<const OutputType, vector<COutput, allocator<COutput>>>, _Select1st<pair<const OutputType, vector<COutput, allocator<COutput>>>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>> *_Rb_tree<OutputType, pair<const OutputType, vector<COutput, allocator<COutput>>>, _Select1st<pair<const OutputType, vector<COutput, allocator<COutput>>>>, less<OutputType>, allocator<pair<const OutputType, vector<COutput, allocator<COutput>>>>> *_Optional_payload_base<PreSelectInputs> *OutputType *constOutputType *const &is_trivially_copy_assignable<PreSelectInputs>is_trivially_copy_assignable<PreSelectInputs> &is_trivially_copy_assignable<PreSelectInputs> &&const is_trivially_copy_assignable<PreSelectInputs>const is_trivially_copy_assignable<PreSelectInputs> &is_trivially_move_assignable<PreSelectInputs>is_trivially_move_assignable<PreSelectInputs> &is_trivially_move_assignable<PreSelectInputs> &&const is_trivially_move_assignable<PreSelectInputs>const is_trivially_move_assignable<PreSelectInputs> &__is_move_iterator<const OutputType *>__is_move_iterator<const OutputType *> &__is_move_iterator<const OutputType *> &&const __is_move_iterator<const OutputType *>const __is_move_iterator<const OutputType *> &__and_<is_same<OutputType *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<optional<PreSelectInputs>, type>__is_trivially_move_constructible_impl<PreSelectInputs, true>__is_trivially_move_constructible_impl<PreSelectInputs, true> &__is_trivially_move_constructible_impl<PreSelectInputs, true> &&const __is_trivially_move_constructible_impl<PreSelectInputs, true>const __is_trivially_move_constructible_impl<PreSelectInputs, true> &__is_trivially_copy_constructible_impl<PreSelectInputs, true>__is_trivially_copy_constructible_impl<PreSelectInputs, true> &__is_trivially_copy_constructible_impl<PreSelectInputs, true> &&const __is_trivially_copy_constructible_impl<PreSelectInputs, true>const __is_trivially_copy_constructible_impl<PreSelectInputs, true> &__is_move_constructible_impl<PreSelectInputs, true>__is_move_constructible_impl<PreSelectInputs, true> &__is_move_constructible_impl<PreSelectInputs, true> &&const __is_move_constructible_impl<PreSelectInputs, true>const __is_move_constructible_impl<PreSelectInputs, true> &__is_move_assignable_impl<PreSelectInputs, true>__is_move_assignable_impl<PreSelectInputs, true> &__is_move_assignable_impl<PreSelectInputs, true> &&const __is_move_assignable_impl<PreSelectInputs, true>const __is_move_assignable_impl<PreSelectInputs, true> &__is_copy_constructible_impl<PreSelectInputs, true>__is_copy_constructible_impl<PreSelectInputs, true> &__is_copy_constructible_impl<PreSelectInputs, true> &&const __is_copy_constructible_impl<PreSelectInputs, true>const __is_copy_constructible_impl<PreSelectInputs, true> &__is_copy_assignable_impl<PreSelectInputs, true>__is_copy_assignable_impl<PreSelectInputs, true> &__is_copy_assignable_impl<PreSelectInputs, true> &&const __is_copy_assignable_impl<PreSelectInputs, true>const __is_copy_assignable_impl<PreSelectInputs, true> &__and_<is_destructible<PreSelectInputs>, integral_constant<bool, true>>__and_<is_destructible<PreSelectInputs>, integral_constant<bool, true>> &__and_<is_destructible<PreSelectInputs>, integral_constant<bool, true>> &&const __and_<is_destructible<PreSelectInputs>, integral_constant<bool, true>>const __and_<is_destructible<PreSelectInputs>, integral_constant<bool, true>> &const allocator<OutputType>const allocator<OutputType> &const new_allocator<OutputType> &new_allocator<OutputType> &const _Rb_tree_node<pair<const OutputType, vector<COutput, allocator<COutput>>>>const _Rb_tree_node<pair<const OutputType, vector<COutput, allocator<COutput>>>> *_Rb_tree_node<pair<const OutputType, vector<COutput, allocator<COutput>>>> *__are_same<OutputType, OutputType>__are_same<OutputType, OutputType> &__are_same<OutputType, OutputType> &&const __are_same<OutputType, OutputType>const __are_same<OutputType, OutputType> &__is_pointer<OutputType *>__is_pointer<OutputType *> &__is_pointer<OutputType *> &&const __is_pointer<OutputType *>const __is_pointer<OutputType *> &__is_pointer<const OutputType *>__is_pointer<const OutputType *> &__is_pointer<const OutputType *> &&const __is_pointer<const OutputType *>const __is_pointer<const OutputType *> &is_nothrow_copy_constructible<const OutputType *>is_nothrow_copy_constructible<const OutputType *> &is_nothrow_copy_constructible<const OutputType *> &&const is_nothrow_copy_constructible<const OutputType *>const is_nothrow_copy_constructible<const OutputType *> &is_nothrow_copy_constructible<OutputType *>is_nothrow_copy_constructible<OutputType *> &is_nothrow_copy_constructible<OutputType *> &&const is_nothrow_copy_constructible<OutputType *>const is_nothrow_copy_constructible<OutputType *> &is_destructible<PreSelectInputs>is_destructible<PreSelectInputs> &is_destructible<PreSelectInputs> &&const is_destructible<PreSelectInputs>const is_destructible<PreSelectInputs> &is_assignable<PreSelectInputs &, const PreSelectInputs &>is_assignable<PreSelectInputs &, const PreSelectInputs &> &is_assignable<PreSelectInputs &, const PreSelectInputs &> &&const is_assignable<PreSelectInputs &, const PreSelectInputs &>const is_assignable<PreSelectInputs &, const PreSelectInputs &> &is_constructible<PreSelectInputs, const PreSelectInputs &>is_constructible<PreSelectInputs, const PreSelectInputs &> &is_constructible<PreSelectInputs, const PreSelectInputs &> &&const is_constructible<PreSelectInputs, const PreSelectInputs &>const is_constructible<PreSelectInputs, const PreSelectInputs &> &conditional<true, is_copy_assignable<PreSelectInputs>, is_copy_constructible<PreSelectInputs>>conditional<true, is_copy_assignable<PreSelectInputs>, is_copy_constructible<PreSelectInputs>> &conditional<true, is_copy_assignable<PreSelectInputs>, is_copy_constructible<PreSelectInputs>> &&const conditional<true, is_copy_assignable<PreSelectInputs>, is_copy_constructible<PreSelectInputs>>const conditional<true, is_copy_assignable<PreSelectInputs>, is_copy_constructible<PreSelectInputs>> &is_assignable<PreSelectInputs &, PreSelectInputs &&>is_assignable<PreSelectInputs &, PreSelectInputs &&> &is_assignable<PreSelectInputs &, PreSelectInputs &&> &&const is_assignable<PreSelectInputs &, PreSelectInputs &&>const is_assignable<PreSelectInputs &, PreSelectInputs &&> &is_constructible<PreSelectInputs, PreSelectInputs &&>is_constructible<PreSelectInputs, PreSelectInputs &&> &is_constructible<PreSelectInputs, PreSelectInputs &&> &&const is_constructible<PreSelectInputs, PreSelectInputs &&>const is_constructible<PreSelectInputs, PreSelectInputs &&> &conditional<true, is_move_assignable<PreSelectInputs>, is_move_constructible<PreSelectInputs>>conditional<true, is_move_assignable<PreSelectInputs>, is_move_constructible<PreSelectInputs>> &conditional<true, is_move_assignable<PreSelectInputs>, is_move_constructible<PreSelectInputs>> &&const conditional<true, is_move_assignable<PreSelectInputs>, is_move_constructible<PreSelectInputs>>const conditional<true, is_move_assignable<PreSelectInputs>, is_move_constructible<PreSelectInputs>> &__and_<is_copy_constructible<PreSelectInputs>, integral_constant<bool, true>>__and_<is_copy_constructible<PreSelectInputs>, integral_constant<bool, true>> &__and_<is_copy_constructible<PreSelectInputs>, integral_constant<bool, true>> &&const __and_<is_copy_constructible<PreSelectInputs>, integral_constant<bool, true>>const __and_<is_copy_constructible<PreSelectInputs>, integral_constant<bool, true>> &__is_referenceable<PreSelectInputs>__is_referenceable<PreSelectInputs> &__is_referenceable<PreSelectInputs> &&const __is_referenceable<PreSelectInputs>const __is_referenceable<PreSelectInputs> &__and_<is_move_constructible<PreSelectInputs>, integral_constant<bool, true>>__and_<is_move_constructible<PreSelectInputs>, integral_constant<bool, true>> &__and_<is_move_constructible<PreSelectInputs>, integral_constant<bool, true>> &&const __and_<is_move_constructible<PreSelectInputs>, integral_constant<bool, true>>const __and_<is_move_constructible<PreSelectInputs>, integral_constant<bool, true>> &remove_const<PreSelectInputs>remove_const<PreSelectInputs> &remove_const<PreSelectInputs> &&const remove_const<PreSelectInputs>const remove_const<PreSelectInputs> &is_same<OutputType *, _Ptr>__is_trivially_move_assignable_impl<PreSelectInputs, true>__is_trivially_move_assignable_impl<PreSelectInputs, true> &__is_trivially_move_assignable_impl<PreSelectInputs, true> &&const __is_trivially_move_assignable_impl<PreSelectInputs, true>const __is_trivially_move_assignable_impl<PreSelectInputs, true> &__is_trivially_copy_assignable_impl<PreSelectInputs, true>__is_trivially_copy_assignable_impl<PreSelectInputs, true> &__is_trivially_copy_assignable_impl<PreSelectInputs, true> &&const __is_trivially_copy_assignable_impl<PreSelectInputs, true>const __is_trivially_copy_assignable_impl<PreSelectInputs, true> &conditional<false, is_move_assignable<OutputType>, is_copy_assignable<OutputType>>conditional<false, is_move_assignable<OutputType>, is_copy_assignable<OutputType>> &conditional<false, is_move_assignable<OutputType>, is_copy_assignable<OutputType>> &&const conditional<false, is_move_assignable<OutputType>, is_copy_assignable<OutputType>>const conditional<false, is_move_assignable<OutputType>, is_copy_assignable<OutputType>> &conditional<true, integral_constant<bool, true>, is_destructible<PreSelectInputs>>conditional<true, integral_constant<bool, true>, is_destructible<PreSelectInputs>> &conditional<true, integral_constant<bool, true>, is_destructible<PreSelectInputs>> &&const conditional<true, integral_constant<bool, true>, is_destructible<PreSelectInputs>>const conditional<true, integral_constant<bool, true>, is_destructible<PreSelectInputs>> &__is_nothrow_copy_constructible_impl<OutputType *, true>__is_nothrow_copy_constructible_impl<OutputType *, true> &__is_nothrow_copy_constructible_impl<OutputType *, true> &&const __is_nothrow_copy_constructible_impl<OutputType *, true>const __is_nothrow_copy_constructible_impl<OutputType *, true> &__is_nothrow_copy_constructible_impl<const OutputType *, true>__is_nothrow_copy_constructible_impl<const OutputType *, true> &__is_nothrow_copy_constructible_impl<const OutputType *, true> &&const __is_nothrow_copy_constructible_impl<const OutputType *, true>const __is_nothrow_copy_constructible_impl<const OutputType *, true> &iterator_traits<OutputType *>iterator_traits<OutputType *> &iterator_traits<OutputType *> &&const iterator_traits<OutputType *>const iterator_traits<OutputType *> &__is_referenceable<const OutputType *>__is_referenceable<const OutputType *> &__is_referenceable<const OutputType *> &&const __is_referenceable<const OutputType *>const __is_referenceable<const OutputType *> &is_nothrow_constructible<const OutputType *, const OutputType *const &>is_nothrow_constructible<const OutputType *, const OutputType *const &> &is_nothrow_constructible<const OutputType *, const OutputType *const &> &&const is_nothrow_constructible<const OutputType *, const OutputType *const &>const is_nothrow_constructible<const OutputType *, const OutputType *const &> &__is_referenceable<OutputType *>__is_referenceable<OutputType *> &__is_referenceable<OutputType *> &&const __is_referenceable<OutputType *>const __is_referenceable<OutputType *> &is_nothrow_constructible<OutputType *, OutputType *const &>is_nothrow_constructible<OutputType *, OutputType *const &> &is_nothrow_constructible<OutputType *, OutputType *const &> &&const is_nothrow_constructible<OutputType *, OutputType *const &>const is_nothrow_constructible<OutputType *, OutputType *const &> &conditional<true, integral_constant<bool, true>, is_copy_constructible<PreSelectInputs>>conditional<true, integral_constant<bool, true>, is_copy_constructible<PreSelectInputs>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<PreSelectInputs>> &&const conditional<true, integral_constant<bool, true>, is_copy_constructible<PreSelectInputs>>const conditional<true, integral_constant<bool, true>, is_copy_constructible<PreSelectInputs>> &conditional<true, integral_constant<bool, true>, is_move_constructible<PreSelectInputs>>conditional<true, integral_constant<bool, true>, is_move_constructible<PreSelectInputs>> &conditional<true, integral_constant<bool, true>, is_move_constructible<PreSelectInputs>> &&const conditional<true, integral_constant<bool, true>, is_move_constructible<PreSelectInputs>>const conditional<true, integral_constant<bool, true>, is_move_constructible<PreSelectInputs>> &/home/tanteikg/QCVE/sources/bitcoin/src/wallet/context.hconst WalletContextconst WalletContext &~WalletContextwallet_load_fnswalletswallets_mutexBITCOIN_WALLET_CONTEXT_H// BITCOIN_WALLET_CONTEXT_H//! definitions for smart pointer and container members.//! instantiating the WalletContext struct doesn't need to #include class// this could introduce inconsistent lock ordering and cause deadlocks.// It is unsafe to lock this after locking a CWallet::cs_wallet mutex because//! behavior.//! collection of state pointers that doesn't pull in dependencies or implement//! The struct isn't intended to have any member functions. It should just be a//! variables.//! Future shared state can be added here as an alternative to adding global//! wallets.//! instances, like the reference to the chain interface, and the list of opened//! WalletContext struct containing references to state shared between CWallet/home/tanteikg/QCVE/sources/bitcoin/src/bench/wallet_loading.cpp<wallet/context.h>WalletLoadingLegacyWalletLoadingconst unique_ptr<TestingSetup, default_delete<TestingSetup>>-unsafesqlitesync"-unsafesqlitesync"DatabaseOptions *const optional<DatabaseFormat>DatabaseFormat::BERKELEYDatabaseFormat &DatabaseFormat::SQLITEunique_ptr<WalletDatabase, default_delete<WalletDatabase>> &&unique_ptr<WalletDatabase, default_delete<WalletDatabase>> &const __shared_ptr_access<CWallet, _S_atomic, false, false>shared_ptr<CWallet> &&lambda [] type at line 362247, col. 25const lambda [] type at line 362247, col. 25const lambda [] type at line 362247, col. 25 &lambda [] type at line 362247, col. 25 &lambda [] type at line 362247, col. 25 &&~DatabaseOptionsshared_ptr<CWallet> *wallet.GetNewDestination(OutputType::BECH32, "")Result<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>> &&Result<variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessV1Taproot, WitnessUnknown>> &bench/wallet_loading.cppconst UpdateWalletTxFnconst UpdateWalletTxFn &BenchUnloadWalletBenchLoadWalletconst lambda [] type at line 362247, col. 25 *lambda [] type at line 362247, col. 25 *bench_97WalletLoadingLegacyPASTE2(__LINE__, WalletLoadingLegacy)97WalletLoadingLegacyUSE_BDBUSE_SQLITE/*legacy_wallet=*/// reload the wallet for the actual benchmark// Generate a bunch of transactions and addresses to put into the wallet// Loading the wallet will also create it// Setup the walletlegacy_walletunique_ptr<TestingSetup, default_delete<TestingSetup>>default_delete<TestingSetup> &unique_ptr<TestingSetup, default_delete<TestingSetup>> *const default_delete<TestingSetup>const unique_ptr<TestingSetup, default_delete<TestingSetup>> *TestingSetup *constTestingSetup *const &const default_delete<TestingSetup> &__uniq_ptr_impl<TestingSetup, default_delete<TestingSetup>>__uniq_ptr_impl<TestingSetup, default_delete<TestingSetup>> &__uniq_ptr_impl<TestingSetup, default_delete<TestingSetup>> &&const __uniq_ptr_impl<TestingSetup, default_delete<TestingSetup>>const __uniq_ptr_impl<TestingSetup, default_delete<TestingSetup>> &default_delete<TestingSetup>default_delete<TestingSetup> &&const default_delete<TestingSetup> *default_delete<TestingSetup> *__uniq_ptr_impl<TestingSetup, default_delete<TestingSetup>> *__tuple_element_t<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>> &tuple<TestingSetup *, default_delete<TestingSetup>> &__and_<is_convertible<pointer, TestingSetup *>, __not_<is_array<_Up>>>tuple<TestingSetup *, default_delete<TestingSetup>>tuple<TestingSetup *, default_delete<TestingSetup>> &&const tuple<TestingSetup *, default_delete<TestingSetup>>const tuple<TestingSetup *, default_delete<TestingSetup>> &_Ptr<TestingSetup, default_delete<TestingSetup>, void>_Ptr<TestingSetup, default_delete<TestingSetup>, void> &_Ptr<TestingSetup, default_delete<TestingSetup>, void> &&const _Ptr<TestingSetup, default_delete<TestingSetup>, void>const _Ptr<TestingSetup, default_delete<TestingSetup>, void> &_Tuple_impl<0UL, TestingSetup *, default_delete<TestingSetup>>_Tuple_impl<0UL, TestingSetup *, default_delete<TestingSetup>> &&const _Tuple_impl<0UL, TestingSetup *, default_delete<TestingSetup>>const _Tuple_impl<0UL, TestingSetup *, default_delete<TestingSetup>> &_Tuple_impl<0UL, TestingSetup *, default_delete<TestingSetup>> &_Tuple_impl<1UL, default_delete<TestingSetup>>_Tuple_impl<1UL, default_delete<TestingSetup>> &&const _Tuple_impl<1UL, default_delete<TestingSetup>>const _Tuple_impl<1UL, default_delete<TestingSetup>> &_Tuple_impl<1UL, default_delete<TestingSetup>> &remove_reference<TestingSetup *&>remove_reference<TestingSetup *&> &remove_reference<TestingSetup *&> &&const remove_reference<TestingSetup *&>const remove_reference<TestingSetup *&> &_MakeUniq<TestingSetup>_MakeUniq<TestingSetup> &_MakeUniq<TestingSetup> &&const _MakeUniq<TestingSetup>const _MakeUniq<TestingSetup> &__tuple_element_t<1UL, tuple<TestingSetup *, default_delete<TestingSetup>>> &const __uniq_ptr_impl<TestingSetup, default_delete<TestingSetup>> *const __tuple_element_t<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>>const __tuple_element_t<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>> &_Head_base<1UL, default_delete<TestingSetup>, true>_Head_base<1UL, default_delete<TestingSetup>, true> &const _Head_base<1UL, default_delete<TestingSetup>, true>const _Head_base<1UL, default_delete<TestingSetup>, true> &_Head_base<0UL, TestingSetup *, false>_Head_base<0UL, TestingSetup *, false> &const _Head_base<0UL, TestingSetup *, false>const _Head_base<0UL, TestingSetup *, false> &is_convertible<pointer, TestingSetup *>tuple_element<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>>tuple_element<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>> &tuple_element<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>> &&const tuple_element<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>>const tuple_element<0UL, tuple<TestingSetup *, default_delete<TestingSetup>>> &_TC<value, TestingSetup *, default_delete<TestingSetup>>_TC<true, TestingSetup *, default_delete<TestingSetup>>_TC<true, TestingSetup *, default_delete<TestingSetup>> &_TC<true, TestingSetup *, default_delete<TestingSetup>> &&const _TC<true, TestingSetup *, default_delete<TestingSetup>>const _TC<true, TestingSetup *, default_delete<TestingSetup>> &tuple_element<0UL, tuple<default_delete<TestingSetup>>>tuple_element<0UL, tuple<default_delete<TestingSetup>>> &tuple_element<0UL, tuple<default_delete<TestingSetup>>> &&const tuple_element<0UL, tuple<default_delete<TestingSetup>>>const tuple_element<0UL, tuple<default_delete<TestingSetup>>> &__is_empty_non_tuple<default_delete<TestingSetup>>__is_empty_non_tuple<default_delete<TestingSetup>> &__is_empty_non_tuple<default_delete<TestingSetup>> &&const __is_empty_non_tuple<default_delete<TestingSetup>>const __is_empty_non_tuple<default_delete<TestingSetup>> &__is_empty_non_tuple<TestingSetup *>__is_empty_non_tuple<TestingSetup *> &__is_empty_non_tuple<TestingSetup *> &&const __is_empty_non_tuple<TestingSetup *>const __is_empty_non_tuple<TestingSetup *> &_Tuple_impl<0UL, TestingSetup *, default_delete<TestingSetup>> *conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestingSetup *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestingSetup *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestingSetup *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestingSetup *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<TestingSetup *>> &is_empty<TestingSetup *>is_empty<TestingSetup *> &is_empty<TestingSetup *> &&const is_empty<TestingSetup *>const is_empty<TestingSetup *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestingSetup>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestingSetup>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestingSetup>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestingSetup>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<TestingSetup>>> &is_empty<default_delete<TestingSetup>>is_empty<default_delete<TestingSetup>> &is_empty<default_delete<TestingSetup>> &&const is_empty<default_delete<TestingSetup>>const is_empty<default_delete<TestingSetup>> &tuple<default_delete<TestingSetup>>_Head_base<0UL, TestingSetup *, false> *_Tuple_impl<1UL, default_delete<TestingSetup>> *_Head_base<1UL, default_delete<TestingSetup>, true> *<asm/socket.h><bits/sockaddr.h><bits/socket_type.h><sys/types.h>cmsghdr *__cmsg_nxthdrmsghdr *linger &linger &&const lingerconst linger &ucred &ucred &&const ucredconst ucred &cmsghdr &cmsghdr &&const cmsghdrconst cmsghdr &msghdr &msghdr &&const msghdrconst msghdr &sockaddr_storage &sockaddr_storage &&const sockaddr_storageconst sockaddr_storage &sockaddr &sockaddr &&const sockaddr &lingerucredSCM_RIGHTSSCM_CREDENTIALScmsghdrmsghdrMSG_OOBMSG_PEEKMSG_DONTROUTEMSG_TRYHARDMSG_CTRUNCMSG_PROXYMSG_TRUNCMSG_DONTWAITMSG_EORMSG_WAITALLMSG_FINMSG_SYNMSG_CONFIRMMSG_RSTMSG_ERRQUEUEMSG_NOSIGNAL0x4000MSG_MORE0x8000MSG_WAITFORONEMSG_BATCH0x40000MSG_ZEROCOPY0x4000000MSG_FASTOPENMSG_CMSG_CLOEXECsockaddr_storagesockaddrl_lingerl_onoffgiduid__cmsg_datacmsg_typecmsg_levelcmsg_lenmsg_flagsmsg_controllenmsg_controlmsg_iovleniovec *msg_iovmsg_namelenmsg_name__ss_alignchar[118]_SS_PADSIZE__ss_paddingss_familyss_sa_datasa_familysa_CMSG_LEN(len)(CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))CMSG_SPACE(len)(CMSG_ALIGN (len) + CMSG_ALIGN (sizeof (struct cmsghdr)))CMSG_ALIGN(len)(((len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))CMSG_FIRSTHDR(mhdr)((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr) ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)CMSG_NXTHDR(mhdr,cmsg)__cmsg_nxthdr (mhdr, cmsg)CMSG_DATA(cmsg)((cmsg)->__cmsg_data)(_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))__ss_aligntypeunsigned long intSOMAXCONNSOL_XDPSOL_TLSSOL_KCMSOL_NFCSOL_ALGSOL_CAIFSOL_IUCVSOL_RDSSOL_PNPIPESOL_BLUETOOTHSOL_PPPOL2TPSOL_RXRPCSOL_TIPCSOL_NETLINKSOL_DCCPSOL_LLCSOL_NETBEUISOL_IRDASOL_AALSOL_ATMSOL_PACKETSOL_X25SOL_DECNETSOL_RAWAF_MAXPF_MAXAF_XDPPF_XDPAF_SMCPF_SMCAF_QIPCRTRPF_QIPCRTRAF_KCMPF_KCMAF_VSOCKPF_VSOCKAF_NFCPF_NFCAF_ALGPF_ALGAF_CAIFPF_CAIFAF_IEEE802154PF_IEEE802154AF_PHONETPF_PHONETAF_ISDNPF_ISDNAF_RXRPCPF_RXRPCAF_IUCVPF_IUCVAF_BLUETOOTHPF_BLUETOOTHAF_TIPCPF_TIPCAF_CANPF_CANAF_MPLSPF_MPLSAF_IBPF_IBAF_LLCPF_LLCAF_WANPIPEPF_WANPIPEAF_PPPOXPF_PPPOXAF_IRDAPF_IRDAAF_SNAPF_SNAAF_RDSPF_RDSAF_ATMSVCPF_ATMSVCAF_ECONETPF_ECONETAF_ASHPF_ASHAF_PACKETPF_PACKETAF_ROUTEPF_ROUTEAF_NETLINKPF_NETLINKAF_KEYPF_KEYAF_SECURITYPF_SECURITYAF_NETBEUIPF_NETBEUIAF_DECnetPF_DECnetAF_ROSEPF_ROSEAF_INET6PF_INET6AF_X25PF_X25AF_ATMPVCPF_ATMPVCAF_BRIDGEPF_BRIDGEAF_NETROMPF_NETROMAF_APPLETALKPF_APPLETALKAF_IPXPF_IPXAF_AX25PF_AX25AF_INETPF_INETAF_FILEPF_FILEAF_UNIXPF_UNIXAF_LOCALPF_LOCALAF_UNSPECPF_UNSPEC__BITS_SOCKET_H_SYS_SOCKET_H__glibc_c99_flexarr_available_EXTERN_INLINE/* bits/socket.h *//* Time to linger.  *//* Nonzero to linger on close.  *//* Structure used to manipulate the SO_LINGER option.  *//* GID of sending process.  *//* UID of sending process.  *//* PID of sending process.  *//* User visible structure for SCM_CREDENTIALS message *//* Credentials passing.  *//* Transfer file descriptors.  *//* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  *//* Use `extern inline'.  *//* No more entries.  *//* The kernel header does this so there may be a reason.  *//* Ancillary data object manipulation macros.  *//* Ancillary data.  *//* Protocol specific type.  *//* Originating protocol.  *//* Length of data in cmsg_data plus length
				   of cmsghdr structure.
				   !! The type should be socklen_t but the
				   definition of the kernel is incompatible
				   with this.  *//* Structure used for storage of ancillary data object information.  *//* Flags on received message.  *//* Ancillary data buffer length.
				   !! The type should be socklen_t but the
				   definition of the kernel is incompatible
				   with this.  *//* Ancillary data (eg BSD filedesc passing). *//* Number of elements in the vector.  *//* Vector of data to send/receive into.  *//* Length of address data.  *//* Address to send to/receive from.  *//* Structure describing messages sent by
   `sendmsg' and received by `recvmsg'.  *//* Set close_on_exit for file
					   descriptor received through
					   SCM_RIGHTS.  *//* Send data in TCP SYN.  *//* Use user data in kernel path.  *//* sendmmsg: more messages coming.  *//* Wait for at least one packet to return.*//* Sender will send more.  *//* Do not generate SIGPIPE.  *//* Fetch message from error queue.  *//* Confirm path validity.  *//* Wait for a full request.  *//* End of record.  *//* Nonblocking IO.  *//* Supply or ask second address.  *//* Control data lost before delivery.  *//* DECnet uses a different name.  *//* Don't use local routing.  *//* Peek at incoming messages.  *//* Process out-of-band data.  *//* Bits in the FLAGS argument to `send', `recv', et al.  *//* Force desired alignment.  *//* Address family, etc.  *//* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  *//* Address data.  *//* Common data: address family and length.  *//* Structure describing a generic socket address.  *//* Get the definition of the macro to define the common sockaddr members.  *//* Maximum queue length specifiable by listen.  *//* ATM Adaption Layer (packet level).  *//* ATM layer (cell level).  *//* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  *//* Address families.  *//* For now..  *//* XDP sockets.  *//* SMC sockets.  *//* Qualcomm IPC Router.  *//* Kernel Connection Multiplexor.  *//* vSockets.  *//* NFC sockets.  *//* Algorithm sockets.  *//* CAIF sockets.  *//* IEEE 802.15.4 sockets.  *//* Phonet sockets.  *//* mISDN sockets.  *//* RxRPC sockets.  *//* IUCV sockets.  *//* Bluetooth sockets.  *//* TIPC sockets.  *//* Controller Area Network.  *//* MPLS.  *//* Native InfiniBand address.  *//* Linux LLC.  *//* Wanpipe API sockets.  *//* PPPoX sockets.  *//* IRDA sockets.  *//* Linux SNA Project *//* RDS sockets.  *//* ATM SVCs.  *//* Acorn Econet.  *//* Ash.  *//* Packet family.  *//* Alias to emulate 4.4BSD.  *//* PF_KEY key management API.  *//* Security callback pseudo AF.  *//* Reserved for 802.2LLC project.  *//* Reserved for DECnet project.  *//* Amateur Radio X.25 PLP.  *//* IP version 6.  *//* Reserved for X.25 project.  *//* ATM PVCs.  *//* Multiprotocol bridge.  *//* Amateur radio NetROM.  *//* Appletalk DDP.  *//* Novell Internet Protocol.  *//* Amateur Radio AX.25.  *//* IP protocol family.  *//* Another non-standard name for PF_LOCAL.  *//* POSIX name for PF_LOCAL.  *//* Local to host (pipes and file-domain).  *//* Unspecified.  *//* Protocol families.  *//* Get the architecture-dependent definition of enum __socket_type.  *//* Type for length arguments in socket calls.  *//* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__mhdr__cmsg/home/tanteikg/QCVE/sources/bitcoin/src/compat/stdin.hStdinReadyStdinTerminalNoechoInst &const NoechoInstconst NoechoInst &NoechoInst~NoechoInstNO_STDIN_ECHO()NoechoInst _no_echoBITCOIN_COMPAT_STDIN_H// BITCOIN_COMPAT_STDIN_H// Copyright (c) 2018 The Bitcoin Core developers/home/tanteikg/QCVE/sources/bitcoin/src/compat/home/tanteikg/QCVE/sources/bitcoin/src/rpc/client.hParseNonRFCJSONValueRPCConvertNamedValuesRPCConvertValuesBITCOIN_RPC_CLIENT_H// BITCOIN_RPC_CLIENT_H/** Non-RFC4627 JSON parser, accepts internal values (such as numbers, true, false, null)
 * as well as objects and arrays.
 *//** Convert named arguments to command-specific RPC representation *//** Convert positional arguments to command-specific RPC representation */// Copyright (c) 2009-2018 The Bitcoin Core developers/home/tanteikg/QCVE/sources/bitcoin/src/rpcstrMethodstrParams/usr/include/event2/buffer.h<event2/util.h><sys/uio.h><stdarg.h><event2/event-config.h><event2/visibility.h>evbuffer_add_iovecevbuffer *evbuffer_defer_callbacksevent_base *evbuffer_unfreezeevbuffer_freezeevbuffer_prepend_bufferevbuffer_prependevbuffer_pullupevbuffer_cb_clear_flagsevbuffer_cb_entry *evbuffer_cb_set_flagsevbuffer_remove_cbevbuffer_remove_cb_entryevbuffer_add_cbevbuffer_peekevbuffer_ptr *evbuffer_search_eolevbuffer_ptr_setevbuffer_search_rangeconst evbuffer_ptrconst evbuffer_ptr *evbuffer_searchevbuffer_readevbuffer_write_atmostevbuffer_writeevbuffer_drainevbuffer_add_vprintfevbuffer_add_printfevbuffer_add_file_segmentevbuffer_file_segment *evbuffer_file_segment_add_cleanup_cbevbuffer_file_segment_freeevbuffer_file_segment_newevbuffer_add_fileevbuffer_add_referenceevbuffer_add_buffer_referenceevbuffer_add_bufferevbuffer_readlnevbuffer_remove_bufferevbuffer_copyout_fromevbuffer_copyoutevbuffer_removeevbuffer_addevbuffer_commit_spaceevbuffer_reserve_spaceevbuffer_expandevbuffer_get_contiguous_spaceconst evbufferconst evbuffer *evbuffer_get_lengthevbuffer_clear_flagsevbuffer_set_flagsevbuffer_unlockevbuffer_lockevbuffer_enable_lockingevbuffer_freeevbuffer_newevbuffer_cb_info &evbuffer_cb_info &&const evbuffer_cb_infoconst evbuffer_cb_info &evbuffer_ptr &evbuffer_ptr &&const evbuffer_ptr &evbuffer_cb_entryconst evbuffer_cb_info *evbuffer_cb_info *evbuffer_cb_funcevbuffer_cb_infoevbuffer_ptr_howEVBUFFER_PTR_SETEVBUFFER_PTR_ADDconst evbuffer_file_segmentconst evbuffer_file_segment *evbuffer_file_segment_cleanup_cbevbuffer_file_segmentevbuffer_ref_cleanup_cbevbuffer_eol_styleEVBUFFER_EOL_ANYEVBUFFER_EOL_CRLFEVBUFFER_EOL_CRLF_STRICTEVBUFFER_EOL_LFEVBUFFER_EOL_NULevbuffer_ptrevbufferevent_basen_deletedn_addedorig_sizeinternal_pos_in_chainEVBUFFER_CB_ENABLEDEVBUF_FS_DISABLE_LOCKINGEVBUF_FS_DISABLE_SENDFILEEVBUF_FS_DISABLE_MMAPEVBUF_FS_CLOSE_ON_FREEEVBUFFER_FLAG_DRAINS_TO_FDEVBUFFER_IOVEC_IS_NATIVE_evbuffer_ioveciovecEVENT2_BUFFER_H_INCLUDED_EVENT__HAVE_SYS_TYPES_HEVENT__HAVE_SYS_UIO_HEVENT_IN_DOXYGEN_/* EVENT2_BUFFER_H_INCLUDED_ *//**
  Append data from 1 or more iovec's to an evbuffer

  Calculates the number of bytes needed for an iovec structure and guarantees
  all data will fit into a single chain. Can be used in lieu of functionality
  which calls evbuffer_add() constantly before being used to increase
  performance.

  @param buffer the destination buffer
  @param vec the source iovec
  @param n_vec the number of iovec structures.
  @return the number of bytes successfully written to the output buffer.
*//**
   Force all the callbacks on an evbuffer to be run, not immediately after
   the evbuffer is altered, but instead from inside the event loop.

   This can be used to serialize all the callbacks to a single thread
   of execution.
 *//**
   Re-enable calls that modify an evbuffer.

   @param buf The buffer to un-freeze
   @param at_front If true, we unfreeze the front of the buffer.  If false,
      we unfreeze the back.
   @return 0 on success, -1 on failure.
 *//**
   Prevent calls that modify an evbuffer from succeeding. A buffer may
   frozen at the front, at the back, or at both the front and the back.

   If the front of a buffer is frozen, operations that drain data from
   the front of the buffer, or that prepend data to the buffer, will
   fail until it is unfrozen.   If the back a buffer is frozen, operations
   that append data from the buffer will fail until it is unfrozen.

   @param buf The buffer to freeze
   @param at_front If true, we freeze the front of the buffer.  If false,
      we freeze the back.
   @return 0 on success, -1 on failure.
*//**
  Prepends all data from the src evbuffer to the beginning of the dst
  evbuffer.

  @param dst the evbuffer to which to prepend data
  @param src the evbuffer to prepend; it will be emptied as a result
  @return 0 if successful, or -1 otherwise
*//**
  Prepends data to the beginning of the evbuffer

  @param buf the evbuffer to which to prepend data
  @param data a pointer to the memory to prepend
  @param size the number of bytes to prepend
  @return 0 if successful, or -1 otherwise
*//**
  Makes the data at the beginning of an evbuffer contiguous.

  @param buf the evbuffer to make contiguous
  @param size the number of bytes to make contiguous, or -1 to make the
	entire buffer contiguous.
  @return a pointer to the contiguous memory array, or NULL if param size
	requested more data than is present in the buffer.
*//** Stop postponing a callback that we postponed with evbuffer_cb_suspend.

	If data was added to or removed from the buffer while the callback was
	suspended, the callback will get called once now.

	@param the buffer that the callback is watching.
	@param cb the callback we want to stop suspending.
 *//** Postpone calling a given callback until unsuspend is called later.

    This is different from disabling the callback, since the callback will get
	invoked later if the buffer size changes between now and when we unsuspend
	it.

	@param the buffer that the callback is watching.
	@param cb the callback we want to suspend.
 *//** Change the flags that are set for a callback on a buffer by removing some

    @param buffer the evbuffer that the callback is watching.
    @param cb the callback whose status we want to change.
    @param flags EVBUFFER_CB_ENABLED to disable the callback.
    @return 0 on success, -1 on failure.
 *//** Change the flags that are set for a callback on a buffer by adding more.

    @param buffer the evbuffer that the callback is watching.
    @param cb the callback whose status we want to change.
    @param flags EVBUFFER_CB_ENABLED to re-enable the callback.
    @return 0 on success, -1 on failure.
 *//** If this flag is not set, then a callback is temporarily disabled, and
 * should not be invoked.
 *
 * @see evbuffer_cb_set_flags(), evbuffer_cb_clear_flags()
 *//** Remove a callback from an evbuffer, given the function and argument
    used to add it.

    @return 0 if a callback was removed, or -1 if no matching callback was
    found.
 *//** Remove a callback from an evbuffer, given a handle returned from
    evbuffer_add_cb.

    Calling this function invalidates the handle.

    @return 0 if a callback was removed, or -1 if no matching callback was
    found.
 *//** Add a new callback to an evbuffer.

  Subsequent calls to evbuffer_add_cb() add new callbacks.  To remove this
  callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.

  @param buffer the evbuffer to be monitored
  @param cb the callback function to invoke when the evbuffer is modified,
	or NULL to remove all callbacks.
  @param cbarg an argument to be provided to the callback function
  @return a handle to the callback on success, or NULL on failure.
 *//** Type definition for a callback that is invoked whenever data is added or
    removed from an evbuffer.

    An evbuffer may have one or more callbacks set at a time.  The order
    in which they are executed is undefined.

    A callback function may add more callbacks, or remove itself from the
    list of callbacks, or add or remove data from the buffer.  It may not
    remove another callback from the list.

    If a callback adds or removes data from the buffer or from another
    buffer, this can cause a recursive invocation of your callback or
    other callbacks.  If you ask for an infinite loop, you might just get
    one: watch out!

    @param buffer the buffer whose size has changed
    @param info a structure describing how the buffer changed.
    @param arg a pointer to user data
*//** The number of bytes removed since callbacks were last invoked. *//** The number of bytes added since callbacks were last invoked. *//** The number of bytes in this evbuffer when callbacks were last
	 * invoked. *//** Structure passed to an evbuffer_cb_func evbuffer callback

    @see evbuffer_cb_func, evbuffer_add_cb()
 *//** Function to peek at data inside an evbuffer without removing it or
    copying it out.

    Pointers to the data are returned by filling the 'vec_out' array
    with pointers to one or more extents of data inside the buffer.

    The total data in the extents that you get back may be more than
    you requested (if there is more data last extent than you asked
    for), or less (if you do not provide enough evbuffer_iovecs, or if
    the buffer does not have as much data as you asked to see).

    @param buffer the evbuffer to peek into,
    @param len the number of bytes to try to peek.  If len is negative, we
       will try to fill as much of vec_out as we can.  If len is negative
       and vec_out is not provided, we return the number of evbuffer_iovecs
       that would be needed to get all the data in the buffer.
    @param start_at an evbuffer_ptr indicating the point at which we
       should start looking for data.  NULL means, "At the start of the
       buffer."
    @param vec_out an array of evbuffer_iovec
    @param n_vec the length of vec_out.  If 0, we only count how many
       extents would be necessary to point to the requested amount of
       data.
    @return The number of extents needed.  This may be less than n_vec
       if we didn't need all the evbuffer_iovecs we were given, or more
       than n_vec if we would need more to return all the data that was
       requested.
 *//**
   Search for an end-of-line string within an evbuffer.

   @param buffer the evbuffer to be searched
   @param start NULL or a pointer to a valid struct evbuffer_ptr to start
      searching at.
   @param eol_len_out If non-NULL, the pointed-to value will be set to
      the length of the end-of-line string.
   @param eol_style The kind of EOL to look for; see evbuffer_readln() for
      more information
   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
     first occurrence EOL in the buffer after 'start'.  The 'pos'
     field of the result is -1 if the string was not found.
 *//**
   Sets the search pointer in the buffer to position.

   There are two ways to use this function: you can call
      evbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_SET)
   to move 'pos' to a position 'N' bytes after the start of the buffer, or
      evbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_ADD)
   to move 'pos' forward by 'N' bytes.

   If evbuffer_ptr is not initialized, this function can only be called
   with EVBUFFER_PTR_SET.

   An evbuffer_ptr can represent any position from the start of the buffer to
   a position immediately after the end of the buffer.

   @param buffer the evbuffer to be search
   @param ptr a pointer to a struct evbuffer_ptr
   @param position the position at which to start the next search
   @param how determines how the pointer should be manipulated.
   @returns 0 on success or -1 otherwise
*//** Advances the pointer by adding to the current position. *//** Sets the pointer to the position; can be called on with an
	    uninitialized evbuffer_ptr. *//**
   Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set()

   @see evbuffer_ptr_set() *//**
   Search for a string within part of an evbuffer.

   @param buffer the evbuffer to be searched
   @param what the string to be searched for
   @param len the length of the search string
   @param start NULL or a pointer to a valid struct evbuffer_ptr that
     indicates where we should start searching.
   @param end NULL or a pointer to a valid struct evbuffer_ptr that
     indicates where we should stop searching.
   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
     first occurrence of the string in the buffer after 'start'.  The 'pos'
     field of the result is -1 if the string was not found.
 *//**
   Search for a string within an evbuffer.

   @param buffer the evbuffer to be searched
   @param what the string to be searched for
   @param len the length of the search string
   @param start NULL or a pointer to a valid struct evbuffer_ptr.
   @return a struct evbuffer_ptr whose 'pos' field has the offset of the
     first occurrence of the string in the buffer after 'start'.  The 'pos'
     field of the result is -1 if the string was not found.
 *//**
  Read from a file descriptor and store the result in an evbuffer.

  @param buffer the evbuffer to store the result
  @param fd the file descriptor to read from
  @param howmuch the number of bytes to be read
  @return the number of bytes read, or -1 if an error occurred
  @see evbuffer_write()
 *//**
  Write some of the contents of an evbuffer to a file descriptor.

  The evbuffer will be drained after the bytes have been successfully written.

  @param buffer the evbuffer to be written and drained
  @param fd the file descriptor to be written to
  @param howmuch the largest allowable number of bytes to write, or -1
	to write as many bytes as we can.
  @return the number of bytes written, or -1 if an error occurred
  @see evbuffer_read()
 *//**
  Write the contents of an evbuffer to a file descriptor.

  The evbuffer will be drained after the bytes have been successfully written.

  @param buffer the evbuffer to be written and drained
  @param fd the file descriptor to be written to
  @return the number of bytes written, or -1 if an error occurred
  @see evbuffer_read()
 *//**
  Remove a specified number of bytes data from the beginning of an evbuffer.

  @param buf the evbuffer to be drained
  @param len the number of bytes to drain from the beginning of the buffer
  @return 0 on success, -1 on failure.
 *//**
  Append a va_list formatted string to the end of an evbuffer.

  @param buf the evbuffer that will be appended to
  @param fmt a format string
  @param ap a varargs va_list argument array that will be passed to vprintf(3)
  @return The number of bytes added if successful, or -1 if an error occurred.
 *//**
  Append a formatted string to the end of an evbuffer.

  The string is formated as printf.

  @param buf the evbuffer that will be appended to
  @param fmt a format string
  @param ... arguments that will be passed to printf(3)
  @return The number of bytes added if successful, or -1 if an error occurred.

  @see evutil_printf(), evbuffer_add_vprintf()
 *//**
   Insert some or all of an evbuffer_file_segment at the end of an evbuffer

   Note that the offset and length parameters of this function have a
   different meaning from those provided to evbuffer_file_segment_new: When
   you create the segment, the offset is the offset _within the file_, and
   the length is the length _of the segment_, whereas when you add a
   segment to an evbuffer, the offset is _within the segment_ and the
   length is the length of the _part of the segment you want to use.

   In other words, if you have a 10 KiB file, and you create an
   evbuffer_file_segment for it with offset 20 and length 1000, it will
   refer to bytes 20..1019 inclusive.  If you then pass this segment to
   evbuffer_add_file_segment and specify an offset of 20 and a length of
   50, you will be adding bytes 40..99 inclusive.

   @param buf the evbuffer to append to
   @param seg the segment to add
   @param offset the offset within the segment to start from
   @param length the amount of data to add, or -1 to add it all.
   @return 0 on success, -1 on failure.
 *//**
   Add cleanup callback and argument for the callback to an
   evbuffer_file_segment.

   The cleanup callback will be invoked when no more references to the
   evbuffer_file_segment exist.
 **//**
   Free an evbuffer_file_segment

   It is safe to call this function even if the segment has been added to
   one or more evbuffers.  The evbuffer_file_segment will not be freed
   until no more references to it exist.
 *//**
   Create and return a new evbuffer_file_segment for reading data from a
   file and sending it out via an evbuffer.

   This function avoids unnecessary data copies between userland and
   kernel.  Where available, it uses sendfile or splice.

   The file descriptor must not be closed so long as any evbuffer is using
   this segment.

   The results of using evbuffer_remove() or evbuffer_pullup() or any other
   function that reads bytes from an evbuffer on any evbuffer containing
   the newly returned segment are undefined, unless you pass the
   EVBUF_FS_DISABLE_SENDFILE flag to this function.

   @param fd an open file to read from.
   @param offset an index within the file at which to start reading
   @param length how much data to read, or -1 to read as much as possible.
      (-1 requires that 'fd' support fstat.)
   @param flags any number of the EVBUF_FS_* flags
   @return a new evbuffer_file_segment, or NULL on failure.
 **//**
   A cleanup function for a evbuffer_file_segment added to an evbuffer
   for reference.
 *//**
   Flag for creating evbuffer_file_segment: Do not allocate a lock for this
   segment.  If this option is set, then neither the segment nor any
   evbuffer it is added to may ever be accessed from more than one thread
   at a time.
 *//**
   Flag for creating evbuffer_file_segment: Disable direct fd-to-fd
   implementations (including sendfile and splice).

   You might want to use this option if data needs to be taken from the
   evbuffer by any means other than writing it to the network: the sendfile
   backend is fast, but it only works for sending files directly to the
   network.
 *//**
   Flag for creating evbuffer_file_segment: Disable memory-map based
   implementations.
 *//**
    Flag for creating evbuffer_file_segment: If this flag is set, then when
    the evbuffer_file_segment is freed and no longer in use by any
    evbuffer, the underlying fd is closed.
 *//**
  An evbuffer_file_segment holds a reference to a range of a file --
  possibly the whole file! -- for use in writing from an evbuffer to a
  socket.  It could be implemented with mmap, sendfile, splice, or (if all
  else fails) by just pulling all the data into RAM.  A single
  evbuffer_file_segment can be added more than once, and to more than one
  evbuffer.
 *//**
  Copy data from a file into the evbuffer for writing to a socket.

  This function avoids unnecessary data copies between userland and
  kernel.  If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD
  flag is set, it uses those functions.  Otherwise, it tries to use
  mmap (or CreateFileMapping on Windows).

  The function owns the resulting file descriptor and will close it
  when finished transferring data.

  The results of using evbuffer_remove() or evbuffer_pullup() on
  evbuffers whose data was added using this function are undefined.

  For more fine-grained control, use evbuffer_add_file_segment.

  @param outbuf the output buffer
  @param fd the file descriptor
  @param offset the offset from which to read data
  @param length how much data to read, or -1 to read as much as possible.
    (-1 requires that 'fd' support fstat.)
  @return 0 if successful, or -1 if an error occurred
*//**
  Reference memory into an evbuffer without copying.

  The memory needs to remain valid until all the added data has been
  read.  This function keeps just a reference to the memory without
  actually incurring the overhead of a copy.

  @param outbuf the output buffer
  @param data the memory to reference
  @param datlen how memory to reference
  @param cleanupfn callback to be invoked when the memory is no longer
	referenced by this evbuffer.
  @param cleanupfn_arg optional argument to the cleanup callback
  @return 0 if successful, or -1 if an error occurred
 *//**
   A cleanup function for a piece of memory added to an evbuffer by
   reference.

   @see evbuffer_add_reference()
 *//**
  Copy data from one evbuffer into another evbuffer.

  This is a non-destructive add.  The data from one buffer is copied
  into the other buffer.  However, no unnecessary memory copies occur.

  Note that buffers already containing buffer references can't be added
  to other buffers.

  @param outbuf the output buffer
  @param inbuf the input buffer
  @return 0 if successful, or -1 if an error occurred
 *//**
  Move all data from one evbuffer into another evbuffer.

  This is a destructive add.  The data from one buffer moves into
  the other buffer.  However, no unnecessary memory copies occur.

  @param outbuf the output buffer
  @param inbuf the input buffer
  @return 0 if successful, or -1 if an error occurred

  @see evbuffer_remove_buffer()
 *//**
 * Read a single line from an evbuffer.
 *
 * Reads a line terminated by an EOL as determined by the evbuffer_eol_style
 * argument.  Returns a newly allocated nul-terminated string; the caller must
 * free the returned value.  The EOL is not included in the returned string.
 *
 * @param buffer the evbuffer to read from
 * @param n_read_out if non-NULL, points to a size_t that is set to the
 *       number of characters in the returned string.  This is useful for
 *       strings that can contain NUL characters.
 * @param eol_style the style of line-ending to use.
 * @return pointer to a single line, or NULL if an error occurred
 *//** An EOL is a NUL character (that is, a single byte with value 0) *//** An EOL is a LF. *//** An EOL is a CR followed by an LF. *//** An EOL is an LF, optionally preceded by a CR.  This style is
	 * most useful for implementing text-based internet protocols. *//** Any sequence of CR and LF characters is acceptable as an
	 * EOL.
	 *
	 * Note that this style can produce ambiguous results: the
	 * sequence "CRLF" will be treated as a single EOL if it is
	 * all in the buffer at once, but if you first read a CR from
	 * the network and later read an LF from the network, it will
	 * be treated as two EOLs.
	 *//** Used to tell evbuffer_readln what kind of line-ending to look for.
 *//**
  Read data from an evbuffer into another evbuffer, draining
  the bytes from the source buffer.  This function avoids copy
  operations to the extent possible.

  If more bytes are requested than are available in src, the src
  buffer is drained completely.

  @param src the evbuffer to be read from
  @param dst the destination evbuffer to store the result into
  @param datlen the maximum numbers of bytes to transfer
  @return the number of bytes read
 *//**
  Read data from the middle of an evbuffer, and leave the buffer unchanged.

  If more bytes are requested than are available in the evbuffer, we
  only extract as many bytes as were available.

  @param buf the evbuffer to be read from
  @param pos the position to start reading from
  @param data_out the destination buffer to store the result
  @param datlen the maximum size of the destination buffer
  @return the number of bytes read, or -1 if we can't drain the buffer.
 *//**
  Read data from an evbuffer, and leave the buffer unchanged.

  If more bytes are requested than are available in the evbuffer, we
  only extract as many bytes as were available.

  @param buf the evbuffer to be read from
  @param data_out the destination buffer to store the result
  @param datlen the maximum size of the destination buffer
  @return the number of bytes read, or -1 if we can't drain the buffer.
 *//**
  Read data from an evbuffer and drain the bytes read.

  If more bytes are requested than are available in the evbuffer, we
  only extract as many bytes as were available.

  @param buf the evbuffer to be read from
  @param data the destination buffer to store the result
  @param datlen the maximum size of the destination buffer
  @return the number of bytes read, or -1 if we can't drain the buffer.
 *//**
  Append data to the end of an evbuffer.

  @param buf the evbuffer to be appended to
  @param data pointer to the beginning of the data buffer
  @param datlen the number of bytes to be copied from the data buffer
  @return 0 on success, -1 on failure.
 *//**
   Commits previously reserved space.

   Commits some of the space previously reserved with
   evbuffer_reserve_space().  It then becomes available for reading.

   This function may return an error if the pointer in the extents do
   not match those returned from evbuffer_reserve_space, or if data
   has been added to the buffer since the space was reserved.

   If you want to commit less data than you got reserved space for,
   modify the iov_len pointer of the appropriate extent to a smaller
   value.  Note that you may have received more space than you
   requested if it was available!

   @param buf the evbuffer in which to reserve space.
   @param vec one or two extents returned by evbuffer_reserve_space.
   @param n_vecs the number of extents.
   @return 0 on success, -1 on error
   @see evbuffer_reserve_space()
*//**
   Reserves space in the last chain or chains of an evbuffer.

   Makes space available in the last chain or chains of an evbuffer that can
   be arbitrarily written to by a user.  The space does not become
   available for reading until it has been committed with
   evbuffer_commit_space().

   The space is made available as one or more extents, represented by
   an initial pointer and a length.  You can force the memory to be
   available as only one extent.  Allowing more extents, however, makes the
   function more efficient.

   Multiple subsequent calls to this function will make the same space
   available until evbuffer_commit_space() has been called.

   It is an error to do anything that moves around the buffer's internal
   memory structures before committing the space.

   NOTE: The code currently does not ever use more than two extents.
   This may change in future versions.

   @param buf the evbuffer in which to reserve space.
   @param size how much space to make available, at minimum.  The
      total length of the extents may be greater than the requested
      length.
   @param vec an array of one or more evbuffer_iovec structures to
      hold pointers to the reserved extents of memory.
   @param n_vec The length of the vec array.  Must be at least 1;
       2 is more efficient.
   @return the number of provided extents, or -1 on error.
   @see evbuffer_commit_space()
*//**
  Expands the available space in an evbuffer.

  Expands the available space in the evbuffer to at least datlen, so that
  appending datlen additional bytes will not require any new allocations.

  @param buf the evbuffer to be expanded
  @param datlen the new minimum length requirement
  @return 0 if successful, or -1 if an error occurred
*//**
   Returns the number of contiguous available bytes in the first buffer chain.

   This is useful when processing data that might be split into multiple
   chains, or that might all be in the first chain.  Calls to
   evbuffer_pullup() that cause reallocation and copying of data can thus be
   avoided.

   @param buf pointer to the evbuffer
   @return 0 if no data is available, otherwise the number of available bytes
     in the first buffer chain.
*//**
  Returns the total number of bytes stored in the evbuffer

  @param buf pointer to the evbuffer
  @return the number of bytes stored in the evbuffer
*//** Change the flags that are set for an evbuffer by removing some.
 *
 * @param buffer the evbuffer that the callback is watching.
 * @param cb the callback whose status we want to change.
 * @param flags One or more EVBUFFER_FLAG_* options
 * @return 0 on success, -1 on failure.
 *//** Change the flags that are set for an evbuffer by adding more.
 *
 * @param buffer the evbuffer that the callback is watching.
 * @param cb the callback whose status we want to change.
 * @param flags One or more EVBUFFER_FLAG_* options
 * @return 0 on success, -1 on failure.
 *//** If this flag is set, then we will not use evbuffer_peek(),
 * evbuffer_remove(), evbuffer_remove_buffer(), and so on to read bytes
 * from this buffer: we'll only take bytes out of this buffer by
 * writing them to the network (as with evbuffer_write_atmost), by
 * removing them without observing them (as with evbuffer_drain),
 * or by copying them all out at once (as with evbuffer_add_buffer).
 *
 * Using this option allows the implementation to use sendfile-based
 * operations for evbuffer_add_file(); see that function for more
 * information.
 *
 * This flag is on by default for bufferevents that can take advantage
 * of it; you should never actually need to set it on a bufferevent's
 * output buffer.
 *//**
   Release the lock on an evbuffer.  Has no effect if locking was not enabled
   with evbuffer_enable_locking.
*//**
   Acquire the lock on an evbuffer.  Has no effect if locking was not enabled
   with evbuffer_enable_locking.
*//**
   Enable locking on an evbuffer so that it can safely be used by multiple
   threads at the same time.

   NOTE: when locking is enabled, the lock will be held when callbacks are
   invoked.  This could result in deadlock if you aren't careful.  Plan
   accordingly!

   @param buf An evbuffer to make lockable.
   @param lock A lock object, or NULL if we should allocate our own.
   @return 0 on success, -1 on failure.
 *//**
  Deallocate storage for an evbuffer.

  @param buf pointer to the evbuffer to be freed
 *//**
  Allocate storage for a new evbuffer.

  @return a pointer to a newly allocated evbuffer struct, or NULL if an error
	occurred
 *//** The length of the extent of memory. *//** The start of the extent of memory. *//* Internal use -- defined only if we are using the native struct iovec *//** Describes a single extent of memory inside an evbuffer.  Used for
    direct-access functions.

    @see evbuffer_reserve_space, evbuffer_commit_space, evbuffer_peek
 *//* Do not alter or rely on the values of fields: they are for internal
	 * use *//**
    Pointer to a position within an evbuffer.

    Used when repeatedly searching through a buffer.  Calling any function
    that modifies or re-packs the buffer contents may invalidate all
    evbuffer_ptrs for that buffer.  Do not modify or contruct these values
    except with evbuffer_ptr_set.

    An evbuffer_ptr can represent any position from the start of a buffer up
    to a position immediately after the end of a buffer.

    @see evbuffer_ptr_set()
 *//**
   An evbuffer is an opaque data type for efficiently buffering data to be
   sent or received on the network.

   @see event2/event.h for more information
*//** @file event2/buffer.h

  Functions for buffering data for network sending or receiving.

  An evbuffer can be used for preparing data before sending it to
  the network or conversely for reading data from the network.
  Evbuffers try to avoid memory copies as much as possible.  As a
  result, evbuffers can be used to pass data around without actually
  incurring the overhead of copying the data.

  A new evbuffer can be allocated with evbuffer_new(), and can be
  freed with evbuffer_free().  Most users will be using evbuffers via
  the bufferevent interface.  To access a bufferevent's evbuffers, use
  bufferevent_get_input() and bufferevent_get_output().

  There are several guidelines for using evbuffers.

  - if you already know how much data you are going to add as a result
    of calling evbuffer_add() multiple times, it makes sense to use
    evbuffer_expand() first to make sure that enough memory is allocated
    before hand.

  - evbuffer_add_buffer() adds the contents of one buffer to the other
    without incurring any unnecessary memory copies.

  - evbuffer_add() and evbuffer_add_buffer() do not mix very well:
    if you use them, you will wind up with fragmented memory in your
	buffer.

  - For high-performance code, you may want to avoid copying data into and out
    of buffers.  You can skip the copy step by using
    evbuffer_reserve_space()/evbuffer_commit_space() when writing into a
    buffer, and evbuffer_peek() when reading.

  In Libevent 2.0 and later, evbuffers are represented using a linked
  list of memory chunks, with pointers to the first and last chunk in
  the chain.

  As the contents of an evbuffer can be stored in multiple different
  memory blocks, it cannot be accessed directly.  Instead, evbuffer_pullup()
  can be used to force a specified number of bytes to be contiguous. This
  will cause memory reallocation and memory copies if the data is split
  across multiple blocks.  It is more efficient, however, to use
  evbuffer_peek() if you don't require that the memory to be contiguous.
 *//*
 * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//usr/include/event2buffern_vecat_frontcbcbargentstart_atvec_outeol_len_outeol_stylehowhowmuchapsegoutbufdatlencleanupfncleanupfn_arginbufn_read_outdata_outn_vecs/usr/include/event2/keyvalq_struct.hevkeyvalq &evkeyvalq &&const evkeyvalqconst evkeyvalq &evkeyval &evkeyval &&const evkeyvalconst evkeyval &evkeyvalqevkeyvalevkeyval *evkeyval **tqh_lasttqh_firsttqe_prevtqe_nextTAILQ_HEADTAILQ_ENTRYTAILQ_HEAD(name,type)struct name { struct type *tqh_first; struct type **tqh_last; }EVENT_DEFINED_TQHEAD_TAILQ_ENTRY(type)struct { struct type *tqe_next; struct type **tqe_prev; }EVENT_DEFINED_TQENTRY_EVENT2_KEYVALQ_STRUCT_H_INCLUDED_/* XXXX This code is duplicated with event_struct.h *//*
 * Key-Value pairs.  Can be used for HTTP headers but also for
 * query argument parsing.
 *//* !TAILQ_ENTRY *//* address of previous next element *//* next element *//* Fix so that people don't have to run with <sys/queue.h> *//*
 * Copyright (c) 2000-2007 Niels Provos <provos@citi.umich.edu>
 * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//usr/include/event2/http.hevhttp_uri_joinevhttp_uri *evhttp_uri_freeevhttp_uri_parseevhttp_uri_parse_with_flagsevhttp_uri_set_fragmentevhttp_uri_set_queryevhttp_uri_set_pathevhttp_uri_set_portevhttp_uri_set_hostevhttp_uri_set_userinfoevhttp_uri_set_schemeevhttp_uri_get_fragmentconst evhttp_uriconst evhttp_uri *evhttp_uri_get_queryevhttp_uri_get_pathevhttp_uri_get_portevhttp_uri_get_hostevhttp_uri_get_userinfoevhttp_uri_get_schemeevhttp_uri_set_flagsevhttp_uri_newevhttp_htmlescapeevhttp_parse_query_strevkeyvalq *evhttp_parse_queryevhttp_uridecodeevhttp_decode_urievhttp_uriencodeevhttp_encode_urievhttp_clear_headersevhttp_add_headerevhttp_remove_headerevhttp_find_headerconst evkeyvalq *evhttp_request_get_hostevhttp_request *evhttp_request_get_output_bufferevhttp_request_get_input_bufferevhttp_request_get_output_headersevhttp_request_get_input_headersevhttp_request_get_response_code_lineconst evhttp_requestconst evhttp_request *evhttp_request_get_response_codeevhttp_request_get_commandevhttp_request_get_evhttp_urievhttp_request_get_urievhttp_cancel_requestevhttp_make_requestevhttp_connection *evhttp_connection_get_addrevhttp_connection_get_peerevhttp_connection_set_closecbevhttp_connection_set_retriesevhttp_connection_set_initial_retry_tvconst timevalconst timeval *timeval *evhttp_connection_set_timeout_tvevhttp_connection_set_timeoutevhttp_connection_set_local_portevhttp_connection_set_local_addressevhttp_connection_free_on_completionevhttp_connection_freeevhttp_connection_set_max_body_sizeevhttp_connection_set_max_headers_sizeevhttp_connection_get_baseevhttp_request_get_connectionevhttp_request_is_ownedevhttp_request_ownevhttp_connection_set_flagsevhttp_connection_set_familyevhttp_connection_base_newevdns_base *evhttp_request_freeevhttp_request_set_on_complete_cbevhttp_request_set_error_cbevhttp_request_set_header_cbevhttp_request_set_chunked_cbevhttp_request_newevhttp *evhttp_connection_get_serverbufferevent *evhttp_connection_get_buffereventevhttp_connection_base_bufferevent_newevhttp_send_reply_endevhttp_send_reply_chunk_with_cbevhttp_send_reply_chunkevhttp_send_reply_startevhttp_send_replyevhttp_send_errorevhttp_set_flagsevhttp_set_timeout_tvevhttp_set_timeoutevhttp_remove_server_aliasevhttp_add_server_aliasevhttp_remove_virtual_hostevhttp_add_virtual_hostevhttp_set_bevcbevhttp_set_gencbevhttp_del_cbevhttp_set_cbevhttp_set_allowed_methodsevhttp_set_default_content_typeevhttp_set_max_body_sizeevhttp_set_max_headers_sizeevhttp_freeevhttp_bound_socket_get_fdevhttp_bound_socket *evhttp_del_accept_socketevhttp_foreach_bound_socketevhttp_bound_socket_foreach_fn *evconnlistener *evhttp_bound_socket_get_listenerevhttp_bind_listenerevhttp_accept_socket_with_handleevhttp_accept_socketevhttp_bind_socket_with_handleevhttp_bind_socketevhttp_newevhttp_urievhttp_request_errorEVREQ_HTTP_TIMEOUTEVREQ_HTTP_EOFEVREQ_HTTP_INVALID_HEADEREVREQ_HTTP_BUFFER_ERROREVREQ_HTTP_REQUEST_CANCELEVREQ_HTTP_DATA_TOO_LONGevhttp_request_kindEVHTTP_REQUESTEVHTTP_RESPONSEevhttp_cmd_typeEVHTTP_REQ_GETEVHTTP_REQ_POSTEVHTTP_REQ_HEADEVHTTP_REQ_PUTEVHTTP_REQ_DELETEEVHTTP_REQ_OPTIONSEVHTTP_REQ_TRACEEVHTTP_REQ_CONNECTEVHTTP_REQ_PATCHevhttp_bound_socket_foreach_fnevdns_baseevconnlistenerevhttp_bound_socketbuffereventevhttp_connectionevhttp_requestevhttpEVHTTP_URI_NONCONFORMANTEVHTTP_CON_PUBLIC_FLAGS_END0x100000EVHTTP_CON_LINGERING_CLOSE0x0020EVHTTP_CON_READ_ON_WRITE_ERROR0x0010EVHTTP_CON_REUSE_CONNECTED_ADDR0x0008EVHTTP_SERVER_LINGERING_CLOSE0x0001HTTP_SERVUNAVAILHTTP_NOTIMPLEMENTEDHTTP_INTERNALHTTP_EXPECTATIONFAILEDHTTP_ENTITYTOOLARGEHTTP_BADMETHODHTTP_NOTFOUNDHTTP_BADREQUESTHTTP_NOTMODIFIEDHTTP_MOVETEMPHTTP_MOVEPERMHTTP_NOCONTENTHTTP_OKEVENT2_HTTP_H_INCLUDED_/* EVENT2_HTTP_H_INCLUDED_ *//**
 * Join together the uri parts from parsed data to form a URI-Reference.
 *
 * Note that no escaping of reserved characters is done on the members
 * of the evhttp_uri, so the generated string might not be a valid URI
 * unless the members of evhttp_uri are themselves valid.
 *
 * @param uri container with parsed data
 * @param buf destination buffer
 * @param limit destination buffer size
 * @return an joined uri as string or NULL on error
 * @see evhttp_uri_parse()
 *//**
 * Free all memory allocated for a parsed uri.  Only use this for URIs
 * generated by evhttp_uri_parse.
 *
 * @param uri container with parsed data
 * @see evhttp_uri_parse()
 *//** Alias for evhttp_uri_parse_with_flags(source_uri, 0) *//** Tolerate URIs that do not conform to RFC3986.
 *
 * Unfortunately, some HTTP clients generate URIs that, according to RFC3986,
 * are not conformant URIs.  If you need to support these URIs, you can
 * do so by passing this flag to evhttp_uri_parse_with_flags.
 *
 * Currently, these changes are:
 * <ul>
 *   <li> Nonconformant URIs are allowed to contain otherwise unreasonable
 *        characters in their path, query, and fragment components.
 * </ul>
 *//**
 * Helper function to parse a URI-Reference as specified by RFC3986.
 *
 * This function matches the URI-Reference production from RFC3986,
 * which includes both URIs like
 *
 *    scheme://[[userinfo]@]foo.com[:port]]/[path][?query][#fragment]
 *
 *  and relative-refs like
 *
 *    [path][?query][#fragment]
 *
 * Any optional elements portions not present in the original URI are
 * left set to NULL in the resulting evhttp_uri.  If no port is
 * specified, the port is set to -1.
 *
 * Note that no decoding is performed on percent-escaped characters in
 * the string; if you want to parse them, use evhttp_uridecode or
 * evhttp_parse_query_str as appropriate.
 *
 * Note also that most URI schemes will have additional constraints that
 * this function does not know about, and cannot check.  For example,
 * mailto://www.example.com/cgi-bin/fortune.pl is not a reasonable
 * mailto url, http://www.example.com:99999/ is not a reasonable HTTP
 * URL, and ftp:username@example.com is not a reasonable FTP URL.
 * Nevertheless, all of these URLs conform to RFC3986, and this function
 * accepts all of them as valid.
 *
 * @param source_uri the request URI
 * @param flags Zero or more EVHTTP_URI_* flags to affect the behavior
 *              of the parser.
 * @return uri container to hold parsed data, or NULL if there is error
 * @see evhttp_uri_free()
 *//** Set the fragment of an evhttp_uri, or clear the fragment if fragment==NULL.
 * The fragment should not include a leading "#".
 * Returns 0 on success, -1 if fragment is not well-formed. *//** Set the query of an evhttp_uri, or clear the query if query==NULL.
 * The query should not include a leading "?".
 * Returns 0 on success, -1 if query is not well-formed. *//** Set the path of an evhttp_uri, or clear the path if path==NULL.
 * Returns 0 on success, -1 if path is not well-formed. *//** Set the port of an evhttp_uri, or clear the port if port==-1.
 * Returns 0 on success, -1 if port is not well-formed. *//** Set the host of an evhttp_uri, or clear the host if host==NULL.
 * Returns 0 on success, -1 if host is not well-formed. *//** Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==NULL.
 * Returns 0 on success, -1 if userinfo is not well-formed. *//** Set the scheme of an evhttp_uri, or clear the scheme if scheme==NULL.
 * Returns 0 on success, -1 if scheme is not well-formed. *//** Return the fragment part of an evhttp_uri (excluding the leading "#"),
 * or NULL if it has no fragment set *//** Return the query part of an evhttp_uri (excluding the leading "?"), or
 * NULL if it has no query set *//** Return the path part of an evhttp_uri, or NULL if it has no path set *//** Return the port part of an evhttp_uri, or -1 if there is no port set. *//**
 * Return the host part of an evhttp_uri, or NULL if it has no host set.
 * The host may either be a regular hostname (conforming to the RFC 3986
 * "regname" production), or an IPv4 address, or the empty string, or a
 * bracketed IPv6 address, or a bracketed 'IP-Future' address.
 *
 * Note that having a NULL host means that the URI has no authority
 * section, but having an empty-string host means that the URI has an
 * authority section with no host part.  For example,
 * "mailto:user@example.com" has a host of NULL, but "file:///etc/motd"
 * has a host of "".
 *//**
 * Return the userinfo part of an evhttp_uri, or NULL if it has no userinfo
 * set.
 *//** Return the scheme of an evhttp_uri, or NULL if there is no scheme has
 * been set and the evhttp_uri contains a Relative-Ref. *//**
 * Changes the flags set on a given URI.  See EVHTTP_URI_* for
 * a list of flags.
 **//**
 * Return a new empty evhttp_uri with no fields set.
 *//**
 * Escape HTML character entities in a string.
 *
 * Replaces <, >, ", ' and & with &lt;, &gt;, &quot;,
 * &#039; and &amp; correspondingly.
 *
 * The returned string needs to be freed by the caller.
 *
 * @param html an unescaped HTML string
 * @return an escaped HTML string or NULL on error
 *//**
   Helper function to parse out arguments from the query portion of an
   HTTP URI.

   Parsing a query string like

     q=test&s=some+thing

   will result in two entries in the key value queue.

   The first entry is: key="q", value="test"
   The second entry is: key="s", value="some thing"

   @param query_parse the query portion of the URI
   @param headers the head of the evkeyval queue
   @return 0 on success, -1 on failure
 *//**
   Helper function to parse out arguments in a query.

   Parsing a URI like

      http://foo.com/?q=test&s=some+thing

   will result in two entries in the key value queue.

   The first entry is: key="q", value="test"
   The second entry is: key="s", value="some thing"

   @deprecated This function is deprecated as of Libevent 2.0.9.  Use
     evhttp_uri_parse and evhttp_parse_query_str instead.

   @param uri the request URI
   @param headers the head of the evkeyval queue
   @return 0 on success, -1 on failure
 *//**
  Helper function to decode a URI-escaped string or HTTP parameter.

  If 'decode_plus' is 1, then we decode the string as an HTTP parameter
  value, and convert all plus ('+') characters to spaces.  If
  'decode_plus' is 0, we leave all plus characters unchanged.

  The returned string must be freed by the caller.

  @param uri a URI-encode encoded URI
  @param decode_plus determines whether we convert '+' to space.
  @param size_out if size_out is not NULL, *size_out is set to the size of the
     returned string
  @return a newly allocated unencoded URI or NULL on failure
 *//**
  Helper function to sort of decode a URI-encoded string.  Unlike
  evhttp_uridecode, it decodes all plus characters that appear
  _after_ the first question mark character, but no plusses that occur
  before.  This is not a good way to decode URIs in whole or in part.

  The returned string must be freed by the caller

  @deprecated  This function is deprecated; you probably want to use
     evhttp_uridecode instead.

  @param uri an encoded URI
  @return a newly allocated unencoded URI or NULL on failure
 *//**
   As evhttp_encode_uri, but if 'size' is nonnegative, treat the string
   as being 'size' bytes long.  This allows you to encode strings that
   may contain 0-valued bytes.

   The returned string must be freed by the caller.

   @param str an unencoded string
   @param size the length of the string to encode, or -1 if the string
      is NUL-terminated
   @param space_to_plus if true, space characters in 'str' are encoded
      as +, not %20.
   @return a newly allocate URI-encoded string, or NULL on failure.
 *//**
   Helper function to encode a string for inclusion in a URI.  All
   characters are replaced by their hex-escaped (%22) equivalents,
   except for characters explicitly unreserved by RFC3986 -- that is,
   ASCII alphanumeric characters, hyphen, dot, underscore, and tilde.

   The returned string must be freed by the caller.

   @param str an unencoded string
   @return a newly allocated URI-encoded string or NULL on failure
 *//* Miscellaneous utility functions *//**
   Removes all headers from the header list.

   @param headers the evkeyvalq object from which to remove all headers
*//**
   Adds a header to a list of existing headers.

   @param headers the evkeyvalq object to which to add a header
   @param key the name of the header
   @param value the value belonging to the header
   @returns 0 on success, -1  otherwise.
   @see evhttp_find_header(), evhttp_clear_headers()
*//**
   Removes a header from a list of existing headers.

   @param headers the evkeyvalq object from which to remove a header
   @param key the name of the header to remove
   @returns 0 if the header was removed, -1  otherwise.
   @see evhttp_find_header(), evhttp_add_header()
*//**
   Finds the value belonging to a header.

   @param headers the evkeyvalq object in which to find the header
   @param key the name of the header to find
   @returns a pointer to the value for the header or NULL if the header
     could not be found.
   @see evhttp_add_header(), evhttp_remove_header()
*//* Interfaces for dealing with HTTP headers *//** Returns the host associated with the request. If a client sends an absolute
    URI, the host part of that is preferred. Otherwise, the input headers are
    searched for a Host: header. NULL is returned if no absolute URI or Host:
    header is provided. *//** Returns the output buffer *//** Returns the input buffer *//** Returns the output headers *//** Returns the input headers *//** Returns the request command *//** Returns the request URI (parsed) *//** Returns the request URI *//**
 * A structure to hold a parsed URI or Relative-Ref conforming to RFC3986.
 *//**
   Cancels a pending HTTP request.

   Cancels an ongoing HTTP request.  The callback associated with this request
   is not executed and the request object is freed.  If the request is
   currently being processed, e.g. it is ongoing, the corresponding
   evhttp_connection object is going to get reset.

   A request cannot be canceled if its callback has executed already. A request
   may be canceled reentrantly from its chunked callback.

   @param req the evhttp_request to cancel; req becomes invalid after this call.
*//**
    Make an HTTP request over the specified connection.

    The connection gets ownership of the request.  On failure, the
    request object is no longer valid as it has been freed.

    @param evcon the evhttp_connection object over which to send the request
    @param req the previously created and configured request object
    @param type the request type EVHTTP_REQ_GET, EVHTTP_REQ_POST, etc.
    @param uri the URI associated with the request
    @return 0 on success, -1 on failure
    @see evhttp_cancel_request()
*//** Get the remote address associated with this connection.
 * extracted from getpeername() OR from nameserver.
 *
 * @return NULL if getpeername() return non success,
 * or connection is not connected,
 * otherwise it return pointer to struct sockaddr_storage *//** Get the remote address and port associated with this connection. *//** Set a callback for connection close. *//** Sets the retry limit for this connection - -1 repeats indefinitely *//** Sets the delay before retrying requests on this connection. This is only
 * used if evhttp_connection_set_retries is used to make the number of retries
 * at least one. Each retry after the first is twice as long as the one before
 * it. *//** Sets the timeout for events related to this connection.  Takes a struct
 * timeval. *//** Sets the timeout in seconds for events related to this connection *//** sets the local port from which http connections are made *//** sets the ip address from which http connections are made *//** Disowns a given connection object
 *
 * Can be used to tell libevent to free the connection object after
 * the last request has completed or failed.
 *//** Frees an http connection *//**
 * Returns the underlying event_base for this connection
 *//**
 * Returns the connection object associated with the request or NULL
 *
 * The user needs to either free the request explicitly or call
 * evhttp_send_reply_end().
 *//** Returns 1 if the request is owned by the user *//** Takes ownership of the request object
 *
 * Can be used in a request callback to keep onto the request until
 * evhttp_request_free() is explicitly called by the user.
 *//**
 * Set connection flags.
 *
 * @see EVHTTP_CON_*
 * @return 0 on success, otherwise non zero (for example if flag doesn't
 * supported).
 *//* Padding for public flags, @see EVHTTP_CON_* in http-internal.h *//* @see EVHTTP_SERVER_LINGERING_CLOSE *//* Try to read error, since server may already send and close
 * connection, but if at that time we have some data to send then we
 * can send get EPIPE and fail, while we can read that HTTP error. *//* reuse connection address on retry *//**
 * Set family hint for DNS requests.
 *//**
 * Create and return a connection object that can be used to for making HTTP
 * requests.  The connection object tries to resolve address and establish the
 * connection when it is given an http request object.
 *
 * @param base the event_base to use for handling the connection
 * @param dnsbase the dns_base to use for resolving host names; if not
 *     specified host name resolution will block.
 * @param address the address to which to connect
 * @param port the port to connect to
 * @return an evhttp_connection object that can be used for making requests or
 *   NULL on error
 *//** Frees the request object and removes associated events. *//**
 * Set a callback to be called on request completion of evhttp_send_* function.
 *
 * The callback function will be called on the completion of the request after
 * the output data has been written and before the evhttp_request object
 * is destroyed. This can be useful for tracking resources associated with a
 * request (ex: timing metrics).
 *
 * @param req a request object
 * @param cb callback function that will be called on request completion
 * @param cb_arg an additional context argument for the callback
 *//**
 * Set a callback for errors
 * @see evhttp_request_error for error types.
 *
 * On error, both the error callback and the regular callback will be called,
 * error callback is called before the regular callback.
 **//**
   * Body is greater then evhttp_connection_set_max_body_size()
   *//**
   * The evhttp_cancel_request() called on this request.
   *//**
   * Error encountered while reading or writing
   *//**
   * Error while reading header, or invalid header
   *//**
   * EOF reached
   *//**
   * Timeout reached, also @see evhttp_connection_set_timeout()
   *//**
 * The different error types supported by evhttp
 *
 * @see evhttp_request_set_error_cb()
 *//**
 * Register callback for additional parsing of request headers.
 * @param cb will be called after receiving and parsing the full header.
 * It allows analyzing the header and possibly closing the connection
 * by returning a value < 0.
 *//**
 * Enable delivery of chunks to requestor.
 * @param cb will be called after every read of data with the same argument
 *           as the completion callback. Will never be called on an empty
 *           response. May drain the input buffer; it will be drained
 *           automatically on return.
 *//**
 * Creates a new request object that needs to be filled in with the request
 * parameters.  The callback is executed when the request completed or an
 * error occurred.
 *//**
 * Return the HTTP server associated with this connection, or NULL.
 *//**
 * Return the bufferevent that an evhttp_connection is using.
 *//**
 * Create and return a connection object that can be used to for making HTTP
 * requests.  The connection object tries to resolve address and establish the
 * connection when it is given an http request object.
 *
 * @param base the event_base to use for handling the connection
 * @param dnsbase the dns_base to use for resolving host names; if not
 *     specified host name resolution will block.
 * @param bev a bufferevent to use for connecting to the server; if NULL, a
 *     socket-based bufferevent will be created.  This buffrevent will be freed
 *     when the connection closes.  It must have no fd set on it.
 * @param address the address to which to connect
 * @param port the port to connect to
 * @return an evhttp_connection object that can be used for making requests or
 *   NULL on error
 *//** a request object can represent either a request or a reply *//** The different request types supported by evhttp.  These are as specified
 * in RFC2616, except for PATCH which is specified by RFC5789.
 *
 * By default, only some of these methods are accepted and passed to user
 * callbacks; use evhttp_set_allowed_methods() to change which methods
 * are allowed.
 *//*
 * Interfaces for making requests
 *//**
   Complete a chunked reply, freeing the request as appropriate.

   @param req a request object
*//**
   Send another data chunk as part of an ongoing chunked reply.

   The reply chunk consists of the data in databuf.  After calling
   evhttp_send_reply_chunk() databuf will be empty, but the buffer is
   still owned by the caller and needs to be deallocated by the caller
   if necessary.

   @param req a request object
   @param databuf the data chunk to send as part of the reply.
   @param cb callback funcion
   @param call back's argument.
*//**
   Send another data chunk as part of an ongoing chunked reply.

   The reply chunk consists of the data in databuf.  After calling
   evhttp_send_reply_chunk() databuf will be empty, but the buffer is
   still owned by the caller and needs to be deallocated by the caller
   if necessary.

   @param req a request object
   @param databuf the data chunk to send as part of the reply.
*//**
   Initiate a reply that uses Transfer-Encoding chunked.

   This allows the caller to stream the reply back to the client and is
   useful when either not all of the reply data is immediately available
   or when sending very large replies.

   The caller needs to supply data chunks with evhttp_send_reply_chunk()
   and complete the reply by calling evhttp_send_reply_end().

   @param req a request object
   @param code the HTTP response code to send
   @param reason a brief message to send with the response code
*//* Low-level response interface, for streaming/chunked replies *//**
 * Send an HTML reply to the client.
 *
 * The body of the reply consists of the data in databuf.  After calling
 * evhttp_send_reply() databuf will be empty, but the buffer is still
 * owned by the caller and needs to be deallocated by the caller if
 * necessary.
 *
 * @param req a request object
 * @param code the HTTP response code to send
 * @param reason a brief message to send with the response code
 * @param databuf the body of the response
 *//**
 * Send an HTML error message to the client.
 *
 * @param req a request object
 * @param error the HTTP error code
 * @param reason a brief explanation of the error.  If this is NULL, we'll
 *    just use the standard meaning of the error code.
 *//* Request/Response functionality *//**
 * Set connection flags for HTTP server.
 *
 * @see EVHTTP_SERVER_*
 * @return 0 on success, otherwise non zero (for example if flag doesn't
 * supported).
 *//* Read all the clients body, and only after this respond with an error if the
 * clients body exceed max_body_size *//**
 * Set the timeout for an HTTP request.
 *
 * @param http an evhttp object
 * @param tv the timeout, or NULL
 *//**
 * Set the timeout for an HTTP request.
 *
 * @param http an evhttp object
 * @param timeout_in_secs the timeout, in seconds
 *//**
   Remove a server alias from an http object.

   @param http the evhttp object
   @param alias the alias to remove
   @see evhttp_add_server_alias()
*//**
   Add a server alias to an http object. The http object can be a virtual
   host or the main server.

   @param http the evhttp object
   @param alias the alias to add
   @see evhttp_add_remove_alias()
*//**
   Removes a virtual host from the http server.

   @param http the evhttp object from which to remove the virtual host
   @param vhost the virtual host to remove from the regular http server.
   @return 0 on success, -1 on failure
   @see evhttp_add_virtual_host()
*//**
   Adds a virtual host to the http server.

   A virtual host is a newly initialized evhttp object that has request
   callbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It
   most not have any listing sockets associated with it.

   If the virtual host has not been removed by the time that evhttp_free()
   is called on the main http server, it will be automatically freed, too.

   It is possible to have hierarchical vhosts.  For example: A vhost
   with the pattern *.example.com may have other vhosts with patterns
   foo.example.com and bar.example.com associated with it.

   @param http the evhttp object to which to add a virtual host
   @param pattern the glob pattern against which the hostname is matched.
     The match is case insensitive and follows otherwise regular shell
     matching.
   @param vhost the virtual host to add the regular http server.
   @return 0 on success, -1 on failure
   @see evhttp_remove_virtual_host()
*//**
   Set a callback used to create new bufferevents for connections
   to a given evhttp object.

   You can use this to override the default bufferevent type -- for example,
   to make this evhttp object use SSL bufferevents rather than unencrypted
   ones.

   New bufferevents must be allocated with no fd set on them.

   @param http the evhttp server object for which to set the callback
   @param cb the callback to invoke for incoming connections
   @param arg an context argument for the callback
 *//**
    Set a callback for all requests that are not caught by specific callbacks

    Invokes the specified callback for all requests that do not match any of
    the previously specified request paths.  This is catchall for requests not
    specifically configured with evhttp_set_cb().

    @param http the evhttp server object for which to set the callback
    @param cb the callback to invoke for any unmatched requests
    @param arg an context argument for the callback
*//** Removes the callback for a specified URI *//**
   Set a callback for a specified URI

   @param http the http sever on which to set the callback
   @param path the path for which to invoke the callback
   @param cb the callback function that gets invoked on requesting path
   @param cb_arg an additional context argument for the callback
   @return 0 on success, -1 if the callback existed already, -2 on failure
*//**
  Sets the what HTTP methods are supported in requests accepted by this
  server, and passed to user callbacks.

  If not supported they will generate a "405 Method not allowed" response.

  By default this includes the following methods: GET, POST, HEAD, PUT, DELETE

  @param http the http server on which to set the methods
  @param methods bit mask constructed from evhttp_cmd_type values
*//**
  Set the value to use for the Content-Type header when none was provided. If
  the content type string is NULL, the Content-Type header will not be
  automatically added.

  @param http the http server on which to set the default content type
  @param content_type the value for the Content-Type header
*//** XXX Document. *//**
 * Free the previously created HTTP server.
 *
 * Works only if no requests are currently being served.
 *
 * @param http the evhttp server object to be freed
 * @see evhttp_start()
 *//**
 * Get the raw file descriptor referenced by an evhttp_bound_socket.
 *
 * @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle
 * @return the file descriptor used by the bound socket
 * @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()
 *//**
 * Makes an HTTP server stop accepting connections on the specified socket
 *
 * This may be useful when a socket has been sent via file descriptor passing
 * and is no longer needed by the current process.
 *
 * If you created this bound socket with evhttp_bind_socket_with_handle or
 * evhttp_accept_socket_with_handle, this function closes the fd you provided.
 * If you created this bound socket with evhttp_bind_listener, this function
 * frees the listener you provided.
 *
 * \a bound_socket is an invalid pointer after this call returns.
 *
 * @param http a pointer to an evhttp object
 * @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle
 * @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()
 *//**
 * Applies the function specified in the first argument to all
 * evhttp_bound_sockets associated with "http". The user must not
 * attempt to free or remove any connections, sockets or listeners
 * in the callback "function".
 *
 * @param http pointer to an evhttp object
 * @param function function to apply to every bound socket
 * @param argument pointer value passed to function for every socket iterated
 *//**
 * Return the listener used to implement a bound socket.
 *//**
 * The most low-level evhttp_bind/accept method: takes an evconnlistener, and
 * returns an evhttp_bound_socket.  The listener will be freed when the bound
 * socket is freed.
 *//**
 * Like evhttp_accept_socket(), but returns a handle for referencing the socket.
 *
 * The returned pointer is not valid after \a http is freed.
 *
 * @param http a pointer to an evhttp object
 * @param fd a socket fd that is ready for accepting connections
 * @return Handle for the socket on success, NULL on failure.
 * @see evhttp_accept_socket(), evhttp_del_accept_socket()
 *//**
 * Makes an HTTP server accept connections on the specified socket.
 *
 * This may be useful to create a socket and then fork multiple instances
 * of an http server, or when a socket has been communicated via file
 * descriptor passing in situations where an http servers does not have
 * permissions to bind to a low-numbered port.
 *
 * Can be called multiple times to have the http server listen to
 * multiple different sockets.
 *
 * @param http a pointer to an evhttp object
 * @param fd a socket fd that is ready for accepting connections
 * @return 0 on success, -1 on failure.
 * @see evhttp_bind_socket()
 *//**
 * Like evhttp_bind_socket(), but returns a handle for referencing the socket.
 *
 * The returned pointer is not valid after \a http is freed.
 *
 * @param http a pointer to an evhttp object
 * @param address a string containing the IP address to listen(2) on
 * @param port the port number to listen on
 * @return Handle for the socket on success, NULL on failure.
 * @see evhttp_bind_socket(), evhttp_del_accept_socket()
 *//**
 * Binds an HTTP server on the specified address and port.
 *
 * Can be called multiple times to bind the same http server
 * to multiple different ports.
 *
 * @param http a pointer to an evhttp object
 * @param address a string containing the IP address to listen(2) on
 * @param port the port number to listen on
 * @return 0 on success, -1 on failure.
 * @see evhttp_accept_socket()
 *//**
 * Create a new HTTP server.
 *
 * @param base (optional) the event base to receive the HTTP events
 * @return a pointer to a newly initialized evhttp server structure or NULL
 *   on error
 * @see evhttp_free()
 *//**< the server is not available *//**< not implemented *//**< internal error *//**< we can't handle this expectation *//**<  *//**< method not allowed for this uri *//**< could not find content for uri *//**< invalid http request was made *//**< page was not modified from last *//**< the uri moved temporarily *//**< the uri moved permanently *//**< request does not have content *//**< request completed ok *//* Response codes *//** @file event2/http.h
 *
 * Basic support for HTTP serving.
 *
 * As Libevent is a library for dealing with event notification and most
 * interesting applications are networked today, I have often found the
 * need to write HTTP code.  The following prototypes and definitions provide
 * an application with a minimal interface for making HTTP requests and for
 * creating a very simple HTTP server.
 *//* In case we haven't included the right headers yet. *//* For int types. */urilimitsource_urifragmentqueryhostuserinfoschemehtmlheadersdecode_plussize_outspace_to_plusreqevconretry_maxtvtimeout_in_secsnew_max_body_sizenew_max_headers_sizefamilydnsbasecb_argbevdatabufhttpaliasvhostmethodscontent_typemax_body_sizemax_headers_sizebound_socketargumentboundlistener/home/tanteikg/QCVE/sources/bitcoin/src/support/events.h<event2/http.h><event2/event.h>obtain_evhttp_connection_baseconst unique_ptr<evhttp_connection, evhttp_connection_deleter>create connection failed"create connection failed"raii_evhttp_connection &unique_ptr<evhttp_connection, evhttp_connection_deleter> &obtain_evhttp_requestobtain_evhttpobtain_eventevent *obtain_event_baseconst unique_ptr<event_base, event_base_deleter>cannot create event_base"cannot create event_base"raii_event_base &unique_ptr<event_base, event_base_deleter> &evhttp_connection_deleter &evhttp_connection_deleter &&const evhttp_connection_deleterconst evhttp_connection_deleter &evhttp_connection_deleter *evhttp_request_deleter &evhttp_request_deleter &&const evhttp_request_deleterconst evhttp_request_deleter &evhttp_request_deleter *evhttp_deleter &evhttp_deleter &&const evhttp_deleterconst evhttp_deleter &evhttp_deleter *event_deleter &event_deleter &&const event_deleterconst event_deleter &event_deleter *eventevent_base_deleter &event_base_deleter &&const event_base_deleterconst event_base_deleter &event_base_deleter *evhttp_connection_deleterevhttp_request_deleterevhttp_deleterevent_deleterevent_base_deleterMAKE_RAII(type)struct type ## _deleter { void operator()(struct type* ob) { type ## _free(ob); }}; typedef std::unique_ptr<struct type, type ## _deleter> raii_ ## typeBITCOIN_SUPPORT_EVENTS_H// BITCOIN_SUPPORT_EVENTS_H/* unique ptr typedef *//* deleter */// Copyright (c) 2016-2018 The Bitcoin Core developerseventsob/home/tanteikg/QCVE/sources/bitcoin/src/common/url.h/home/tanteikg/QCVE/sources/bitcoin/src/rpc/mining.h/home/tanteikg/QCVE/sources/bitcoin/src/rpc/protocol.h/home/tanteikg/QCVE/sources/bitcoin/src/rpc/request.h/home/tanteikg/QCVE/sources/bitcoin/src/util/exception.h/usr/include/event2/visibility.h/usr/include/event2/event-config.h/usr/include/x86_64-linux-gnu/sys/uio.h/usr/include/x86_64-linux-gnu/bits/uio-ext.h/usr/include/event2/util.h/usr/include/x86_64-linux-gnu/sys/time.h/usr/include/event2/event.h/home/tanteikg/QCVE/sources/bitcoin/src/bitcoin-cli.cpp<support/events.h><event2/keyvalq_struct.h><event2/buffer.h><util/exception.h><rpc/request.h><rpc/protocol.h><rpc/mining.h><rpc/client.h><compat/stdin.h><common/url.h>Error: Initializing networking failed
"Error: Initializing networking failed\n"CONTINUE_EXECUTIONconst exception *exception *AppInitRPC()"AppInitRPC()" EXIT_FAILURECommandLineRPC()"CommandLineRPC()"CommandLineRPCstrPrintnRetrpcPassrh-stdinrpcpass"-stdinrpcpass"_no_echoRPC password> "RPC password> "-stdinrpcpass specified but failed to read from standard input"-stdinrpcpass specified but failed to read from standard input"-rpcpassword"-rpcpassword"-stdinwalletpassphrase"-stdinwalletpassphrase"walletPasswalletpassphrase"walletpassphrase"-stdinwalletpassphrase is only applicable for walletpassphrase(change)"-stdinwalletpassphrase is only applicable for walletpassphrase(change)"const char[71]char[71]Wallet passphrase> "Wallet passphrase> "-stdinwalletpassphrase specified but failed to read from standard input"-stdinwalletpassphrase specified but failed to read from standard input"-stdin"-stdin"-getinfo"-getinfo"GetinfoRequestHandlerGetinfoRequestHandler *BaseRequestHandlerBaseRequestHandler *-netinfo"-netinfo""help""%s\n"NetinfoRequestHandlerNetinfoRequestHandler *-generate"-generate""error"GenerateToAddressRequestHandlerGenerateToAddressRequestHandler *-addrinfo"-addrinfo"AddrinfoRequestHandlerAddrinfoRequestHandler *DefaultRequestHandlerDefaultRequestHandler *too few parameters (need at least command)"too few parameters (need at least command)"replyconst optional<basic_string<char, char_traits<char>, allocator<char>>> &optional<basic_string<char, char_traits<char>, allocator<char>>> &const unique_ptr<BaseRequestHandler, default_delete<BaseRequestHandler>>-rpcwallet"-rpcwallet"error: "error: "SetGenerateToAddressArgstoo many arguments (maximum 2 for nblocks and maxtries)"too many arguments (maximum 2 for nblocks and maxtries)"the first argument (number of blocks to generate, default: "the first argument (number of blocks to generate, default: ") must be an integer value greater than zero") must be an integer value greater than zero"GetNewAddress"getnewaddress"~DefaultRequestHandlerParseGetInfoResultRESETGREENBLUEYELLOWMAGENTACYANshould_colorize-color"-color"coloralways"always"never"never"auto"auto"Invalid value for -color option. Valid values: always, auto, never."Invalid value for -color option. Valid values: always, auto, never."[0m"\x1B[0m"[32m"\x1B[32m"[34m"\x1B[34m"[33m"\x1B[33m"[35m"\x1B[35m"[36m"\x1B[36m"result_string%sChain: %s%s
"%sChain: %s%s\n""chain"Blocks: %s
"Blocks: %s\n"blocks"blocks"Headers: %s
"Headers: %s\n""headers"ibd_progressverificationprogress"verificationprogress"ibd_progress_bar0.98999999999999999110.99Verification progress: %s%.4f%%
"Verification progress: %s%.4f%%\n"Difficulty: %s

"Difficulty: %s\n\n"difficulty"difficulty"%sNetwork: in %s, out %s, total %s%s
"%sNetwork: in %s, out %s, total %s%s\n"connections"connections""in""out"Version: %s
"Version: %s\n""version"Time offset (s): %s
"Time offset (s): %s\n"timeoffset"timeoffset"proxy_networksordered_proxiesnetworks"networks""proxy"_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &formatted_proxies%s (%s)"%s (%s)"lambda [] type at line 143449, col. 39const lambda [] type at line 143449, col. 39const lambda [] type at line 143449, col. 39 &lambda [] type at line 143449, col. 39 &lambda [] type at line 143449, col. 39 &&const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>Proxies: %s
"Proxies: %s\n"n/a"n/a"Min tx relay fee rate (%s/kvB): %s

"Min tx relay fee rate (%s/kvB): %s\n\n"relayfee"relayfee"has_wallet"has_wallet"walletname"walletname"%sWallet: %s%s
"%sWallet: %s%s\n""\"\""Keypool size: %s
"Keypool size: %s\n"keypoolsize"keypoolsize"unlocked_until"unlocked_until"Unlocked until: %s
"Unlocked until: %s\n"Transaction fee rate (-paytxfee) (%s/kvB): %s

"Transaction fee rate (-paytxfee) (%s/kvB): %s\n\n"paytxfee"paytxfee""balance"%sBalance:%s %s

"%sBalance:%s %s\n\n""balances"max_balance_length%sBalances%s
"%sBalances%s\n"const __normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &%*s %s
"%*s %s\n""warnings"%sWarnings:%s %s"%sWarnings:%s %s"(none)"(none)"GetProgressBarINCREMENTCOMPLETE_BARINCOMPLETE_BAR"\u2591""\u2592"GetWalletBalanceslistwallets"listwallets"progress_barUniValue::VOBJgetbalances"getbalances"mine"mine"trusted"trusted"ParseErrorerr_code"code"err_msg"message"error code: "error code: "error message:
"error message:\n"RPC_WALLET_NOT_SPECIFIED
Try adding "-rpcwallet=<filename>" option to bitcoin-cli command line."\nTry adding \"-rpcwallet=<filename>\" option to bitcoin-cli command line."ParseResultConnectAndCallRPCresponsefWait-rpcwait"-rpcwait"timeout-rpcwaittimeout"-rpcwaittimeout"DEFAULT_WAIT_CLIENT_TIMEOUTdeadline-28RPC_IN_WARMUPserver in warmup"server in warmup"const CConnectionFailedconst CConnectionFailed &CConnectionFailed &timeout on transient error: %s"timeout on transient error: %s"CallRPCconst CBaseChainParamsconst CBaseChainParams &CBaseChainParams &-rpcconnect"-rpcconnect"-rpcport"-rpcport"-rpcclienttimeout"-rpcclienttimeout"DEFAULT_HTTP_CLIENT_TIMEOUTYEAR_IN_SECONDS31556952 315569521577847605 * YEAR_IN_SECONDSHTTPReply *const unique_ptr<evhttp_request, evhttp_request_deleter>const unique_ptr<evhttp_request, evhttp_request_deleter> &unique_ptr<evhttp_request, evhttp_request_deleter> &create http request failed"create http request failed"strRPCUserColonPassfailedToGetAuthCookie-rpcuser"-rpcuser":":"output_headersbitcoin-cli.cppconst char[427]char[427]UniValue CallRPC(BaseRequestHandler *, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, const std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &, const std::optional<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>> &)Host"Host"Connection"Connection""close"Content-Type"Content-Type"application/json"application/json"Authorization"Authorization"Basic "Basic "strRequestoutput_bufferendpointencodedURIconst basic_string<char, char_traits<char>, allocator<char>> */wallet/"/wallet/"uri-encode failed"uri-encode failed"send http request failed"send http request failed"responseErrorMessage (error code %d - "%s")" (error code %d - \"%s\")"Could not connect to the server %s:%d%s

Make sure the bitcoind server is running and that you are connecting to the correct RPC port."Could not connect to the server %s:%d%s\n\nMake sure the bitcoind server is running and that you are connecting to the correct RPC port."HTTP_UNAUTHORIZEDCould not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)"Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)"const char[167]char[167]Authorization failed: Incorrect rpcuser or rpcpassword"Authorization failed: Incorrect rpcuser or rpcpassword"HTTP_SERVICE_UNAVAILABLEServer response: %s"Server response: %s"rpcwalletHTTP_BAD_REQUESTHTTP_NOT_FOUNDHTTP_INTERNAL_SERVER_ERRORserver returned HTTP error %d"server returned HTTP error %d"no response from server"no response from server"valReplyUniValue::VSTRcouldn't parse reply from server"couldn't parse reply from server"expected reply to have result, error and id properties"expected reply to have result, error and id properties"~HTTPReplyhttp_error_cbhttp_request_donehttp_errorstringtimeout reached"timeout reached"EOF reached"EOF reached"error while reading header, or invalid header"error while reading header, or invalid header"error encountered while reading or writing"error encountered while reading or writing"request was canceled"request was canceled"response body is larger than allowed"response body is larger than allowed"unknown"unknown"AppInitRPC-version"-version"strUsageBitcoin Core RPC client version 
Usage:  bitcoin-cli [options] <command> [params]  Send command to Bitcoin Core
or:     bitcoin-cli [options] -named <command> [name=value]...  Send command to Bitcoin Core (with named arguments)
or:     bitcoin-cli [options] help                List commands
or:     bitcoin-cli [options] help <command>      Get help for a command
"\n"
                "Usage:  bitcoin-cli [options] <command> [params]  Send command to " PACKAGE_NAME "\n"
                "or:     bitcoin-cli [options] -named <command> [name=value]...  Send command to " PACKAGE_NAME " (with named arguments)\n"
                "or:     bitcoin-cli [options] help                List commands\n"
                "or:     bitcoin-cli [options] help <command>      Get help for a command\n"const char[334]char[334]Error: too few parameters
"Error: too few parameters\n"Error: Specified data directory "%s" does not exist.
"Error: Specified data directory \"%s\" does not exist.\n"-datadir"-datadir"Error reading configuration file: %s
"Error reading configuration file: %s\n"libevent_log_cbEVENT_LOG_ERRlibevent error: %s"libevent error: %s"SetupCliArgsconst unique_ptr<CBaseChainParams, default_delete<CBaseChainParams>>defaultBaseParamstestnetBaseParamssignetBaseParamsregtestBaseParamsPrint version and exit"Print version and exit"-conf=<file>"-conf=<file>"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)"-datadir=<dir>"-datadir=<dir>"Specify data directory"Specify data directory"Generate blocks, equivalent to RPC getnewaddress followed by RPC generatetoaddress. Optional positional integer arguments are number of blocks to generate (default: %s) and maximum iterations to try (default: %s), equivalent to RPC generatetoaddress nblocks and maxtries arguments. Example: bitcoin-cli -generate 4 1000"Generate blocks, equivalent to RPC getnewaddress followed by RPC generatetoaddress. Optional positional integer "
                             "arguments are number of blocks to generate (default: %s) and maximum iterations to try (default: %s), equivalent to "
                             "RPC generatetoaddress nblocks and maxtries arguments. Example: bitcoin-cli -generate 4 1000"const char[320]char[320]const uint64_t &Get the number of addresses known to the node, per network and total, after filtering for quality and recency. The total number of addresses known to the node may be higher."Get the number of addresses known to the node, per network and total, after filtering for quality and recency. The total number of addresses known to the node may be higher."const char[174]char[174]Get general information from the remote server. Note that unlike server-side RPC calls, the output of -getinfo is the result of multiple non-atomic requests. Some entries in the output may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)"Get general information from the remote server. Note that unlike server-side RPC calls, the output of -getinfo is the result of multiple non-atomic requests. Some entries in the output may represent results from different states (e.g. wallet balance may be as of a different block from the chain state reported)"const char[312]char[312]Get network peer connection information from the remote server. An optional integer argument from 0 to 4 can be passed for different peers listings (default: 0). Pass "help" for detailed help documentation."Get network peer connection information from the remote server. An optional integer argument from 0 to 4 can be passed for different peers listings (default: 0). Pass \"help\" for detailed help documentation."const char[207]char[207]-color=<when>"-color=<when>"Color setting for CLI output (default: %s). Valid values: always, auto (add color codes when standard output is connected to a terminal and OS is not WIN32), never."Color setting for CLI output (default: %s). Valid values: always, auto (add color codes when standard output is connected to a terminal and OS is not WIN32), never."const char[165]char[165]-named"-named"Pass named instead of positional arguments (default: %s)"Pass named instead of positional arguments (default: %s)"-rpcclienttimeout=<n>"-rpcclienttimeout=<n>"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)"const char[76]char[76]-rpcconnect=<ip>"-rpcconnect=<ip>"Send commands to node running on <ip> (default: %s)"Send commands to node running on <ip> (default: %s)"-rpccookiefile=<loc>"-rpccookiefile=<loc>"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"const char[117]char[117]-rpcpassword=<pw>"-rpcpassword=<pw>"Password for JSON-RPC connections"Password for JSON-RPC connections"-rpcport=<port>"-rpcport=<port>"Connect to JSON-RPC on <port> (default: %u, testnet: %u, signet: %u, regtest: %u)"Connect to JSON-RPC on <port> (default: %u, testnet: %u, signet: %u, regtest: %u)"const CBaseChainParams *CBaseChainParams *ArgsManager::NETWORK_ONLYArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY-rpcuser=<user>"-rpcuser=<user>"Username for JSON-RPC connections"Username for JSON-RPC connections"Wait for RPC server to start"Wait for RPC server to start"-rpcwaittimeout=<n>"-rpcwaittimeout=<n>"Timeout in seconds to wait for the RPC server to start, or 0 for no timeout. (default: %d)"Timeout in seconds to wait for the RPC server to start, or 0 for no timeout. (default: %d)"const char[91]char[91]-rpcwallet=<walletname>"-rpcwallet=<walletname>"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind). This changes the RPC endpoint used, e.g. http://127.0.0.1:8332/wallet/<walletname>"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind). This changes the RPC endpoint used, e.g. http://127.0.0.1:8332/wallet/<walletname>"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases). When combined with -stdinrpcpass, the first line from standard input is used for the RPC password."Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases). When combined with -stdinrpcpass, the first line from standard input is used for the RPC password."const char[232]char[232]Read RPC password from standard input as a single line. When combined with -stdin, the first line from standard input is used for the RPC password. When combined with -stdinwalletpassphrase, -stdinrpcpass consumes the first line, and -stdinwalletpassphrase consumes the second."Read RPC password from standard input as a single line. When combined with -stdin, the first line from standard input is used for the RPC password. When combined with -stdinwalletpassphrase, -stdinrpcpass consumes the first line, and -stdinwalletpassphrase consumes the second."const char[278]char[278]Read wallet passphrase from standard input as a single line. When combined with -stdin, the first line from standard input is used for the wallet passphrase."Read wallet passphrase from standard input as a single line. When combined with -stdin, the first line from standard input is used for the wallet passphrase."const char[158]char[158]DefaultRequestHandler &DefaultRequestHandler &&const DefaultRequestHandlerconst DefaultRequestHandler &ProcessReplyPrepareRequestDEFAULT_NAMEDGenerateToAddressRequestHandler &GenerateToAddressRequestHandler &&const GenerateToAddressRequestHandlerconst GenerateToAddressRequestHandler &~GenerateToAddressRequestHandler"address"generatetoaddress"generatetoaddress"NetinfoRequestHandler &const NetinfoRequestHandlerconst NetinfoRequestHandler &~NetinfoRequestHandlerNetinfoRequestHandler &&ID_PEERINFOID_NETWORKINFOseveritybatch_innetworkinfo209900-netinfo requires bitcoind server to be running v0.21.0 and up"-netinfo requires bitcoind server to be running v0.21.0 and up"time_nowpeer"network"network_idconst NetinfoRequestHandler *is_outboundinbound"inbound"is_tx_relayrelaytxes"relaytxes"conn_typeconnection_type"connection_type"UNKNOWN_NETWORKconst array<const char *, 7UL>NETWORKS.size()block-relay-only"block-relay-only"manual"manual"peer_id"id"mapped_as"mapped_as"addr_processed"addr_processed"addr_rate_limited"addr_rate_limited"conn_timeconntime"conntime"last_blcklast_block"last_block"last_recvlastrecv"lastrecv"last_sendlastsend"lastsend"last_trxnlast_transaction"last_transaction"min_pingminping"minping"pingpingtime"pingtime""addr"ageconst long &sub_versionsubver"subver"is_addr_relay_enabledaddr_relay_enabled"addr_relay_enabled"is_bip152_hb_frombip152_hb_from"bip152_hb_from"is_bip152_hb_tobip152_hb_to"bip152_hb_to"Peer &&Peer &%s client %s%s - server %i%s

"%s client %s%s - server %i%s\n\n"protocolversion"protocolversion"subversion"subversion"const vector<Peer, allocator<Peer>><->   type   net  mping   ping send recv  txn  blk  hb %*s%*s%*s "<->   type   net  mping   ping send recv  txn  blk  hb %*s%*s%*s "addrp"addrp"addrl"addrl""age" asmap " asmap "%*s %-*s%s
"%*s %-*s%s\n"vector<Peer, allocator<Peer>> &const Peerconst Peer &const __normal_iterator<Peer *, vector<Peer, allocator<Peer>>>const __normal_iterator<Peer *, vector<Peer, allocator<Peer>>> &__normal_iterator<Peer *, vector<Peer, allocator<Peer>>> &%3s %6s %5s%7s%7s%5s%5s%5s%5s  %2s %*s%*s%*s%*i %*s %-*s%s
"%3s %6s %5s%7s%7s%5s%5s%5s%5s  %2s %*s%*s%*s%*i %*s %-*s%s\n"*"*"%s%s"%s%s"."."                     ms     ms  sec  sec  min  min                %*s

"                     ms     ms  sec  sec  min  min                %*s\n\n""min"     "     "reachable_networksreachable"reachable"network_name%8s"%8s"const int8_t &const array<int, 2UL>const array<int, 2UL> &array<int, 2UL> &signed char &&   total   block"   total   block"  manual"  manual"const arrayrowsconst char *[3]char *[3]const array<const char *, 3UL>rows.size()
%-5s"\n%-5s"vector<signed char, allocator<signed char>> &const __normal_iterator<signed char *, vector<signed char, allocator<signed char>>>const __normal_iterator<signed char *, vector<signed char, allocator<signed char>>> &__normal_iterator<signed char *, vector<signed char, allocator<signed char>>> &%8i"%8i"   %5i"   %5i"

Local addresses"\n\nLocal addresses"local_addrslocaladdresses"localaddresses": n/a
": n/a\n"max_addr_size
%-*s    port %6i    score %6i"\n%-*s    port %6i    score %6i""port"score"score"invalid -netinfo argument: %s
For more information, run: bitcoin-cli -netinfo help"invalid -netinfo argument: %s\nFor more information, run: bitcoin-cli -netinfo help"UniValue::VARRgetpeerinfo"getpeerinfo"getnetworkinfo"getnetworkinfo"ConnectionTypeForNetinfooutbound-full-relay"outbound-full-relay"full"full"feeler"feeler"addr-fetch"addr-fetch"PingTimeToStringmilliseconds999999999999.0-"-"ChainToString testnet" testnet" signet" signet" regtest" regtest"IsVersionSelectedIsAddressSelectedDetailsRequestedNetworkStringToIdGetinfoRequestHandler &const GetinfoRequestHandlerconst GetinfoRequestHandler &~GetinfoRequestHandlerGetinfoRequestHandler &&connections_in"connections_in"connections_out"connections_out"-getinfo takes no arguments"-getinfo takes no arguments"getblockchaininfo"getblockchaininfo"getwalletinfo"getwalletinfo"AddrinfoRequestHandler &AddrinfoRequestHandler &&const AddrinfoRequestHandlerconst AddrinfoRequestHandler &~AddrinfoRequestHandler-addrinfo requires bitcoind server to be running v22.0 and up"-addrinfo requires bitcoind server to be running v22.0 and up"unsigned long[7]const AddrinfoRequestHandler *NETWORKS.size() - 1addresses_known"addresses_known"-addrinfo takes no arguments"-addrinfo takes no arguments"getnodeaddresses"getnodeaddresses"const basic_string<char, char_traits<char>, allocator<char>>[1]basic_string<char, char_traits<char>, allocator<char>>[1]HTTPReply &HTTPReply &&const HTTPReplyconst HTTPReply &HTTPReplyCConnectionFailed &&~CConnectionFailedCConnectionFailed *CConnectionFailedBaseRequestHandler &const BaseRequestHandlerconst BaseRequestHandler &Peer *~PeerPeerconst Peer *const tuple<const bool &, const double &>const tuple<const bool &, const double &> &tuple<const bool &, const double &> &~BaseRequestHandlerCliClockaddress_strm_help_doc-netinfo level|"help" 

Returns a network peer connections dashboard with information from the remote server.
This human-readable interface will change regularly and is not intended to be a stable API.
Under the hood, -netinfo fetches the data by calling getpeerinfo and getnetworkinfo.
"-netinfo level|\"help\" \n\n"
        "Returns a network peer connections dashboard with information from the remote server.\n"
        "This human-readable interface will change regularly and is not intended to be a stable API.\n"
        "Under the hood, -netinfo fetches the data by calling getpeerinfo and getnetworkinfo.\n"const char[288]char[288]An optional integer argument from 0 to %d can be passed for different peers listings; %d to 255 are parsed as %d.
"An optional integer argument from 0 to %d can be passed for different peers listings; %d to 255 are parsed as %d.\n"const char[115]char[115]Pass "help" to see this detailed help documentation.
If more than one argument is passed, only the first one is read and parsed.
Suggestion: use with the Linux watch(1) command for a live dashboard; see example below.

Arguments:
"Pass \"help\" to see this detailed help documentation.\n"
        "If more than one argument is passed, only the first one is read and parsed.\n"
        "Suggestion: use with the Linux watch(1) command for a live dashboard; see example below.\n\n"
        "Arguments:\n"const char[231]char[231]1. level (integer 0-%d, optional)  Specify the info level of the peers dashboard (default 0):
"1. level (integer 0-%d, optional)  Specify the info level of the peers dashboard (default 0):\n"                                  0 - Peer counts for each reachable network as well as for block relay peers
                                      and manual peers, and the list of local addresses and ports
                                  1 - Like 0 but preceded by a peers listing (without address and version columns)
                                  2 - Like 1 but with an address column
                                  3 - Like 1 but with a version column
                                  4 - Like 1 but with both address and version columns
2. help (string "help", optional) Print this help documentation instead of the dashboard.

Result:

"                                  0 - Peer counts for each reachable network as well as for block relay peers\n"
        "                                      and manual peers, and the list of local addresses and ports\n"
        "                                  1 - Like 0 but preceded by a peers listing (without address and version columns)\n"
        "                                  2 - Like 1 but with an address column\n"
        "                                  3 - Like 1 but with a version column\n"
        "                                  4 - Like 1 but with both address and version columns\n"
        "2. help (string \"help\", optional) Print this help documentation instead of the dashboard.\n\n"
        "Result:\n\n"const char[654]char[654]* The peers listing in levels 1-%d displays all of the peers sorted by direction and minimum ping time:

"* The peers listing in levels 1-%d displays all of the peers sorted by direction and minimum ping time:\n\n"const char[106]char[106]  Column   Description
  ------   -----------
  <->      Direction
           "in"  - inbound connections are those initiated by the peer
           "out" - outbound connections are those initiated by us
  type     Type of peer connection
           "full"   - full relay, the default
           "block"  - block relay; like full relay but does not relay transactions or addresses
           "manual" - peer we manually added using RPC addnode or the -addnode/-connect config options
           "feeler" - short-lived connection for testing addresses
           "addr"   - address fetch; short-lived connection for requesting addresses
  net      Network the peer connected through ("ipv4", "ipv6", "onion", "i2p", "cjdns", or "npr" (not publicly routable))
  mping    Minimum observed ping time, in milliseconds (ms)
  ping     Last observed ping time, in milliseconds (ms)
  send     Time since last message sent to the peer, in seconds
  recv     Time since last message received from the peer, in seconds
  txn      Time since last novel transaction received from the peer and accepted into our mempool, in minutes
           "*" - we do not relay transactions to this peer (relaytxes is false)
  blk      Time since last novel block passing initial validity checks received from the peer, in minutes
  hb       High-bandwidth BIP152 compact block relay
           "." (to)   - we selected the peer as a high-bandwidth peer
           "*" (from) - the peer selected us as a high-bandwidth peer
  addrp    Total number of addresses processed, excluding those dropped due to rate limiting
           "." - we do not relay addresses to this peer (addr_relay_enabled is false)
  addrl    Total number of addresses dropped due to rate limiting
  age      Duration of connection to the peer, in minutes
  asmap    Mapped AS (Autonomous System) number in the BGP route to the peer, used for diversifying
           peer selection (only displayed if the -asmap config option is set)
  id       Peer index, in increasing order of peer connections since node startup
  address  IP address and port of the peer
  version  Peer version and subversion concatenated, e.g. "70016/Satoshi:21.0.0/"

* The peer counts table displays the number of peers for each reachable network as well as
  the number of block relay peers and manual peers.

* The local addresses table lists each local address broadcast by the node, the port, and the score.

Examples:

Peer counts table of reachable networks and list of local addresses
> bitcoin-cli -netinfo

The same, preceded by a peers listing without address and version columns
> bitcoin-cli -netinfo 1

Full dashboard
"  Column   Description\n"
        "  ------   -----------\n"
        "  <->      Direction\n"
        "           \"in\"  - inbound connections are those initiated by the peer\n"
        "           \"out\" - outbound connections are those initiated by us\n"
        "  type     Type of peer connection\n"
        "           \"full\"   - full relay, the default\n"
        "           \"block\"  - block relay; like full relay but does not relay transactions or addresses\n"
        "           \"manual\" - peer we manually added using RPC addnode or the -addnode/-connect config options\n"
        "           \"feeler\" - short-lived connection for testing addresses\n"
        "           \"addr\"   - address fetch; short-lived connection for requesting addresses\n"
        "  net      Network the peer connected through (\"ipv4\", \"ipv6\", \"onion\", \"i2p\", \"cjdns\", or \"npr\" (not publicly routable))\n"
        "  mping    Minimum observed ping time, in milliseconds (ms)\n"
        "  ping     Last observed ping time, in milliseconds (ms)\n"
        "  send     Time since last message sent to the peer, in seconds\n"
        "  recv     Time since last message received from the peer, in seconds\n"
        "  txn      Time since last novel transaction received from the peer and accepted into our mempool, in minutes\n"
        "           \"*\" - we do not relay transactions to this peer (relaytxes is false)\n"
        "  blk      Time since last novel block passing initial validity checks received from the peer, in minutes\n"
        "  hb       High-bandwidth BIP152 compact block relay\n"
        "           \".\" (to)   - we selected the peer as a high-bandwidth peer\n"
        "           \"*\" (from) - the peer selected us as a high-bandwidth peer\n"
        "  addrp    Total number of addresses processed, excluding those dropped due to rate limiting\n"
        "           \".\" - we do not relay addresses to this peer (addr_relay_enabled is false)\n"
        "  addrl    Total number of addresses dropped due to rate limiting\n"
        "  age      Duration of connection to the peer, in minutes\n"
        "  asmap    Mapped AS (Autonomous System) number in the BGP route to the peer, used for diversifying\n"
        "           peer selection (only displayed if the -asmap config option is set)\n"
        "  id       Peer index, in increasing order of peer connections since node startup\n"
        "  address  IP address and port of the peer\n"
        "  version  Peer version and subversion concatenated, e.g. \"70016/Satoshi:21.0.0/\"\n\n"
        "* The peer counts table displays the number of peers for each reachable network as well as\n"
        "  the number of block relay peers and manual peers.\n\n"
        "* The local addresses table lists each local address broadcast by the node, the port, and the score.\n\n"
        "Examples:\n\n"
        "Peer counts table of reachable networks and list of local addresses\n"
        "> bitcoin-cli -netinfo\n\n"
        "The same, preceded by a peers listing without address and version columns\n"
        "> bitcoin-cli -netinfo 1\n\n"
        "Full dashboard\n"const char[2652]char[2652]> bitcoin-cli -netinfo %d

"> bitcoin-cli -netinfo %d\n\n"Full live dashboard, adjust --interval or --no-title as needed (Linux)
"Full live dashboard, adjust --interval or --no-title as needed (Linux)\n"> watch --interval 1 --no-title bitcoin-cli -netinfo %d

"> watch --interval 1 --no-title bitcoin-cli -netinfo %d\n\n"See this help
> bitcoin-cli -netinfo help
"See this help\n"
        "> bitcoin-cli -netinfo help\n"m_peersm_max_id_lengthm_max_age_lengthm_max_addr_rate_limited_lengthm_max_addr_processed_lengthm_max_addr_lengthm_is_asmap_onm_details_levelm_manual_peers_countm_block_relay_peers_countm_countsarray<unsigned short, 8UL>[3]ID_BALANCES 3ID_WALLETINFOID_BLOCKCHAININFObodyDEFAULT_COLOR_SETTINGDEFAULT_NBLOCKSUNREACHABLE_NETWORK_IDSNETWORK_SHORT_NAMESconst char *[7]char *[7]npr"npr"ipv4"ipv4""ipv6"onion"onion"i2p"i2p"cjdns"cjdns""int"NETWORKSnot_publicly_routable"not_publicly_routable"internal"internal"DEFAULT_RPCCONNECT127.0.0.1"127.0.0.1"UrlDecodeFn *UrlDecodeFn *constURL_DECODEMAX_DETAIL_LEVEL// fetch multiwallet balances and append to result// Parse reply// Perform RPC call// Remove trailing method name from arguments vector// Read one arg per line from stdin and append// Skip switches/**
 * Check bounds and set up args for RPC generatetoaddress params: nblocks, address, maxtries.
 * @param[in] address  Reference to const string address to insert into the args.
 * @param     args     Reference to vector of string args to modify.
 *//* args=*//**
 * Call RPC getnewaddress.
 * @returns getnewaddress response as a UniValue object.
 */// Add proxy to ordered_proxy if has not been processed// proxies// Add padding between progress bar and IBD progress// Display the progress bar only if IBD progress is less than 99%// By default, only print colored text if OS is not WIN32 and stdout is connected to a terminal./**
 * ParseGetInfoResult takes in -getinfo result in UniValue object and parses it
 * into a user friendly UniValue string to be printed on the console.
 * @param[out] result  Reference to UniValue result containing the -getinfo output.
 *//**
 * GetProgressBar constructs a progress bar with 5% intervals.
 *
 * @param[in]   progress      The proportion of the progress bar to be filled between 0 and 1.
 * @param[out]  progress_bar  String representation of the progress bar.
 *//**
 * GetWalletBalances calls listwallets; if more than one wallet is loaded, it then
 * fetches mine.trusted balances for each loaded wallet and pushes them to `result`.
 *
 * @param result  Reference to UniValue object the wallet names and balances are pushed to.
 *//** Parse UniValue error to update the message to print to std::cerr and the code to return. *//** Parse UniValue result to update the message to print to std::cout. */// Connection succeeded, no need to retry.// Execute and handle connection failures with -rpcwait./**
 * ConnectAndCallRPC wraps CallRPC with -rpcwait and an exception handler.
 *
 * @param[in] rh         Pointer to RequestHandler.
 * @param[in] strMethod  Reference to const string method to forward to CallRPC.
 * @param[in] rpcwallet  Reference to const optional string wallet name to forward to CallRPC.
 * @returns the RPC response as a UniValue object.
 * @throws a CConnectionFailed std::runtime_error if connection failed or RPC server still in warmup.
 */// ownership moved to evcon in above call// check if we should use a special wallet endpoint// Attach request data// Try fall back to cookie-based authentication if no password is provided// Get credentials// Average length of year in Gregorian calendar// set the timeout to a very long time period instead.// Indefinite request timeouts are not possible in libevent-http, so we// Set connection timeout// Synchronously look up hostname// Obtain event base//     3. default port for chain//     2. port in -rpcconnect (ie following : in ipv4 or ]: in ipv6)//     1. -rpcport// In preference order, we choose the following for the port:/** Process default single requests *//** Process RPC generatetoaddress request. */// Report local addresses, ports, and scores.// the outbound row has two extra columns for block relay and manual peer counts// total peers count// network peers count// row header// column header// Report peer connection totals by type.// variable spacing// Report detailed peer connections list sorted by direction and minimum ping time.// Generate report header.// Push data for this peer to the peers vector.// total overall// total by network// in/out overall// in/out by network// Count peer connection totals, and if DetailsRequested(), store peer data in a vector of structs.//!< Optional user-supplied arg to set dashboard details level//!< Peer counts by (in/out/total, networks/total)/** Process netinfo requests */// getwalletinfo() and getbalances() are allowed to fail if there is no wallet.// Errors in getnetworkinfo() and getblockchaininfo() are fatal, pass them on;/** Collect values from the batch and form a simulated `getinfo` reply. *//** Create a simulated `getinfo` request. *//** Process getinfo requests */// Total address count// Prepare result to return to user.// Count the number of peers known to our node, by network./** Process addrinfo requests *//** Class that handles the conversion from a command-line to a JSON-RPC request,
 * as well as converting back to a JSON object that can be shown as result.
 *//* If req is nullptr, it means an error occurred while connecting: the
         * error code will have been passed to http_error_cb.
         *//** Reply structure for request_done to fill in */// Check for chain settings (BaseParams() calls are only valid after this clause)// CONTINUE_EXECUTION when it's expected to continue further.// This function returns either one of EXIT_ codes when it's expected to stop the process or// when to wait if -rpcwait is given.// Exception thrown on connection error.  This error is used to determine// Ignore everything other than errors/** libevent event log callback *//** Default -color setting. *//** Default number of blocks to generate for RPC generatetoaddress. *//*internal*//*not_publicly_routable*/// See GetNetworkName() in netbase.cpp// just use a plain system_clock.// trivial to get the mocked time from the server, nor is it needed for now, so// The server returns time values from a mockable system clock, but it is nottuple<const bool &, const double &>tuple<const bool &, const double &> &&__normal_iterator<signed char *, vector<signed char, allocator<signed char>>>__normal_iterator<signed char *, vector<signed char, allocator<signed char>>> &&__normal_iterator<signed char *, vector<signed char, allocator<signed char>>> *array<const char *, 3UL>array<const char *, 3UL> &array<const char *, 3UL> &&const array<const char *, 3UL> &__normal_iterator<Peer *, vector<Peer, allocator<Peer>>>__normal_iterator<Peer *, vector<Peer, allocator<Peer>>> &&__normal_iterator<Peer *, vector<Peer, allocator<Peer>>> *array<const char *, 7UL>array<const char *, 7UL> &array<const char *, 7UL> &&const array<const char *, 7UL> &array<unsigned short, 8UL> &unique_ptr<evhttp_request, evhttp_request_deleter>pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &const pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *array<unsigned long, 7UL>array<unsigned long, 7UL> &array<unsigned long, 7UL> &&const array<unsigned long, 7UL>const array<unsigned long, 7UL> &array<array<unsigned short, 8UL>, 3UL>array<array<unsigned short, 8UL>, 3UL> &array<array<unsigned short, 8UL>, 3UL> &&const array<array<unsigned short, 8UL>, 3UL>const array<array<unsigned short, 8UL>, 3UL> &vector<Peer, allocator<Peer>>allocator<Peer> &vector<signed char, allocator<signed char>>allocator<signed char> &map<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const map<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const map<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> *map<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> *multimap<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &&multimap<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &map<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &&map<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &unique_ptr<BaseRequestHandler, default_delete<BaseRequestHandler>>default_delete<BaseRequestHandler> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *_Vector_base<Peer, allocator<Peer>>_Vector_base<Peer, allocator<Peer>> &const _Vector_base<Peer, allocator<Peer>>const _Vector_base<Peer, allocator<Peer>> &_Vector_base<signed char, allocator<signed char>>_Vector_base<signed char, allocator<signed char>> &const _Vector_base<signed char, allocator<signed char>>const _Vector_base<signed char, allocator<signed char>> &allocator_traits<allocator<Peer>>allocator_traits<allocator<Peer>> &allocator_traits<allocator<Peer>> &&const allocator_traits<allocator<Peer>>const allocator_traits<allocator<Peer>> &allocator_traits<allocator<signed char>>allocator_traits<allocator<signed char>> &allocator_traits<allocator<signed char>> &&const allocator_traits<allocator<signed char>>const allocator_traits<allocator<signed char>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &&const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>>allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>>const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &allocator<Peer>allocator<signed char>allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>new_allocator<Peer>new_allocator<Peer> &const new_allocator<Peer>const new_allocator<Peer> &new_allocator<signed char>new_allocator<signed char> &const new_allocator<signed char>const new_allocator<signed char> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &raii_evhttp_requestarray<unsigned long, 7UL> *unsigned long(&)[7]vector<signed char, allocator<signed char>> *_Vector_base<signed char, allocator<signed char>> *signed char *constsigned char *const &signed char *&const __normal_iterator<signed char *, vector<signed char, allocator<signed char>>> *const array<const char *, 3UL> *array<const char *, 3UL> *char *(&)[3]const array<const char *, 7UL> *array<const char *, 7UL> *char *(&)[7]const array<int, 2UL> *array<int, 2UL> *const signed char &Peer *constPeer *const &Peer *&const __normal_iterator<Peer *, vector<Peer, allocator<Peer>>> *vector<Peer, allocator<Peer>> *_Vector_base<Peer, allocator<Peer>> *const vector<Peer, allocator<Peer>> *const __normal_iterator<const Peer *, vector<Peer, allocator<Peer>>>const __normal_iterator<const Peer *, vector<Peer, allocator<Peer>>> &__normal_iterator<const Peer *, vector<Peer, allocator<Peer>>> &array<array<unsigned short, 8UL>, 3UL> *const array<unsigned short, 8UL>array<unsigned short, 8UL>(&)[3]array<unsigned short, 8UL> *unsigned short[8]unsigned short(&)[8]const time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>>unique_ptr<evhttp_request, evhttp_request_deleter> *evhttp_request *&evhttp_request *&&const unique_ptr<evhttp_request, evhttp_request_deleter> *const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *unique_ptr<BaseRequestHandler, default_delete<BaseRequestHandler>> *BaseRequestHandler *&const default_delete<BaseRequestHandler>BaseRequestHandler *&&const unique_ptr<BaseRequestHandler, default_delete<BaseRequestHandler>> *const basic_string<char, char_traits<char>, allocator<char>> *constconst basic_string<char, char_traits<char>, allocator<char>> *const &const basic_ios<char, char_traits<char>> *char **constchar **const &char **&const char(*)[4]char(*)[4]const char(*)[3]char(*)[3]const char(*)[2]char(*)[2]const _Vector_base<Peer, allocator<Peer>> *const allocator<Peer>const allocator<Peer> &const _Vector_base<signed char, allocator<signed char>> *const allocator<signed char>const allocator<signed char> &evhttp_request *constevhttp_request *const &BaseRequestHandler *constBaseRequestHandler *const &const default_delete<BaseRequestHandler> &__alloc_traits<allocator<signed char>, signed char>__alloc_traits<allocator<signed char>, signed char> &__alloc_traits<allocator<signed char>, signed char> &&const __alloc_traits<allocator<signed char>, signed char>const __alloc_traits<allocator<signed char>, signed char> &__alloc_traits<allocator<Peer>, Peer>__alloc_traits<allocator<Peer>, Peer> &__alloc_traits<allocator<Peer>, Peer> &&const __alloc_traits<allocator<Peer>, Peer>const __alloc_traits<allocator<Peer>, Peer> &convertToInt<char[2], false>convertToInt<char[2], false> &convertToInt<char[2], false> &&const convertToInt<char[2], false>const convertToInt<char[2], false> &convertToInt<char[3], false>convertToInt<char[3], false> &convertToInt<char[3], false> &&const convertToInt<char[3], false>const convertToInt<char[3], false> &convertToInt<char[4], false>convertToInt<char[4], false> &convertToInt<char[4], false> &&const convertToInt<char[4], false>const convertToInt<char[4], false> &__normal_iterator<const Peer *, vector<Peer, allocator<Peer>>>__normal_iterator<const Peer *, vector<Peer, allocator<Peer>>> &&__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 0UL, 2UL>__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 0UL, 2UL> &__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 0UL, 2UL> &&const __tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 0UL, 2UL>const __tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 0UL, 2UL> &const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *const pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&_Temporary_value &const _Temporary_valueconst _Temporary_value &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &__uniq_ptr_impl<BaseRequestHandler, default_delete<BaseRequestHandler>>__uniq_ptr_impl<BaseRequestHandler, default_delete<BaseRequestHandler>> &__uniq_ptr_impl<BaseRequestHandler, default_delete<BaseRequestHandler>> &&const __uniq_ptr_impl<BaseRequestHandler, default_delete<BaseRequestHandler>>const __uniq_ptr_impl<BaseRequestHandler, default_delete<BaseRequestHandler>> &default_delete<BaseRequestHandler>default_delete<BaseRequestHandler> &&map<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>multimap<basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, bool>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>pair<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>__pair_base<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>__uniq_ptr_impl<evhttp_request, evhttp_request_deleter>__uniq_ptr_impl<evhttp_request, evhttp_request_deleter> &__uniq_ptr_impl<evhttp_request, evhttp_request_deleter> &&const __uniq_ptr_impl<evhttp_request, evhttp_request_deleter>const __uniq_ptr_impl<evhttp_request, evhttp_request_deleter> &_Tuple_impl<0UL, const bool &, const double &>_Tuple_impl<0UL, const bool &, const double &> &&const _Tuple_impl<0UL, const bool &, const double &>const _Tuple_impl<0UL, const bool &, const double &> &_Tuple_impl<0UL, const bool &, const double &> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> *allocator<Peer> *allocator<signed char> *new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> *const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> *const new_allocator<signed char> *new_allocator<signed char> *const new_allocator<Peer> *new_allocator<Peer> *37191016277640225__uniq_ptr_impl<evhttp_request, evhttp_request_deleter> *__uniq_ptr_impl<BaseRequestHandler, default_delete<BaseRequestHandler>> *const __uniq_ptr_impl<BaseRequestHandler, default_delete<BaseRequestHandler>> *const __tuple_element_t<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>>const __tuple_element_t<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>> &const tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>const tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>> &tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>> &const default_delete<BaseRequestHandler> *default_delete<BaseRequestHandler> *__tuple_element_t<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> *const __uniq_ptr_impl<evhttp_request, evhttp_request_deleter> *const __tuple_element_t<0UL, tuple<evhttp_request *, evhttp_request_deleter>>const __tuple_element_t<0UL, tuple<evhttp_request *, evhttp_request_deleter>> &const tuple<evhttp_request *, evhttp_request_deleter>const tuple<evhttp_request *, evhttp_request_deleter> &tuple<evhttp_request *, evhttp_request_deleter> &__tuple_element_t<0UL, tuple<evhttp_request *, evhttp_request_deleter>> &const array<unsigned short, 8UL> *const Peer *constconst Peer *const &const vector<signed char, allocator<signed char>>const vector<signed char, allocator<signed char>> *int(&)[2]..(*)(..))[3]__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 1UL, 2UL>__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 1UL, 2UL> &__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 1UL, 2UL> &&const __tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 1UL, 2UL>const __tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 1UL, 2UL> &is_nothrow_constructible<signed char, const signed char &>is_nothrow_constructible<signed char, const signed char &> &is_nothrow_constructible<signed char, const signed char &> &&const is_nothrow_constructible<signed char, const signed char &>const is_nothrow_constructible<signed char, const signed char &> &FormatListN<23>FormatListN<23> &const FormatListN<23>const FormatListN<23> &FormatArg[23]__and_<is_nothrow_move_constructible<BaseRequestHandler *>, is_nothrow_move_assignable<BaseRequestHandler *>>__and_<is_nothrow_move_constructible<BaseRequestHandler *>, is_nothrow_move_assignable<BaseRequestHandler *>> &__and_<is_nothrow_move_constructible<BaseRequestHandler *>, is_nothrow_move_assignable<BaseRequestHandler *>> &&const __and_<is_nothrow_move_constructible<BaseRequestHandler *>, is_nothrow_move_assignable<BaseRequestHandler *>>const __and_<is_nothrow_move_constructible<BaseRequestHandler *>, is_nothrow_move_assignable<BaseRequestHandler *>> &formatValueAsType<char[4], const void *, true>formatValueAsType<char[4], const void *, true> &formatValueAsType<char[4], const void *, true> &&const formatValueAsType<char[4], const void *, true>const formatValueAsType<char[4], const void *, true> &formatValueAsType<char[4], char, false>formatValueAsType<char[4], char, false> &formatValueAsType<char[4], char, false> &&const formatValueAsType<char[4], char, false>const formatValueAsType<char[4], char, false> &is_convertible<char[4], const void *>is_convertible<char[4], const void *> &is_convertible<char[4], const void *> &&const is_convertible<char[4], const void *>const is_convertible<char[4], const void *> &is_convertible<char[4], char>is_convertible<char[4], char> &is_convertible<char[4], char> &&const is_convertible<char[4], char>const is_convertible<char[4], char> &formatValueAsType<char[3], const void *, true>formatValueAsType<char[3], const void *, true> &formatValueAsType<char[3], const void *, true> &&const formatValueAsType<char[3], const void *, true>const formatValueAsType<char[3], const void *, true> &formatValueAsType<char[3], char, false>formatValueAsType<char[3], char, false> &formatValueAsType<char[3], char, false> &&const formatValueAsType<char[3], char, false>const formatValueAsType<char[3], char, false> &is_convertible<char[3], const void *>is_convertible<char[3], const void *> &is_convertible<char[3], const void *> &&const is_convertible<char[3], const void *>const is_convertible<char[3], const void *> &is_convertible<char[3], char>is_convertible<char[3], char> &is_convertible<char[3], char> &&const is_convertible<char[3], char>const is_convertible<char[3], char> &formatValueAsType<char[2], const void *, true>formatValueAsType<char[2], const void *, true> &formatValueAsType<char[2], const void *, true> &&const formatValueAsType<char[2], const void *, true>const formatValueAsType<char[2], const void *, true> &formatValueAsType<char[2], char, false>formatValueAsType<char[2], char, false> &formatValueAsType<char[2], char, false> &&const formatValueAsType<char[2], char, false>const formatValueAsType<char[2], char, false> &is_convertible<char[2], const void *>is_convertible<char[2], const void *> &is_convertible<char[2], const void *> &&const is_convertible<char[2], const void *>const is_convertible<char[2], const void *> &is_convertible<char[2], char>is_convertible<char[2], char> &is_convertible<char[2], char> &&const is_convertible<char[2], char>const is_convertible<char[2], char> &_TC<value, const bool &, const double &>_TC<true, const bool &, const double &>_TC<true, const bool &, const double &> &_TC<true, const bool &, const double &> &&const _TC<true, const bool &, const double &>const _TC<true, const bool &, const double &> &_Tuple_impl<0UL, evhttp_request *, evhttp_request_deleter>_Tuple_impl<0UL, evhttp_request *, evhttp_request_deleter> &&const _Tuple_impl<0UL, evhttp_request *, evhttp_request_deleter>const _Tuple_impl<0UL, evhttp_request *, evhttp_request_deleter> &_Tuple_impl<0UL, evhttp_request *, evhttp_request_deleter> &_Tuple_impl<0UL, BaseRequestHandler *, default_delete<BaseRequestHandler>>_Tuple_impl<0UL, BaseRequestHandler *, default_delete<BaseRequestHandler>> &&const _Tuple_impl<0UL, BaseRequestHandler *, default_delete<BaseRequestHandler>>const _Tuple_impl<0UL, BaseRequestHandler *, default_delete<BaseRequestHandler>> &_Tuple_impl<0UL, BaseRequestHandler *, default_delete<BaseRequestHandler>> &_Tuple_impl<1UL, default_delete<BaseRequestHandler>>_Tuple_impl<1UL, default_delete<BaseRequestHandler>> &&const _Tuple_impl<1UL, default_delete<BaseRequestHandler>>const _Tuple_impl<1UL, default_delete<BaseRequestHandler>> &_Tuple_impl<1UL, default_delete<BaseRequestHandler>> &_Tuple_impl<1UL, const double &>_Tuple_impl<1UL, const double &> &&const _Tuple_impl<1UL, const double &>const _Tuple_impl<1UL, const double &> &_Tuple_impl<1UL, const double &> &iterator_traits<signed char *>iterator_traits<signed char *> &iterator_traits<signed char *> &&const iterator_traits<signed char *>const iterator_traits<signed char *> &__array_traits<const char *, 3UL>__array_traits<const char *, 3UL> &__array_traits<const char *, 3UL> &&const __array_traits<const char *, 3UL>const __array_traits<const char *, 3UL> &reverse_iterator<const char **>reverse_iterator<const char *const *>__array_traits<const char *, 7UL>__array_traits<const char *, 7UL> &__array_traits<const char *, 7UL> &&const __array_traits<const char *, 7UL>const __array_traits<const char *, 7UL> &__and_<is_convertible<pointer, evhttp_request *>, __not_<is_array<_Up>>>tuple<evhttp_request *, evhttp_request_deleter>tuple<evhttp_request *, evhttp_request_deleter> &&_Ptr<evhttp_request, evhttp_request_deleter, void>_Ptr<evhttp_request, evhttp_request_deleter, void> &_Ptr<evhttp_request, evhttp_request_deleter, void> &&const _Ptr<evhttp_request, evhttp_request_deleter, void>const _Ptr<evhttp_request, evhttp_request_deleter, void> &_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &&const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &_PCC<<expression>, const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>reverse_iterator<unsigned long *>reverse_iterator<const unsigned long *>__array_traits<unsigned long, 7UL>__array_traits<unsigned long, 7UL> &__array_traits<unsigned long, 7UL> &&const __array_traits<unsigned long, 7UL>const __array_traits<unsigned long, 7UL> &reverse_iterator<array<unsigned short, 8UL> *>reverse_iterator<const array<unsigned short, 8UL> *>__array_traits<array<unsigned short, 8UL>, 3UL>__array_traits<array<unsigned short, 8UL>, 3UL> &__array_traits<array<unsigned short, 8UL>, 3UL> &&const __array_traits<array<unsigned short, 8UL>, 3UL>const __array_traits<array<unsigned short, 8UL>, 3UL> &reverse_iterator<__normal_iterator<const Peer *, vector<Peer, allocator<Peer>>>>reverse_iterator<__normal_iterator<Peer *, vector<Peer, allocator<Peer>>>>__normal_iterator<const signed char *, vector<signed char, allocator<signed char>>>reverse_iterator<__normal_iterator<const signed char *, vector<signed char, allocator<signed char>>>>reverse_iterator<__normal_iterator<signed char *, vector<signed char, allocator<signed char>>>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &__pair_base<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>__pair_base<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>__and_<is_convertible<pointer, BaseRequestHandler *>, __not_<is_array<_Up>>>tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>> &&_Ptr<BaseRequestHandler, default_delete<BaseRequestHandler>, void>_Ptr<BaseRequestHandler, default_delete<BaseRequestHandler>, void> &_Ptr<BaseRequestHandler, default_delete<BaseRequestHandler>, void> &&const _Ptr<BaseRequestHandler, default_delete<BaseRequestHandler>, void>const _Ptr<BaseRequestHandler, default_delete<BaseRequestHandler>, void> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &reverse_iterator<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>reverse_iterator<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>>_Node_insert_return<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, value_type>unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const basic_string<char, char_traits<char>, allocator<char>>>unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const basic_string<char, char_traits<char>, allocator<char>>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const basic_string<char, char_traits<char>, allocator<char>>> &&const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const basic_string<char, char_traits<char>, allocator<char>>>const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const basic_string<char, char_traits<char>, allocator<char>>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &unsigned char[56]remove_reference<signed char &>remove_reference<signed char &> &remove_reference<signed char &> &&const remove_reference<signed char &>const remove_reference<signed char &> &remove_reference<Peer &>remove_reference<Peer &> &remove_reference<Peer &> &&const remove_reference<Peer &>const remove_reference<Peer &> &remove_reference<evhttp_request *&>remove_reference<evhttp_request *&> &remove_reference<evhttp_request *&> &&const remove_reference<evhttp_request *&>const remove_reference<evhttp_request *&> &remove_reference<BaseRequestHandler *&>remove_reference<BaseRequestHandler *&> &remove_reference<BaseRequestHandler *&> &&const remove_reference<BaseRequestHandler *&>const remove_reference<BaseRequestHandler *&> &is_convertible<char[4], int>is_convertible<char[4], int> &is_convertible<char[4], int> &&const is_convertible<char[4], int>const is_convertible<char[4], int> &is_convertible<char[3], int>is_convertible<char[3], int> &is_convertible<char[3], int> &&const is_convertible<char[3], int>const is_convertible<char[3], int> &is_convertible<char[2], int>is_convertible<char[2], int> &is_convertible<char[2], int> &&const is_convertible<char[2], int>const is_convertible<char[2], int> &rebind<Peer>rebind<Peer> &rebind<Peer> &&const rebind<Peer>const rebind<Peer> &rebind<signed char>rebind<signed char> &rebind<signed char> &&const rebind<signed char>const rebind<signed char> &iterator_traits<Peer *>iterator_traits<Peer *> &iterator_traits<Peer *> &&const iterator_traits<Peer *>const iterator_traits<Peer *> &_Tuple_impl<0UL, const bool &, const double &> *const __normal_iterator<const Peer *, vector<Peer, allocator<Peer>>> *__normal_iterator<const Peer *, vector<Peer, allocator<Peer>>> *__tuple_element_t<1UL, tuple<evhttp_request *, evhttp_request_deleter>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> *__tuple_element_t<1UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>> &const char[202]char[202]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = char [4]; fmtT = char; bool convertible = false]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = char [3]; fmtT = char; bool convertible = false]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = char [2]; fmtT = char; bool convertible = false]is_nothrow_default_constructible<allocator<Peer>>is_nothrow_default_constructible<allocator<Peer>> &is_nothrow_default_constructible<allocator<Peer>> &&const is_nothrow_default_constructible<allocator<Peer>>const is_nothrow_default_constructible<allocator<Peer>> &is_nothrow_constructible<Peer, Peer>is_nothrow_constructible<Peer, Peer> &is_nothrow_constructible<Peer, Peer> &&const is_nothrow_constructible<Peer, Peer>const is_nothrow_constructible<Peer, Peer> &is_nothrow_default_constructible<allocator<signed char>>is_nothrow_default_constructible<allocator<signed char>> &is_nothrow_default_constructible<allocator<signed char>> &&const is_nothrow_default_constructible<allocator<signed char>>const is_nothrow_default_constructible<allocator<signed char>> &is_constructible<signed char, signed char &&>is_constructible<signed char, signed char &&> &is_constructible<signed char, signed char &&> &&const is_constructible<signed char, signed char &&>const is_constructible<signed char, signed char &&> &__is_move_constructible_impl<signed char, true>__is_move_constructible_impl<signed char, true> &__is_move_constructible_impl<signed char, true> &&const __is_move_constructible_impl<signed char, true>const __is_move_constructible_impl<signed char, true> &is_move_constructible<signed char>is_move_constructible<signed char> &is_move_constructible<signed char> &&const is_move_constructible<signed char>const is_move_constructible<signed char> &__is_move_insertable<allocator<signed char>>__is_move_insertable<allocator<signed char>> &__is_move_insertable<allocator<signed char>> &&const __is_move_insertable<allocator<signed char>>const __is_move_insertable<allocator<signed char>> &is_nothrow_constructible<signed char, signed char>is_nothrow_constructible<signed char, signed char> &is_nothrow_constructible<signed char, signed char> &&const is_nothrow_constructible<signed char, signed char>const is_nothrow_constructible<signed char, signed char> &__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 2UL, 2UL>__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 2UL, 2UL> &__tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 2UL, 2UL> &&const __tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 2UL, 2UL>const __tuple_compare<tuple<const bool &, const double &>, tuple<const bool &, const double &>, 2UL, 2UL> &__and_<is_same<signed char *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<Peer *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<const Peer *>iterator_traits<const Peer *> &iterator_traits<const Peer *> &&const iterator_traits<const Peer *>const iterator_traits<const Peer *> &is_convertible<pointer, BaseRequestHandler *>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &&const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &&const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>>const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &is_same<vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>, _U2>is_convertible<pointer, evhttp_request *>_Head_base<1UL, const double &, false>_Head_base<1UL, const double &, false> &const _Head_base<1UL, const double &, false>const _Head_base<1UL, const double &, false> &_Head_base<1UL, default_delete<BaseRequestHandler>, true>_Head_base<1UL, default_delete<BaseRequestHandler>, true> &const _Head_base<1UL, default_delete<BaseRequestHandler>, true>const _Head_base<1UL, default_delete<BaseRequestHandler>, true> &_Head_base<0UL, BaseRequestHandler *, false>_Head_base<0UL, BaseRequestHandler *, false> &const _Head_base<0UL, BaseRequestHandler *, false>const _Head_base<0UL, BaseRequestHandler *, false> &_Head_base<0UL, evhttp_request *, false>_Head_base<0UL, evhttp_request *, false> &const _Head_base<0UL, evhttp_request *, false>const _Head_base<0UL, evhttp_request *, false> &is_wchar<char[2]>is_wchar<char[2]> &is_wchar<char[2]> &&const is_wchar<char[2]>const is_wchar<char[2]> &is_wchar<char[3]>is_wchar<char[3]> &is_wchar<char[3]> &&const is_wchar<char[3]>const is_wchar<char[3]> &is_wchar<char[4]>is_wchar<char[4]> &is_wchar<char[4]> &&const is_wchar<char[4]>const is_wchar<char[4]> &is_nothrow_move_assignable<BaseRequestHandler *>is_nothrow_move_assignable<BaseRequestHandler *> &is_nothrow_move_assignable<BaseRequestHandler *> &&const is_nothrow_move_assignable<BaseRequestHandler *>const is_nothrow_move_assignable<BaseRequestHandler *> &is_nothrow_move_constructible<BaseRequestHandler *>is_nothrow_move_constructible<BaseRequestHandler *> &is_nothrow_move_constructible<BaseRequestHandler *> &&const is_nothrow_move_constructible<BaseRequestHandler *>const is_nothrow_move_constructible<BaseRequestHandler *> &remove_reference<Peer>remove_reference<Peer> &remove_reference<Peer> &&const remove_reference<Peer>const remove_reference<Peer> &remove_reference<const signed char &>remove_reference<const signed char &> &remove_reference<const signed char &> &&const remove_reference<const signed char &>const remove_reference<const signed char &> &remove_reference<signed char>remove_reference<signed char> &remove_reference<signed char> &&const remove_reference<signed char>const remove_reference<signed char> &_Tuple_impl<0UL, evhttp_request *, evhttp_request_deleter> *_Tuple_impl<0UL, BaseRequestHandler *, default_delete<BaseRequestHandler>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *unsigned char(*)[56]_Tuple_impl<1UL, evhttp_request_deleter> &FormatListN<6> *FormatArg[6]FormatListN<23> *signed char *&&_Tuple_impl<1UL, const double &> *is_nothrow_destructible<signed char>is_nothrow_destructible<signed char> &is_nothrow_destructible<signed char> &&const is_nothrow_destructible<signed char>const is_nothrow_destructible<signed char> &is_constructible<Peer, Peer &&>is_constructible<Peer, Peer &&> &is_constructible<Peer, Peer &&> &&const is_constructible<Peer, Peer &&>const is_constructible<Peer, Peer &&> &__is_move_constructible_impl<Peer, true>__is_move_constructible_impl<Peer, true> &__is_move_constructible_impl<Peer, true> &&const __is_move_constructible_impl<Peer, true>const __is_move_constructible_impl<Peer, true> &is_move_constructible<Peer>is_move_constructible<Peer> &is_move_constructible<Peer> &&const is_move_constructible<Peer>const is_move_constructible<Peer> &__is_move_insertable<allocator<Peer>>__is_move_insertable<allocator<Peer>> &__is_move_insertable<allocator<Peer>> &&const __is_move_insertable<allocator<Peer>>const __is_move_insertable<allocator<Peer>> &tuple_element<0UL, tuple<const bool &, const double &>>tuple_element<0UL, tuple<const bool &, const double &>> &tuple_element<0UL, tuple<const bool &, const double &>> &&const tuple_element<0UL, tuple<const bool &, const double &>>const tuple_element<0UL, tuple<const bool &, const double &>> &tuple_element<0UL, tuple<evhttp_request *, evhttp_request_deleter>>tuple_element<0UL, tuple<evhttp_request *, evhttp_request_deleter>> &tuple_element<0UL, tuple<evhttp_request *, evhttp_request_deleter>> &&const tuple_element<0UL, tuple<evhttp_request *, evhttp_request_deleter>>const tuple_element<0UL, tuple<evhttp_request *, evhttp_request_deleter>> &tuple_element<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>>tuple_element<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>> &tuple_element<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>> &&const tuple_element<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>>const tuple_element<0UL, tuple<BaseRequestHandler *, default_delete<BaseRequestHandler>>> &conditional<true, is_nothrow_move_assignable<BaseRequestHandler *>, is_nothrow_move_constructible<BaseRequestHandler *>>conditional<true, is_nothrow_move_assignable<BaseRequestHandler *>, is_nothrow_move_constructible<BaseRequestHandler *>> &conditional<true, is_nothrow_move_assignable<BaseRequestHandler *>, is_nothrow_move_constructible<BaseRequestHandler *>> &&const conditional<true, is_nothrow_move_assignable<BaseRequestHandler *>, is_nothrow_move_constructible<BaseRequestHandler *>>const conditional<true, is_nothrow_move_assignable<BaseRequestHandler *>, is_nothrow_move_constructible<BaseRequestHandler *>> &__is_nothrow_move_constructible_impl<BaseRequestHandler *, true>__is_nothrow_move_constructible_impl<BaseRequestHandler *, true> &__is_nothrow_move_constructible_impl<BaseRequestHandler *, true> &&const __is_nothrow_move_constructible_impl<BaseRequestHandler *, true>const __is_nothrow_move_constructible_impl<BaseRequestHandler *, true> &__is_nt_move_assignable_impl<BaseRequestHandler *, true>__is_nt_move_assignable_impl<BaseRequestHandler *, true> &__is_nt_move_assignable_impl<BaseRequestHandler *, true> &&const __is_nt_move_assignable_impl<BaseRequestHandler *, true>const __is_nt_move_assignable_impl<BaseRequestHandler *, true> &__is_swappable<const char *>__is_nothrow_swappable<const char *>_TC<value, evhttp_request *, evhttp_request_deleter>_TC<true, evhttp_request *, evhttp_request_deleter>_TC<true, evhttp_request *, evhttp_request_deleter> &_TC<true, evhttp_request *, evhttp_request_deleter> &&const _TC<true, evhttp_request *, evhttp_request_deleter>const _TC<true, evhttp_request *, evhttp_request_deleter> &__is_swappable<unsigned long>__is_nothrow_swappable<unsigned long>__is_swappable<array<unsigned short, 8UL>>__is_nothrow_swappable<array<unsigned short, 8UL>>__and_<is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _U2>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _U1>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _U2>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>, _U1>_TC<value, BaseRequestHandler *, default_delete<BaseRequestHandler>>_TC<true, BaseRequestHandler *, default_delete<BaseRequestHandler>>_TC<true, BaseRequestHandler *, default_delete<BaseRequestHandler>> &_TC<true, BaseRequestHandler *, default_delete<BaseRequestHandler>> &&const _TC<true, BaseRequestHandler *, default_delete<BaseRequestHandler>>const _TC<true, BaseRequestHandler *, default_delete<BaseRequestHandler>> &__and_<is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<Peer *, _Ptr>is_same<signed char *, _Ptr>__is_referenceable<signed char>__is_referenceable<signed char> &__is_referenceable<signed char> &&const __is_referenceable<signed char>const __is_referenceable<signed char> &_Head_base<1UL, const double &, false> *Peer *&&const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *_Head_base<0UL, BaseRequestHandler *, false> *_Tuple_impl<1UL, default_delete<BaseRequestHandler>> *_Head_base<0UL, evhttp_request *, false> *is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const piecewise_construct_t &, tuple<const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<>>is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const piecewise_construct_t &, tuple<const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<>> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const piecewise_construct_t &, tuple<const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<>> &&const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const piecewise_construct_t &, tuple<const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<>>const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>, const piecewise_construct_t &, tuple<const basic_string<char, char_traits<char>, allocator<char>> &>, tuple<>> &is_nothrow_destructible<Peer>is_nothrow_destructible<Peer> &is_nothrow_destructible<Peer> &&const is_nothrow_destructible<Peer>const is_nothrow_destructible<Peer> &tuple_element<0UL, tuple<default_delete<BaseRequestHandler>>>tuple_element<0UL, tuple<default_delete<BaseRequestHandler>>> &tuple_element<0UL, tuple<default_delete<BaseRequestHandler>>> &&const tuple_element<0UL, tuple<default_delete<BaseRequestHandler>>>const tuple_element<0UL, tuple<default_delete<BaseRequestHandler>>> &tuple_element<0UL, tuple<evhttp_request_deleter>>tuple_element<0UL, tuple<evhttp_request_deleter>> &tuple_element<0UL, tuple<evhttp_request_deleter>> &&const tuple_element<0UL, tuple<evhttp_request_deleter>>const tuple_element<0UL, tuple<evhttp_request_deleter>> &tuple_element<0UL, tuple<const double &>>tuple_element<0UL, tuple<const double &>> &tuple_element<0UL, tuple<const double &>> &&const tuple_element<0UL, tuple<const double &>>const tuple_element<0UL, tuple<const double &>> &is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *, _Ptr>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> *, _Ptr>__is_empty_non_tuple<default_delete<BaseRequestHandler>>__is_empty_non_tuple<default_delete<BaseRequestHandler>> &__is_empty_non_tuple<default_delete<BaseRequestHandler>> &&const __is_empty_non_tuple<default_delete<BaseRequestHandler>>const __is_empty_non_tuple<default_delete<BaseRequestHandler>> &__is_empty_non_tuple<BaseRequestHandler *>__is_empty_non_tuple<BaseRequestHandler *> &__is_empty_non_tuple<BaseRequestHandler *> &&const __is_empty_non_tuple<BaseRequestHandler *>const __is_empty_non_tuple<BaseRequestHandler *> &__is_empty_non_tuple<evhttp_request *>__is_empty_non_tuple<evhttp_request *> &__is_empty_non_tuple<evhttp_request *> &&const __is_empty_non_tuple<evhttp_request *>const __is_empty_non_tuple<evhttp_request *> &is_nothrow_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>is_nothrow_assignable<BaseRequestHandler *&, BaseRequestHandler *&&> &is_nothrow_assignable<BaseRequestHandler *&, BaseRequestHandler *&&> &&const is_nothrow_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>const is_nothrow_assignable<BaseRequestHandler *&, BaseRequestHandler *&&> &__is_referenceable<BaseRequestHandler *>__is_referenceable<BaseRequestHandler *> &__is_referenceable<BaseRequestHandler *> &&const __is_referenceable<BaseRequestHandler *>const __is_referenceable<BaseRequestHandler *> &is_nothrow_constructible<BaseRequestHandler *, BaseRequestHandler *&&>is_nothrow_constructible<BaseRequestHandler *, BaseRequestHandler *&&> &is_nothrow_constructible<BaseRequestHandler *, BaseRequestHandler *&&> &&const is_nothrow_constructible<BaseRequestHandler *, BaseRequestHandler *&&>const is_nothrow_constructible<BaseRequestHandler *, BaseRequestHandler *&&> &__is_referenceable<Peer>__is_referenceable<Peer> &__is_referenceable<Peer> &&const __is_referenceable<Peer>const __is_referenceable<Peer> &__iterator_traits<__normal_iterator<Peer *, vector<Peer, allocator<Peer>>>, void>__iterator_traits<__normal_iterator<Peer *, vector<Peer, allocator<Peer>>>, void> &__iterator_traits<__normal_iterator<Peer *, vector<Peer, allocator<Peer>>>, void> &&const __iterator_traits<__normal_iterator<Peer *, vector<Peer, allocator<Peer>>>, void>const __iterator_traits<__normal_iterator<Peer *, vector<Peer, allocator<Peer>>>, void> &_Head_base<1UL, default_delete<BaseRequestHandler>, true> *const unsigned char[56]const unsigned char(*)[56]_Head_base<1UL, evhttp_request_deleter, true> &is_nothrow_copy_constructible<signed char *>is_nothrow_copy_constructible<signed char *> &is_nothrow_copy_constructible<signed char *> &&const is_nothrow_copy_constructible<signed char *>const is_nothrow_copy_constructible<signed char *> &is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &&const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>>const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> &__and_<is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>>__and_<is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>> &__and_<is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>> &&const __and_<is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>>const __and_<is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<evhttp_request *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<evhttp_request *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<evhttp_request *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<evhttp_request *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<evhttp_request *>> &is_empty<evhttp_request *>is_empty<evhttp_request *> &is_empty<evhttp_request *> &&const is_empty<evhttp_request *>const is_empty<evhttp_request *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<BaseRequestHandler *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<BaseRequestHandler *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<BaseRequestHandler *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<BaseRequestHandler *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<BaseRequestHandler *>> &is_empty<BaseRequestHandler *>is_empty<BaseRequestHandler *> &is_empty<BaseRequestHandler *> &&const is_empty<BaseRequestHandler *>const is_empty<BaseRequestHandler *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<BaseRequestHandler>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<BaseRequestHandler>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<BaseRequestHandler>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<BaseRequestHandler>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<BaseRequestHandler>>> &is_empty<default_delete<BaseRequestHandler>>is_empty<default_delete<BaseRequestHandler>> &is_empty<default_delete<BaseRequestHandler>> &&const is_empty<default_delete<BaseRequestHandler>>const is_empty<default_delete<BaseRequestHandler>> &tuple<const double &>tuple<evhttp_request_deleter>tuple<default_delete<BaseRequestHandler>>remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *&>remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *&> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *&> &&const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *&>const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>> *&> &__and_<is_nothrow_move_constructible<Peer>, is_nothrow_move_assignable<Peer>>__and_<is_nothrow_move_constructible<Peer>, is_nothrow_move_assignable<Peer>> &__and_<is_nothrow_move_constructible<Peer>, is_nothrow_move_assignable<Peer>> &&const __and_<is_nothrow_move_constructible<Peer>, is_nothrow_move_assignable<Peer>>const __and_<is_nothrow_move_constructible<Peer>, is_nothrow_move_assignable<Peer>> &__are_same<Peer, Peer>__are_same<Peer, Peer> &__are_same<Peer, Peer> &&const __are_same<Peer, Peer>const __are_same<Peer, Peer> &__is_pointer<Peer *>__is_pointer<Peer *> &__is_pointer<Peer *> &&const __is_pointer<Peer *>const __is_pointer<Peer *> &is_nothrow_copy_constructible<Peer *>is_nothrow_copy_constructible<Peer *> &is_nothrow_copy_constructible<Peer *> &&const is_nothrow_copy_constructible<Peer *>const is_nothrow_copy_constructible<Peer *> &enable_if<true, signed char *>enable_if<true, signed char *> &enable_if<true, signed char *> &&const enable_if<true, signed char *>const enable_if<true, signed char *> &__is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>__is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&> &__is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&> &&const __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>const __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&> &is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&> &is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&> &&const is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>const is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&> &__is_nothrow_copy_constructible_impl<signed char *, true>__is_nothrow_copy_constructible_impl<signed char *, true> &__is_nothrow_copy_constructible_impl<signed char *, true> &&const __is_nothrow_copy_constructible_impl<signed char *, true>const __is_nothrow_copy_constructible_impl<signed char *, true> &__is_referenceable<signed char *>__is_referenceable<signed char *> &__is_referenceable<signed char *> &&const __is_referenceable<signed char *>const __is_referenceable<signed char *> &is_nothrow_constructible<signed char *, signed char *const &>is_nothrow_constructible<signed char *, signed char *const &> &is_nothrow_constructible<signed char *, signed char *const &> &&const is_nothrow_constructible<signed char *, signed char *const &>const is_nothrow_constructible<signed char *, signed char *const &> &conditional<true, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>, is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>>conditional<true, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>, is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>> &conditional<true, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>, is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>> &&const conditional<true, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>, is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>>const conditional<true, __is_nt_assignable_impl<BaseRequestHandler *&, BaseRequestHandler *&&>, is_assignable<BaseRequestHandler *&, BaseRequestHandler *&&>> &__is_nothrow_copy_constructible_impl<Peer *, true>__is_nothrow_copy_constructible_impl<Peer *, true> &__is_nothrow_copy_constructible_impl<Peer *, true> &&const __is_nothrow_copy_constructible_impl<Peer *, true>const __is_nothrow_copy_constructible_impl<Peer *, true> &is_nothrow_move_assignable<Peer>is_nothrow_move_assignable<Peer> &is_nothrow_move_assignable<Peer> &&const is_nothrow_move_assignable<Peer>const is_nothrow_move_assignable<Peer> &is_nothrow_move_constructible<Peer>is_nothrow_move_constructible<Peer> &is_nothrow_move_constructible<Peer> &&const is_nothrow_move_constructible<Peer>const is_nothrow_move_constructible<Peer> &conditional<true, is_nothrow_move_assignable<Peer>, is_nothrow_move_constructible<Peer>>conditional<true, is_nothrow_move_assignable<Peer>, is_nothrow_move_constructible<Peer>> &conditional<true, is_nothrow_move_assignable<Peer>, is_nothrow_move_constructible<Peer>> &&const conditional<true, is_nothrow_move_assignable<Peer>, is_nothrow_move_constructible<Peer>>const conditional<true, is_nothrow_move_assignable<Peer>, is_nothrow_move_constructible<Peer>> &__is_nothrow_move_constructible_impl<Peer, true>__is_nothrow_move_constructible_impl<Peer, true> &__is_nothrow_move_constructible_impl<Peer, true> &&const __is_nothrow_move_constructible_impl<Peer, true>const __is_nothrow_move_constructible_impl<Peer, true> &__is_nt_move_assignable_impl<Peer, true>__is_nt_move_assignable_impl<Peer, true> &__is_nt_move_assignable_impl<Peer, true> &&const __is_nt_move_assignable_impl<Peer, true>const __is_nt_move_assignable_impl<Peer, true> &__is_referenceable<Peer *>__is_referenceable<Peer *> &__is_referenceable<Peer *> &&const __is_referenceable<Peer *>const __is_referenceable<Peer *> &is_nothrow_constructible<Peer *, Peer *const &>is_nothrow_constructible<Peer *, Peer *const &> &is_nothrow_constructible<Peer *, Peer *const &> &&const is_nothrow_constructible<Peer *, Peer *const &>const is_nothrow_constructible<Peer *, Peer *const &> &is_nothrow_assignable<Peer &, Peer &&>is_nothrow_assignable<Peer &, Peer &&> &is_nothrow_assignable<Peer &, Peer &&> &&const is_nothrow_assignable<Peer &, Peer &&>const is_nothrow_assignable<Peer &, Peer &&> &is_nothrow_constructible<Peer, Peer &&>is_nothrow_constructible<Peer, Peer &&> &is_nothrow_constructible<Peer, Peer &&> &&const is_nothrow_constructible<Peer, Peer &&>const is_nothrow_constructible<Peer, Peer &&> &__and_<is_assignable<Peer &, Peer &&>, __is_nt_assignable_impl<Peer &, Peer &&>>__and_<is_assignable<Peer &, Peer &&>, __is_nt_assignable_impl<Peer &, Peer &&>> &__and_<is_assignable<Peer &, Peer &&>, __is_nt_assignable_impl<Peer &, Peer &&>> &&const __and_<is_assignable<Peer &, Peer &&>, __is_nt_assignable_impl<Peer &, Peer &&>>const __and_<is_assignable<Peer &, Peer &&>, __is_nt_assignable_impl<Peer &, Peer &&>> &__is_nt_assignable_impl<Peer &, Peer &&>__is_nt_assignable_impl<Peer &, Peer &&> &__is_nt_assignable_impl<Peer &, Peer &&> &&const __is_nt_assignable_impl<Peer &, Peer &&>const __is_nt_assignable_impl<Peer &, Peer &&> &is_assignable<Peer &, Peer &&>is_assignable<Peer &, Peer &&> &is_assignable<Peer &, Peer &&> &&const is_assignable<Peer &, Peer &&>const is_assignable<Peer &, Peer &&> &conditional<true, __is_nt_assignable_impl<Peer &, Peer &&>, is_assignable<Peer &, Peer &&>>conditional<true, __is_nt_assignable_impl<Peer &, Peer &&>, is_assignable<Peer &, Peer &&>> &conditional<true, __is_nt_assignable_impl<Peer &, Peer &&>, is_assignable<Peer &, Peer &&>> &&const conditional<true, __is_nt_assignable_impl<Peer &, Peer &&>, is_assignable<Peer &, Peer &&>>const conditional<true, __is_nt_assignable_impl<Peer &, Peer &&>, is_assignable<Peer &, Peer &&>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &vector<CTxIn, allocator<CTxIn>> &const vector<CTxIn, allocator<CTxIn>> &const vector<CTxOut, allocator<CTxOut>> &vector<CTxOut, allocator<CTxOut>> *vector<vector<unsigned char, allocator<unsigned char>>, allocator<vector<unsigned char, allocator<unsigned char>>>> &&<bits/stl_construct.h>const variant<_Tp...>const variant<_Tp...> &variant<_Tp...> &__variant_construct_by_index_Variant_Variant &_Np__variant_cast__throw_bad_variant_accessbad_variant_access(__what)variant<_Types...> &visit_Visitor_Visitor &&_Variants_Variants &&>greaterconst variant<_Types...>const variant<_Types...> &>=greater_equal!=not_equal==<=less_equal<get_ifconst variant<_Types...> *variant<_Types...> *const variant<_Types...> &&variant<_Types...> &&holds_alternative__do_visit__use_index__same_return_typesconst variant_alternative_t<_Np, variant<_Types...>>const variant_alternative_t<_Np, variant<_Types...>> &&const variant_alternative_t<_Np, variant<_Types...>> &variant_alternative_t<_Np, variant<_Types...>> &&variant_alternative_t<_Np, variant<_Types...>> &hash<monostate> &hash<monostate> &&const hash<monostate>const hash<monostate> &const monostateconst monostate &monostate &const hash<monostate> *hash<monostate> *__magic_monostate_hash777718446744073709543839-7777bad_variant_access &bad_variant_access &&const bad_variant_accessconst bad_variant_access &~bad_variant_accessbad_variant_access *bad_variant_accessconst bad_variant_access *Unknown reason"Unknown reason"monostate &&valueless_by_exceptionvariant_Tj~variant__get_storage_Vp &&_Variant &&__variant_construct__variant_construct_single__never_valueless_Union_Union &&_S_apply__visit_invoke_Result_type__do_visit_invoke_r__do_visit_invoke__visit_invoke_impl__element_by_index_or_cookie__index_S_apply_single_alt__do_cookie_S_apply_all_alts_Array_type &_Multi_array<..(*)(..), __dimensions...> &__var_indices_S_fun_First_Variant_base<_Types...> &_Variant_base<_Types...> &&const _Variant_base<_Types...>const _Variant_base<_Types...> &_Variant_base_Variant_base<_Types...> *_S_nothrow_default_ctor_Move_assign_base<<unnamed>, _Types...> &const _Move_assign_base<<unnamed>, _Types...>const _Move_assign_base<<unnamed>, _Types...> &_Move_assign_base_Move_assign_base<<unnamed>, _Types...> &&_S_nothrow_move_assign_Copy_assign_base<<unnamed>, _Types...> &_Copy_assign_base<<unnamed>, _Types...> &&_Copy_assign_baseconst _Copy_assign_base<<unnamed>, _Types...>const _Copy_assign_base<<unnamed>, _Types...> &_S_nothrow_copy_assign_M_destructive_copy_M_destructive_move_Move_ctor_base<<unnamed>, _Types...> &_Move_ctor_base<<unnamed>, _Types...> &&const _Move_ctor_base<<unnamed>, _Types...>const _Move_ctor_base<<unnamed>, _Types...> &_Move_ctor_base_S_nothrow_move_ctor_Copy_ctor_base<<unnamed>, _Types...> &_Copy_ctor_base<<unnamed>, _Types...> &&const _Copy_ctor_base<<unnamed>, _Types...>const _Copy_ctor_base<<unnamed>, _Types...> &_Copy_ctor_base_S_nothrow_copy_ctor_M_valid_Variant_storage_Variant_storage<true, _Types...> *~_Variant_storage_M_reset_impl_Variadic_union_Variadic_union<_First, _Rest...> *const in_place_index_t<0UL>_Type &&const _Type &&&&__reason__visitor__vars_Uninitialized<_Type, false> *_Type *_Uninitialized__variant_idx_cookie &__variant_idx_cookie &&const __variant_idx_cookieconst __variant_idx_cookie &__variant_cookie &__variant_cookie &&const __variant_cookieconst __variant_cookie &__is_fast_hash<hash<variant<_Types...>>>hash<monostate>hash<variant<_Types...>>__variant_hash_call_base_impl<false, _Types...>__variant_hash_call_base_impl<<unnamed>, _Types...>monostatevariant_alternative<_Np, const volatile _Variant>const volatile _Variantvariant_alternative<_Np, volatile _Variant>volatile _Variantvariant_alternative<_Np, const _Variant>const _Variantvariant_alternative_tvariant_alternative<0UL, variant<_First, _Rest...>>variant_alternative<_Np, variant<_First, _Rest...>>variant_alternative<_Np, _Variant>variant_size<variant<_Types...>>variant_size<const volatile _Variant>variant_size<volatile _Variant>variant_size<const _Variant>variant_size<_Variant>variant<_Types...>__is_in_place_tag<in_place_index_t<_Np>>__is_in_place_tag<in_place_type_t<_Tp>>__is_in_place_tag<_Tp>__accepted_type__to_type_Variant_hash_base<variant<_Types...>, index_sequence<__indices...>>_Variant_hash_base<_Variant, __indices>__indices_Base_dedup<_Np, _Tp>__gen_vtable<__same_return_types, _Result_type, _Visitor, _Variants...>__gen_vtable_impl<__same_return_types, _Multi_array<..(*)(..)>, tuple<_Variants...>, index_sequence<__indices...>>__gen_vtable_impl<__same_return_types, _Multi_array<..(*)(..), __dimensions...>, tuple<_Variants...>, index_sequence<__indices...>>_Next__gen_vtable_impl<__same_return_types, _Array_type, _Variant_tuple, _Index_seq>_Array_type_Variant_tuple_Index_seq_Multi_array<..(*)(..), __first, __rest...>__rest_Multi_array<_Tp>_Multi_array<_Tp, _Dimensions...>_Dimensions_Extra_visit_slot_needed<_Maybe_variant_cookie, _Variant>_Maybe_variant_cookie_Variant_never_valueless<variant<_Types...>>_Variant_never_valueless<<unnamed>>__accepted_index<_Tp, variant<_Types...>, void_t<decltype((<expression>))>>__accepted_index<_Tp, _Variant, <unnamed>>__overload_set<void, _Rest...>_Rest__overload_set<_First, _Rest...>__overload_set<_Types...>__tuple_count<_Tp, tuple<_First, _Rest...>>__tuple_count<_Tp, tuple<_Types...>>__tuple_count<_Tp, _Tuple>_Variant_base<_Types...>_Move_assign_base<true, _Types...>_Move_assign_base<<unnamed>, _Types...>_Copy_assign_base<true, _Types...>_Copy_assign_base<<unnamed>, _Types...>_Move_ctor_base<true, _Types...>_Move_ctor_base<<unnamed>, _Types...>_Copy_ctor_base<true, _Types...>_Copy_ctor_base<<unnamed>, _Types...>_Variant_storage<true, _Types...>__index_type_Variant_storage<false, _Types...>__select_index_Variant_storage<__trivially_destructible, _Types...>__trivially_destructible_Variadic_union<_First, _Rest...>_Variadic_union<_Types...>_Traits<_Types...>_Uninitialized<_Type, false>_Uninitialized<_Type, true>_Uninitialized<_Type, <unnamed>>__variant_idx_cookie__variant_cookie__index_of<_Tp, _First, _Rest...>__index_of<_Tp, _Types...>_Nth_type<0UL, _First, _Rest...>_Nth_type<_Np, _First, _Rest...>_Nth_type<_Np, _Types...>variant_size_v__not_in_place_tag__index_of__accepted_index__exactly_once__tuple_count_v__index_of_v_S_vtable_S_trivial_move_assign_S_trivial_copy_assign_S_trivial_move_ctor_S_trivial_copy_ctor_S_trivial_dtor_S_move_assign_S_copy_assign_S_move_ctor_S_copy_ctor_S_default_ctor_M_reason_Multi_array<..(*)(..), __rest...>[]_M_arr_M_index_M_u_M_rest_M_firstvariant_nposconst bool_constant<true>__visit_with_indexconst _Array_typevariant must have no void alternativevariant must have no reference alternativevariant must have at least one alternative_VARIANT_RELATION_FUNCTION_TEMPLATE_VARIANT_RELATION_FUNCTION_TEMPLATE(__OP)template<typename... _Tp> friend constexpr bool operator __OP(const variant<_Tp...>& __lhs, const variant<_Tp...>& __rhs);_VARIANT_RELATION_FUNCTION_TEMPLATE(__OP,__NAME)template<typename... _Types> constexpr bool operator __OP(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) { bool __ret = true; __do_visit<__detail::__variant::__visit_with_index>( [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable -> __detail::__variant::__variant_idx_cookie { if constexpr (__rhs_index != variant_npos) { if (__lhs.index() == __rhs_index) { auto& __this_mem = std::get<__rhs_index>(__lhs); __ret = __this_mem __OP __rhs_mem; } else __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); } else __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); return {}; }, __rhs); return __ret; } constexpr bool operator __OP(monostate, monostate) noexcept { return 0 __OP 0; }__cpp_lib_variant_GLIBCXX_VARIANTdefined(__clang__) && __clang_major__ <= 7// _GLIBCXX_VARIANT// See https://bugs.llvm.org/show_bug.cgi?id=31852// i.e. the variant can become valueless.// This case only provides the basic exception-safety guarantee,// But _Never_valueless_alt<type> means this won't:// This construction might throw:// to avoid becoming valueless.// Provide the strong exception-safety guarantee when possible,// But these steps won't throw:// This might invoke a potentially-throwing conversion operator:// namespace __variant// Perform the implicit conversion to _Result_type for std::visit<R>.// For std::visit<cv void>, cast the result to void:// For raw visitation using indices, pass the indices to the visitor:// that invokes the visitor with the alternatives specified by __indices.// It populates a _Multi_array element with the address of a function// This partial specialization is the base case for the recursion.// The base case of the recursion defines the actual function pointers.// calling _S_apply() on the next specialization of __gen_vtable_impl.// This partial specialization builds up the index sequences by recursively// for each valid pack of indexes into the variant types _Variants.// with function pointers that perform the visitation expressions e(m)// Defines the _S_apply() member that returns a _Multi_array populated// using index calculation.// The returned multi-dimensional vtable can be fast accessed by the visitor//                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>//     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,//                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>//                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>//                     tuple<V1&&, V2&&>, std::index_sequence<1>>//   __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 3>,//                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>//                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>//                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>//                     tuple<V1&&, V2&&>, std::index_sequence<0>>//                   tuple<V1&&, V2&&>, std::index_sequence<>>// __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 2, 3>,// will trigger instantiations of://       variant<float, double, long double>())  // typedef'ed as V2//       variant<int, char>(),  // typedef'ed as V1// visit([](auto, auto){},// For example,// required by std::visit but not std::visit<R>.// to enforce that all visitor invocations return the same type. This is// The __same_return_types non-type template parameter specifies whether// Creates a multi-dimensional vtable recursively.// Partial specialization with rank >= 1.// Partial specialization with rank zero, stores a single _Tp element.// Used for storing a multi-dimensional vtable.// Returns the raw storage for __v.// (or to variant_npos).// __accepted_index maps an arbitrary _Tp to an alternative type in _Variant// Helper for variant(_Tp&&) and variant::operator=(_Tp&&).// If a type appears more than once in _Types, create only one overload.// Takes _Types and create an overloaded _S_fun for each type.// TODO: Reuse this in <tuple> ?// For how many times does _Tp appear in _Tuple?// basic exception safety anyway.// and move construction can throw, so emplace only gives// exception safety guarantee, or both copy construction// doesn't throw, so _M_destructive_copy gives strong// equivalent in this case. Either copy construction// should be used here, but _M_destructive_copy is// The standard says this->emplace<__rhs_type>(__rhs_mem)// triviality and handling non-trivial SMF behaviors.// The following are (Copy|Move) (ctor|assign) layers for forwarding// Defines index and the dtor, possibly trivial.// can never be valueless, which enables some minor optimizations.// without it becoming valueless. If this is true, variant<_Types...>// True if every alternative in _Types... can be emplaced in a variant// variant using that alternative, so we can't change the value later!// Whether _Never_valueless_alt<T> is true or not affects the ABI of a// guarantee, by creating and moving a temporary.// so that emplacing the type will provide the strong exception-safety// non-throwing and cheap move construction and move assignment operator,// Specialize _Never_valueless_alt for other types which have a// on the stack and then memcpy them into place.// For suitably-small, trivially copyable types we can create temporaries// always be placed in a variant without it becoming valueless.// _Never_valueless_alt is true for variant alternatives that can// Defines members and ctors.// are always nothrow.// The following nothrow traits are for non-trivial SMFs. Trivial SMFs// Returns the typed storage for __v.// is; but we will see.// want _Uninitialized<T> to be trivially destructible, no matter whether T// Another reason we may not want to remove _Uninitialzied<T> may be that, we// to T, therefore equivalent to being removed entirely.// yet. When it's implemented, _Uninitialized<T> can be changed to the alias// We have to do this, because [basic.types]p10.5.3 (n4606) is not implemented// _Uninitialized<T> is guaranteed to be a literal type, even if T is not.// a more explanatory name than 'true'// used for raw visitation with indices passed in// used for raw visitation// Returns sizeof...(_Types) if _Tp is not in _Types.// Returns the first apparence of _Tp in _Types./** @file variant
 *  This is the `<variant>` C++ Library header.
 */// <variant> -*- C++ -*-__variants__rhs_mem__var__element__cookie_element__vtable__first_index__rest_indices__rhs_index||first_nonmatchingstd::errc{}JSON integer out of range"JSON integer out of range"/home/tanteikg/QCVE/sources/bitcoin/src/key_io.h/home/tanteikg/QCVE/sources/bitcoin/src/util/moneystr.h/home/tanteikg/QCVE/sources/bitcoin/src/util/rbf.h/home/tanteikg/QCVE/sources/bitcoin/src/bitcoin-tx.cpp<util/rbf.h><util/moneystr.h><script/sign.h><key_io.h><core_io.h>AppInitRawTx()"AppInitRawTx()"CommandLineRawTx()"CommandLineRawTx()"CommandLineRawTxstartArgstrHexTxtoo few parameters"too few parameters"invalid transaction encoding"invalid transaction encoding"eqpos'='readStdinchar[4096]breadsizeof(buf)error reading stdin"error reading stdin"OutputTx-json"-json"-txid"-txid"OutputTxHexstrHexOutputTxHashstrHexHashOutputTxJSONconst CTxUndoconst CTxUndo *CTxUndo *jsonOutputMutateTxeccnversion"nversion"locktime"locktime"replaceable"replaceable"delin"delin"delout"delout"outaddr"outaddr"outpubkey"outpubkey"Secp256k1Init *outmultisig"outmultisig"outscript"outscript"outdata"outdata""sign""load""set"unknown command"unknown command"MutateTxSignnHashTypeunknown sighash flag/sign option"unknown sighash flag/sign option"mergedTxtxvviewDummyviewprivatekeys"privatekeys"privatekeys register variable must be set."privatekeys register variable must be set."tempKeystorekeysObjkidxprivatekey not a std::string"privatekey not a std::string"privatekey not valid"privatekey not valid"prevtxs"prevtxs"prevtxs register variable must be set."prevtxs register variable must be set."prevtxsObjprevidxprevOuttypesconst pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>[3]pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>[3]"txid""vout"UniValue::VNUM"scriptPubKey"const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> *pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> *commandValflagStrpkDataexpected prevtxs internal object"expected prevtxs internal object"prevtxs internal object typecheck fail"prevtxs internal object typecheck fail"txid must be hexadecimal string (not '"txid must be hexadecimal string (not '"')"')"vout cannot be negative"vout cannot be negative"const Coinconst Coin &newcoinPrevious output scriptPubKey mismatch:
"Previous output scriptPubKey mismatch:\n"
vs:
"\nvs:\n"2100000000000000MAX_MONEYamount"amount"Coin &&"redeemScript"rsDatafHashSingleSIGHASH_ANYONECANPAY-129~SIGHASH_ANYONECANPAYSIGHASH_SINGLEprevPubKeysigdataconst BaseSignatureCreatorconst BaseSignatureCreator &BaseSignatureCreator &SignatureData &Missing amount for CTxOut with scriptPubKey=%s"Missing amount for CTxOut with scriptPubKey=%s"const SignatureDataconst SignatureData &~CoinCoin *~SignatureDataSignatureData *optional<TaprootBuilder> *_Optional_base<TaprootBuilder, false, false> *~TaprootSpendDataTaprootSpendData *AmountFromValueAmount is not a number or string"Amount is not a number or string"Invalid amount"Invalid amount"Amount out of range"Amount out of range"findSighashFlagsN_SIGHASH_OPTSconst struct <unnamed>[7]struct <unnamed>[7]const struct <unnamed> *struct <unnamed> *MutateTxDelOutputoutIdxInvalid TX output index '"Invalid TX output index '"MutateTxDelInputinIdxInvalid TX input index '"Invalid TX input index '"MutateTxAddOutScriptvStrInputPartsTX output missing separator"TX output missing separator"strScriptbSegWitbScriptHash'W''S'script exceeds size limit: %d > %d"script exceeds size limit: %d > %d"WitnessV0ScriptHash &redeemScript exceeds size limit: %d > %d"redeemScript exceeds size limit: %d > %d"ScriptHash &MutateTxAddOutDataTX output value not specified"TX output value not specified"strDatainvalid TX output data"invalid TX output data"strOutIdxstrInIdxstrInputMutateTxAddOutMultiSigNot enough multisig parameters"Not enough multisig parameters"requiredinvalid multisig required number"invalid multisig required number"numkeysinvalid multisig total number"invalid multisig total number"incorrect number of multisig pubkeys"incorrect number of multisig pubkeys"multisig parameter mismatch. Required "multisig parameter mismatch. Required " of " of "signatures."signatures."invalid TX output pubkey"invalid TX output pubkey"Too many parameters"Too many parameters"const vector<CPubKey, allocator<CPubKey>>const vector<CPubKey, allocator<CPubKey>> &vector<CPubKey, allocator<CPubKey>> &const __normal_iterator<CPubKey *, vector<CPubKey, allocator<CPubKey>>>const __normal_iterator<CPubKey *, vector<CPubKey, allocator<CPubKey>>> &__normal_iterator<CPubKey *, vector<CPubKey, allocator<CPubKey>>> &Uncompressed pubkeys are not useable for SegWit outputs"Uncompressed pubkeys are not useable for SegWit outputs"MutateTxAddOutPubKeyTX output missing or too many separators"TX output missing or too many separators"WitnessV0KeyHash &MutateTxAddOutAddrstrAddrdestinationinvalid TX output address"invalid TX output address"MutateTxAddInputTX input missing separator"TX input missing separator"invalid TX input txid"invalid TX input txid"minTxOutSzmaxVoutstrVout111111static_cast<int64_t>(maxVout)invalid TX input vout '"invalid TX input vout '"CTxIn::SEQUENCE_FINALinvalid TX sequence id"invalid TX sequence id"MAX_BLOCK_WEIGHTWITNESS_SCALE_FACTOR * minTxOutSz(WITNESS_SCALE_FACTOR * minTxOutSz)MAX_BLOCK_WEIGHT / (WITNESS_SCALE_FACTOR * minTxOutSz)parsed '" '"TrimAndParseMutateTxRBFOptIncnt4294967293MAX_BIP125_RBF_SEQUENCEMutateTxLocktimenewLocktime0LL0xffffffffLLInvalid TX locktime requested: '"Invalid TX locktime requested: '"MutateTxVersionnewVersionTX_MAX_STANDARD_VERSIONInvalid TX version requested: '"Invalid TX version requested: '"ExtractAndValidateValueconst optional<signed long>invalid TX output value"invalid TX output value"RegisterLoadcmdValRegister load requires NAME:FILENAME"Register load requires NAME:FILENAME"strErrCannot open file "Cannot open file "valStrError reading file "Error reading file "RegisterSetRegister input requires NAME:VALUE"Register input requires NAME:VALUE"RegisterSetJsonCannot parse JSON for key "Cannot parse JSON for key "AppInitRawTx-create"-create"Bitcoin Core bitcoin-tx utility version 
Usage:  bitcoin-tx [options] <hex-tx> [commands]  Update hex-encoded bitcoin transaction
or:     bitcoin-tx [options] -create [commands]   Create hex-encoded bitcoin transaction

"\n"
                "Usage:  bitcoin-tx [options] <hex-tx> [commands]  Update hex-encoded bitcoin transaction\n"
                "or:     bitcoin-tx [options] -create [commands]   Create hex-encoded bitcoin transaction\n"
                "\n"const char[181]char[181]SetupBitcoinTxArgsCreate new, empty TX."Create new, empty TX."Select JSON output"Select JSON output"Output only the hex-encoded transaction id of the resultant transaction."Output only the hex-encoded transaction id of the resultant transaction."delin=N"delin=N"Delete input N from TX"Delete input N from TX"OptionsCategory::COMMANDSdelout=N"delout=N"Delete output N from TX"Delete output N from TX"in=TXID:VOUT(:SEQUENCE_NUMBER)"in=TXID:VOUT(:SEQUENCE_NUMBER)"Add input to TX"Add input to TX"locktime=N"locktime=N"Set TX lock time to N"Set TX lock time to N"nversion=N"nversion=N"Set TX version to N"Set TX version to N"outaddr=VALUE:ADDRESS"outaddr=VALUE:ADDRESS"Add address-based output to TX"Add address-based output to TX"outdata=[VALUE:]DATA"outdata=[VALUE:]DATA"Add data-based output to TX"Add data-based output to TX"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]"outmultisig=VALUE:REQUIRED:PUBKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]"Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS. Optionally add the "W" flag to produce a pay-to-witness-script-hash output. Optionally add the "S" flag to wrap the output in a pay-to-script-hash."Add Pay To n-of-m Multi-sig output to TX. n = REQUIRED, m = PUBKEYS. "
        "Optionally add the \"W\" flag to produce a pay-to-witness-script-hash output. "
        "Optionally add the \"S\" flag to wrap the output in a pay-to-script-hash."const char[217]char[217]outpubkey=VALUE:PUBKEY[:FLAGS]"outpubkey=VALUE:PUBKEY[:FLAGS]"Add pay-to-pubkey output to TX. Optionally add the "W" flag to produce a pay-to-witness-pubkey-hash output. Optionally add the "S" flag to wrap the output in a pay-to-script-hash."Add pay-to-pubkey output to TX. "
        "Optionally add the \"W\" flag to produce a pay-to-witness-pubkey-hash output. "
        "Optionally add the \"S\" flag to wrap the output in a pay-to-script-hash."const char[180]char[180]outscript=VALUE:SCRIPT[:FLAGS]"outscript=VALUE:SCRIPT[:FLAGS]"Add raw script output to TX. Optionally add the "W" flag to produce a pay-to-witness-script-hash output. Optionally add the "S" flag to wrap the output in a pay-to-script-hash."Add raw script output to TX. "
        "Optionally add the \"W\" flag to produce a pay-to-witness-script-hash output. "
        "Optionally add the \"S\" flag to wrap the output in a pay-to-script-hash."replaceable(=N)"replaceable(=N)"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)"sign=SIGHASH-FLAGS"sign=SIGHASH-FLAGS"Add zero or more signatures to transaction. This command requires JSON registers:prevtxs=JSON object, privatekeys=JSON object. See signrawtransactionwithkey docs for format of sighash flags, JSON objects."Add zero or more signatures to transaction. "
        "This command requires JSON registers:"
        "prevtxs=JSON object, "
        "privatekeys=JSON object. "
        "See signrawtransactionwithkey docs for format of sighash flags, JSON objects."load=NAME:FILENAME"load=NAME:FILENAME"Load JSON file FILENAME into register NAME"Load JSON file FILENAME into register NAME"OptionsCategory::REGISTER_COMMANDSset=NAME:JSON-STRING"set=NAME:JSON-STRING"Set register NAME to given JSON-STRING"Set register NAME to given JSON-STRING"Secp256k1Init &const Secp256k1Initconst Secp256k1Init &Secp256k1Init~Secp256k1InitsighashOptions"DEFAULT"SIGHASH_DEFAULT"ALL""NONE"SIGHASH_NONESINGLE"SINGLE"ALL|ANYONECANPAY"ALL|ANYONECANPAY"SIGHASH_ALL|SIGHASH_ANYONECANPAYNONE|ANYONECANPAY"NONE|ANYONECANPAY"SIGHASH_NONE|SIGHASH_ANYONECANPAYSINGLE|ANYONECANPAY"SINGLE|ANYONECANPAY"SIGHASH_SINGLE|SIGHASH_ANYONECANPAYregistersfCreateBlank// "-" implies standard input// param: hex-encoded bitcoin transaction// require at least one param// Skip switches; Permit common stdin convention "-"// the hex-encoded transaction hash (aka the transaction id)/*block_hash=*/// Only sign SIGHASH_SINGLE if there's a corresponding output:// Sign what we can:// add redeemScript to the tempKeystore so it can be signed:// if redeemScript given and private keys given,// Add previous txouts given in the RPC call:// starts as a clone of the raw tx:// mergedTx will end up with all the signatures; it// delete output from transaction// parse requested deletion index// delete input from transaction// construct TxOut, append to transaction output list// Extract FLAGS// extract and validate script// Extract and validate VALUE// separate VALUE:SCRIPT[:FLAGS]// extract and validate DATA// separate [VALUE:]DATA in string// Get the ID for the script, and then construct a P2SH destination for it.// Build a P2WSH with the multisig script// Validate that there were no more parameters passed// extract and validate PUBKEYs// Validate there are the correct number of pubkeys// Extract NUMKEYS// Extract REQUIRED// Check that there are enough parameters// Separate into VALUE:REQUIRED:NUMKEYS:PUBKEY1:PUBKEY2:....[:FLAGS]// Build a P2WPKH script// Extract and validate FLAGS// Extract and validate PUBKEY// Separate into VALUE:PUBKEY[:FLAGS]// extract and validate ADDRESS// Separate into VALUE:ADDRESS// append to transaction input list// extract the optional sequence number// extract and validate vout// extract and validate TXID// separate TXID:VOUT in string// set the nSequence to MAX_INT - 2 (= RBF opt in flag)// parse requested index// evaluate as JSON buffer register// load file chunks into one big buffer// separate NAME:FILENAME in string// separate NAME:VALUE in string// First part of help message is specific to this utility// Check for chain settings (Params() calls are only valid after this clause)rawJsonint_strinitializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &&const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &unique_ptr<Secp256k1Init, default_delete<Secp256k1Init>>default_delete<Secp256k1Init> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>>allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>>const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &size_type(0)const __normal_iterator<const CTxIn *, vector<CTxIn, allocator<CTxIn>>>const __normal_iterator<const CTxIn *, vector<CTxIn, allocator<CTxIn>>> &__normal_iterator<const CTxIn *, vector<CTxIn, allocator<CTxIn>>> &map<basic_string<char, char_traits<char>, allocator<char>>, VType, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> *VType &&initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &unique_ptr<Secp256k1Init, default_delete<Secp256k1Init>> *Secp256k1Init *&const default_delete<Secp256k1Init>Secp256k1Init *&&Secp256k1Init *constSecp256k1Init *const &const default_delete<Secp256k1Init> &const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &&const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &__uniq_ptr_impl<Secp256k1Init, default_delete<Secp256k1Init>>__uniq_ptr_impl<Secp256k1Init, default_delete<Secp256k1Init>> &__uniq_ptr_impl<Secp256k1Init, default_delete<Secp256k1Init>> &&const __uniq_ptr_impl<Secp256k1Init, default_delete<Secp256k1Init>>const __uniq_ptr_impl<Secp256k1Init, default_delete<Secp256k1Init>> &default_delete<Secp256k1Init>default_delete<Secp256k1Init> &&const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> *new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> *const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> *__uniq_ptr_impl<Secp256k1Init, default_delete<Secp256k1Init>> *const default_delete<Secp256k1Init> *default_delete<Secp256k1Init> *__tuple_element_t<0UL, tuple<Secp256k1Init *, default_delete<Secp256k1Init>>> &tuple<Secp256k1Init *, default_delete<Secp256k1Init>> &const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> *const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *const optional<unsigned int> *optional<unsigned int> *const _Optional_base<unsigned int, true, true>const _Optional_base<unsigned int, true, true> *_Optional_base<unsigned int, true, true> *const _Optional_base_impl<unsigned int, _Optional_base<unsigned int, true, true>>const _Optional_base_impl<unsigned int, _Optional_base<unsigned int, true, true>> *_Optional_base_impl<unsigned int, _Optional_base<unsigned int, true, true>> *__and_<is_nothrow_move_constructible<Secp256k1Init *>, is_nothrow_move_assignable<Secp256k1Init *>>__and_<is_nothrow_move_constructible<Secp256k1Init *>, is_nothrow_move_assignable<Secp256k1Init *>> &__and_<is_nothrow_move_constructible<Secp256k1Init *>, is_nothrow_move_assignable<Secp256k1Init *>> &&const __and_<is_nothrow_move_constructible<Secp256k1Init *>, is_nothrow_move_assignable<Secp256k1Init *>>const __and_<is_nothrow_move_constructible<Secp256k1Init *>, is_nothrow_move_assignable<Secp256k1Init *>> &__and_<is_convertible<pointer, Secp256k1Init *>, __not_<is_array<_Up>>>tuple<Secp256k1Init *, default_delete<Secp256k1Init>>tuple<Secp256k1Init *, default_delete<Secp256k1Init>> &&const tuple<Secp256k1Init *, default_delete<Secp256k1Init>>const tuple<Secp256k1Init *, default_delete<Secp256k1Init>> &_Ptr<Secp256k1Init, default_delete<Secp256k1Init>, void>_Ptr<Secp256k1Init, default_delete<Secp256k1Init>, void> &_Ptr<Secp256k1Init, default_delete<Secp256k1Init>, void> &&const _Ptr<Secp256k1Init, default_delete<Secp256k1Init>, void>const _Ptr<Secp256k1Init, default_delete<Secp256k1Init>, void> &_Tuple_impl<0UL, Secp256k1Init *, default_delete<Secp256k1Init>>_Tuple_impl<0UL, Secp256k1Init *, default_delete<Secp256k1Init>> &&const _Tuple_impl<0UL, Secp256k1Init *, default_delete<Secp256k1Init>>const _Tuple_impl<0UL, Secp256k1Init *, default_delete<Secp256k1Init>> &_Tuple_impl<0UL, Secp256k1Init *, default_delete<Secp256k1Init>> &_Tuple_impl<1UL, default_delete<Secp256k1Init>>_Tuple_impl<1UL, default_delete<Secp256k1Init>> &&const _Tuple_impl<1UL, default_delete<Secp256k1Init>>const _Tuple_impl<1UL, default_delete<Secp256k1Init>> &_Tuple_impl<1UL, default_delete<Secp256k1Init>> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &&const is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const basic_string<char, char_traits<char>, allocator<char>>>unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const basic_string<char, char_traits<char>, allocator<char>>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const basic_string<char, char_traits<char>, allocator<char>>> &&const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const basic_string<char, char_traits<char>, allocator<char>>>const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const basic_string<char, char_traits<char>, allocator<char>>> &remove_reference<Secp256k1Init *&>remove_reference<Secp256k1Init *&> &remove_reference<Secp256k1Init *&> &&const remove_reference<Secp256k1Init *&>const remove_reference<Secp256k1Init *&> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &&const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &__tuple_element_t<1UL, tuple<Secp256k1Init *, default_delete<Secp256k1Init>>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &_Head_base<1UL, default_delete<Secp256k1Init>, true>_Head_base<1UL, default_delete<Secp256k1Init>, true> &const _Head_base<1UL, default_delete<Secp256k1Init>, true>const _Head_base<1UL, default_delete<Secp256k1Init>, true> &_Head_base<0UL, Secp256k1Init *, false>_Head_base<0UL, Secp256k1Init *, false> &const _Head_base<0UL, Secp256k1Init *, false>const _Head_base<0UL, Secp256k1Init *, false> &is_convertible<pointer, Secp256k1Init *>is_nothrow_move_assignable<Secp256k1Init *>is_nothrow_move_assignable<Secp256k1Init *> &is_nothrow_move_assignable<Secp256k1Init *> &&const is_nothrow_move_assignable<Secp256k1Init *>const is_nothrow_move_assignable<Secp256k1Init *> &is_nothrow_move_constructible<Secp256k1Init *>is_nothrow_move_constructible<Secp256k1Init *> &is_nothrow_move_constructible<Secp256k1Init *> &&const is_nothrow_move_constructible<Secp256k1Init *>const is_nothrow_move_constructible<Secp256k1Init *> &_Tuple_impl<0UL, Secp256k1Init *, default_delete<Secp256k1Init>> *const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> *_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *tuple_element<0UL, tuple<Secp256k1Init *, default_delete<Secp256k1Init>>>tuple_element<0UL, tuple<Secp256k1Init *, default_delete<Secp256k1Init>>> &tuple_element<0UL, tuple<Secp256k1Init *, default_delete<Secp256k1Init>>> &&const tuple_element<0UL, tuple<Secp256k1Init *, default_delete<Secp256k1Init>>>const tuple_element<0UL, tuple<Secp256k1Init *, default_delete<Secp256k1Init>>> &conditional<true, is_nothrow_move_assignable<Secp256k1Init *>, is_nothrow_move_constructible<Secp256k1Init *>>conditional<true, is_nothrow_move_assignable<Secp256k1Init *>, is_nothrow_move_constructible<Secp256k1Init *>> &conditional<true, is_nothrow_move_assignable<Secp256k1Init *>, is_nothrow_move_constructible<Secp256k1Init *>> &&const conditional<true, is_nothrow_move_assignable<Secp256k1Init *>, is_nothrow_move_constructible<Secp256k1Init *>>const conditional<true, is_nothrow_move_assignable<Secp256k1Init *>, is_nothrow_move_constructible<Secp256k1Init *>> &__is_nothrow_move_constructible_impl<Secp256k1Init *, true>__is_nothrow_move_constructible_impl<Secp256k1Init *, true> &__is_nothrow_move_constructible_impl<Secp256k1Init *, true> &&const __is_nothrow_move_constructible_impl<Secp256k1Init *, true>const __is_nothrow_move_constructible_impl<Secp256k1Init *, true> &__is_nt_move_assignable_impl<Secp256k1Init *, true>__is_nt_move_assignable_impl<Secp256k1Init *, true> &__is_nt_move_assignable_impl<Secp256k1Init *, true> &&const __is_nt_move_assignable_impl<Secp256k1Init *, true>const __is_nt_move_assignable_impl<Secp256k1Init *, true> &_TC<value, Secp256k1Init *, default_delete<Secp256k1Init>>_TC<true, Secp256k1Init *, default_delete<Secp256k1Init>>_TC<true, Secp256k1Init *, default_delete<Secp256k1Init>> &_TC<true, Secp256k1Init *, default_delete<Secp256k1Init>> &&const _TC<true, Secp256k1Init *, default_delete<Secp256k1Init>>const _TC<true, Secp256k1Init *, default_delete<Secp256k1Init>> &__and_<is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *, _Ptr>, __not_<is_pointer<_Ptr>>>remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &>remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &> &remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &> &&const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &>const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &> &remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &>remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &> &remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &> &&const remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &>const remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *_Head_base<0UL, Secp256k1Init *, false> *_Tuple_impl<1UL, default_delete<Secp256k1Init>> *tuple_element<0UL, tuple<default_delete<Secp256k1Init>>>tuple_element<0UL, tuple<default_delete<Secp256k1Init>>> &tuple_element<0UL, tuple<default_delete<Secp256k1Init>>> &&const tuple_element<0UL, tuple<default_delete<Secp256k1Init>>>const tuple_element<0UL, tuple<default_delete<Secp256k1Init>>> &is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *, _Ptr>__is_empty_non_tuple<default_delete<Secp256k1Init>>__is_empty_non_tuple<default_delete<Secp256k1Init>> &__is_empty_non_tuple<default_delete<Secp256k1Init>> &&const __is_empty_non_tuple<default_delete<Secp256k1Init>>const __is_empty_non_tuple<default_delete<Secp256k1Init>> &__is_empty_non_tuple<Secp256k1Init *>__is_empty_non_tuple<Secp256k1Init *> &__is_empty_non_tuple<Secp256k1Init *> &&const __is_empty_non_tuple<Secp256k1Init *>const __is_empty_non_tuple<Secp256k1Init *> &is_nothrow_assignable<Secp256k1Init *&, Secp256k1Init *&&>is_nothrow_assignable<Secp256k1Init *&, Secp256k1Init *&&> &is_nothrow_assignable<Secp256k1Init *&, Secp256k1Init *&&> &&const is_nothrow_assignable<Secp256k1Init *&, Secp256k1Init *&&>const is_nothrow_assignable<Secp256k1Init *&, Secp256k1Init *&&> &__is_referenceable<Secp256k1Init *>__is_referenceable<Secp256k1Init *> &__is_referenceable<Secp256k1Init *> &&const __is_referenceable<Secp256k1Init *>const __is_referenceable<Secp256k1Init *> &is_nothrow_constructible<Secp256k1Init *, Secp256k1Init *&&>is_nothrow_constructible<Secp256k1Init *, Secp256k1Init *&&> &is_nothrow_constructible<Secp256k1Init *, Secp256k1Init *&&> &&const is_nothrow_constructible<Secp256k1Init *, Secp256k1Init *&&>const is_nothrow_constructible<Secp256k1Init *, Secp256k1Init *&&> &_Head_base<1UL, default_delete<Secp256k1Init>, true> *__and_<is_assignable<Secp256k1Init *&, Secp256k1Init *&&>, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>>__and_<is_assignable<Secp256k1Init *&, Secp256k1Init *&&>, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>> &__and_<is_assignable<Secp256k1Init *&, Secp256k1Init *&&>, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>> &&const __and_<is_assignable<Secp256k1Init *&, Secp256k1Init *&&>, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>>const __and_<is_assignable<Secp256k1Init *&, Secp256k1Init *&&>, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Secp256k1Init *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Secp256k1Init *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Secp256k1Init *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Secp256k1Init *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<Secp256k1Init *>> &is_empty<Secp256k1Init *>is_empty<Secp256k1Init *> &is_empty<Secp256k1Init *> &&const is_empty<Secp256k1Init *>const is_empty<Secp256k1Init *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<Secp256k1Init>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<Secp256k1Init>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<Secp256k1Init>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<Secp256k1Init>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<Secp256k1Init>>> &is_empty<default_delete<Secp256k1Init>>is_empty<default_delete<Secp256k1Init>> &is_empty<default_delete<Secp256k1Init>> &&const is_empty<default_delete<Secp256k1Init>>const is_empty<default_delete<Secp256k1Init>> &tuple<default_delete<Secp256k1Init>>__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &&const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> &__is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>__is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&> &__is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&> &&const __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>const __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&> &is_assignable<Secp256k1Init *&, Secp256k1Init *&&>is_assignable<Secp256k1Init *&, Secp256k1Init *&&> &is_assignable<Secp256k1Init *&, Secp256k1Init *&&> &&const is_assignable<Secp256k1Init *&, Secp256k1Init *&&>const is_assignable<Secp256k1Init *&, Secp256k1Init *&&> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *&>remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *&> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *&> &&const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *&>const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>> *&> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &>is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &> &&const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &>const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, VType> &> &conditional<true, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>, is_assignable<Secp256k1Init *&, Secp256k1Init *&&>>conditional<true, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>, is_assignable<Secp256k1Init *&, Secp256k1Init *&&>> &conditional<true, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>, is_assignable<Secp256k1Init *&, Secp256k1Init *&&>> &&const conditional<true, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>, is_assignable<Secp256k1Init *&, Secp256k1Init *&&>>const conditional<true, __is_nt_assignable_impl<Secp256k1Init *&, Secp256k1Init *&&>, is_assignable<Secp256k1Init *&, Secp256k1Init *&&>> &crefreference_wrapperconst reference_wrapper<_Tp>const reference_wrapper<_Tp> *reference_wrapper<_Tp> *operator _Tp &reference_wrapper<_Tp> &const reference_wrapper<_Tp> &_Reference_wrapper_base_memfun<_MemFunPtr, true>__maybe_type_MemFunPtr__result_type_Reference_wrapper_base_memfun<_Tp, <unnamed>>_Reference_wrapper_base<..(*)(..)>_Reference_wrapper_base<..(..)>_Reference_wrapper_base<_Tp>_Refwrap_base_arg2<_Tp, __void_t<first_argument_type, second_argument_type>>_Refwrap_base_arg2<_Tp, <unnamed>>_Refwrap_base_arg1<_Tp, __void_t<argument_type>>_Refwrap_base_arg1<_Tp, <unnamed>>_Weak_result_type<_Functor>_Weak_result_type_memfun<_Func _Class::*, false>_Weak_result_type_memfun<_MemFunPtr, true>_Weak_result_type_memfun<_Functor, <unnamed>>_Weak_result_type_impl<..(*)(..)>_Weak_result_type_impl<..(..)>_Weak_result_type_impl<_Functor>_Maybe_get_result_type<_Functor, __void_t<result_type>>_Maybe_get_result_type<_Functor, <unnamed>>_Mem_fn_traits<..(*)(..)>_Mem_fn_traits_base<_Res, _Class, _ArgTypes...>_Mem_fn_traits<_Signature>_Maybe_unary_or_binary_function<_Res, _T1, _T2>_Maybe_unary_or_binary_function<_Res, _T1>_Maybe_unary_or_binary_function<_Res, _ArgTypes...>reference_wrapper<_Tp>__not_same&& noexceptfalse_typetrue_typeconst volatilevolatile& noexceptnoexcept_Up2_GLIBCXX_MEM_FN_TRAITS2_GLIBCXX_MEM_FN_TRAITS_GLIBCXX_MEM_FN_TRAITS(_REF,_LVAL,_RVAL)_GLIBCXX_MEM_FN_TRAITS2( , _REF, _LVAL, _RVAL) _GLIBCXX_MEM_FN_TRAITS2(const , _REF, _LVAL, _RVAL) _GLIBCXX_MEM_FN_TRAITS2(volatile , _REF, _LVAL, _RVAL) _GLIBCXX_MEM_FN_TRAITS2(const volatile, _REF, _LVAL, _RVAL)_GLIBCXX_MEM_FN_TRAITS2(_CV,_REF,_LVAL,_RVAL)template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) _CV _REF> : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) _CV _REF> : _Mem_fn_traits_base<_Res, _CV _Class, _ArgTypes...> { using __vararg = true_type; };_GLIBCXX_REFWRAP_H__cplusplus <= 201703L// _GLIBCXX_REFWRAP_H/// @} group functors/// std::cref overload to prevent wrapping a reference_wrapper/// std::ref overload to prevent wrapping a reference_wrapper/// Denotes a const reference should be taken to a variable./// Denotes a reference should be taken to a variable.// 3041. Unnecessary decay in reference_wrapper// 2993. reference_wrapper<T> conversion from T&&// so checking for nested types could result in ODR violations.// In C++20 std::reference_wrapper<T> allows T to be incomplete,/**
   *  @brief Primary class template for reference_wrapper.
   *  @ingroup functors
   *  @{
   */// ! C++20// - a function pointer type (binary)// - a function pointer type (unary)// - a function type (binary)// - a function type (unary)/**
   *  Derives from unary_function or binary_function when it
   *  can. Specializations handle all of the easy cases. The primary
   *  template determines what to do with a class type, which may
   *  derive from both unary_function and binary_function.
  */// Nested first_argument_type and second_argument_type.// Detect nested first_argument_type and second_argument_type.// Nested argument_type.// Detect nested argument_type./**
   *  Strip top-level cv-qualifiers from the function object and let
   *  _Weak_result_type_memfun perform the real work.
  */// A pointer to data member doesn't have a weak result type.// A pointer to member function has a weak result type.// Let _Weak_result_type_impl perform the real work./// Retrieve the result type for a varargs function pointer./// Retrieve the result type for a function pointer./// Retrieve the result type for a varargs function type./// Retrieve the result type for a function type./**
   *  Base class for any function object that has a weak result type, as
   *  defined in 20.8.2 [func.require] of C++11.
  *//// If we have found a result_type, extract it./// Derives from @c binary_function, as appropriate./// Derives from @c unary_function, as appropriate./**
   * Derives from @c unary_function or @c binary_function, or perhaps
   * nothing, depending on the number of arguments provided. The
   * primary template is the basis case, which derives nothing.
   */// for unary_function and binary_function/** @file include/bits/refwrap.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Implementation of std::reference_wrapper -*- C++ -*-__ureflambda [] type at line 81177, col. 58lambda [] type at line 81177, col. 58 &const lambda [] type at line 81177, col. 58const lambda [] type at line 81177, col. 58 &const lambda [] type at line 81177, col. 58 *lambda [] type at line 81177, col. 58 *TxToUnivTxVerbosity::SHOW_DETAILSScriptToUnivSighashToStrEncodeHexTxFormatScriptValueFromAmountParseSighashStringParseHexUVParseHashStrDecodeHexBlockHeaderDecodeHexBlkDecodeHexTxScriptToAsmStrParseScriptTxVerbositySHOW_TXIDSHOW_DETAILSSHOW_DETAILS_AND_PREVOUTCTxUndoBITCOIN_CORE_IO_H// BITCOIN_CORE_IO_H// core_write.cpp/**
 * Parse a hex string into 256 bits
 * @param[in] strHex a hex-formatted, 64-character string
 * @param[out] result the result of the parsing
 * @returns true if successful, false if not
 *
 * @see ParseHashV for an RPC-oriented version of this
 */// core_read.cpp//!< The same as previous option with information about prevouts if available//!< Include TXID, inputs, outputs, and other common block's transaction information//!< Only TXID for each block's transaction/**
 * Verbose level for block's transaction
 */include_hexserialize_flagstxundoverbosityinclude_addressserializeFlagssighashstrNamehex_headerstrHexBlkhex_txtry_no_witnesstry_witnessfAttemptSighashDecode/home/tanteikg/QCVE/sources/bitcoin/src/bitcoin-util.cpp<chain.h>AppInitUtil()"AppInitUtil()"const optional<const Command>Error: must specify a command
"Error: must specify a command\n"const Command *Command *grind"grind"bitcoin-util.cppint main(int, char **)unknown error"unknown error"optional<const Command> *_Optional_base<const Command, false, false> *GrindMust specify block header to grind"Must specify block header to grind"Could not decode block header"Could not decode block header"proposed_noncethreadsn_tasks1uatomic<bool> &..(&)(..)reference_wrapper<atomic<bool>> &&reference_wrapper<unsigned int> &&reference_wrapper<atomic<bool>> &reference_wrapper<unsigned int> &const atomic<bool>Could not satisfy difficulty target"Could not satisfy difficulty target"grind_taskoverfinishAppInitUtilBitcoin Core bitcoin-util utility version 
Usage:  bitcoin-util [options] [commands]  Do stuff
"\n"
                "Usage:  bitcoin-util [options] [commands]  Do stuff\n"SetupBitcoinUtilArgsPerform proof of work on hex header string"Perform proof of work on hex header string"// unknown command should be caught earlierstepreference_wrapper<unsigned int>reference_wrapper<atomic<bool>>atomic<bool> *_State_impl<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>_State_impl<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> *_State_impl<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &_State_impl<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &&const _State_impl<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>const _State_impl<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const _Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const _Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> *tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> *_Tuple_impl<0UL, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&_Tuple_impl<0UL, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<0UL, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<0UL, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<0UL, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &const reference_wrapper<atomic<bool>>const reference_wrapper<atomic<bool>> &const reference_wrapper<unsigned int>const reference_wrapper<unsigned int> &__result<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>__result<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__result<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const __result<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const __result<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Reference_wrapper_base_memfun<atomic<bool>, false>_Reference_wrapper_base_memfun_Reference_wrapper_base_memfun<atomic<bool>, false> &_Reference_wrapper_base_memfun<atomic<bool>, false> &&const _Reference_wrapper_base_memfun<atomic<bool>, false>const _Reference_wrapper_base_memfun<atomic<bool>, false> &_Reference_wrapper_base_memfun<unsigned int, false>_Reference_wrapper_base_memfun<unsigned int, false> &_Reference_wrapper_base_memfun<unsigned int, false> &&const _Reference_wrapper_base_memfun<unsigned int, false>const _Reference_wrapper_base_memfun<unsigned int, false> &const _Vector_base<thread, allocator<thread>>const _Vector_base<thread, allocator<thread>> *noexcept(reference_wrapper::_S_fun(std::declval<_Up>()))_Tuple_impl<0UL, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> *__and_<is_nothrow_move_constructible<_Head>,
	              is_nothrow_move_constructible<_Inherited>>::value_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &__and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>__and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &__and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &&const __and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>const __and_<is_nothrow_move_constructible<..(*)(..)>, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &_Index_tuple<0UL, 1UL, 2UL, 3UL, 4UL, 5UL, 6UL>_Index_tuple<0UL, 1UL, 2UL, 3UL, 4UL, 5UL, 6UL> &_Index_tuple<0UL, 1UL, 2UL, 3UL, 4UL, 5UL, 6UL> &&const _Index_tuple<0UL, 1UL, 2UL, 3UL, 4UL, 5UL, 6UL>const _Index_tuple<0UL, 1UL, 2UL, 3UL, 4UL, 5UL, 6UL> &is_nothrow_constructible<thread, ..(&)(..), unsigned int &, CBlockHeader &, int &, int &, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>is_nothrow_constructible<thread, ..(&)(..), unsigned int &, CBlockHeader &, int &, int &, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &is_nothrow_constructible<thread, ..(&)(..), unsigned int &, CBlockHeader &, int &, int &, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const is_nothrow_constructible<thread, ..(&)(..), unsigned int &, CBlockHeader &, int &, int &, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const is_nothrow_constructible<thread, ..(&)(..), unsigned int &, CBlockHeader &, int &, int &, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &is_member_function_pointer<unsigned int>is_member_function_pointer<unsigned int> &is_member_function_pointer<unsigned int> &&const is_member_function_pointer<unsigned int>const is_member_function_pointer<unsigned int> &_Reference_wrapper_base<unsigned int>_Reference_wrapper_base_Reference_wrapper_base<unsigned int> &_Reference_wrapper_base<unsigned int> &&const _Reference_wrapper_base<unsigned int>const _Reference_wrapper_base<unsigned int> &is_member_function_pointer<atomic<bool>>is_member_function_pointer<atomic<bool>> &is_member_function_pointer<atomic<bool>> &&const is_member_function_pointer<atomic<bool>>const is_member_function_pointer<atomic<bool>> &_Reference_wrapper_base<atomic<bool>>_Reference_wrapper_base<atomic<bool>> &_Reference_wrapper_base<atomic<bool>> &&const _Reference_wrapper_base<atomic<bool>>const _Reference_wrapper_base<atomic<bool>> &__invoke_result<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>__invoke_result<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &__invoke_result<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const __invoke_result<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const __invoke_result<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<6UL, reference_wrapper<unsigned int>>_Tuple_impl<6UL, _UHead> &&const _Tuple_impl<6UL, _UHead>const _Tuple_impl<6UL, _UHead> &_Tuple_impl<6UL, _UHead> &_Tuple_impl<6UL, reference_wrapper<unsigned int>> &&const _Tuple_impl<6UL, reference_wrapper<unsigned int>>const _Tuple_impl<6UL, reference_wrapper<unsigned int>> &_Tuple_impl<6UL, reference_wrapper<unsigned int>> &_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>_Tuple_impl<5UL, _UHead, _UTails...> &&const _Tuple_impl<5UL, _UElements...>const _Tuple_impl<5UL, _UElements...> &_Tuple_impl<5UL, _UElements...> &const _Tuple_impl<5UL, _UHead, _UTails...>const _Tuple_impl<5UL, _UHead, _UTails...> &_Tuple_impl<5UL, _UHead, _UTails...> &_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const _Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>_Tuple_impl<4UL, _UHead, _UTails...> &&const _Tuple_impl<4UL, _UElements...>const _Tuple_impl<4UL, _UElements...> &_Tuple_impl<4UL, _UElements...> &const _Tuple_impl<4UL, _UHead, _UTails...>const _Tuple_impl<4UL, _UHead, _UTails...> &_Tuple_impl<4UL, _UHead, _UTails...> &_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const _Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>_Tuple_impl<3UL, _UHead, _UTails...> &&const _Tuple_impl<3UL, _UElements...>const _Tuple_impl<3UL, _UElements...> &_Tuple_impl<3UL, _UElements...> &const _Tuple_impl<3UL, _UHead, _UTails...>const _Tuple_impl<3UL, _UHead, _UTails...> &_Tuple_impl<3UL, _UHead, _UTails...> &_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const _Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const _Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &_Head_base<0UL, ..(*)(..), false>_Head_base<0UL, ..(*)(..), false> &const _Head_base<0UL, ..(*)(..), false>const _Head_base<0UL, ..(*)(..), false> &_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const _Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &remove_reference<..(&)(..)>remove_reference<..(&)(..)> &remove_reference<..(&)(..)> &&const remove_reference<..(&)(..)>const remove_reference<..(&)(..)> &remove_reference<reference_wrapper<atomic<bool>>>remove_reference<reference_wrapper<atomic<bool>>> &remove_reference<reference_wrapper<atomic<bool>>> &&const remove_reference<reference_wrapper<atomic<bool>>>const remove_reference<reference_wrapper<atomic<bool>>> &remove_reference<reference_wrapper<unsigned int>>remove_reference<reference_wrapper<unsigned int>> &remove_reference<reference_wrapper<unsigned int>> &&const remove_reference<reference_wrapper<unsigned int>>const remove_reference<reference_wrapper<unsigned int>> &remove_reference<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>remove_reference<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &remove_reference<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &&const remove_reference<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>const remove_reference<_Invoker<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> *unsigned int &&__tuple_element_t<0UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&__tuple_element_t<0UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__tuple_element_t<1UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&__tuple_element_t<1UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__tuple_element_t<2UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&__tuple_element_t<2UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__tuple_element_t<3UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&__tuple_element_t<3UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__tuple_element_t<4UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&__tuple_element_t<4UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__tuple_element_t<5UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&__tuple_element_t<5UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__tuple_element_t<6UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&__tuple_element_t<6UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>__and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &__and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &&const __and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>const __and_<is_nothrow_move_constructible<unsigned int>, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &_Head_base<1UL, unsigned int, false>_Head_base<1UL, unsigned int, false> &const _Head_base<1UL, unsigned int, false>const _Head_base<1UL, unsigned int, false> &_Head_base<2UL, CBlockHeader, false>_Head_base<2UL, CBlockHeader, false> &const _Head_base<2UL, CBlockHeader, false>const _Head_base<2UL, CBlockHeader, false> &_Head_base<3UL, int, false>_Head_base<3UL, int, false> &const _Head_base<3UL, int, false>const _Head_base<3UL, int, false> &_Tuple_impl<4UL, _UElements...>_Tuple_impl<4UL, _UHead, _UTails...>_Head_base<4UL, int, false>_Head_base<4UL, int, false> &const _Head_base<4UL, int, false>const _Head_base<4UL, int, false> &_Tuple_impl<5UL, _UElements...>_Tuple_impl<5UL, _UHead, _UTails...>_Head_base<5UL, reference_wrapper<atomic<bool>>, false>_Head_base<5UL, reference_wrapper<atomic<bool>>, false> &const _Head_base<5UL, reference_wrapper<atomic<bool>>, false>const _Head_base<5UL, reference_wrapper<atomic<bool>>, false> &_Tuple_impl<6UL, _UHead>_Head_base<6UL, reference_wrapper<unsigned int>, false>_Head_base<6UL, reference_wrapper<unsigned int>, false> &const _Head_base<6UL, reference_wrapper<unsigned int>, false>const _Head_base<6UL, reference_wrapper<unsigned int>, false> &_TC<value, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>_TC<<expression>, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>_Refwrap_base_arg2<atomic<bool>, void>_Refwrap_base_arg2<atomic<bool>, void> &_Refwrap_base_arg2<atomic<bool>, void> &&const _Refwrap_base_arg2<atomic<bool>, void>const _Refwrap_base_arg2<atomic<bool>, void> &_Refwrap_base_arg1<atomic<bool>, void>_Refwrap_base_arg1<atomic<bool>, void> &_Refwrap_base_arg1<atomic<bool>, void> &&const _Refwrap_base_arg1<atomic<bool>, void>const _Refwrap_base_arg1<atomic<bool>, void> &_Weak_result_type<atomic<bool>>_Weak_result_type_Weak_result_type<atomic<bool>> &_Weak_result_type<atomic<bool>> &&const _Weak_result_type<atomic<bool>>const _Weak_result_type<atomic<bool>> &_Refwrap_base_arg2<unsigned int, void>_Refwrap_base_arg2<unsigned int, void> &_Refwrap_base_arg2<unsigned int, void> &&const _Refwrap_base_arg2<unsigned int, void>const _Refwrap_base_arg2<unsigned int, void> &_Refwrap_base_arg1<unsigned int, void>_Refwrap_base_arg1<unsigned int, void> &_Refwrap_base_arg1<unsigned int, void> &&const _Refwrap_base_arg1<unsigned int, void>const _Refwrap_base_arg1<unsigned int, void> &_Weak_result_type<unsigned int>_Weak_result_type<unsigned int> &_Weak_result_type<unsigned int> &&const _Weak_result_type<unsigned int>const _Weak_result_type<unsigned int> &_Build_index_tuple<7UL>_Build_index_tuple<7UL> &_Build_index_tuple<7UL> &&const _Build_index_tuple<7UL>const _Build_index_tuple<7UL> &is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &remove_reference<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>remove_reference<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &remove_reference<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &&const remove_reference<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>const remove_reference<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &remove_reference<..(*)(..)>remove_reference<..(*)(..)> &remove_reference<..(*)(..)> &&const remove_reference<..(*)(..)>const remove_reference<..(*)(..)> &_Head_base<0UL, ..(*)(..), false> *_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> *__and_<is_nothrow_move_constructible<CBlockHeader>, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>__and_<is_nothrow_move_constructible<CBlockHeader>, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &__and_<is_nothrow_move_constructible<CBlockHeader>, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &&const __and_<is_nothrow_move_constructible<CBlockHeader>, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>const __and_<is_nothrow_move_constructible<CBlockHeader>, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &__is_nothrow_invocable<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>__is_nothrow_invocable<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &__is_nothrow_invocable<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const __is_nothrow_invocable<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const __is_nothrow_invocable<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &conditional<true, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<..(*)(..)>>conditional<true, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<..(*)(..)>> &conditional<true, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<..(*)(..)>> &&const conditional<true, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<..(*)(..)>>const conditional<true, is_nothrow_move_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<..(*)(..)>> &__is_nothrow_move_constructible_impl<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true>__is_nothrow_move_constructible_impl<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &__is_nothrow_move_constructible_impl<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &&const __is_nothrow_move_constructible_impl<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true>const __is_nothrow_move_constructible_impl<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &_Weak_result_type_memfun<unsigned int, false>_Weak_result_type_memfun_Weak_result_type_memfun<unsigned int, false> &_Weak_result_type_memfun<unsigned int, false> &&const _Weak_result_type_memfun<unsigned int, false>const _Weak_result_type_memfun<unsigned int, false> &_Weak_result_type_memfun<atomic<bool>, false>_Weak_result_type_memfun<atomic<bool>, false> &_Weak_result_type_memfun<atomic<bool>, false> &&const _Weak_result_type_memfun<atomic<bool>, false>const _Weak_result_type_memfun<atomic<bool>, false> &is_same<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, tuple<_UElements...>>__result_of_impl<false, false, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>__result_of_impl<false, false, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &__result_of_impl<false, false, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&const __result_of_impl<false, false, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>const __result_of_impl<false, false, ..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &__is_empty_non_tuple<..(*)(..)>__is_empty_non_tuple<..(*)(..)> &__is_empty_non_tuple<..(*)(..)> &&const __is_empty_non_tuple<..(*)(..)>const __is_empty_non_tuple<..(*)(..)> &is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &remove_reference<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>remove_reference<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &remove_reference<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &&const remove_reference<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>const remove_reference<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &remove_reference<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>remove_reference<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &remove_reference<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &&const remove_reference<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>const remove_reference<tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> *__and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>__and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &__and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &&const __and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>const __and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &tuple_element<0UL, tuple<reference_wrapper<unsigned int>>>tuple_element<0UL, tuple<reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<reference_wrapper<unsigned int>>> &&const tuple_element<0UL, tuple<reference_wrapper<unsigned int>>>const tuple_element<0UL, tuple<reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>tuple_element<0UL, tuple<reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const tuple_element<0UL, tuple<reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const tuple_element<0UL, tuple<reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>tuple_element<0UL, tuple<int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const tuple_element<0UL, tuple<int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const tuple_element<0UL, tuple<int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>tuple_element<0UL, tuple<int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const tuple_element<0UL, tuple<int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const tuple_element<0UL, tuple<int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>tuple_element<0UL, tuple<CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const tuple_element<0UL, tuple<CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const tuple_element<0UL, tuple<CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>tuple_element<0UL, tuple<unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const tuple_element<0UL, tuple<unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const tuple_element<0UL, tuple<unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>tuple_element<0UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &tuple_element<0UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const tuple_element<0UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const tuple_element<0UL, tuple<..(*)(..), unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &conditional<true, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<unsigned int>>conditional<true, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<unsigned int>> &conditional<true, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<unsigned int>> &&const conditional<true, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<unsigned int>>const conditional<true, is_nothrow_move_constructible<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<unsigned int>> &__is_nothrow_move_constructible_impl<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true>__is_nothrow_move_constructible_impl<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &__is_nothrow_move_constructible_impl<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &&const __is_nothrow_move_constructible_impl<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true>const __is_nothrow_move_constructible_impl<_Tuple_impl<2UL, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &__is_empty_non_tuple<unsigned int>__is_empty_non_tuple<unsigned int> &__is_empty_non_tuple<unsigned int> &&const __is_empty_non_tuple<unsigned int>const __is_empty_non_tuple<unsigned int> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<..(*)(..)>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<..(*)(..)>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<..(*)(..)>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<..(*)(..)>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<..(*)(..)>> &is_empty<..(*)(..)>is_empty<..(*)(..)> &is_empty<..(*)(..)> &&const is_empty<..(*)(..)>const is_empty<..(*)(..)> &__is_empty_non_tuple<CBlockHeader>__is_empty_non_tuple<CBlockHeader> &__is_empty_non_tuple<CBlockHeader> &&const __is_empty_non_tuple<CBlockHeader>const __is_empty_non_tuple<CBlockHeader> &__is_empty_non_tuple<reference_wrapper<atomic<bool>>>__is_empty_non_tuple<reference_wrapper<atomic<bool>>> &__is_empty_non_tuple<reference_wrapper<atomic<bool>>> &&const __is_empty_non_tuple<reference_wrapper<atomic<bool>>>const __is_empty_non_tuple<reference_wrapper<atomic<bool>>> &__is_empty_non_tuple<reference_wrapper<unsigned int>>__is_empty_non_tuple<reference_wrapper<unsigned int>> &__is_empty_non_tuple<reference_wrapper<unsigned int>> &&const __is_empty_non_tuple<reference_wrapper<unsigned int>>const __is_empty_non_tuple<reference_wrapper<unsigned int>> &_Weak_result_type_impl<atomic<bool>>_Weak_result_type_impl_Weak_result_type_impl<atomic<bool>> &_Weak_result_type_impl<atomic<bool>> &&const _Weak_result_type_impl<atomic<bool>>const _Weak_result_type_impl<atomic<bool>> &_Weak_result_type_impl<unsigned int>_Weak_result_type_impl<unsigned int> &_Weak_result_type_impl<unsigned int> &&const _Weak_result_type_impl<unsigned int>const _Weak_result_type_impl<unsigned int> &__is_referenceable<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>__is_referenceable<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &__is_referenceable<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const __is_referenceable<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const __is_referenceable<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &is_nothrow_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, _Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&>is_nothrow_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, _Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&> &is_nothrow_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, _Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&> &&const is_nothrow_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, _Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&>const is_nothrow_constructible<_Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, _Tuple_impl<1UL, unsigned int, CBlockHeader, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &&> &remove_reference<reference_wrapper<unsigned int> &&>remove_reference<reference_wrapper<unsigned int> &&> &remove_reference<reference_wrapper<unsigned int> &&> &&const remove_reference<reference_wrapper<unsigned int> &&>const remove_reference<reference_wrapper<unsigned int> &&> &remove_reference<reference_wrapper<atomic<bool>> &&>remove_reference<reference_wrapper<atomic<bool>> &&> &remove_reference<reference_wrapper<atomic<bool>> &&> &&const remove_reference<reference_wrapper<atomic<bool>> &&>const remove_reference<reference_wrapper<atomic<bool>> &&> &remove_reference<CBlockHeader &&>remove_reference<CBlockHeader &&> &remove_reference<CBlockHeader &&> &&const remove_reference<CBlockHeader &&>const remove_reference<CBlockHeader &&> &remove_reference<unsigned int &&>remove_reference<unsigned int &&> &remove_reference<unsigned int &&> &&const remove_reference<unsigned int &&>const remove_reference<unsigned int &&> &remove_reference<..(*&&)(..)>remove_reference<..(*&&)(..)> &remove_reference<..(*&&)(..)> &&const remove_reference<..(*&&)(..)>const remove_reference<..(*&&)(..)> &is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &&const is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>const is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>> &is_nothrow_move_constructible<CBlockHeader>is_nothrow_move_constructible<CBlockHeader> &is_nothrow_move_constructible<CBlockHeader> &&const is_nothrow_move_constructible<CBlockHeader>const is_nothrow_move_constructible<CBlockHeader> &remove_reference<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>remove_reference<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &remove_reference<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &&const remove_reference<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &>const remove_reference<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> &> &operator unsigned int &const reference_wrapper<unsigned int> *reference_wrapper<unsigned int> *operator std::atomic<bool> &const reference_wrapper<atomic<bool>> *reference_wrapper<atomic<bool>> *_Tuple_impl<4UL, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>> *__and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>__and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &__and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &&const __and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>>const __and_<is_nothrow_move_constructible<int>, is_nothrow_move_constructible<_Tuple_impl<5UL, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>> &conditional<true, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<CBlockHeader>>conditional<true, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<CBlockHeader>> &conditional<true, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<CBlockHeader>> &&const conditional<true, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<CBlockHeader>>const conditional<true, is_nothrow_move_constructible<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>>, is_nothrow_move_constructible<CBlockHeader>> &__is_nothrow_move_constructible_impl<CBlockHeader, true>__is_nothrow_move_constructible_impl<CBlockHeader, true> &__is_nothrow_move_constructible_impl<CBlockHeader, true> &&const __is_nothrow_move_constructible_impl<CBlockHeader, true>const __is_nothrow_move_constructible_impl<CBlockHeader, true> &__is_nothrow_move_constructible_impl<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true>__is_nothrow_move_constructible_impl<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &__is_nothrow_move_constructible_impl<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &&const __is_nothrow_move_constructible_impl<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true>const __is_nothrow_move_constructible_impl<_Tuple_impl<3UL, int, int, reference_wrapper<atomic<bool>>, reference_wrapper<unsigned int>>, true> &_Maybe_get_result_type<unsigned int, void>_Maybe_get_result_type<unsigned int, void> &_Maybe_get_result_type<unsigned int, void> &&const _Maybe_get_result_type<unsigned int, void>const _Maybe_get_result_type<unsigned int, void> &_Maybe_get_result_type<atomic<bool>, void>_Maybe_get_result_type<atomic<bool>, void> &_Maybe_get_result_type<atomic<bool>, void> &&const _Maybe_get_result_type<atomic<bool>, void>const _Maybe_get_result_type<atomic<bool>, void> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<unsigned int>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<unsigned int>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<unsigned int>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<unsigned int>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<unsigned int>>> &is_empty<reference_wrapper<unsigned int>>is_empty<reference_wrapper<unsigned int>> &is_empty<reference_wrapper<unsigned int>> &&const is_empty<reference_wrapper<unsigned int>>const is_empty<reference_wrapper<unsigned int>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<atomic<bool>>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<atomic<bool>>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<atomic<bool>>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<atomic<bool>>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<reference_wrapper<atomic<bool>>>> &is_empty<reference_wrapper<atomic<bool>>>is_empty<reference_wrapper<atomic<bool>>> &is_empty<reference_wrapper<atomic<bool>>> &&const is_empty<reference_wrapper<atomic<bool>>>const is_empty<re !  jL    