/usr/include/features.h<gnu/stubs.h><sys/cdefs.h><stdc-predef.h>__GLIBC_PREREQ(maj,min)((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))__GLIBC_MINOR__31__GLIBC__2__GNU_LIBRARY__6__GLIBC_USE_DEPRECATED_SCANF0__GLIBC_USE_DEPRECATED_GETS__USE_FORTIFY_LEVEL__USE_GNU1__USE_ATFILE__USE_MISC__USE_LARGEFILE64__USE_LARGEFILE__USE_ISOC99__USE_ISOC95__USE_XOPEN2KXSI__USE_XOPEN2K__USE_XOPEN2K8XSI__USE_XOPEN2K8_LARGEFILE_SOURCE__USE_UNIX98__USE_XOPEN_EXTENDED__USE_XOPEN_ATFILE_SOURCE__USE_POSIX199506__USE_POSIX199309__USE_POSIX2__USE_POSIX_POSIX_C_SOURCE200809L_POSIX_SOURCE__USE_ISOCXX11__USE_ISOC11__GLIBC_USE_ISOC2X_DEFAULT_SOURCE_LARGEFILE64_SOURCE_XOPEN_SOURCE_EXTENDED_XOPEN_SOURCE700_ISOC2X_SOURCE_ISOC11_SOURCE_ISOC99_SOURCE_ISOC95_SOURCE__GLIBC_USE(F)__GLIBC_USE_ ## F__glibc_clang_prereq(maj,min)__GNUC_PREREQ(maj,min)((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))__KERNEL_STRICT_NAMES__USE_FILE_OFFSET64_FEATURES_H_LOOSE_KERNEL_NAMESdefined __GNUC__ && defined __GNUC_MINOR__defined __clang_major__ && defined __clang_minor__(defined _BSD_SOURCE || defined _SVID_SOURCE) \_GNU_SOURCE(defined _DEFAULT_SOURCE					\(defined _ISOC2X_SOURCE \(defined _ISOC11_SOURCE || defined _ISOC2X_SOURCE \(defined _ISOC99_SOURCE || defined _ISOC11_SOURCE			\__cplusplus__cplusplus >= 201703L__cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__!defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE((!defined __STRICT_ANSI__					\defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 700((!defined _POSIX_C_SOURCE || (_POSIX_C_SOURCE - 0) < 199506L) \(defined _POSIX_SOURCE					\defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCEdefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199309Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199506Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200112Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200809L(_XOPEN_SOURCE - 0) >= 500(_XOPEN_SOURCE - 0) >= 600(_XOPEN_SOURCE - 0) >= 700defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64defined _DEFAULT_SOURCEdefined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0 \_FORTIFY_SOURCE > 1defined __cplusplus ? __cplusplus >= 201402L : defined __USE_ISOC11(defined __USE_GNU							\__ASSEMBLER___SYS_CDEFS_Hdefined __USE_FILE_OFFSET64 && !defined __REDIRECT__GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \__NO_INLINE____GNUC_MINOR__47__GNUC__9__GXX_EXPERIMENTAL_CXX0X__201703L_FORTIFY_SOURCE3_REENTRANT__STRICT_ANSI__/* features.h  *//* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  *//* Decide whether we can define 'extern inline' functions in headers.  *//* !ASSEMBLER *//* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. *//* This is here only because every header file already includes this one.  *//* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  *//* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  *//* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  *//* GNU formerly extended the scanf functions with modified format
   specifiers %as, %aS, and %a[...] that allocate a buffer for the
   input using malloc.  This extension conflicts with ISO C99, which
   defines %a as a standalone format specifier that reads a floating-
   point number; moreover, POSIX.1-2008 provides the same feature
   using the modifier letter 'm' instead (%ms, %mS, %m[...]).

   We now follow C99 unless GNU extensions are active and the compiler
   is specifically in C89 or C++98 mode (strict or not).  For
   instance, with GCC, -std=gnu11 will have C99-compliant scanf with
   or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
   old extension.  *//* The function 'gets' existed in C89, but is impossible to use
   safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
   compatibility with various implementations of <cstdio>, this test
   must consider only the value of __cplusplus when compiling C++.  *//* Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
   defined in all multithreaded code.  GNU libc has not required this
   for many years.  We now treat them as compatibility synonyms for
   _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
   comprehensive support for multithreaded code.  Using them never
   lowers the selected level of POSIX conformance, only raises it.  *//* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
   is defined, use POSIX.1-2008 (or another version depending on
   _XOPEN_SOURCE).  *//* This is to enable compatibility for ISO C++11.
   Check the temporary macro for now, too.  *//* This is to enable compatibility for ISO C++17.  *//* This is to enable the ISO C90 Amendment 1:1995 extension.  *//* This is to enable the ISO C99 extension.  *//* This is to enable the ISO C11 extension.  *//* This is to enable the ISO C2X extension.  *//* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
   define _DEFAULT_SOURCE.  *//* If _GNU_SOURCE was defined by the user, turn on all the other features.  *//* _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
   _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
   issue a warning; the expectation is that the source is being
   transitioned to use the new macro.  *//* Whether to use feature set F.  *//* Similarly for clang.  Features added to GCC after version 4.2 may
   or may not also be available in clang, and clang's definitions of
   __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
   features can be queried via __has_extension/__has_feature.  *//* Convenience macro to test the version of gcc.
   Use like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
   added in 2.0.  *//* Suppress kernel-name space pollution unless user expressedly asks
   for it.  *//* Undefine everything, so we get a clean slate.  *//* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
   _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
   __STDC_WANT_LIB_EXT2__
			Extensions to ISO C99 from TR 27431-2:2010.
   __STDC_WANT_IEC_60559_BFP_EXT__
			Extensions to ISO C11 from TS 18661-1:2014.
   __STDC_WANT_IEC_60559_FUNCS_EXT__
			Extensions to ISO C11 from TS 18661-4:2015.
   __STDC_WANT_IEC_60559_TYPES_EXT__
			Extensions to ISO C11 from TS 18661-3:2015.

   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _DEFAULT_SOURCE	The default set of features (taking precedence over
			__STRICT_ANSI__).

   _FORTIFY_SOURCE	Add security hardening to many library functions.
			Set to 1 or 2; 2 performs stricter checks than 1.

   _REENTRANT, _THREAD_SAFE
			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.

   The `-ansi' switch to the GNU C compiler, and standards conformance
   options such as `-std=c99', define __STRICT_ANSI__.  If none of
   these are defined, or if _DEFAULT_SOURCE is defined, the default is
   to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200809L, as well as enabling miscellaneous functions from BSD and
   SVID.  If more than one of these are defined, they accumulate.  For
   example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
   give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __GLIBC_USE (F)	Define things from feature set F.  This is defined
			to 1 or 0; the subsequent macros are either defined
			or undefined, and those tests should be moved to
			__GLIBC_USE.
   __USE_ISOC11		Define ISO C11 things.
   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_ISOCXX11	Define ISO C++11 things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_MISC		Define things from 4.3BSD or System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.

   ISO C feature test macros depend on the definition of the macro
   when an affected header is included, not when the first system
   header is included, and so they are handled in
   <bits/libc-header-start.h>, which does not have a multiple include
   guard.  Feature test macros that can be handled from the first
   system header included are handled here.  *//* Copyright (C) 1991-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/usr//usr/include/c++/9/bits/stl_iterator.h<type_traits><bits/ptr_traits.h><bits/move.h><ext/type_traits.h><bits/cpp_type_traits.h>base__miter_basestd_Iterator__niter_base_Tp_Tp *_ReturnType__make_move_if_noexcept_iteratormake_move_iteratoroperator+difference_typeconst move_iterator<_Iterator>const move_iterator<_Iterator> &move_iterator<_Iterator> &const move_iterator<_IteratorL>const move_iterator<_IteratorL> &move_iterator<_IteratorL> &const move_iterator<_IteratorR>const move_iterator<_IteratorR> &move_iterator<_IteratorR> &operator-_IteratorL_IteratorRoperator>=operator>operator<=operator<operator!=operator==_Containerinserter_Container &iteratorfront_inserterback_insertermake_reverse_iterator__make_reverse_iteratorconst reverse_iterator<_Iterator>const reverse_iterator<_Iterator> &reverse_iterator<_Iterator> &const reverse_iterator<_IteratorR>const reverse_iterator<_IteratorR> &reverse_iterator<_IteratorR> &const reverse_iterator<_IteratorL>const reverse_iterator<_IteratorL> &reverse_iterator<_IteratorL> &operator[]operator-=operator+=operator--operator++move_iterator<_Iterator> *operator->operator*const move_iterator<_Iterator> *move_iteratorconst move_iterator<_Iter>const move_iterator<_Iter> &move_iterator<_Iter> &_Iterexplicitinsert_iterator<_Container> &operator=value_typevalue_type &&const value_typeconst value_type &value_type &insert_iteratorfront_insert_iterator<_Container> &front_insert_iteratorback_insert_iterator<_Container> &back_insert_iterator_S_to_pointerconst reverse_iterator<_Iterator> *reverse_iterator<_Iterator> *__tmpreverse_iteratorconst reverse_iterator<_Iter>const reverse_iterator<_Iter> &reverse_iterator<_Iter> &const __normal_iterator<_Iterator, _Container>const __normal_iterator<_Iterator, _Container> &__normal_iterator<_Iterator, _Container> &const __normal_iterator<_IteratorL, _Container>const __normal_iterator<_IteratorL, _Container> &__normal_iterator<_IteratorL, _Container> &const __normal_iterator<_IteratorR, _Container>const __normal_iterator<_IteratorR, _Container> &__normal_iterator<_IteratorR, _Container> &const _Iteratorconst _Iterator &_Iterator &const __normal_iterator<_Iterator, _Container> *__normal_iterator<_Iterator, _Container> *const __normal_iterator<_Iter, __type>const __normal_iterator<_Iter, __type> &__normal_iterator<_Iter, __type> &__normal_iteratorsecond_type__iter_val_t__iter_key_ttype__is_move_iterator<move_iterator<_Iterator>>__type(unnamed enum)__valuemove_iterator<_Iterator>referencepointeriterator_categoryiterator_type__base_refinsert_iterator<_Container>container_typefront_insert_iterator<_Container>back_insert_iterator<_Container>__is_move_iterator<reverse_iterator<_Iterator>>/usr/include/c++/9/bits/usr/include/c++/9/usr/include/c++__n__i__xreverse_iterator<_Iterator>__normal_iterator<_Iterator, _Container>_InputIteratorpair<_T1, _T2>_T1_T2std::is_nothrow_copy_constructible<_Iterator>::valuevaluestatic_M_currentiter_Container *containercurrent_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter)std::__make_move_if_noexcept_iterator(_Iter)_GLIBCXX_MAKE_MOVE_ITERATOR(_Iter)std::make_move_iterator(_Iter)__cpp_lib_make_reverse_iterator201402__cpp_lib_array_constexpr201803L_STL_ITERATOR_H__cplusplus >= 201103L__cplusplus < 201103L__cplusplus > 201103L__cpp_deduction_guides >= 201606_GLIBCXX_DEBUG__cpp_deduction_guides201703default// namespace// of associative containers.// These helper traits are used for deduction guides// C++11/// @} group iterators// returning a constant iterator when we don't want to move.// Overload for pointers that matches std::move_if_noexcept more closely,// DR 685.// operators.// why there are always 2 versions for most of the move_iterator// Note: See __normal_iterator operators note from Gaby to understand// 2106. move_iterator wrapping iterators returning prvalues// _GLIBCXX_RESOLVE_LIB_DEFECTS// NB: DR 680./**
   *  Class template move_iterator is an iterator adapter with the same
   *  behavior as the underlying iterator except that its dereference
   *  operator implicitly converts the value returned by the underlying
   *  iterator's dereference operator to an rvalue reference.  Some
   *  generic algorithms can be called with move iterators to replace
   *  copying with moving.
   */// 24.4.3  Move iterators/**
   * @addtogroup iterators
   * @{
   */// parameters.// operators but also operator- must accept mixed iterator/const_iterator// According to the resolution of DR179 not only the various comparison// Random access iterator requirements// Forward iterator requirements// remind me what generic programming is about? -- Gaby// provide overloads whose operands are of the same type.  Can someone// will make overload resolution ambiguous (when in scope) if we don't// valid.  However, the greedy and unfriendly operators in std::rel_ops// comparison between cv-qualified and non-cv-qualified iterators be// allowed to vary in types (conceptually in cv-qualification) so that// Note: In what follows, the left- and right-hand-side iterators are// Bidirectional iterator requirements// Allow iterator to const_iterator conversion// _Iterator parameter is the same.// using this template can instantiate different types, even if the// The _Container parameter exists solely so that different containers// not a class, e.g. a pointer, into an iterator that is a class.// parameter.  Its primary purpose is to convert an iterator that is// change the semantics of any of the operators of its iterator// This iterator adapter is @a normal in the sense that it does not/**
   *  @param __x  A container of arbitrary type.
   *  @param __i  An iterator into the container.
   *  @return  An instance of insert_iterator working on @p __x.
   *
   *  This wrapper function helps in creating insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  *//// Simply returns *this.  (This %iterator does not @a move.)/// Simply returns *this./**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator maintains its own position in the
       *  container.  Assigning a value to the %iterator will insert the
       *  value into the container at the place before the %iterator.
       *
       *  The position is maintained such that subsequent assignments will
       *  insert values immediately after one another.  For example,
       *  @code
       *     // vector v contains A and Z
       *
       *     insert_iterator i (v, ++v.begin());
       *     i = 1;
       *     i = 2;
       *     i = 3;
       *
       *     // vector v contains A, 1, 2, 3, and Z
       *  @endcode
      *//**
       *  The only way to create this %iterator is with a container and an
       *  initial position (a normal %iterator into the container).
      *//// A nested typedef for the type of whatever container you used./**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator inserts it in the container at the
   *  %iterator's position, rather than overwriting the value at that
   *  position.
   *
   *  (Sequences will actually insert a @e copy of the value before the
   *  %iterator's position.)
   *
   *  Tip:  Using the inserter function to create these iterators can
   *  save typing.
  *//**
   *  @param  __x  A container of arbitrary type.
   *  @return  An instance of front_insert_iterator working on @p x.
   *
   *  This wrapper function helps in creating front_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  *//**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the front, if you like).  Assigning a value to the %iterator will
       *  always prepend the value to the front of the container.
      *//// The only way to create this %iterator is with a container./**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator prepends it to the container using
   *  push_front.
   *
   *  Tip:  Using the front_inserter function to create these iterators can
   *  save typing.
  *//**
   *  @param  __x  A container of arbitrary type.
   *  @return  An instance of back_insert_iterator working on @p __x.
   *
   *  This wrapper function helps in creating back_insert_iterator instances.
   *  Typing the name of the %iterator requires knowing the precise full
   *  type of the container, which can be tedious and impedes generic
   *  programming.  Using this function lets you take advantage of automatic
   *  template parameter deduction, making the compiler match the correct
   *  types for you.
  *//**
       *  @param  __value  An instance of whatever type
       *                 container_type::const_reference is; presumably a
       *                 reference-to-const T for container<T>.
       *  @return  This %iterator, for chained operations.
       *
       *  This kind of %iterator doesn't really have a @a position in the
       *  container (you can think of the position as being permanently at
       *  the end, if you like).  Assigning a value to the %iterator will
       *  always append the value to the end of the container.
      *//**
   *  @brief  Turns assignment into insertion.
   *
   *  These are output iterators, constructed from a container-of-T.
   *  Assigning a T to the iterator appends it to the container using
   *  push_back.
   *
   *  Tip:  Using the back_inserter function to create these iterators can
   *  save typing.
  */// 24.4.2.2.1 back_insert_iterator/// Generator function for reverse_iterator.// DR 2285. make_reverse_iterator// Same as C++14 make_reverse_iterator but used in C++11 mode too.// DR 685. reverse_iterator/move_iterator difference has invalid signatures///@}// DR 280. Comparison of reverse_iterator to const reverse_iterator./**
   *  @param  __x  A %reverse_iterator.
   *  @param  __y  A %reverse_iterator.
   *  @return  A simple bool.
   *
   *  Reverse iterators forward many operations to their underlying base()
   *  iterators.  Others are implemented in terms of one another.
   *
  *////@{/**
       *  @return  The value at @c current - @a __n - 1
       *
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  *this
       *
       *  Moves the underlying iterator forwards @a __n steps.
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  A reverse_iterator that refers to @c current - @a __n
       *
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  *this
       *
       *  Moves the underlying iterator backwards @a __n steps.
       *  The underlying iterator must be a Random Access Iterator.
      *//**
       *  @return  A reverse_iterator with the previous value of @c *this
       *
       *  Increments the underlying iterator.
      *//**
       *  @return  @c *this
       *
       *  Increments the underlying iterator.
      *//**
       *  @return  The original value of @c *this
       *
       *  Decrements the underlying iterator.
      *//**
       *  @return  @c *this
       *
       *  Decrements the underlying iterator.
      */// 1052. operator-> should also support smart pointers/**
       *  @return  A pointer to the value at @c --current
       *
       *  This requires that @c --current is dereferenceable.
      *//**
       *  @return  A reference to the value at @c --current
       *
       *  This requires that @c --current is dereferenceable.
       *
       *  @warning This implementation requires that for an iterator of the
       *           underlying iterator type, @c x, a reference obtained by
       *           @c *x remains valid after @c x has been modified or
       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
      *//**
       *  @return  @c current, the %iterator used for underlying work.
      *//**
       *  A %reverse_iterator across other types can be copied if the
       *  underlying %iterator can be converted to the type of @c current.
      *//**
       *  The copy constructor is normal.
      *//**
       *  This %iterator will move in the opposite direction that @p x does.
      */// 1012. reverse_iterator default ctor should value initialize// 235 No specification of default ctor for reverse_iterator/**
       *  The default constructor value-initializes member @p current.
       *  If it is a pointer, that means it is zero-initialized.
      *//**
   *  Bidirectional and random access iterators have corresponding reverse
   *  %iterator adaptors that iterate through the data structure in the
   *  opposite direction.  They have the same signatures as the corresponding
   *  iterators.  The fundamental relation between a reverse %iterator and its
   *  corresponding %iterator @c i is established by the identity:
   *  @code
   *      &*(reverse_iterator(i)) == &*(i - 1)
   *  @endcode
   *
   *  <em>This mapping is dictated by the fact that while there is always a
   *  pointer past the end of an array, there might not be a valid pointer
   *  before the beginning of an array.</em> [24.4.1]/1,2
   *
   *  Reverse iterators can be tricky and surprising at first.  Their
   *  semantics make sense, however, and the trickiness is a side effect of
   *  the requirement that the iterators must be safe.
  */// 24.4.1 Reverse iterators/** @file bits/stl_iterator.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 *
 *  This file implements reverse_iterator, back_insert_iterator,
 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
 *  supporting functions and overloaded operators.
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996-1998
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// <http://www.gnu.org/licenses/>.// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// a copy of the GCC Runtime Library Exception along with this program;// You should have received a copy of the GNU General Public License and// 3.1, as published by the Free Software Foundation.// permissions described in the GCC Runtime Library Exception, version// Under Section 7 of GPL version 3, you are granted additional// GNU General Public License for more details.// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// but WITHOUT ANY WARRANTY; without even the implied warranty of// This library is distributed in the hope that it will be useful,// any later version.// Free Software Foundation; either version 3, or (at your option)// terms of the GNU General Public License as published by the// software; you can redistribute it and/or modify it under the// This file is part of the GNU ISO C++ Library.  This library is free//// Copyright (C) 2001-2019 Free Software Foundation, Inc.// Iterators -*- C++ -*-__it__y__t__p__lhs__rhs/usr/include/c++/9/bits/stl_algobase.h<bits/predefined_ops.h><debug/debug.h><bits/concept_check.h><bits/stl_iterator.h><bits/stl_iterator_base_funcs.h><bits/stl_iterator_base_types.h><bits/stl_pair.h><ext/numeric_traits.h><bits/functexcept.h><bits/c++config.h>mismatch_InputIterator1_InputIterator2_BinaryPredicate__mismatchlexicographical_compare_II1_II2_Compareequal_IIter1_IIter2__equal4_InputIteratorConcept<_II1>_InputIteratorConcept<_II2>_EqualOpConcept< typename iterator_traits<_II1>::value_type, typename iterator_traits<_II2>::value_type>__first1__last1__first2__lg8(int)sizeof(long long)64(int)sizeof(long long) * __CHAR_BIT__63(int)sizeof(long long) * __CHAR_BIT__ - 1__builtin_clzll..(*)(..)(int)sizeof(long)(int)sizeof(long) * __CHAR_BIT__(int)sizeof(long) * __CHAR_BIT__ - 1__builtin_clzl(int)sizeof(int)32(int)sizeof(int) * __CHAR_BIT__(int)sizeof(int) * __CHAR_BIT__  - 1__builtin_clz_ForwardIteratorlower_boundconst _Tpconst _Tp &_Tp &__lower_bound__lexicographical_compare_aux__lexicographical_compare_impl_ValueType1_ValueType2const bool__simple__equal_aux_OI_Size_OutputIteratorConcept<_OI, _Tp>__firstfill_n__fill_n_a_OutputIterator_Mutable_ForwardIteratorConcept< _ForwardIterator>__lastfillconst size_t__len__builtin_memsetvoid *__fill_a_BI1_BI2_BidirectionalIteratorConcept<_BI1>_Mutable_BidirectionalIteratorConcept<_BI2>_ConvertibleConcept< typename iterator_traits<_BI1>::value_type, typename iterator_traits<_BI2>::value_type>__resultmove_backwardcopy_backward__copy_move_backward_a2_IsMove_Category__copy_move_b__copy_move_backward_a_II_InputIteratorConcept<_II>_OutputIteratorConcept<_OI, typename iterator_traits<_II>::value_type>movecopy__copy_move_a2_ValueTypeI_ValueTypeO__copy_m__copy_move_a__niter_wrap_From_Tomaxmin_LessThanComparableConcept<_Tp>_ForwardIterator2swap_ranges_ForwardIterator1iter_swap__lexicographical_compare<true> &__lexicographical_compare<true> &&const __lexicographical_compare<true>const __lexicographical_compare<true> &__lcconst _Tp *_Upconst _Upconst _Up *_Up *__lc_rai<random_access_iterator_tag, random_access_iterator_tag> &__lc_rai<random_access_iterator_tag, random_access_iterator_tag> &&const __lc_rai<random_access_iterator_tag, random_access_iterator_tag>const __lc_rai<random_access_iterator_tag, random_access_iterator_tag> &__cnd2_RAI_RAI1__newlast1_RAI2__equal<true> &__equal<true> &&const __equal<true>const __equal<true> &falsetrue__assignableconst ptrdiff_t_Num__builtin_memmoveconst voidconst void *type is not assignable__copy_move_backward<true, false, random_access_iterator_tag> &__copy_move_backward<true, false, random_access_iterator_tag> &&const __copy_move_backward<true, false, random_access_iterator_tag>const __copy_move_backward<true, false, random_access_iterator_tag> &__copy_move_backward<false, false, random_access_iterator_tag> &__copy_move_backward<false, false, random_access_iterator_tag> &&const __copy_move_backward<false, false, random_access_iterator_tag>const __copy_move_backward<false, false, random_access_iterator_tag> &__copy_move<true, false, random_access_iterator_tag> &__copy_move<true, false, random_access_iterator_tag> &&const __copy_move<true, false, random_access_iterator_tag>const __copy_move<true, false, random_access_iterator_tag> &__copy_move<false, false, random_access_iterator_tag> &__copy_move<false, false, random_access_iterator_tag> &&const __copy_move<false, false, random_access_iterator_tag>const __copy_move<false, false, random_access_iterator_tag> &__lexicographical_compare<true>__lexicographical_compare<_BoolType>_BoolType__lc_rai<random_access_iterator_tag, random_access_iterator_tag>__lc_rai<<unnamed>, <unnamed>>(unnamed template parameter)__equal<true>__equal<_BoolType>__copy_move_backward<_IsMove, true, random_access_iterator_tag>__copy_move_backward<true, false, random_access_iterator_tag>__copy_move_backward<false, false, random_access_iterator_tag>__copy_move_backward<true, false, _Category>__copy_move_backward<<unnamed>, <unnamed>, <unnamed>>(unnamed template parameter constant)__copy_move<_IsMove, true, random_access_iterator_tag>__copy_move<true, false, random_access_iterator_tag>__copy_move<false, false, random_access_iterator_tag>__copy_move<true, false, _Category>__copy_move<_IsMove, _IsSimple, _Category>_IsSimple_CharT_CharT *const _CharTconst _CharT *istreambuf_iterator<_CharT, _Traits>_Traitsostreambuf_iterator<_CharT, _Traits>char_traits<_CharT>__cpp_lib_robust_nonmodifying_seq_ops201304_GLIBCXX_MOVE_BACKWARD3(_Tp,_Up,_Vp)std::move_backward(_Tp, _Up, _Vp)_GLIBCXX_MOVE3(_Tp,_Up,_Vp)std::move(_Tp, _Up, _Vp)_STL_ALGOBASE_H_GLIBCXX_CONCEPT_CHECKS_GLIBCXX_PARALLEL__last2_InputIteratorConcept<_InputIterator2>_InputIteratorConcept<_InputIterator1>_EqualOpConcept< typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>_LessThanOpConcept<_ValueType2, _ValueType1>_LessThanOpConcept<_ValueType1, _ValueType2>_InputIteratorConcept<_IIter2>_InputIteratorConcept<_IIter1>__CHAR_BIT____val_LessThanOpConcept< typename iterator_traits<_ForwardIterator>::value_type, _Tp>_ForwardIteratorConcept<_ForwardIterator>_Mutable_ForwardIteratorConcept< _ForwardIterator2>_Mutable_ForwardIteratorConcept< _ForwardIterator1>// come in too if requested.// of getting the base algorithms. So, make sure that parallel bits// NB: This file is included within many other C++ includes, as a way// namespace std// concept requirements/**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *         functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  *//**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  *//**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *         functor@endlink.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  *//**
   *  @brief Finds the places in ranges which don't match.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @return   A pair of iterators pointing to the first mismatch.
   *
   *  This compares the elements of two ranges using @c == and returns a pair
   *  of iterators.  The first iterator points into the first range, the
   *  second iterator points into the second range, and the elements pointed
   *  to by the iterators are not equal.
  *//**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   A boolean true or false.
   *
   *  The same as the four-parameter @c lexicographical_compare, but uses the
   *  comp parameter instead of @c <.
  *//**
   *  @brief Performs @b dictionary comparison on ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  <em>Returns true if the sequence of elements defined by the range
   *  [first1,last1) is lexicographically less than the sequence of elements
   *  defined by the range [first2,last2).  Returns false otherwise.</em>
   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
   *  then this is an inline call to @c memcmp.
  */// C++14/**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *                  functor@endlink.
   *  @return         A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  *//**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param  __last2   An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  */// 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.// 4-iterator version of std::equal<It1, It2> for use in C++11./**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @param __binary_pred A binary predicate @link functors
   *                  functor@endlink.
   *  @return         A boolean true or false.
   *
   *  This compares the elements of two ranges using the binary_pred
   *  parameter, and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  *//**
   *  @brief Tests a range for element-wise equality.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  An input iterator.
   *  @param  __last1   An input iterator.
   *  @param  __first2  An input iterator.
   *  @return   A boolean true or false.
   *
   *  This compares the elements of two ranges using @c == and returns true or
   *  false depending on whether all of the corresponding elements of the
   *  ranges are equal.
  *///  Precondition: __n > 0./// This is a helper function for the sort routines and for random.tcc./**
   *  @brief Finds the first position in which @a val could be inserted
   *         without changing the ordering.
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return         An iterator pointing to the first element <em>not less
   *                  than</em> @a val, or end() if every element is less than
   *                  @a val.
   *  @ingroup binary_search_algorithms
  *//**
   *  @brief Fills the range [first,first+n) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  __first  An output iterator.
   *  @param  __n      The count of copies to perform.
   *  @param  __value  A reference-to-const of arbitrary type.
   *  @return   The iterator at first+n.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @ wmemset.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 865. More algorithms that throw away information
  *//**
   *  @brief Fills the range [first,last) with copies of value.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __value  A reference-to-const of arbitrary type.
   *  @return   Nothing.
   *
   *  This function fills a range with copies of the same value.  For char
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @c wmemset.
  */// Specialization: for char types we can use memset./**
   *  @brief Moves the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @param  __result A bidirectional iterator.
   *  @return   result - (last - first)
   *
   *  The function has the same effect as move, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range (first,last].  Use move instead.  Note
   *  that the start of the output range may overlap [first,last).
  *//**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @param  __result A bidirectional iterator.
   *  @return   result - (last - first)
   *
   *  The function has the same effect as copy, but starts at the end of the
   *  range and works its way to the start, returning the start of the result.
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
   *
   *  Result may not be in the range (first,last].  Use copy instead.  Note
   *  that the start of the output range may overlap [first,last).
  */// trivial types can have deleted assignment/**
   *  @brief Moves the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   result + (last - first)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the move_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  *//**
   *  @brief Copies the range [first,last) into result.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __result An output iterator.
   *  @return   result + (last - first)
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).  Result may not be contained within
   *  [first,last); the copy_backward function should be used instead.
   *
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  */// NB: avoid including <iosfwd>, relatively large.// Helpers for streambuf iterators (either istream or ostream).// a for loop with an explicit count.// (2) If we're using random access iterators, then write the loop as// because the input and output ranges are permitted to overlap.)// calls to copy with memmove whenever possible.  (Memmove, not memcpy,// All of these auxiliary structs serve two purposes.  (1) Replace// No need to wrap, iterator already has the right type.// is only used to wrap random access iterators, like pointers).// __normal_iterator back again (this assumes that __normal_iterator// Reverse the __niter_base transformation to get a// remove the __normal_iterator wrapper. See copy, fill, ...// Fallback implementation of the function in bits/stl_iterator.h used to//return __comp(__a, __b) ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The greater of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  *///return __comp(__b, __a) ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
   *  @return   The lesser of the parameters.
   *
   *  This will work on temporary expressions, since they are only evaluated
   *  once, unlike a preprocessor macro.
  *///return  __a < __b ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The greater of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  *///return __b < __a ? __b : __a;/**
   *  @brief This does what you think it does.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return   The lesser of the parameters.
   *
   *  This is the simple classic generic implementation.  It will work on
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  *//**
   *  @brief Swap the elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @return   An iterator equal to @p first2+(last1-first1).
   *
   *  Swaps each element in the range @p [first1,last1) with the
   *  corresponding element in the range @p [first2,(last1-first1)).
   *  The ranges must not overlap.
  *//**
   *  @brief Swaps the contents of two iterators.
   *  @ingroup mutating_algorithms
   *  @param  __a  An iterator.
   *  @param  __b  Another iterator.
   *  @return   Nothing.
   *
   *  This function swaps the values pointed to by two iterators, not the
   *  iterators themselves.
  */// when it's safe, i.e., the value_types are equal.// nutshell, we are partially implementing the resolution of DR 187,// See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a// For std::swap/** @file bits/stl_algobase.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 */// Core algorithmic facilities -*- C++ -*-__binary_pred__comp__c__res__from__a__b/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.hmax_align_t &max_align_t &&const max_align_tconst max_align_t &nullptrnullptr_tmax_align_tptrdiff_tsize_t__max_align_ld16__alignof__(long double)aligned__max_align_ll__alignof__(long long)_GXX_NULLPTR_T_GCC_MAX_ALIGN_Toffsetof(TYPE,MEMBER)__builtin_offsetof (TYPE, MEMBER)__need_NULLNULL__null__need_wchar_t__need_size_t__size_t_SIZET__GCC_SIZE_T___int_size_t_h_SIZE_T_DECLARED_BSD_SIZE_T_DEFINED__SIZE_T_DEFINED_SIZE_T_DEFINED__BSD_SIZE_T__SIZE_T___SIZE_T_T_SIZE_T_SIZE__SYS_SIZE_T_H_SIZE_T__SIZE_T____size_t____need_ptrdiff_t_PTRDIFF_T_DECLARED_GCC_PTRDIFF_T___int_ptrdiff_t_h_BSD_PTRDIFF_T__PTRDIFF_T___PTRDIFF_T_T_PTRDIFF_T_PTRDIFF__PTRDIFF_T_ANSI_STDDEF_H_STDDEF_H__STDDEF_H(!defined(_STDDEF_H) && !defined(_STDDEF_H_) && !defined(_ANSI_STDDEF_H) \(!defined(__need_wchar_t) && !defined(__need_size_t)	\__sys_stdtypes_hdefined(__NetBSD__)defined (__FreeBSD__)!defined(_SIZE_T_) && !defined(_BSD_SIZE_T_)!defined(_PTRDIFF_T_) && !defined(_BSD_PTRDIFF_T_)!defined(_WCHAR_T_) && !defined(_BSD_WCHAR_T_)_BSD_WCHAR_T_defined (__need_ptrdiff_t) || defined (_STDDEF_H_)defined (__need_size_t) || defined (_STDDEF_H_)defined (__need_wchar_t) || defined (_STDDEF_H_)defined (__sequent__) && defined (_PTRDIFF_T_)defined (_TYPE_ptrdiff_t) && (defined (__need_ptrdiff_t) || defined (_STDDEF_H_))defined (_TYPE_size_t) && (defined (__need_size_t) || defined (_STDDEF_H_))defined (_TYPE_wchar_t) && (defined (__need_wchar_t) || defined (_STDDEF_H_))defined (_STDDEF_H) || defined (__need_ptrdiff_t)__PTRDIFF_TYPE__defined (_STDDEF_H) || defined (__need_size_t)defined (__FreeBSD__) \__SIZE_TYPE__!(defined (__GNUG__) && defined (size_t))__BEOS__defined (_STDDEF_H) || defined (__need_wchar_t)__wchar_t____WCHAR_T___WCHAR_T_T_WCHAR__T_WCHAR__WCHAR_T_WCHAR_T__BSD_WCHAR_T_DEFINED__BSD_RUNE_T_DEFINED__WCHAR_T_DECLARED_WCHAR_T_DEFINED__WCHAR_T_DEFINED_WCHAR_T_H___int_wchar_t_h__INT_WCHAR_T_H_GCC_WCHAR_T_BSD_RUNE_T_!defined (_ANSI_SOURCE) && !defined (_POSIX_SOURCE)defined (__FreeBSD__) && (__FreeBSD__ < 5)defined (__FreeBSD__) && (__FreeBSD__ >= 5)__BSD_VISIBLE_RUNE_T_DECLARED__WCHAR_TYPE__defined (__need_wint_t)_WINT_T__WINT_TYPE___GCC_PTRDIFF_T__GCC_SIZE_T__GCC_WCHAR_T_defined (_STDDEF_H) || defined (__need_NULL)__GNUG__(defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) \__i386__defined(__cplusplus) && __cplusplus >= 201103Llong unsigned intlong int/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before *//* _STDDEF_H was defined this time *//* C++11.  *//* C11 or C++11.  *//* _Float128 is defined as a basic type, so max_align_t must be
     sufficiently aligned for it.  This code must work in C++, so we
     use __float128 here; that is only available on some
     architectures, but only on i386 is extra alignment needed for
     __float128.  *//* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  *//* Offset of member MEMBER in a struct of type TYPE. *//* NULL not defined and <stddef.h> or need NULL.  *//* G++ *//* C++ *//* in case <stdio.h> has defined it. *//* A null pointer constant.  *//* __sys_stdtypes_h *//* __NetBSD__ *//*  The following ones are the real ones.  *//*  The references to _GCC_PTRDIFF_T_, _GCC_SIZE_T_, and _GCC_WCHAR_T_
    are probably typos and should be removed before 2.8 is released.  *//* _STDDEF_H or __need_wchar_t.  *//* __wchar_t__ *//* __WCHAR_T__ *//* _BSD_RUNE_T_DEFINED_ *//* _WCHAR_T_DECLARED *//* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... *//* Why is this file so hard to maintain properly?  In contrast to
   the comment above regarding BSD/386 1.1, on FreeBSD for as long
   as the symbol has existed, _BSD_RUNE_T_ must not stay defined or
   redundant typedefs will occur when stdlib.h is included after this file. *//* Darwin *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." *//* Cray Unicos/Mk *//* BeOS *//* FreeBSD 5 *//* Define this type if we are doing the whole job,
   or if we want this type in particular.  *//* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  *//* _STDDEF_H or __need_size_t.  *//* __size_t__ *//* __SIZE_T__ *//* _SIZE_T *//* _SYS_SIZE_T_H *//* _T_SIZE_ *//* _T_SIZE *//* __SIZE_T *//* _SIZE_T_ *//* _BSD_SIZE_T_ *//* _SIZE_T_DEFINED_ *//* _SIZE_T_DEFINED *//* _BSD_SIZE_T_DEFINED_ *//* _SIZE_T_DECLARED *//* ___int_size_t_h *//* _GCC_SIZE_T *//* _SIZET_ *//* __size_t *//* !(defined (__GNUG__) && defined (size_t)) *//* __BEOS__ *//* __size_t is a typedef, must not trash it.  *//* in case <sys/types.h> has defined it. *//* Unsigned type of `sizeof' something.  *//* _STDDEF_H or __need_ptrdiff_t.  *//* If this symbol has done its job, get rid of it.  *//* _PTRDIFF_T *//* _T_PTRDIFF_ *//* _T_PTRDIFF *//* __PTRDIFF_T *//* _PTRDIFF_T_ *//* _BSD_PTRDIFF_T_ *//* ___int_ptrdiff_t_h *//* _GCC_PTRDIFF_T *//* _PTRDIFF_T_DECLARED *//* DragonFly *//* Signed type of difference of two pointers.  *//* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  *//* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  *//* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  *//* defined(__NetBSD__) *//* Undef _FOO_T_ if we are supposed to define foo_t.  *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_. *//* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  *//* snaroff@next.com says the NeXT needs this.  *//* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  *//*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 *//* Copyright (C) 1989-2019 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//usr/lib/gcc/x86_64-linux-gnu/9/include/usr/lib/gcc/x86_64-linux-gnu/9/usr/lib/gcc/x86_64-linux-gnu/usr/lib/gcc/usr/lib/usr/include/c++/9/ext/aligned_buffer.h_M_ptrconst __aligned_buffer<_Tp>const __aligned_buffer<_Tp> *__aligned_buffer<_Tp> *..(..)_M_addr__aligned_bufferconst __aligned_membuf<_Tp>const __aligned_membuf<_Tp> *__aligned_membuf<_Tp> *unsigned char[]__aligned_membuf__aligned_buffer<_Tp>__aligned_membuf<_Tp>_Tp2_M_storage_M_talignas_ALIGNED_BUFFER_HGCC system_header_GLIBCXX_INLINE_VERSION/* _ALIGNED_BUFFER_H */// Can be used to avoid value-initialization// This type is still used to avoid an ABI change.// instead, as it has smaller size for some types on some targets.// and <bits/hashtable_policy.h>, but ideally they would use __aligned_membuf// This type is used in <forward_list>, <future>, <bits/shared_ptr_base.h>// Similar to __aligned_membuf but aligned for complete objects, not members.// Can be used to avoid value-initialization zeroing _M_storage.// versions of non-GNU compilers might still need this trick.// Since GCC 8 we could just use alignof(_Tp) instead, but older// for use as a class member, so align the buffer as for a class member.// types when used as class members. __aligned_membuf is intended// Target macro ADJUST_FIELD_ALIGN can produce different alignment for// complete objects.// Intended for use as a data member subobject, use __aligned_buffer for// _Tp initialized via placement new or allocator_traits::construct.// A utility type containing a POD object that can hold an object of type/** @file ext/aligned_buffer.h
 *  This file is a GNU extension to the Standard C++ Library.
 */// Copyright (C) 2013-2019 Free Software Foundation, Inc.// Aligned memory buffer -*- C++ -*-/usr/include/c++/9/ext/usr/include/c++/9/utility<initializer_list><bits/stl_relops.h>as_constconst _Tp &&_Tp &&add_const_t<_Tp> &type &exchange_Up &&getconst pair<_Up, _Tp>const pair<_Up, _Tp> &&pair<_Up, _Tp> &&const pair<_Up, _Tp> &pair<_Up, _Tp> &const pair<_Tp, _Up>const pair<_Tp, _Up> &&pair<_Tp, _Up> &&const pair<_Tp, _Up> &pair<_Tp, _Up> &const typeconst type &&type &&const pair<_Tp1, _Tp2>const pair<_Tp1, _Tp2> &&pair<_Tp1, _Tp2> &&_Int_Tp1__const_getconst pair<_Tp1, _Tp2> &pair<_Tp1, _Tp2> &const type &__move_getin_place_index_tin_place_type_tsize__pair_get<1UL> &__pair_get<1UL> &&const __pair_get<1UL>const __pair_get<1UL> &const _Tp2const _Tp2 &&_Tp2 &&__const_move_getconst _Tp2 &_Tp2 &second__get__pair_get<0UL> &__pair_get<0UL> &&const __pair_get<0UL>const __pair_get<0UL> &const _Tp1const _Tp1 &&_Tp1 &&firstconst _Tp1 &_Tp1 &in_place_t &in_place_t &&const in_place_tconst in_place_t &in_place_tin_place_t *__is_in_place_type<_Tp>__is_in_place_type_impl<in_place_type_t<_Tp>>__is_in_place_type_impl<<unnamed>>in_place_index_t<_Idx>_Idxin_place_type_t<_Tp>integer_sequence<_Tp, _Idx...>_Build_index_tuple<_Num>__pair_get<1UL>__pair_get<0UL>__pair_get<_Int>tuple_element<1UL, pair<_Tp1, _Tp2>>tuple_element<0UL, pair<_Tp1, _Tp2>>tuple_size<pair<_Tp1, _Tp2>>__is_tuple_like_impl<pair<_T1, _T2>>tuple_element_ttuple_element<__i, const volatile _Tp>const volatile _Tptuple_element<__i, volatile _Tp>volatile _Tptuple_element<__i, const _Tp>__tuple_element_ttuple_element<__i, _Tp>tuple_size<const volatile __enable_if_has_tuple_size<_Tp, type, type, value>>const volatile __enable_if_has_tuple_size<_Tp, type, type, value>tuple_size<volatile __enable_if_has_tuple_size<_Tp, type, type, value>>volatile __enable_if_has_tuple_size<_Tp, type, type, value>tuple_size<const __enable_if_has_tuple_size<_Tp, type, type, value>>const __enable_if_has_tuple_size<_Tp, type, type, value>__enable_if_has_tuple_sizetuple_size<_Tp>_Index_tuple<_Indexes...>_Indexesin_place_indexin_place_type_Typesin_place__cpp_lib_as_const201510_GLIBCXX_USE_MAKE_INTEGER_SEQ__cpp_lib_integer_sequence__cpp_lib_exchange_function__cpp_lib_tuples_by_type__cpp_lib_tuple_element_t201402L_GLIBCXX_UTILITY__cplusplus >= 201402L__has_builtin__has_builtin(__make_integer_seq)__cplusplus > 201402L/* _GLIBCXX_UTILITY */// C++17/// Alias template index_sequence_for/// Alias template make_index_sequence/// Alias template index_sequence/// Alias template make_integer_sequence/// Class template integer_sequence// Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.// extract the elements in a tuple.// Stores a tuple of indices.  Used by tuple and pair, and by bind() to/// Assign @p __new_val to @p __obj and return its previous value./// Partial specialization for std::pair// Various functions which give std::pair a tuple-like interface.// of tuple_element<pair<T,U>> and tuple_element<array<T,N>> are defined.// but we define them here, to be available when the partial specializations// The standard says this macro and alias template should be in <tuple>// Duplicate of C++14's tuple_element_t for internal use in C++11 mode/// Gives the type of the ith element of a given tuple type.// 2770. tuple_size<const T> specialization is not SFINAE compatible// 2313. tuple_size should always derive from integral_constant<size_t, N>/// Finds the size of a given tuple type./**
 * @defgroup utilities Utilities
 *
 * Components deemed generally useful. Includes pair, tuple,
 * forward/move helpers, ratio, function object, metaprogramming and
 * type traits, time, date, and memory functions.
 *//** @file include/utility
 *  This is a Standard C++ Library header.
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// <utility> -*- C++ -*-__obj__new_val__in__pair/usr/include/c++/9/bits/range_access.hdata_Tp[]_Tp(&)[]_Nmconst _Containerconst _Container &emptynodiscardconst _Tp[]const _Tp(&)[]crendcrbeginrendrbegincendcbeginendconst valarray<_Tp>const valarray<_Tp> &valarray<_Tp> &beginvalarray<_Tp>__cpp_lib_nonmember_container_access201411_GLIBCXX_RANGE_ACCESS_H// _GLIBCXX_RANGE_ACCESS_H/**
   *  @brief  Return the data pointer of an initializer list.
   *  @param  __il  Initializer list.
   *//**
   *  @brief  Return the data pointer of an array.
   *  @param  __array  Array.
   *//**
   *  @brief  Return the data pointer of a const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return the data pointer of a container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return whether an initializer_list is empty.
   *  @param  __il  Initializer list.
   *//*__array*//**
   *  @brief  Return whether an array is empty (always false).
   *  @param  __array  Container.
   *//**
   *  @brief  Return whether a container is empty.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return the size of an array.
   *  @param  __array  Array.
   *//**
   *  @brief  Return the size of a container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the initializer_list.
   *  @param  __il  initializer_list.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the initializer_list.
   *  @param  __il  initializer_list.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return a reverse iterator pointing one past the first element of
   *          the container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return a reverse iterator pointing to the last element of
   *          the container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the const container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return an iterator pointing to the first element of
   *          the const container.
   *  @param  __cont  Container.
   */// These overloads must be declared for cbegin and cend to use them./**
   *  @brief  Return an iterator pointing to one past the last element
   *          of the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return an iterator pointing to the first element of the array.
   *  @param  __arr  Array.
   *//**
   *  @brief  Return an iterator pointing to one past the last element of
   *          the container.
   *  @param  __cont  Container.
   *//**
   *  @brief  Return an iterator pointing to the first element of
   *          the container.
   *  @param  __cont  Container.
   *//** @file bits/range_access.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iterator}
 */// Copyright (C) 2010-2019 Free Software Foundation, Inc.// <range_access.h> -*- C++ -*-__il__array__cont__arr/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h<bits/endian.h><bits/types.h>timespec &timespec &&const timespecconst timespec &timespectv_nsectv_sec_STRUCT_TIMESPEC__WORDSIZE == 64 \__BYTE_ORDER == __BIG_ENDIAN/* Padding.  *//* Nanoseconds.  *//* Seconds.  *//* POSIX.1b structure for a time value.  This is like a `struct timeval' but
   has nanoseconds instead of microseconds.  *//* NB: Include guard matches what <linux/time.h> uses.  *//usr/include/x86_64-linux-gnu/bits/types/usr/include/x86_64-linux-gnu/bits/usr/include/x86_64-linux-gnu/usr/include/sched.h<bits/cpu-set.h><bits/sched.h><bits/types/struct_timespec.h><bits/types/time_t.h><stddef.h><features.h>sched_getaffinitycpu_set_t *sched_setaffinityconst cpu_set_tconst cpu_set_t *sched_rr_get_intervaltimespec *sched_get_priority_minsched_get_priority_maxsched_yieldsched_getschedulersched_setschedulerconst sched_paramconst sched_param *sched_param *sched_getparamsched_setparampid_tCPU_FREE(cpuset)__CPU_FREE (cpuset)CPU_ALLOC(count)__CPU_ALLOC (count)CPU_ALLOC_SIZE(count)__CPU_ALLOC_SIZE (count)CPU_XOR_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, ^)CPU_OR_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, |)CPU_AND_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, &)CPU_XOR(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)CPU_OR(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)CPU_AND(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)CPU_EQUAL_S(setsize,cpusetp1,cpusetp2)__CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)CPU_EQUAL(cpusetp1,cpusetp2)__CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)CPU_COUNT_S(setsize,cpusetp)__CPU_COUNT_S (setsize, cpusetp)CPU_ZERO_S(setsize,cpusetp)__CPU_ZERO_S (setsize, cpusetp)CPU_ISSET_S(cpu,setsize,cpusetp)__CPU_ISSET_S (cpu, setsize, cpusetp)CPU_CLR_S(cpu,setsize,cpusetp)__CPU_CLR_S (cpu, setsize, cpusetp)CPU_SET_S(cpu,setsize,cpusetp)__CPU_SET_S (cpu, setsize, cpusetp)CPU_COUNT(cpusetp)__CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)CPU_ZERO(cpusetp)__CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)CPU_ISSET(cpu,cpusetp)__CPU_ISSET_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_CLR(cpu,cpusetp)__CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_SET(cpu,cpusetp)__CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_SETSIZE__CPU_SETSIZE__sched_prioritysched_priority__pid_t_defined_SCHED_Hexternc_linkagevoid_param_list/* sched.h *//* Get the CPU affinity for a task *//* Set the CPU affinity for a task *//* Access macros for `cpu_set'.  *//* Get the SCHED_RR interval for the named process.  *//* Get minimum priority value for a scheduler.  *//* Get maximum priority value for a scheduler.  *//* Yield the processor.  *//* Retrieve scheduling algorithm for a particular purpose.  *//* Set scheduling algorithm and/or parameters for a process.  *//* Retrieve scheduling parameters for a particular process.  *//* Set scheduling parameters for a process.  *//* Backward compatibility.  *//* Get system specific constant and data structure definitions.  *//* Get type definitions.  *//* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__pid__cpusetsize__cpuset__algorithm__policy__param/usr/include/x86_64-linux-gnu/bits/types/clock_t.hclock_t__clock_t_defined/* Returned by `clock'.  *//usr/include/x86_64-linux-gnu/bits/types/clockid_t.hclockid_t__clockid_t_defined/* Clock ID used in clock and timer functions.  *//usr/include/x86_64-linux-gnu/bits/types/timer_t.htimer_t__timer_t_defined/* Timer ID returned by `timer_create'.  *//usr/include/time.h<bits/types/locale_t.h><bits/types/struct_itimerspec.h><bits/types/timer_t.h><bits/types/clockid_t.h><bits/types/struct_tm.h><bits/types/clock_t.h><bits/time.h>getdate_rconst charconst char *char *const char *__restrict__tm *tm *__restrict__getdatetimer_getoverruntimer_gettimeitimerspec *timer_settimeconst itimerspecconst itimerspec *const itimerspec *__restrict__itimerspec *__restrict__timer_deletetimer_createsigevent *sigevent *__restrict__timer_t *void **timer_t *__restrict__clock_getcpuclockidclockid_t *int *clock_nanosleepconst timespec *clock_settimeclock_gettimeclock_getresnanosleepdysizetimelocaltimegmtzsetctime_rconst time_tconst time_t *long *const time_t *__restrict__char *__restrict__asctime_rconst tmconst tm *const tm *__restrict__localtime_rgmtime_rstrptime_lstrftime_lstrptimetimespec_getstrftimelocaltimegmtimectimeasctimetimetime_t *mktimedifftimeclockgetdate_errtimezonedaylightchar *[2]tzname__timezone__daylight__tzname__isleap(year)((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))TIME_UTC_TIME_Hdefined __USE_POSIX199309 || defined __USE_ISOC11defined __USE_POSIX || __GLIBC_USE (ISOC2X)defined __USE_MISC || defined __USE_XOPEN(1)nonnullconstsigeventISOC2X/* time.h.  *//* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
	specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) *//* Set TS to calendar time based in time base BASE.  *//* Get expiration overrun for timer TIMERID.  *//* Get current value of timer TIMERID and store it in VALUE.  *//* Set timer TIMERID to VALUE, returning old value in OVALUE.  *//* Delete timer TIMERID.  *//* Create new per-process timer using CLOCK_ID.  *//* Return clock ID for CPU-time clock.  *//* High-resolution sleep with the specified clock.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Set clock CLOCK_ID to value TP.  *//* Get current value of clock CLOCK_ID and store it in TP.  *//* Get resolution of clock CLOCK_ID.  *//* Pause execution for a number of nanoseconds.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Return the number of days in YEAR.  *//* Another name for `mktime'.  *//* Like `mktime', but for TP represents Universal Time, not local time.  *//* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  *//* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  *//* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  *//* Same as above.  *//* Seconds west of UTC.  *//* If daylight-saving time is ever in use.  *//* Current timezone names.  *//* Defined in localtime.c.  *//* POSIX || C2X *//* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  *//* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  *//* Reentrant versions of the above functions.  *//* Equivalent to `asctime (localtime (timer))'.  *//* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  *//* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  *//* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  *//* Return the `struct tm' representation
   of *TIMER in the local timezone.  *//* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  *//* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  *//* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  *//* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  *//* Return the `time_t' representation of TP and normalize TP.  *//* Return the difference between TIME1 and TIME0.  *//* Return the current time and put it in *TIMER if TIMER is not NULL.  *//* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SEC is program time in seconds.  *//* Time base values for timespec_get.  *//* Many of the typedefs and structs whose official home is this header
   may also need to be defined by other headers.  *//* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second, and possibly a number of other constants.   *//*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */__string__resbufp__ts__base__timerid__flags__ovalue__clock_id__evp__req__rem__tp__requested_time__remaining__year__timer__buf__s__fmt__loc__maxsize__format__time1__time0/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h<bits/wordsize.h>__ONCE_ALIGNMENT__LOCK_ALIGNMENT__SIZEOF_PTHREAD_BARRIERATTR_T__SIZEOF_PTHREAD_RWLOCKATTR_T__SIZEOF_PTHREAD_CONDATTR_T__SIZEOF_PTHREAD_COND_T48__SIZEOF_PTHREAD_MUTEXATTR_T__SIZEOF_PTHREAD_BARRIER_T__SIZEOF_PTHREAD_RWLOCK_T56__SIZEOF_PTHREAD_ATTR_T__SIZEOF_PTHREAD_MUTEX_T40_BITS_PTHREADTYPES_ARCH_H__x86_64____WORDSIZE == 64/* bits/pthreadtypes.h *//* Extra attributes for the cleanup functions.  *//* Copyright (C) 2002-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/struct_mutex.h__pthread_mutex_s &__pthread_mutex_s &&const __pthread_mutex_sconst __pthread_mutex_s &__pthread_mutex_s__list__elision__spins__kind__nusers__owner__count__lock__PTHREAD_MUTEX_INITIALIZER(__kind)0, 0, 0, 0, __kind, 0, 0, { 0, 0 }__PTHREAD_MUTEX_HAVE_PREV_THREAD_MUTEX_INTERNAL_H/* KIND must stay at this position in the structure to maintain
     binary compatibility with static initializers.  *//* x86 internal mutex struct definitions.
   Copyright (C) 2019-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/struct_rwlock.h__pthread_rwlock_arch_t &__pthread_rwlock_arch_t &&const __pthread_rwlock_arch_tconst __pthread_rwlock_arch_t &__pthread_rwlock_arch_t__pad2unsigned char[7]__pad1__rwelision__shared__cur_writer__pad4__pad3__writers_futex__wrphase_futex__writers__readers__PTHREAD_RWLOCK_INITIALIZER(__flags)0, 0, 0, 0, 0, 0, 0, 0, __PTHREAD_RWLOCK_ELISION_EXTRA, 0, __flags__PTHREAD_RWLOCK_ELISION_EXTRA0, { 0, 0, 0, 0, 0, 0, 0 }_RWLOCK_INTERNAL_H__ILP32__/* FLAGS must stay at this position in the structure to maintain
     binary compatibility.  *//* __x86_64__  *//* x86 internal rwlock struct definitions.
   Copyright (C) 2019-2020 Free Software Foundation, Inc.

   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/thread-shared-types.h<bits/struct_rwlock.h><bits/struct_mutex.h><bits/pthreadtypes-arch.h>__pthread_internal_slist &__pthread_internal_slist &&const __pthread_internal_slistconst __pthread_internal_slist &__pthread_cond_s &__pthread_cond_s &&const __pthread_cond_sconst __pthread_cond_s &union <unnamed> &union <unnamed> &&const union <unnamed>const union <unnamed> &struct <unnamed> &struct <unnamed> &&const struct <unnamed>const struct <unnamed> &__pthread_internal_list &__pthread_internal_list &&const __pthread_internal_listconst __pthread_internal_list &__pthread_slist_t__pthread_internal_slist__pthread_cond_sunion <unnamed>struct <unnamed>__pthread_list_t__pthread_internal_list__pthread_internal_slist *__nextunsigned int[2]__g_signals__wrefs__g1_orig_size__g_size__g_refs(unknown field)__g1_start32__high__low__g1_start__wseq32__wseq__pthread_internal_list *__prev_THREAD_SHARED_TYPES_H/* _THREAD_SHARED_TYPES_H  *//* Common definition of pthread_cond_t. *//* Arch-sepecific read-write lock definitions.  A generic implementation is
   provided by struct_rwlock.h.  If required, an architecture can override it
   by defining:

   1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
      It should contain at least the internal members defined in the
      generic version.

   2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
      It should initialize the rwlock internal type.  *//* Arch-specific mutex definitions.  A generic implementation is provided
   by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
   can override it by defining:

   1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
      definition).  It should contains at least the internal members
      defined in the generic version.

   2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
      atomic operations.

   3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
      It should initialize the mutex internal flag.  *//* Common definition of pthread_mutex_t. *//* Arch-specific definitions.  Each architecture must define the following
   macros to define the expected sizes of pthread data types:

   __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
   __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
   __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
   __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
   __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
   __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
   __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
   __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
   __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.

   The additional macro defines any constraint for the lock alignment
   inside the thread structures:

   __LOCK_ALIGNMENT - for internal lock/futex usage.

   Same idea but for the once locking primitive:

   __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.  *//* Common threading primitives definitions for both POSIX and C11.
   Copyright (C) 2017-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/pthreadtypes.h<bits/thread-shared-types.h>pthread_barrierattr_t &pthread_barrierattr_t &&const pthread_barrierattr_tconst pthread_barrierattr_t &pthread_barrier_t &pthread_barrier_t &&const pthread_barrier_tconst pthread_barrier_t &pthread_rwlockattr_t &pthread_rwlockattr_t &&const pthread_rwlockattr_tconst pthread_rwlockattr_t &pthread_rwlock_t &pthread_rwlock_t &&const pthread_rwlock_tconst pthread_rwlock_t &pthread_attr_t &pthread_attr_t &&const pthread_attr_tconst pthread_attr_t &pthread_condattr_t &pthread_condattr_t &&const pthread_condattr_tconst pthread_condattr_t &pthread_mutexattr_t &pthread_mutexattr_t &&const pthread_mutexattr_tconst pthread_mutexattr_t &pthread_cond_t &pthread_cond_t &&const pthread_cond_tconst pthread_cond_t &pthread_mutex_t &pthread_mutex_t &&const pthread_mutex_tconst pthread_mutex_t &pthread_barrierattr_tpthread_barrier_tvolatile intpthread_spinlock_tpthread_rwlockattr_tpthread_rwlock_tpthread_attr_tpthread_key_tpthread_condattr_tpthread_mutexattr_tpthread_tpthread_cond_tpthread_once_tpthread_mutex_t__alignchar[4]__sizechar[32]char[8]char[56]__datachar[48]char[40]__have_pthread_attr_t_BITS_PTHREADTYPES_COMMON_Hdefined __USE_UNIX98 || defined __USE_XOPEN2K/* POSIX barriers data type.  The structure of the type is
   deliberately not exposed.  *//* POSIX spinlock data type.  *//* Data structure for reader-writer lock variable handling.  The
   structure of the attribute type is deliberately not exposed.  *//* Once-only execution *//* Keys for thread-specific data *//* Data structure for condition variable handling.  The structure of
   the attribute type is not exposed on purpose.  *//* Data structures for mutex handling.  The structure of the attribute
   type is not exposed on purpose.  *//* Thread identifiers.  The structure of the attribute type is not
   exposed on purpose.  *//* For internal mutex and condition variable definitions.  *//* Declaration of common pthread types for all architectures.
   Copyright (C) 2017-2020 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/c++/9/bits/functional_hash.h<bits/hash_bytes.h>__is_fast_hash__is_fast_hash<hash<long double>> &__is_fast_hash<hash<long double>> &&const __is_fast_hash<hash<long double>>const __is_fast_hash<hash<long double>> &hashhash<std::nullptr_t> &hash<std::nullptr_t> &&const hash<std::nullptr_t>const hash<std::nullptr_t> &operator()const hash<std::nullptr_t> *hash<std::nullptr_t> *hash<long double> &hash<long double> &&const hash<long double>const hash<long double> &hash<double> &hash<double> &&const hash<double>const hash<double> &const hash<double> *hash<double> *0.0const doubleconst double &double &hash<float> &hash<float> &&const hash<float>const hash<float> &const hash<float> *hash<float> *0.0fconst floatconst float &float &_Fnv_hash_impl &_Fnv_hash_impl &&const _Fnv_hash_implconst _Fnv_hash_impl &__hash_combine21661362612166136261ULstatic_cast<size_t>(2166136261UL)_Hash_impl &_Hash_impl &&const _Hash_implconst _Hash_impl &33396759110xc70f6907ULstatic_cast<size_t>(0xc70f6907UL)hash<unsigned long long> &hash<unsigned long long> &&const hash<unsigned long long>const hash<unsigned long long> &const hash<unsigned long long> *hash<unsigned long long> *unsigned long longhash<unsigned long> &hash<unsigned long> &&const hash<unsigned long>const hash<unsigned long> &const hash<unsigned long> *hash<unsigned long> *unsigned longhash<unsigned int> &hash<unsigned int> &&const hash<unsigned int>const hash<unsigned int> &const hash<unsigned int> *hash<unsigned int> *unsigned inthash<unsigned short> &hash<unsigned short> &&const hash<unsigned short>const hash<unsigned short> &const hash<unsigned short> *hash<unsigned short> *unsigned shorthash<long long> &hash<long long> &&const hash<long long>const hash<long long> &const hash<long long> *hash<long long> *long longhash<long> &hash<long> &&const hash<long>const hash<long> &const hash<long> *hash<long> *longhash<short> &hash<short> &&const hash<short>const hash<short> &const hash<short> *hash<short> *shorthash<char32_t> &hash<char32_t> &&const hash<char32_t>const hash<char32_t> &const hash<char32_t> *hash<char32_t> *char32_thash<char16_t> &hash<char16_t> &&const hash<char16_t>const hash<char16_t> &const hash<char16_t> *hash<char16_t> *char16_thash<wchar_t> &hash<wchar_t> &&const hash<wchar_t>const hash<wchar_t> &const hash<wchar_t> *hash<wchar_t> *wchar_thash<unsigned char> &hash<unsigned char> &&const hash<unsigned char>const hash<unsigned char> &const hash<unsigned char> *hash<unsigned char> *unsigned charhash<signed char> &hash<signed char> &&const hash<signed char>const hash<signed char> &const hash<signed char> *hash<signed char> *signed charhash<char> &hash<char> &&const hash<char>const hash<char> &const hash<char> *hash<char> *charhash<bool> &hash<bool> &&const hash<bool>const hash<bool> &const hash<bool> *hash<bool> *boolconst __hash_enum<_Tp, true>const __hash_enum<_Tp, true> *__hash_enum<_Tp, true> *~__hash_enum__hash_enum__hash_enum<_Tp, <unnamed>> &&~__poison_hash__poison_hash__poison_hash<_Tp, <unnamed>> &&hash<int> &hash<int> &&const hash<int>const hash<int> &const hash<int> *hash<int> *int__is_fast_hash<hash<long double>>__is_fast_hash<_Hash>_Hashhash<std::nullptr_t>hash<long double>hash<double>hash<float>_Fnv_hash_impl_Hash_implhash<unsigned long long>hash<unsigned long>hash<unsigned int>hash<unsigned short>hash<long long>hash<long>hash<short>hash<char32_t>hash<char16_t>hash<wchar_t>hash<unsigned char>hash<signed char>hash<char>hash<bool>hash<_Tp *>__hash_enum<_Tp, true>__hash_enum<_Tp, <unnamed>>__poison_hash<_Tp, __void_t<decltype((<expression>))>>__poison_hash<_Tp, <unnamed>>hash<_Tp>__hash_base<_Result, _Arg>_Result_Argargument_typedeprecatedresult_typehash<int>__enable_hash_call_Cxx_hashtable_define_trivial_hash_Cxx_hashtable_define_trivial_hash(_Tp)template<> struct hash<_Tp> : public __hash_base<size_t, _Tp> { size_t operator()(_Tp __val) const noexcept { return static_cast<size_t>(__val); } };_FUNCTIONAL_HASH_H_GLIBCXX_USE_CHAR8_T__GLIBCXX_TYPE_INT_N_0__GLIBCXX_TYPE_INT_N_1__GLIBCXX_TYPE_INT_N_2__GLIBCXX_TYPE_INT_N_3pure// _FUNCTIONAL_HASH_H// otherwise.// Default behavior is to consider that hashers are fast unless specified// containers will cache the hash code.// Hint about performance of hash functor. If not fast the hash-based/// @} group hashes/// Specialization for long double.// 0 and -0 both hash to zero./// Specialization for double./// Specialization for float.// A hash function similar to FNV-1a (see PR59406 for how it differs)./// Explicit specialization for unsigned long long./// Explicit specialization for unsigned long./// Explicit specialization for unsigned int./// Explicit specialization for unsigned short./// Explicit specialization for long long./// Explicit specialization for long./// Explicit specialization for int./// Explicit specialization for short./// Explicit specialization for char32_t./// Explicit specialization for char16_t./// Explicit specialization for char8_t./// Explicit specialization for wchar_t./// Explicit specialization for unsigned char./// Explicit specialization for signed char./// Explicit specialization for char./// Explicit specialization for bool.// Explicit specializations for integer types./// Partial specializations for pointer types.// Use with non-enum types still SFINAES./// Primary class template hash, usable for enum types only.// Helper struct for hash with enum types.// Private rather than deleted to be non-trivially-copyable.// Helper struct for SFINAE-poisoning non-enum types./// Primary class template hash./** @defgroup hashes Hashes
   *  @ingroup functors
   *
   *   Hashing functors taking a variable type and returning a @c std::size_t.
   *
   *  @{
   *//** @file bits/functional_hash.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Copyright (C) 2007-2019 Free Software Foundation, Inc.// functional_hash.h header -*- C++ -*-__ptr__clength__seed__hash/usr/include/x86_64-linux-gnu/sys/types.h<bits/pthreadtypes.h><sys/select.h><endian.h><bits/stdint-intn.h>fsfilcnt64_tfsblkcnt64_tblkcnt64_tfsfilcnt_tfsblkcnt_tblkcnt_tblksize_tregister_tmode__word__u_int64_tu_int32_tu_int16_tu_int8_tuintushortulongsuseconds_tuseconds_tkey_tcaddr_tdaddr_tid_toff64_toff_tuid_tnlink_tmode_tgid_tdev_tino64_tino_tloff_tfsid_tu_quad_tquad_tu_longu_intu_shortu_charssize_t__fsfilcnt_t_defined__fsblkcnt_t_defined__blkcnt_t_defined__blksize_t_defined__BIT_TYPES_DEFINED____suseconds_t_defined__useconds_t_defined__key_t_defined__daddr_t_defined__ssize_t_defined__id_t_defined__off64_t_defined__off_t_defined__uid_t_defined__nlink_t_defined__mode_t_defined__gid_t_defined__dev_t_defined__ino64_t_defined__ino_t_defined__u_char_defined_SYS_TYPES_Hdefined __USE_LARGEFILE64 && !defined __ino64_t_defineddefined __USE_LARGEFILE64 && !defined __off64_t_defined(defined __USE_XOPEN || defined __USE_XOPEN2K8) \(defined __USE_MISC || defined __USE_XOPEN) && !defined __key_t_defineddefined __USE_XOPEN || defined __USE_XOPEN2K8__GNUC_PREREQ (2, 7)(defined __USE_UNIX98 || defined __USE_XOPEN2K8) \defined __USE_POSIX199506 || defined __USE_UNIX98/* sys/types.h *//* Now add the thread types.  *//* Type to count file system inodes.  *//* Type to count file system blocks.  *//* Type to count number of disk blocks. *//* Type to count number of disk blocks.  *//* Types from the Large File Support interface.  *//* Use misc.  *//* It also defines `fd_set' and the FD_* macros for `select'.  *//* In BSD <sys/types.h> is expected to define BYTE_ORDER.  *//* Some code from BIND tests this macro to see if the types above are
   defined.  *//* These were defined by ISO C without the first `_'.  *//* These size-specific names are used by some of the inet code.  *//* Old compatibility names for C types.  *//*
 *	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>
 *//usr/include/x86_64-linux-gnu/sys/usr/include/c++/9/bits/basic_string.h<bits/functional_hash.h><ext/string_conversions.h><string_view><ext/alloc_traits.h><ext/atomicity.h>operator ""scxx11const char[6]char[6]abi_tagconst char32_tconst char32_t *char32_t *const char16_tconst char16_t *char16_t *const wchar_tconst wchar_t *wchar_t *to_wstringconst int4932__gnu_cxx::__numeric_traits<long double>::__max_exponent10204952__gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20__va_list_tag *%LfL"%Lf"const wchar_t[4]wchar_t[4]308__gnu_cxx::__numeric_traits<double>::__max_exponent10328__gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20%fL"%f"const wchar_t[3]wchar_t[3]38__gnu_cxx::__numeric_traits<float>::__max_exponent1058__gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20sizeof(unsigned long long)4 * sizeof(unsigned long long)%lluL"%llu"const wchar_t[5]wchar_t[5]sizeof(long long)4 * sizeof(long long)%lldL"%lld"sizeof(unsigned long)4 * sizeof(unsigned long)%luL"%lu"sizeof(long)4 * sizeof(long)%ldL"%ld"sizeof(unsigned)4 * sizeof(unsigned)%uL"%u"sizeof(int)4 * sizeof(int)%dL"%d"stoldconst wstringconst wstring &basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> &size_t *unsigned long *wchar_t **"stold"stod"stod"const char[5]char[5]stof"stof"stoull10"stoull"const char[7]char[7]stoll"stoll"stoul"stoul"stol"stol"stoi"stoi"to_string"%Lf"const char[4]"%f"const char[3]char[3]"%llu""%lld""%lu""%ld""%u""%d"const stringconst string &basic_string<char, char_traits<char>, allocator<char>> &char **basic_stringsize_type_Allocatorconst _Allocatorconst _Allocator &_Allocator &basic_istream<wchar_t, char_traits<wchar_t>> &getlinebasic_istream<char, char_traits<char>> &basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits> &&basic_string<_CharT, _Traits, _Alloc> &_Allocbasic_ostream<_CharT, _Traits> &const basic_string<_CharT, _Traits, _Alloc>const basic_string<_CharT, _Traits, _Alloc> &operator<<operator>>swapcompare__str__idxconst basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>const basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>> &basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>> &basic_string<_CharT, _Traits, _Alloc> &&appendinsertconst auto__condcapacity__is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>> &__is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>> &&const __is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>const __is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>> &hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &&const hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>const hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> &const u32stringconst u32string &basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>> &const hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> *hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>> *sizeof(char32_t)__is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>> &__is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>> &&const __is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>const __is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>> &hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &&const hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>const hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> &const u16stringconst u16string &basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>> &const hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> *hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>> *sizeof(char16_t)__is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>> &__is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>> &&const __is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>const __is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>> &hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &&const hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>const hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> &const hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> *hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>> *sizeof(wchar_t)__is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>> &__is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>> &&const __is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>>const __is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>> &hash<basic_string<char, char_traits<char>, allocator<char>>> &hash<basic_string<char, char_traits<char>, allocator<char>>> &&const hash<basic_string<char, char_traits<char>, allocator<char>>>const hash<basic_string<char, char_traits<char>, allocator<char>>> &const hash<basic_string<char, char_traits<char>, allocator<char>>> *hash<basic_string<char, char_traits<char>, allocator<char>>> *const basic_string<_CharT, _Traits, _Alloc> *basic_string<_CharT, _Traits, _Alloc> *const size_type__osize__rsubstrbasic_string::substr"basic_string::substr"const char[21]char[21]find_last_not_offind_first_not_offind_last_offind_first_ofrfindfindget_allocatorconst allocator_typeotherconst allocator_type &other &c_str_M_replace_dispatch_Integerreplacebegin() <= __i1 && __i1 <= __i2 && __i2 <= end()__k1__k2basic_string::replace"basic_string::replace"const char[22]char[22]__n2pop_backeraselengthassign__pos__i1__i2__l__n1__pos1__pos2__position_S_nothrow_movepush_back__svbasic_string::append"basic_string::append"back!empty()frontat__pos <= size()__cplusplus >= 201103L || __pos < size()clear15shrink_to_fitresizemax_sizeoperator std::basic_string_view<_CharT, _Traits>_S_propagate_on_move_assign_S_always_equalallocator_type &__capacity_CharT[]_S_propagate_on_copy_assign__allocallocate~basic_stringconst _Allocconst _Alloc &_Alloc &__startbasic_string::basic_string"basic_string::basic_string"const char[27]char[27]_S_select_on_copyis_nothrow_default_constructible<_Alloc>::value_S_compareconst difference_type__d_S_copy_chars_S_assign_S_move_S_copy_M_disjunct_M_limit__testoff_M_check_length_M_check"%s: __pos (which is %zu) > " "this->size() (which is %zu)"%s: __pos (which is %zu) > this->size() (which is %zu)const char[55]char[55]__N("%s: __pos (which is %zu) > "
				       "this->size() (which is %zu)")_M_get_allocator_Integral_InIterator_M_construct_M_construct_aux_2_M_construct_aux_Tag_M_destroydeallocate_M_dispose_M_is_local_M_set_length_M_capacity_M_local_datapointer_to_M_data_M_p_M_length_M_sv_S_to_string_view_Alloc_hider_Alloc &&_Alloc_hider *__sv_wrapper__sv_wrapper *_Never_valueless_alt<basic_string<_Tp, _Traits, _Alloc>>_Never_valueless_alt<<unnamed>>__is_fast_hash<hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>>hash<basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>>__is_fast_hash<hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>>hash<basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>>__is_fast_hash<hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>>hash<basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>>__is_fast_hash<hash<basic_string<char, char_traits<char>, allocator<char>>>>hash<basic_string<char, char_traits<char>, allocator<char>>>basic_string<_CharT, _Traits, _Alloc>basic_stringbuf<<unnamed>, <unnamed>, <unnamed>>_S_local_capacity_If_svconst_pointerconst_referenceallocator_typechar_typetraits_type_Char_alloc_typebasic_stringbuf<_CharT, _Traits, _Alloc>_FwdIterator_Res_M_dataplus_M_string_length_M_allocated_capacity_M_local_bufnpos__cpp_lib_string_udls__cpp_lib_constexpr_string201611L_BASIC_STRING_Hstring_literals__variant_GLIBCXX_USE_CXX11_ABI_GLIBCXX_DISAMBIGUATE_REPLACE_INST__cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS__cpp_exceptions_GLIBCXX_DEFINING_STRING_INSTANTIATIONS__cplusplus > 201703Ldefined(__GTHREADS)_GLIBCXX_FULLY_DYNAMIC_STRING == 0_GLIBCXX_TM_TS_INTERNAL_GLIBCXX_USE_WCHAR_T_GLIBCXX_USE_C99_STDLIB_GLIBCXX_USE_C99_STDIOdefined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_WCHAR_GLIBCXX_HAVE_BROKEN_VSWPRINTF_GLIBCXX_COMPATIBILITY_CXX0XGCC diagnostic pushGCC diagnostic ignored "-Wliteral-suffix"GCC diagnostic pop__off__length__svw__svt__dat__is__delim__os__beg__end_M_append_M_replace_M_replace_auxreserve_M_erase_M_mutate_M_assign_M_createsize_type &__first >= begin() && __first <= __last && __last <= end()__position >= begin() && __position < end()__p >= begin() && __p <= end()"basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)"199711noexcept(__lhs.swap(__rhs))/* _BASIC_STRING_H */// namespace __detail::__variant// basic_string into a variant, but only if moving the string cannot throw.// Provide the strong exception-safety guarantee when emplacing a// see <variant>// inline namespace literals// inline namespace string_literals/// std::hash specialization for u32string./// std::hash specialization for u16string./// std::hash specialization for u8string./* _GLIBCXX_COMPATIBILITY_CXX0X *//// std::hash specialization for wstring./// std::hash specialization for string.// DR 1182./* C++11 */// _GLIBCXX_USE_WCHAR_T && _GLIBCXX_USE_C99_WCHAR// _GLIBCXX_HAVE_BROKEN_VSWPRINTF// DR 1261.// NB: wcstof vs wcstod.// _GLIBCXX_USE_C99_STDIO// NB: (v)snprintf vs sprintf.// _GLIBCXX_USE_C99_STDLIB// NB: strtof vs strtod.// 21.4 Numeric Conversions [string.conversions]./// Read a line from an rvalue stream into a string./**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from is into @a __str until &apos;\n&apos; is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  end of line is encountered, it is extracted but not stored into
   *  @a __str.
   *//**
   *  @brief  Read a line from stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @param __delim  Character marking end of line.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a __is into @a __str until @a __delim is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  Any previous contents of @a __str are erased.  If
   *  @a __delim is encountered, it is extracted but not stored into
   *  @a __str.
   */// 586. string inserter not a formatted function/**
   *  @brief  Write string to a stream.
   *  @param __os  Output stream.
   *  @param __str  String to write out.
   *  @return  Reference to the output stream.
   *
   *  Output characters of @a __str into os following the same rules as for
   *  writing a C string.
   *//**
   *  @brief  Read stream into a string.
   *  @param __is  Input stream.
   *  @param __str  Buffer to store into.
   *  @return  Reference to the input stream.
   *
   *  Stores characters from @a __is into @a __str until whitespace is
   *  found, the end of the stream is encountered, or str.max_size()
   *  is reached.  If is.width() is non-zero, that is the limit on the
   *  number of characters stored into @a __str.  Any previous
   *  contents of @a __str are erased.
   *//**
   *  @brief  Swap contents of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *
   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
   *//**
   *  @brief  Test if C string doesn't precede string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't precede C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't precede string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
   */// operator >=/**
   *  @brief  Test if C string doesn't follow string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't follow C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string doesn't follow string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
   */// operator <=/**
   *  @brief  Test if C string follows string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string follows C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string follows string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
   */// operator >/**
   *  @brief  Test if C string precedes string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string precedes C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   *//**
   *  @brief  Test if string precedes string.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
   */// operator </**
   *  @brief  Test difference of string and C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
   *//**
   *  @brief  Test difference of C string and string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
   *//**
   *  @brief  Test difference of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
   */// operator !=/**
   *  @brief  Test equivalence of string and C string.
   *  @param __lhs  String.
   *  @param __rhs  C string.
   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
   *//**
   *  @brief  Test equivalence of C string and string.
   *  @param __lhs  C string.
   *  @param __rhs  String.
   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
   *//**
   *  @brief  Test equivalence of two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Second string.
   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
   */// operator ==/**
   *  @brief  Concatenate string and character.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate string and C string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate character and string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate C string and string.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with value of @a __lhs followed by @a __rhs.
   *//**
   *  @brief  Concatenate two strings.
   *  @param __lhs  First string.
   *  @param __rhs  Last string.
   *  @return  New string with value of @a __lhs followed by @a __rhs.
   */// operator+// 3075. basic_string needs deduction guides from basic_string_view// !_GLIBCXX_USE_CXX11_ABI// C++20/**
       *  @brief  Compare substring against a character %array.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  character %array to compare against.
       *  @param __n2  Number of characters of s.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos.  Form a string from the
       *  first @a __n2 characters of @a __s.  Returns an integer < 0
       *  if this substring is ordered before the string from @a __s,
       *  0 if their values are equivalent, or > 0 if this substring
       *  is ordered after the string from @a __s.  Determines the
       *  effective length rlen of the strings to compare as the
       *  smallest of the length of the substring and @a __n2.  The
       *  function then compares the two strings by calling
       *  traits::compare(substring.data(),s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
       *
       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
       *  no special meaning.
      *//**
       *  @brief  Compare substring to a C string.
       *  @param __pos  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a pos.  Returns an integer < 0 if
       *  the substring is ordered before @a __s, 0 if their values
       *  are equivalent, or > 0 if the substring is ordered after @a
       *  __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of the length of the substring and
       *  the length of a string constructed from @a __s.  The
       *  function then compares the two string by calling
       *  traits::compare(substring.data(),__s,rlen).  If the result of
       *  the comparison is nonzero returns it, otherwise the shorter
       *  one is ordered first.
      */// 5 String::compare specification questionable/**
       *  @brief  Compare to a C string.
       *  @param __s  C string to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
       *  their values are equivalent, or > 0 if this string is ordered after
       *  @a __s.  Determines the effective length rlen of the strings to
       *  compare as the smallest of size() and the length of a string
       *  constructed from @a __s.  The function then compares the two strings
       *  by calling traits::compare(data(),s,rlen).  If the result of the
       *  comparison is nonzero returns it, otherwise the shorter one is
       *  ordered first.
      *//**
       *  @brief  Compare substring to a substring.
       *  @param __pos1  Index of first character of substring.
       *  @param __n1  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @param __pos2  Index of first character of substring of str.
       *  @param __n2  Number of characters in substring of str.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n1
       *  characters starting at @a __pos1.  Form the substring of @a
       *  __str from the @a __n2 characters starting at @a __pos2.
       *  Returns an integer < 0 if this substring is ordered before
       *  the substring of @a __str, 0 if their values are equivalent,
       *  or > 0 if this substring is ordered after the substring of
       *  @a __str.  Determines the effective length rlen of the
       *  strings to compare as the smallest of the lengths of the
       *  substrings.  The function then compares the two strings by
       *  calling
       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      *//**
       *  @brief  Compare substring to a string.
       *  @param __pos  Index of first character of substring.
       *  @param __n  Number of characters in substring.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Form the substring of this string from the @a __n characters
       *  starting at @a __pos.  Returns an integer < 0 if the
       *  substring is ordered before @a __str, 0 if their values are
       *  equivalent, or > 0 if the substring is ordered after @a
       *  __str.  Determines the effective length rlen of the strings
       *  to compare as the smallest of the length of the substring
       *  and @a __str.size().  The function then compares the two
       *  strings by calling
       *  traits::compare(substring.data(),str.data(),rlen).  If the
       *  result of the comparison is nonzero returns it, otherwise
       *  the shorter one is ordered first.
      *//**
       *  @brief  Compare to a string_view.
       *  @param __pos1  A position in the string to start comparing from.
       *  @param __n1  The number of characters to compare.
       *  @param __svt   An object convertible to string_view to compare
       *                 against.
       *  @param __pos2  A position in the string_view to start comparing from.
       *  @param __n2  The number of characters to compare.
       *  @return  Integer < 0, 0, or > 0.
       *//**
       *  @brief  Compare to a string_view.
       *  @param __pos  A position in the string to start comparing from.
       *  @param __n  The number of characters to compare.
       *  @param __svt  An object convertible to string_view to compare
       *                against.
       *  @return  Integer < 0, 0, or > 0.
       *//**
       *  @brief  Compare to a string_view.
       *  @param __svt An object convertible to string_view to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *//**
       *  @brief  Compare to a string.
       *  @param __str  String to compare against.
       *  @return  Integer < 0, 0, or > 0.
       *
       *  Returns an integer < 0 if this string is ordered before @a
       *  __str, 0 if their values are equivalent, or > 0 if this
       *  string is ordered after @a __str.  Determines the effective
       *  length rlen of the strings to compare as the smallest of
       *  size() and str.size().  The function then compares the two
       *  strings by calling traits::compare(data(), str.data(),rlen).
       *  If the result of the comparison is nonzero returns it,
       *  otherwise the shorter one is ordered first.
      *//**
       *  @brief  Get a substring.
       *  @param __pos  Index of first character (default 0).
       *  @param __n  Number of characters in substring (default remainder).
       *  @return  The new string.
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Construct and return a new string using the @a __n
       *  characters starting at @a __pos.  If the string is too
       *  short, use the remainder of the characters.  If @a __pos is
       *  beyond the end of the string, out_of_range is thrown.
      *//**
       *  @brief  Find last position of a character not in a string_view.
       *  @param __svt  An object convertible to string_view containing
       *                characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *//**
       *  @brief  Find last position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character other than
       *  @a __c within this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __s within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find last position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to consider.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character not
       *  contained in the first @a __n characters of @a __s within this string.
       *  If found, returns the index where it was found.  If not found,
       *  returns npos.
      *//**
       *  @brief  Find last position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for a character
       *  not contained in @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find position of a character not in a string_view.
       *  @param __svt  An object convertible to string_view containing
       *                characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *//**
       *  @brief  Find position of a different character.
       *  @param __c  Character to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character
       *  other than @a __c within this string.  If found, returns the
       *  index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character not in C string.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character not in C substring.
       *  @param __s  C string containing characters to avoid.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from __s to consider.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not
       *  contained in the first @a __n characters of @a __s within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character not in string.
       *  @param __str  String containing characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for a character not contained
       *  in @a __str within this string.  If found, returns the index where it
       *  was found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a character of string.
       *  @param __svt  An object convertible to string_view containing
       *                characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
      *//**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
       *
       *  Note: equivalent to rfind(__c, __pos).
      *//**
       *  @brief  Find last position of a character of C string.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a character of C substring.
       *  @param __s  C string containing characters to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      *//**
       *  @brief  Find last position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find position of a character of a string_view.
       *  @param __svt  An object convertible to string_view containing
       *                characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
      *//**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the character
       *  @a __c within this string.  If found, returns the index
       *  where it was found.  If not found, returns npos.
       *
       *  Note: equivalent to find(__c, __pos).
      *//**
       *  @brief  Find position of a character of C string.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __s within this string.  If found, returns
       *  the index where it was found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a character of C substring.
       *  @param __s  String containing characters to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  first @a __n characters of @a __s within this string.  If
       *  found, returns the index where it was found.  If not found,
       *  returns npos.
      *//**
       *  @brief  Find position of a character of string.
       *  @param __str  String containing characters to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for one of the
       *  characters of @a __str within this string.  If found,
       *  returns the index where it was found.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find last position of a string_view.
       *  @param __svt  The object convertible to string_view to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
      *//**
       *  @brief  Find last position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of last occurrence.
       *
       *  Starting from @a __pos, searches backward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to start search at (default end).
       *  @return  Index of start of  last occurrence.
       *
       *  Starting from @a __pos, searches backward for the value of
       *  @a __s within this string.  If found, returns the index
       *  where it begins.  If not found, returns npos.
      *//**
       *  @brief  Find last position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search back from.
       *  @param __n  Number of characters from s to search for.
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      *//**
       *  @brief  Find last position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search back from (default end).
       *  @return  Index of start of last occurrence.
       *
       *  Starting from @a __pos, searches backward for value of @a
       *  __str within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      *//**
       *  @brief  Find position of a string_view.
       *  @param __svt  The object convertible to string_view to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
      *//**
       *  @brief  Find position of a character.
       *  @param __c  Character to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *
       *  Starting from @a __pos, searches forward for @a __c within
       *  this string.  If found, returns the index where it was
       *  found.  If not found, returns npos.
      *//**
       *  @brief  Find position of a C string.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the value of @a
       *  __s within this string.  If found, returns the index where
       *  it begins.  If not found, returns npos.
      *//**
       *  @brief  Find position of a string.
       *  @param __str  String to locate.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for value of @a __str within
       *  this string.  If found, returns the index where it begins.  If not
       *  found, returns npos.
      *//**
       *  @brief  Find position of a C substring.
       *  @param __s  C string to locate.
       *  @param __pos  Index of character to search from.
       *  @param __n  Number of characters from @a s to search for.
       *  @return  Index of start of first occurrence.
       *
       *  Starting from @a __pos, searches forward for the first @a
       *  __n characters in @a __s within this string.  If found,
       *  returns the index where it begins.  If not found, returns
       *  npos.
      *//**
       *  @brief  Return copy of allocator used to construct this string.
      *//**
       *  @brief  Return non-const pointer to contents.
       *
       *  This is a pointer to the character sequence held by the string.
       *  Modifying the characters in the sequence is allowed.
      *//**
       *  @brief  Return const pointer to contents.
       *
       *  This is a pointer to internal data.  It is undefined to modify
       *  the contents through the returned pointer. To get a pointer that
       *  allows modifying the contents use @c &str[0] instead,
       *  (or in C++17 the non-const @c str.data() overload).
      *//**
       *  @brief  Return const pointer to null-terminated contents.
       *
       *  This is a handle to internal data.  Do not modify or dire things may
       *  happen.
      */// String operations:/**
       *  @brief  Swap contents with another string.
       *  @param __s  String to swap with.
       *
       *  Exchanges the contents of this string with that of @a __s in constant
       *  time.
      *//**
       *  @brief  Copy substring into C string.
       *  @param __s  C string to copy value into.
       *  @param __n  Number of characters to copy.
       *  @param __pos  Index of first character to copy.
       *  @return  Number of characters actually copied
       *  @throw  std::out_of_range  If __pos > size().
       *
       *  Copies up to @a __n characters starting at @a __pos into the
       *  C string @a __s.  If @a __pos is %greater than size(),
       *  out_of_range is thrown.
      */// string::iterator, _CharT*, etc.// For forward_iterators up to random_access_iterators, used for// For Input Iterators, used in istreambuf_iterators, etc.// 438. Ambiguity in the "do the right thing" clause// requires special behaviour if _InIter is an integral type// _S_construct_aux is used to implement the 21.3.1 para 15 which/**
       *  @brief  Replace range of characters with string_view.
       *  @param __i1    An iterator referencing the start position
          to replace at.
       *  @param __i2    An iterator referencing the end position
          for the replace.
       *  @param __svt   The object convertible to string_view to insert from.
       *  @return  Reference to this string.
      *//**
       *  @brief  Replace range of characters with string_view.
       *  @param __pos1  The position to replace at.
       *  @param __n1    The number of characters to replace.
       *  @param __svt   The object convertible to string_view to insert from.
       *  @param __pos2  The position in the string_view to insert from.
       *  @param __n2    The number of characters to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Replace range of characters with string_view.
       *  @param __pos  The position to replace at.
       *  @param __n    The number of characters to replace.
       *  @param __svt  The object convertible to string_view to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Replace range of characters with initializer_list.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __l  The initializer_list of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      */// useful to avoid the overhead of temporary buffering in _M_replace.// Specializations for the common case of pointer and iterator:/**
       *  @brief  Replace range of characters with range.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __k1  Iterator referencing start of range to insert.
       *  @param __k2  Iterator referencing end of range to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  characters in the range [__k1,__k2) are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      *//**
       *  @brief  Replace range of characters with multiple characters
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __n  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  @a __n copies of @a __c are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace range of characters with C string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the characters of @a __s are inserted.  If the length of
       *  result exceeds max_size(), length_error is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace range of characters with C substring.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __s  C string value to insert.
       *  @param __n  Number of characters from s to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the first @a __n characters of @a __s are inserted.  If the
       *  length of result exceeds max_size(), length_error is thrown.
       *  The value of the string doesn't change if an error is
       *  thrown.
      *//**
       *  @brief  Replace range of characters with string.
       *  @param __i1  Iterator referencing start of range to replace.
       *  @param __i2  Iterator referencing end of range to replace.
       *  @param __str  String value to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__i1,__i2).  In place,
       *  the value of @a __str is inserted.  If the length of result
       *  exceeds max_size(), length_error is thrown.  The value of
       *  the string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace characters with multiple characters.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __n2  Number of characters to insert.
       *  @param __c  Character to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [pos,pos + n1) from this
       *  string.  In place, @a __n2 copies of @a __c are inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      *//**
       *  @brief  Replace characters with value of a C string.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the characters of @a __s are
       *  inserted.  If @a __pos is beyond end of string, out_of_range
       *  is thrown.  If the length of result exceeds max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Replace characters with value of a C substring.
       *  @param __pos  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __s  C string to insert.
       *  @param __n2  Number of characters from @a s to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos1 > size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos + __n1)
       *  from this string.  In place, the first @a __n2 characters of
       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
       *  @a __pos is beyond end of string, out_of_range is thrown.  If
       *  the length of result exceeds max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      *//**
       *  @brief  Replace characters with value from another string.
       *  @param __pos1  Index of first character to replace.
       *  @param __n1  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @param __pos2  Index of first character of str to use.
       *  @param __n2  Number of characters from str to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
       *  __str.size().
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos1,__pos1 + n) from this
       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
       *  beyond end of string, out_of_range is thrown.  If the length of the
       *  result exceeds max_size(), length_error is thrown.  The value of the
       *  string doesn't change if an error is thrown.
      *//**
       *  @brief  Replace characters with value from another string.
       *  @param __pos  Index of first character to replace.
       *  @param __n  Number of characters to be replaced.
       *  @param __str  String to insert.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Removes the characters in the range [__pos,__pos+__n) from
       *  this string.  In place, the value of @a __str is inserted.
       *  If @a __pos is beyond end of string, out_of_range is thrown.
       *  If the length of the result exceeds max_size(), length_error
       *  is thrown.  The value of the string doesn't change if an
       *  error is thrown.
      */// FIXME C++11: should be noexcept./**
       *  @brief  Remove the last character.
       *
       *  The string must be non-empty.
       *//**
       *  @brief  Remove a range of characters.
       *  @param __first  Iterator referencing the first character to remove.
       *  @param __last  Iterator referencing the end of the range.
       *  @return  Iterator referencing location of first after removal.
       *
       *  Removes the characters in the range [first,last) from this string.
       *  The value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Remove one character.
       *  @param __position  Iterator referencing the character to remove.
       *  @return  iterator referencing same location after removal.
       *
       *  Removes the character at @a __position from this string. The value
       *  of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Remove characters.
       *  @param __pos  Index of first character to remove (default 0).
       *  @param __n  Number of characters to remove (default remainder).
       *  @return  Reference to this string.
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Removes @a __n characters from this string starting at @a
       *  __pos.  The length of the string is reduced by @a __n.  If
       *  there are < @a __n characters to remove, the remainder of
       *  the string is truncated.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert a string_view.
       *  @param __pos1  Position in string to insert at.
       *  @param __svt   The object convertible to string_view to insert from.
       *  @param __pos2  Position in string_view to insert from.
       *  @param __n    The number of characters to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Insert a string_view.
       *  @param __pos  Iterator referencing position in string to insert at.
       *  @param __svt  The object convertible to string_view to insert.
       *  @return  Reference to this string.
      *//**
       *  @brief  Insert one character.
       *  @param __p  Iterator referencing position in string to insert at.
       *  @param __c  The character to insert.
       *  @return  Iterator referencing newly inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts character @a __c at position referenced by @a __p.
       *  If adding character causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __p is beyond end of string,
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert multiple characters.
       *  @param __pos  Index in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts @a __n copies of character @a __c starting at index
       *  @a __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos > length(),
       *  out_of_range is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert a C string.
       *  @param __pos  Iterator referencing location in string to insert at.
       *  @param __s  The C string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
       *  adding characters causes the length to exceed max_size(),
       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
       *  thrown.  The value of the string doesn't change if an error is
       *  thrown.
      *//**
       *  @brief  Insert a C substring.
       *  @param __pos  Iterator referencing location in string to insert at.
       *  @param __s  The C string to insert.
       *  @param __n  The number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
       *  string.
       *
       *  Inserts the first @a __n characters of @a __s starting at @a
       *  __pos.  If adding characters causes the length to exceed
       *  max_size(), length_error is thrown.  If @a __pos is beyond
       *  end(), out_of_range is thrown.  The value of the string
       *  doesn't change if an error is thrown.
      *//**
       *  @brief  Insert a substring.
       *  @param __pos1  Iterator referencing location in string to insert at.
       *  @param __str  The string to insert.
       *  @param __pos2  Start of characters in str to insert.
       *  @param __n  Number of characters to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *  @throw  std::out_of_range  If @a pos1 > size() or
       *  @a __pos2 > @a str.size().
       *
       *  Starting at @a pos1, insert @a __n character of @a __str
       *  beginning with @a __pos2.  If adding characters causes the
       *  length to exceed max_size(), length_error is thrown.  If @a
       *  __pos1 is beyond the end of this string or @a __pos2 is
       *  beyond the end of @a __str, out_of_range is thrown.  The
       *  value of the string doesn't change if an error is thrown.
      *//**
       *  @brief  Insert value of a string.
       *  @param __pos1  Iterator referencing location in string to insert at.
       *  @param __str  The string to insert.
       *  @return  Reference to this string.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts value of @a __str starting at @a __pos1.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert an initializer_list of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __l  The initializer_list of characters to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *//**
       *  @brief  Insert a range of characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __beg  Start of range.
       *  @param __end  End of range.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [__beg,__end).  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Insert multiple characters.
       *  @param __p  Iterator referencing location in string to insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Set value from a range of characters in a string_view.
       *  @param __svt  The source object convertible to string_view.
       *  @param __pos  The position in the string_view to assign from.
       *  @param __n  The number of characters to assign.
       *  @return  Reference to this string.
       *//**
       *  @brief  Set value from a string_view.
       *  @param __svt The source object convertible to string_view.
       *  @return  Reference to this string.
       *//**
       *  @brief  Set value to an initializer_list of characters.
       *  @param __l  The initializer_list of characters to assign.
       *  @return  Reference to this string.
       *//**
       *  @brief  Set value to a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Sets value of string to characters in the range [__first,__last).
      *//**
       *  @brief  Set value to multiple characters.
       *  @param __n  Length of the resulting string.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to @a __n copies of
       *  character @a __c.
       *//**
       *  @brief  Set value to contents of a C string.
       *  @param __s  The C string to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the value of @a __s.
       *  The data is copied, so there is no dependence on @a __s once the
       *  function returns.
       *//**
       *  @brief  Set value to a C substring.
       *  @param __s  The C string to use.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *
       *  This function sets the value of this string to the first @a __n
       *  characters of @a __s.  If @a __n is is larger than the number of
       *  available characters in @a __s, the remainder of @a __s is used.
       *//**
       *  @brief  Set value to a substring of a string.
       *  @param __str  The string to use.
       *  @param __pos  Index of the first character of str.
       *  @param __n  Number of characters to use.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a pos is not a valid index.
       *
       *  This function sets this string to the substring of @a __str
       *  consisting of @a __n characters at @a __pos.  If @a __n is
       *  is larger than the number of available characters in @a
       *  __str, the remainder of @a __str is used.
       *//**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       *
       *  This function sets this string to the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       *//**
       *  @brief  Set value to contents of another string.
       *  @param  __str  Source string to use.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a single character.
       *  @param __c  Character to append.
       *//**
       *  @brief  Append a range of characters from a string_view.
       *  @param __svt The object convertible to string_view to be appended
       *               from.
       *  @param __pos The position in the string_view to append from.
       *  @param __n   The number of characters to append from the string_view.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a string_view.
       *  @param __svt The object convertible to string_view to be appended.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a range of characters.
       *  @param __first  Iterator referencing the first character to append.
       *  @param __last  Iterator marking the end of the range.
       *  @return  Reference to this string.
       *
       *  Appends characters in the range [__first,__last) to this string.
       *//**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append multiple characters.
       *  @param __n  The number of characters to append.
       *  @param __c  The character to use.
       *  @return  Reference to this string.
       *
       *  Appends __n copies of __c to this string.
       *//**
       *  @brief  Append a C string.
       *  @param __s  The C string to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a C substring.
       *  @param __s  The C string to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a substring.
       *  @param __str  The string to append.
       *  @param __pos  Index of the first character of str to append.
       *  @param __n  The number of characters to append.
       *  @return  Reference to this string.
       *  @throw  std::out_of_range if @a __pos is not a valid index.
       *
       *  This function appends @a __n characters from @a __str
       *  starting at @a __pos to this string.  If @a __n is is larger
       *  than the number of available characters in @a __str, the
       *  remainder of @a __str is appended.
       *//**
       *  @brief  Append a string to this string.
       *  @param __str  The string to append.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append an initializer_list of characters.
       *  @param __l  The initializer_list of characters to be appended.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a character.
       *  @param __c  The character to append.
       *  @return  Reference to this string.
       */// Modifiers:/**
       *  Returns a read-only (constant) reference to the data at the
       *  last element of the %string.
       *//**
       *  Returns a read/write reference to the data at the last
       *  element of the %string.
       *//**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %string.
       *//**
       *  Returns a read/write reference to the data at the first
       *  element of the %string.
       *//**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read/write reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.  Success results in
       *  unsharing the string.
       *//**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read-only (const) reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       */// In pedantic mode be strict in C++98 mode.// and in C++11 mode.// Allow pos == size() both in C++98 mode, as v3 extension,/**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read/write reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)  Unshares the string.
       *//**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read-only (constant) reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */// Element access:/**
       *  Returns true if the %string is empty.  Equivalent to 
       *  <code>*this == ""</code>.
       */// PR 56166: this should not throw./**
       *  Erases the string, making it empty.
       *//**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          characters.
       *  @param  __res_arg  Number of characters required.
       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %string to hold the specified number of characters.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the string length that will be
       *  required, the user can reserve the memory in %advance, and thus
       *  prevent a possible reallocation of memory and copying of %string
       *  data.
       *//**
       *  Returns the total number of characters that the %string can hold
       *  before needing to allocate more memory.
       *////  A non-binding request to reduce capacity() to size()./**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *
       *  This function will resize the %string to the specified length.  If
       *  the new size is smaller than the %string's current size the %string
       *  is truncated, otherwise the %string is extended and new characters
       *  are default-constructed.  For basic types such as char, this means
       *  setting them to 0.
       *//**
       *  @brief  Resizes the %string to the specified number of characters.
       *  @param  __n  Number of characters the %string should contain.
       *  @param  __c  Character to fill any new elements.
       *
       *  This function will %resize the %string to the specified
       *  number of characters.  If the number is smaller than the
       *  %string's current size the %string is truncated, otherwise
       *  the %string is extended and new elements are %set to @a __c.
       *////  Returns the size() of the largest possible %string.///  null-termination.///  Returns the number of characters in the string, not including any// Capacity:/**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first character in the %string.  Iteration
       *  is done in reverse element order.
       *//**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last character in the %string.  Iteration is done in
       *  reverse element order.
       *//**
       *  Returns a read-only (constant) iterator that points one past the
       *  last character in the %string.
       *//**
       *  Returns a read-only (constant) iterator that points to the first
       *  character in the %string.
       *//**
       *  Returns a read/write reverse iterator that points to one before the
       *  first character in the %string.  Iteration is done in reverse
       *  element order.  Unshares the string.
       *//**
       *  Returns a read/write reverse iterator that points to the last
       *  character in the %string.  Iteration is done in reverse element
       *  order.  Unshares the string.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  character in the %string.  Unshares the string.
       *//**
       *  Returns a read/write iterator that points to the first character in
       *  the %string.  Unshares the string.
       */// Iterators:/**
       *  @brief  Convert to a string_view.
       *  @return A string_view.
       *//**
       *  @brief  Set value to string constructed from a string_view.
       *  @param  __svt An object convertible to  string_view.
       *//**
       *  @brief  Set value to string constructed from initializer %list.
       *  @param  __l  std::initializer_list.
       */// NB: DR 1204./**
       *  @brief  Move assign the value of @a str to this string.
       *  @param  __str  Source string.
       *
       *  The contents of @a str are moved into this string (without copying).
       *  @a str is a valid, but unspecified string.
       **//**
       *  @brief  Set value to string of length 1.
       *  @param  __c  Source character.
       *
       *  Assigning to a character makes this string length 1 and
       *  (*this)[0] == @a c.
       *//**
       *  @brief  Copy contents of @a s into this string.
       *  @param  __s  Source null-terminated string.
       *//**
       *  @brief  Assign the value of @a str to this string.
       *  @param  __str  Source string.
       *//**
       *  @brief  Destroy the string instance.
       *//**
       *  @brief  Construct string from a string_view.
       *  @param  __t  Source object convertible to string view.
       *  @param  __a  Allocator to use (default is default allocator).
       *//**
       *  @brief  Construct string from a substring of a string_view.
       *  @param  __t   Source object convertible to string view.
       *  @param  __pos The index of the first character to copy from __t.
       *  @param  __n   The number of characters to copy from __t.
       *  @param  __a   Allocator to use.
       *//**
       *  @brief  Construct string as copy of a range.
       *  @param  __beg  Start of range.
       *  @param  __end  End of range.
       *  @param  __a  Allocator to use (default is default allocator).
       *//**
       *  @brief  Construct string from an initializer %list.
       *  @param  __l  std::initializer_list of characters.
       *  @param  __a  Allocator to use (default is default allocator).
       */// FIXME C++11: should always be noexcept./**
       *  @brief  Move construct string.
       *  @param  __str  Source string.
       *
       *  The newly-created string contains the exact contents of @a __str.
       *  @a __str is a valid, but unspecified string.
       **//**
       *  @brief  Construct string as multiple characters.
       *  @param  __n  Number of characters.
       *  @param  __c  Character to use.
       *  @param  __a  Allocator to use (default is default allocator).
       *//**
       *  @brief  Construct string as copy of a C string.
       *  @param  __s  Source C string.
       *  @param  __a  Allocator to use (default is default allocator).
       *//**
       *  @brief  Construct string initialized by a character %array.
       *  @param  __s  Source character %array.
       *  @param  __n  Number of characters to copy.
       *  @param  __a  Allocator to use (default is default allocator).
       *
       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
       *  has no special meaning.
       *//**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy.
       *  @param  __a  Allocator to use.
       *//**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __n  Number of characters to copy.
       *//**
       *  @brief  Construct string as copy of a substring.
       *  @param  __str  Source string.
       *  @param  __pos  Index of first character to copy from.
       *  @param  __a  Allocator to use.
       */// 2583. no way to supply an allocator for basic_string(str, pos)/**
       *  @brief  Construct string with copy of value of @a str.
       *  @param  __str  Source string.
       */// NB: per LWG issue 42, semantics different from IS:/**
       *  @brief  Construct an empty string using allocator @a a.
       *//**
       *  @brief  Default constructor creates an empty string.
       */// arguments, per 17.4.4.4 para. 2 item 2.// NB: We overload ctors in some cases instead of using default// Construct/copy/destroy:/**
       *  @brief  Only internally used: Construct string from a string view
       *          wrapper.
       *  @param  __svw  string view wrapper.
       *  @param  __a  Allocator to use.
       */// is provided.// participate in overload resolution when a string_view// allows to add an internal constructor that does not// Wraps a string_view by explicit conversion and thus// Allows an implicit conversion to __sv_type.// A helper type for avoiding boiler-plate.// These types are off.// to optimize for the common case of pointers as iterators.// _S_copy_chars is a separate template to permit specialization// traits_type::copy/move/assign.// When __n = 1 way faster than the general multichar// True if _Rep and source do not overlap.// NB: _M_limit doesn't check for a bad __pos value.// for use in begin() & non-const op[]// but they do not call _M_leak.// For the internal use we have functions similar to `begin'/`end'// Data Members (private):///  Value returned by various member functions when they fail.// size that the allocator can hold.// NB: This is an unsigned type, and thus represents the maximum// Data Members (public):// The actual data.// Use empty-base optimization: http://www.cantrip.org/emptyopt.html// XXX MT//   the object is not shared anymore.//   the acquire load in _M_is_shared that will conclude that// - last but one decrement needs to release to synchronize with//   all the previous decrements.// - the last decrement needs to acquire to synchronize with//   the last decrement that will delete the object.// - all but last decrements need to release to synchronize with// Decrement of _M_refcount is acq_rel, because:// Be race-detector-friendly.  For more info see bits/c++config.// Create & Destroy// You cannot leave those LWG people alone for a second.// grrr. (per 21.3.4)// One reference.// _M_dispose.// load to be acquire to synchronize with release fetch_and_add in// but one reference concurrently with this check, so we need this// so we need to use an atomic load. Another thread can drop last// _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,// leaked or not), so a relaxed load is enough.// predicate does not change concurrently (i.e. the string is either// so we need to use an atomic load. However, _M_is_leaked// be reasonably safe in this case.// _S_empty_rep_storage is never modified and the punning should// NB: Mild hack to avoid strict-aliasing warnings.  Note that// (carefully) in an empty string with one reference.// The following storage is init'd to 0 by the linker, resulting// In addition, this implementation quarters this amount.// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1// Solving for m:// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)// look like this:// with a terminating character and m _CharT elements, it'd// If one was to divvy up the theoretical largest size string,// is the maximum number of bytes the allocator can allocate.)// value that will be returned by max_size().  (Whereas npos// individual string is determined by _S_max_size. This is the// The maximum number of individual char_type elements of an// (Public) Data members:// Types://      empty string representation needs no constructor.//      beyond-the-end for a null terminator; thus, the shared//   4. All fields==0 is an empty string, given the extra storage//     n>0: n + 1 references, operations require a lock, const.//       0: one reference, non-const.//      -1: leaked, one reference, no ref-copies allowed, non-const.//   3. _M_refcount has three states://      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).//   2. _M_capacity >= _M_length//      must be kept null-terminated.//   1. String really contains _M_length + 1 characters: due to 21.3.4//   Invariants:// _Rep: string representation// type used for positions in insert, erase etc.// 21.3  Template class basic_string/**
   *  @class basic_string basic_string.h <string>
   *  @brief  Managing sequences of characters and character-like objects.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  @tparam _CharT  Type of character
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.  Of the
   *  <a href="tables.html#68">optional sequence requirements</a>, only
   *  @c push_back, @c at, and @c %array access are supported.
   *
   *  @doctodo
   *
   *
   *  Documentation?  What's that?
   *  Nathan Myers <ncm@cantrip.org>.
   *
   *  A string looks like this:
   *
   *  @code
   *                                        [_Rep]
   *                                        _M_length
   *   [basic_string<char_type>]            _M_capacity
   *   _M_dataplus                          _M_refcount
   *   _M_p ---------------->               unnamed array of char_type
   *  @endcode
   *
   *  Where the _M_p points to the first character in the string, and
   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
   *  pointer to the header.
   *
   *  This approach has the enormous advantage that a string object
   *  requires only one allocation.  All the ugliness is confined
   *  within a single %pair of inline functions, which each compile to
   *  a single @a add instruction: _Rep::_M_data(), and
   *  string::_M_rep(); and the allocation function which gets a
   *  block of raw bytes and with room enough and constructs a _Rep
   *  object at the front.
   *
   *  The reason you want _M_data pointing to the character %array and
   *  not the _Rep is so that the debugger can see the string
   *  contents. (Probably we should add a non-inline member to get
   *  the _Rep for the debugger to use, so users can check the actual
   *  string length.)
   *
   *  Note that the _Rep object is a POD so that you can have a
   *  static <em>empty string</em> _Rep object already @a constructed before
   *  static constructors have run.  The reference-count encoding is
   *  chosen so that a 0 indicates one reference, so you never try to
   *  destroy the empty-string _Rep object.
   *
   *  All but the last paragraph is considered pretty conventional
   *  for a C++ string implementation.
  */// Reference-counted COW string implentation// Allow basic_stringbuf::__xfer_bufptrs to call _M_length:/**
       *  @brief  Compare to a string_view.
       *  @param __pos1  A position in the string to start comparing from.
       *  @param __n1  The number of characters to compare.
       *  @param __svt  An object convertible to string_view to compare
       *                against.
       *  @param __pos2  A position in the string_view to start comparing from.
       *  @param __n2  The number of characters to compare.
       *  @return  Integer < 0, 0, or > 0.
       *//**
       *  @brief  Find position of a character not in a string_view.
       *  @param __svt  A object convertible to string_view containing
       *                characters to avoid.
       *  @param __pos  Index of character to search from (default 0).
       *  @return  Index of first occurrence.
       *//**
       *  @brief  Insert a string_view.
       *  @param __pos  Iterator referencing position in string to insert at.
       *  @param __svt  The object convertible to string_view to insert from.
       *  @param __pos  Iterator referencing position in string_view to insert
       *  from.
       *  @param __n    The number of characters to insert.
       *  @return  Reference to this string.
      */// See PR libstdc++/83328/**
       *  @brief  Insert a range of characters.
       *  @param __p  Const_iterator referencing location in string to
       *              insert at.
       *  @param __beg  Start of range.
       *  @param __end  End of range.
       *  @return  Iterator referencing the first inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts characters in range [beg,end).  If adding characters
       *  causes the length to exceed max_size(), length_error is
       *  thrown.  The value of the string doesn't change if an error
       *  is thrown.
      *//**
       *  @brief  Insert multiple characters.
       *  @param __p  Const_iterator referencing location in string to
       *              insert at.
       *  @param __n  Number of characters to insert
       *  @param __c  The character to insert.
       *  @return  Iterator referencing the first inserted char.
       *  @throw  std::length_error  If new length exceeds @c max_size().
       *
       *  Inserts @a __n copies of character @a __c starting at the
       *  position referenced by iterator @a __p.  If adding
       *  characters causes the length to exceed max_size(),
       *  length_error is thrown.  The value of the string doesn't
       *  change if an error is thrown.
      *//**
       *  @brief  Set value from a string_view.
       *  @param __svt  The source object convertible to string_view.
       *  @return  Reference to this string.
       */// 2063. Contradictory requirements for string move assignment/**
       *  @brief  Append a range of characters from a string_view.
       *  @param __svt  An object convertible to string_view to be appended from.
       *  @param __pos The position in the string_view to append from.
       *  @param __n   The number of characters to append from the string_view.
       *  @return  Reference to this string.
       *//**
       *  @brief  Append a string_view.
       *  @param __svt  An object convertible to string_view to be appended.
       *  @return  Reference to this string.
       *//**
       *  @brief  Provides access to the data contained in the %string.
       *  @param __n The index of the character to access.
       *  @return  Read/write reference to the character.
       *  @throw  std::out_of_range  If @a n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter is
       *  first checked that it is in the range of the string.  The function
       *  throws out_of_range if the check fails.
       *//**
       *  @brief  Subscript access to the data contained in the %string.
       *  @param  __pos  The index of the character to access.
       *  @return  Read/write reference to the character.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       *//**
       *  Returns a read/write reverse iterator that points to one before the
       *  first character in the %string.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read/write reverse iterator that points to the last
       *  character in the %string.  Iteration is done in reverse element
       *  order.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  character in the %string.
       *//**
       *  Returns a read/write iterator that points to the first character in
       *  the %string.
       *//**
       *  @brief  Set value to string constructed from a string_view.
       *  @param  __svt  An object convertible to string_view.
       */// Need to do a deep copy// __str can't use it, so free it.// __str can reuse our existing storage.// Just move the allocated pointer, our allocator can free it.// We've always got room for a short string, just copy it.// Replace allocator if POCMA is true.// Destroy existing storage before replacing allocator.// If this allocation throws there are no effects:// deallocate it before replacing current allocator.// Propagating allocator cannot free existing storage so must// we mess up the contents if we put a '\0' in the string.// basic_stringbuf relies on writing into unallocated capacity so// Must use _M_length() here not _M_set_length() because// 3076. basic_string CTAD ambiguity/**
       *  @brief  Construct string with copy of value of @a __str.
       *  @param  __str  Source string.
       */// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063// The explicit instantiations in misc-inst.cc require this due to// requires special behaviour if _InIterator is an integral type// _M_construct_aux is used to implement the 21.3.1 para 15 which// TODO check __is_final/**
   *  @class basic_string basic_string.h <string>
   *  @brief  Managing sequences of characters and character-like objects.
   *
   *  @ingroup strings
   *  @ingroup sequences
   *
   *  @tparam _CharT  Type of character
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.  Of the
   *  <a href="tables.html#68">optional sequence requirements</a>, only
   *  @c push_back, @c at, and @c %array access are supported.
   */// Support P0426R1 changes to char_traits in C++17.// ISO C++ 14882: 21 Strings library/** @file bits/basic_string.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{string}
 */// Copyright (C) 1997-2019 Free Software Foundation, Inc.// Components for manipulating sequences of characters -*- C++ -*-__len1__len2__res_arg/usr/include/c++/9/optional<bits/enable_special_members.h><new><stdexcept><utility>optionalmake_optional_Args_Args &&optional<_Tp> &const _Up &_Up &const optional<_Tp>const optional<_Tp> &const optional<_Up>const optional<_Up> &optional<_Up> &__throw_bad_optional_accessbad_optional_access()_Optional_base<_Tp, true, true> &_Optional_base<_Tp, true, true> &&const _Optional_base<_Tp, true, true>const _Optional_base<_Tp, true, true> &_Optional_base_Optional_base<_Tp, true, true> *_Optional_base<_Tp, true, false> &_Optional_base<_Tp, true, false> &&const _Optional_base<_Tp, true, false>const _Optional_base<_Tp, true, false> &_Optional_base<_Tp, false, true> &_Optional_base<_Tp, false, true> &&const _Optional_base<_Tp, false, true>const _Optional_base<_Tp, false, true> &_Optional_base<_Tp, <unnamed>, <unnamed>> &_Optional_base<_Tp, <unnamed>, <unnamed>> &&const _Optional_base<_Tp, <unnamed>, <unnamed>>const _Optional_base<_Tp, <unnamed>, <unnamed>> &_Optional_base<_Tp, <unnamed>, <unnamed>> *_M_get_Optional_base_impl<_Tp, _Dp> *_Dp_Dp *_M_payloadthis->_M_is_engaged()_M_is_engagedconst _Optional_base_impl<_Tp, _Dp>const _Optional_base_impl<_Tp, _Dp> *const _Dpconst _Dp *_M_engaged_M_reset_M_destruct_Stored_type *type *~_Optional_payload_Optional_payload<_Tp, false, _Copy, _Move> *_Optional_payload<_Tp, false, _Copy, _Move> &_Optional_payload<_Tp, false, _Copy, _Move> &&const _Optional_payload<_Tp, false, _Copy, _Move>const _Optional_payload<_Tp, false, _Copy, _Move> &_Optional_payload_Optional_payload<_Tp, true, false, false> &_Optional_payload<_Tp, true, false, false> &&const _Optional_payload<_Tp, true, false, false>const _Optional_payload<_Tp, true, false, false> &_Optional_payload<_Tp, true, true, false> &_Optional_payload<_Tp, true, true, false> &&const _Optional_payload<_Tp, true, true, false>const _Optional_payload<_Tp, true, true, false> &_Optional_payload<_Tp, true, false, true> &const _Optional_payload<_Tp, true, false, true>const _Optional_payload<_Tp, true, false, true> &_Optional_payload<_Tp, true, false, true> &&_Optional_payload_base<_Tp> *_M_value_M_move_assign_Optional_payload_base<_Tp> &&_M_copy_assignconst _Optional_payload_base<_Tp>const _Optional_payload_base<_Tp> &_Optional_payload_base<_Tp> &_Optional_payload_base_M_engaged(true)~_Optional_payload_base~_Storage_Storage<_Up, false> *_Storage_Vp_Storage<_Up, <unnamed>> *bad_optional_access &const bad_optional_accessconst bad_optional_access &bad_optional_access~bad_optional_accessbad_optional_access *virtualwhatconst bad_optional_access *bad optional access"bad optional access"const char[20]char[20]resetvalue_oroptional<_Tp> *__other__engagedhas_valueconst optional<_Tp> *operator boolemplaceoptional<_Up> &&nullopt_t &nullopt_t &&const nullopt_tconst nullopt_t &nullopt_tnullopt_t *__is_fast_hash<hash<optional<_Tp>>>hash<optional<_Tp>>__optional_hash_call_base<_Tp, _Up, false>__optional_hash_call_base<_Tp, _Up, <unnamed>>__optional_relop_t_Optional_base<_Tp, true, true>_Optional_base<_Tp, true, false>_Optional_base<_Tp, false, true>_Optional_base<_Tp, <unnamed>, <unnamed>>_Optional_base_impl<_Tp, _Dp>_Stored_type_Optional_payload<_Tp, false, _Copy, _Move>_Copy_Move_Optional_payload<_Tp, true, false, false>_Optional_payload<_Tp, true, true, false>_Optional_payload<_Tp, true, false, true>_Optional_payload<_Tp, true, true, true>_Optional_payload<_Tp, <unnamed>, <unnamed>, <unnamed>>_Optional_payload_base<_Tp>_Storage<_Up, false>_Storage<_Up, <unnamed>>_Empty_byteoptional<_Tp>_Requires_Construct_Token_Cond_M_empty falsenulloptnullopt_t::_Construct::_Token__cpp_lib_optional201606L_GLIBCXX_OPTIONALnoreturn// _GLIBCXX_OPTIONAL/// @}// usual values of _Tp won't typically hash to.// We pick an arbitrary hash for disengaged optionals which hopefully// Hash.// 2748. swappable traits for optionals// Swap and creation functions.// Comparisons with value type./* __lhs *//* __rhs */// Comparisons with nullopt.// Comparisons between optional values.// Observers.// Swap.// Destructor is implicit, implemented in _Optional_base.// Assignment operators.// Converting constructors for engaged optionals.// SFINAE helpers// Unique tag type.// Move assignment.// Move constructor.// Copy assignment.// Copy constructor./**
    * @brief Class template for optional values.
    */// Copy and move constructors.// Constructors for engaged optionals.// Constructors for disengaged optionals./**
    * @brief Class template that provides copy/move constructors of optional.
    *
    * Such a separate base class template is necessary in order to
    * conditionally make copy/move constructors trivial.
    *
    * When the contained value is trivally copy/move constructible,
    * the copy/move constructors of _Optional_base will invoke the
    * trivial copy/move constructor of _Optional_payload. Otherwise,
    * they will invoke _Optional_payload(bool, const _Optional_payload&)
    * or _Optional_payload(bool, _Optional_payload&&) to initialize
    * the contained value, if copying/moving an engaged optional.
    *
    * Whether the other special members are trivial is determined by the
    * _Optional_payload<_Tp> specialization used for the _M_payload member.
    *
    * @see optional, _Enable_special_members
    */// The _M_get operations have _M_engaged as a precondition.// _M_reset is a 'safe' operation with no precondition.// while _M_destruct has _M_engaged as a precondition.// The _M_construct operation has !_M_engaged as a precondition// member functions in each specialization.// Common base class for _Optional_base<T> to avoid repeating these// Destructor needs to destroy the contained value:// Base class implements all the constructors and assignment operators:// Payload for optionals with non-trivial destructors.// Non-trivial move assignment.// Non-trivial copy assignment.// Payload for optionals with non-trivial copy and move assignment.// Payload for optionals with non-trivial move construction/assignment.// Payload for optionals with non-trivial copy construction/assignment.// Payload for potentially-constexpr optionals (trivial copy/move/destroy)./*_HasTrivialMove *//*_HasTrivialCopy *//*_HasTrivialDestructor*/// Class template that manages the payload for optionals.// const-qualification, because _M_payload has had the const removed.// They exist to access the contained value with the appropriate// The _M_get() operations have _M_engaged as a precondition.// User-provided destructor is needed when _Up has non-trivial dtor.// used to perform non-trivial move assignment.// used to perform non-trivial copy assignment.// trivially copy constructible.// Move constructor is only used to when the contained value is// Copy constructor is only used to when the contained value is// contained value is not trivially move constructible.// Constructor used by _Optional_base move constructor when the// contained value is not trivially copy constructible.// Constructor used by _Optional_base copy constructor when the// the contained value for a std::optional.// This class template manages construction/destruction of// XXX Does not belong here./**
   *  @brief Exception class thrown when a disengaged optional object is
   *  dereferenced.
   *  @ingroup exceptions
   *//// Tag to disengage optional objects.// Must be constexpr for nullopt_t to be literal.// Used for constructing nullopt.// nullopt_t() = delete;// optional_value = {} syntax to work.// Do not user-declare default constructor at all for/// Tag type to disengage optional objects./**
   *  @addtogroup utilities
   *  @{
   *//** @file include/optional
 *  This is a Standard C++ Library header.
 */// <optional> -*- C++ -*-__args__tag__u/usr/include/c++/9/bits/stl_tree.h<bits/node_handle.h><ext/aligned_buffer.h><bits/stl_function.h><bits/allocator.h><bits/stl_algobase.h>const _Selfconst _Self &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>> &_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>> &_Rb_tree_iterator<pair<const CSubNet, CBanEntry>> &const _Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>>const _Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> &_Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> &_Rb_tree_const_iterator<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>> &_Rb_tree_iterator<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>> &const _Rb_tree<OptionsCategory, pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>, _Select1st<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>>, less<OptionsCategory>, allocator<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>>>const _Rb_tree<OptionsCategory, pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>, _Select1st<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>>, less<OptionsCategory>, allocator<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>>> &_Rb_tree<OptionsCategory, pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>, _Select1st<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>>, less<OptionsCategory>, allocator<pair<const OptionsCategory, map<basic_string<char, char_traits<char>, allocator<char>>, Arg, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, Arg>>>>>> &_Rb_tree_const_iterator<basic_string<char, char_traits<char>, allocator<char>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _Identity<basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _Identity<basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, basic_string<char, char_traits<char>, allocator<char>>, _Identity<basic_string<char, char_traits<char>, allocator<char>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_Rb_tree_const_iterator<pair<const int, const AssumeutxoData>> &_Rb_tree_iterator<pair<const int, const AssumeutxoData>> &const _Rb_tree<int, pair<const int, const AssumeutxoData>, _Select1st<pair<const int, const AssumeutxoData>>, less<int>, allocator<pair<const int, const AssumeutxoData>>>const _Rb_tree<int, pair<const int, const AssumeutxoData>, _Select1st<pair<const int, const AssumeutxoData>>, less<int>, allocator<pair<const int, const AssumeutxoData>>> &_Rb_tree<int, pair<const int, const AssumeutxoData>, _Select1st<pair<const int, const AssumeutxoData>>, less<int>, allocator<pair<const int, const AssumeutxoData>>> &_Rb_tree_const_iterator<pair<const int, uint256>> &_Rb_tree_iterator<pair<const int, uint256>> &const _Rb_tree<int, pair<const int, uint256>, _Select1st<pair<const int, uint256>>, less<int>, allocator<pair<const int, uint256>>>const _Rb_tree<int, pair<const int, uint256>, _Select1st<pair<const int, uint256>>, less<int>, allocator<pair<const int, uint256>>> &_Rb_tree<int, pair<const int, uint256>, _Select1st<pair<const int, uint256>>, less<int>, allocator<pair<const int, uint256>>> &_Rb_tree_const_iterator<pair<const uint256, unsigned int>> &_Rb_tree_iterator<pair<const uint256, unsigned int>> &const _Rb_tree<uint256, pair<const uint256, unsigned int>, _Select1st<pair<const uint256, unsigned int>>, less<uint256>, allocator<pair<const uint256, unsigned int>>>const _Rb_tree<uint256, pair<const uint256, unsigned int>, _Select1st<pair<const uint256, unsigned int>>, less<uint256>, allocator<pair<const uint256, unsigned int>>> &_Rb_tree<uint256, pair<const uint256, unsigned int>, _Select1st<pair<const uint256, unsigned int>>, less<uint256>, allocator<pair<const uint256, unsigned int>>> &_Rb_tree_black_countconst _Rb_tree_node_baseconst _Rb_tree_node_base *_Rb_tree_node_base *_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_Key_Val_KeyOfValueconst _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &_Rb_tree_rebalance_for_erase_Rb_tree_node_base *const_Rb_tree_node_base &_Rb_tree_insert_and_rebalance_Rb_tree_const_iterator<_Tp> &_Rb_tree_iterator<_Tp> &_Rb_tree_decrement_Rb_tree_incrementauto &_S_get_impl_Rb_tree<_Key, _Val, _Sel, _Cmp2, _Alloc> &_M_merge_equal_Compatible_tree<_Compare2> &_Rb_tree<_Key, _Val, _KeyOfValue, _Compare2, _Alloc> &_Compare2_M_merge_uniqueextractconst key_typeconst key_type &_Key &_M_reinsert_node_hint_equalnode_type &&_Node_handle<_Key, _Val, other> &&_M_reinsert_node_hint_unique_M_reinsert_node_equal_M_reinsert_node_unique_M_move_data_M_assign_equal_M_assign_unique_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> &&__rb_verify_M_equal_range_tr_Ktconst _Ktconst _Kt &_Kt &_Req_M_upper_bound_tr_M_lower_bound_tr_M_count_tr_M_find_trequal_rangeconst _Keyconst _Key &upper_bound_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> *countconst key_type *_Key *const _Key *_M_erase_aux_M_insert_range_equal_M_insert_range_unique__an_M_emplace_hint_equal__z..._M_emplace_hint_unique_M_emplace_equal_M_emplace_unique_M_insert_equal__Arg &&_NodeGen_NodeGen &_M_insert_unique___v_M_insert_equal_M_insert_unique__is_nothrow_swappable<_Compare>::valueconst _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc> *_M_node_count_M_header_M_leftkey_comp_M_key_compare~_Rb_tree_Rb_tree_Node_allocator &&other &&const _Compareconst _Compare &_Compare &_M_upper_bound__tree__k__hint__nh_M_lower_bound_M_copy_M_insert_equal_lower_node_M_insert_lower_node_M_insert_equal_lower_M_insert_lower_M_insert_node__insert_left_M_insert__M_get_insert_hint_equal_pos_M_get_insert_hint_unique_pos_M_const_cast_M_node_Base_ptr &_Rb_tree_node_base *&__before__after_M_get_insert_equal_pos_M_get_insert_unique_pos true__j_S_maximum_S_minimum_S_key_S_value_S_right_S_left_M_valptrcomparison object must be invocable as constcomparison object must be invocable with two arguments of key type_M_end_M_begin_M_parent_M_rightmost_M_right_M_leftmost_M_root_M_clone_node_M_drop_node_M_destroy_nodedestroy_Node_allocator &~_Rb_tree_node_M_create_node_Rb_tree_node<_Val> *construct_M_construct_node_M_put_node_M_get_nodeconst _Node_allocatorconst _Node_allocator &_M_get_Node_allocator_Rb_tree_impl_Key_compareconst _Key_compareconst _Key_compare &_Key_compare &_Rb_tree_impl<_Key_compare, <unnamed>> *_Rb_tree_impl<_Key_compare, <unnamed>> &&const _Rb_tree_impl<_Key_compare, <unnamed>>const _Rb_tree_impl<_Key_compare, <unnamed>> &_Rb_tree_impl<_Key_compare, <unnamed>> &is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::value__argconst _Alloc_nodeconst _Alloc_node *_Alloc_node *_Alloc_node_M_extract~_Reuse_or_alloc_node_Reuse_or_alloc_nodeconst _Reuse_or_alloc_nodeconst _Reuse_or_alloc_node &_Reuse_or_alloc_node &_Self &_Rb_tree_const_iterator<_Tp> *const _Rb_tree_const_iterator<_Tp>const _Rb_tree_const_iterator<_Tp> *_Base_ptr_Rb_tree_const_iteratorconst iteratorconst iterator &_Rb_tree_iterator<_Tp> *const _Rb_tree_iterator<_Tp>const _Rb_tree_iterator<_Tp> *_Rb_tree_iteratorconst _Valconst _Val *_Val *const _Rb_tree_node<_Val>const _Rb_tree_node<_Val> *_Rb_tree_key_compare_Rb_tree_key_compare<_Key_compare> &&const _Rb_tree_key_compare<_Key_compare>const _Rb_tree_key_compare<_Key_compare> &_Rb_tree_key_compare<_Key_compare> &_Rb_tree_key_compare<_Key_compare> *is_nothrow_default_constructible<_Key_compare>::value_Rb_tree_header &const _Rb_tree_headerconst _Rb_tree_header &_Rb_tree_header_Rb_tree_header *_Rb_tree_header &&_S_red_Rb_tree_node_base &&const _Rb_tree_node_base &<unnamed>_Rb_tree_merge_helper<_Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>, _Cmp2>_Cmp2_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>_Rb_tree_merge_helper<<unnamed>, <unnamed>>_Rb_tree_impl<_Key_compare, <unnamed>>_Val &const value_type *value_type *key_type_Const_Link_type_Link_type_Const_Base_ptr_Node_allocator_Rb_tree_merge_helper<_Tree1, _Cmp2>_Tree1__has_is_transparent_t__has_is_transparent<_Cmp, _SfinaeType, __void_t<is_transparent>>_Cmp_SfinaeType__has_is_transparent<_Cmp, _SfinaeType, <unnamed>>_Rb_tree_const_iterator<_Tp>const _Rb_tree_node<_Tp>const _Rb_tree_node<_Tp> *_Rb_tree_node<_Tp> *_Self_Rb_tree_iterator<_Tp>_Rb_tree_node<_Val>_Rb_tree_key_compare<_Key_compare>_Rb_tree_node_base_Rb_tree_color_S_black_Sel_Cmp1_M_nodes_M_impl_M_color__cpp_lib_generic_associative_lookup_STL_TREE_H_M_get_Node_allocator() == *__nh._M_alloc__position != end()// Allow access to internals of compatible _Rb_tree specializations.// ... then try after.// begin()// First, try before...// end()// Equivalent keys.// No need to swap header's color as it does not change.// Erase without rebalancing.// Structural copy. __x and __p must be non-null.// to erase nodes first.// Replacement allocator cannot free existing storage, we need// Note that _Key may be a constant type.// structure.// Try to move each node reusing existing nodes and copying __x nodes/// Merge from a compatible container into one with equivalent keys./// Merge from a compatible container into one with unique keys./// Extract a node./// Re-insert an extracted node.// which might result in a copy not a move.// Move assignment from container with possibly non-equal allocator,// Move assignment from container with equal allocator.// Move elements from container with possibly non-equal allocator,// Move elements from container with equal allocator.// Debugging.// Set operations.// DR 130. Associative erase should return an iterator.// LWG 2059.// Insert/erase.// Accessors.// allocation/deallocation// 233. Insertion hints in associative containers.// 2542. Missing const requirements for associative containers// object, and so this is a good place to sanity check it.// If we're asking for the key we're presumably using the comparison/* _Is_pod_comparator */// Unused _Is_pod_comparator is kept as it is part of mangled name.// recycle.// Functor similar to the previous one but without any pool of nodes to// __node is on the left.// is empty.// Functor recycling a pool of nodes and using allocation once the pool// Keeps track of size of tree.// Helper type to manage default initialization of node count and header.// Copy constructor added for consistency with C++98 mode.// Helper type offering value initialization guarantee on the compare functor.// iterators invalidated are those referring to the deleted node.// is relinked into its place, rather than copied, so that the only// (2) when a node being deleted has two children its successor node// (set_union, etc.)// linear time performance when used with the generic set algorithms// time begin(), and to the rightmost node of the tree, to enable// but also to the leftmost node of the tree, to enable constant// (1) the header cell is maintained with links not only to the root// 1990), except that// Leiserson, and Rivest, Introduction to Algorithms (MIT Press,// insertion and deletion algorithms are based on those in Cormen,// associative containers (set, multiset, map, and multimap). The// Red-black tree class, designed for use in implementing STL/** @file bits/stl_tree.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map,set}
 *//*
 *
 * Copyright (c) 1996,1997
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 */// RB tree implementation -*- C++ -*-__node_gen__src__gen__node__root__header/usr/include/c++/9/array<bits/range_access.h>const array<_Tp, _Nm>const array<_Tp, _Nm> &&array<_Tp, _Nm> &&const array<_Tp, _Nm> &array<_Tp, _Nm> &arrayconst array<_Tp, _Nm> *array<_Tp, _Nm> *_S_ptr_Type_Is_nothrow_swappableconst _Typeconst _Type &_Type &_S_ref__is_tuple_like_impl<array<_Tp, _Nm>>tuple_element<_Int, array<_Tp, _Nm>>tuple_size<array<_Tp, _Nm>>array<_Tp, _Nm>const_iterator__array_traits<_Tp, 0UL>__array_traits<_Tp, _Nm>_M_elemsindex is out of bounds_GLIBCXX_ARRAY__cplusplus > 201402L || !defined(__STRICT_ANSI__)_GLIBCXX_PROFILE"array::at: __n (which is %zu) " ">= _Nm (which is %zu)"// _GLIBCXX_ARRAY/// Partial specialization for std::array/// tuple_element/// tuple_size// Tuple interface to class template array.// c++1z or gnu++11// Constrained free swap overload, see p0185r1// Specialized algorithms.// Array comparisons.// boolean ? lvalue : (throw-expr, lvalue)// Result of conditional expression must be an lvalue so use// Element access.// Capacity.// Iterators.// DR 776.// No explicit construct/copy/destroy for aggregate type.// Support for zero-sized arrays mandatory./**
   *  @brief A standard container for storing a fixed size sequence of elements.
   *
   *  @ingroup sequences
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>.
   *
   *  Sets support random access iterators.
   *
   *  @tparam  Tp  Type of element. Required to be a complete type.
   *  @tparam  N  Number of elements.
  *//** @file include/array
 *  This is a Standard C++ Library header.
 */// <array> -*- C++ -*-__one__two/usr/include/c++/9/bits/invoke.h__invoke_Callable_Callable &&__invoke_impl_MemPtr_MemPtr &&_MemFun_MemFun &&_Fn_Fn &&__invfwd_GLIBCXX_INVOKE_H// _GLIBCXX_INVOKE_H/// Invoke a callable object.// reference_wrapper is converted to an lvalue-reference.// Used by __invoke_impl instead of std::forward<_Tp> so that a/** @file include/bits/invoke.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Copyright (C) 2016-2019 Free Software Foundation, Inc.// Implementation of INVOKE -*- C++ -*-__fn__f/usr/include/c++/9/tuple<bits/invoke.h><bits/uses_allocator.h><array>make_from_tuple_Tuple_Tuple &&__make_from_tuple_implapply__apply_impltuple<_Elements...> &_Elements_Elements &tietuple_cat_Tpls_Tpls &&_Elements &&forward_as_tuplemake_tupleconst tuple<_TElements...>const tuple<_TElements...> &tuple<_TElements...> &const tuple<_UElements...>const tuple<_UElements...> &tuple<_UElements...> &_TElements_UElements__compare__lesstuple objects can only be compared if they have equal sizes.__eqconst tuple<_Types...>const tuple<_Types...> &&tuple<_Types...> &&const tuple<_Types...> &tuple<_Types...> &_Headconst _Headconst _Head &_Head &__get_helper2const _Tuple_impl<__i, _Head, _Tail...>const _Tuple_impl<__i, _Head, _Tail...> &_Tuple_impl<__i, _Head, _Tail...> &_Tailconst __tuple_element_t<__i, tuple<_Elements...>>const __tuple_element_t<__i, tuple<_Elements...>> &&const tuple<_Elements...>const tuple<_Elements...> &&tuple<_Elements...> &&__tuple_element_t<__i, tuple<_Elements...>> &&const tuple<_Elements...> &const __tuple_element_t<__i, tuple<_Elements...>> &__tuple_element_t<__i, tuple<_Elements...>> &_M_head__get_helpertuple_UTypes_Swallow_assign &_Swallow_assign &&const _Swallow_assignconst _Swallow_assign &_Ret_S_do_Us_Us &&__make_1st_indices<> &__make_1st_indices<> &&const __make_1st_indices<>const __make_1st_indices<> &__combine_tuples<> &__combine_tuples<> &&const __combine_tuples<>const __combine_tuples<> &tuple<_T1, _T2> &pair<_U1, _U2> &&_U1_U2const pair<_U1, _U2>const pair<_U1, _U2> &pair<_U1, _U2> &tuple<_U1, _U2> &&const tuple<_U1, _U2>const tuple<_U1, _U2> &tuple<_U1, _U2> &tuple<_T1, _T2> &&const tuple<_T1, _T2>const tuple<_T1, _T2> &_U1 &&_U2 &&const _T1const _T1 &_T1 &const _T2const _T2 &_T2 &_Dummytuple<_T1, _T2> *__nothrow_assignable_NotSameTuple_NonNestedTuple_ImplicitlyMoveConvertibleTuple_MoveConstructibleTuple_ImplicitlyConvertibleTuple_ConstructibleTuple_SrcTuple_M_swap_Tuple_impl<_Idx, _Head> &_Tuple_impl<_Idx, _UHead> &&_UHeadconst _Tuple_impl<_Idx, _UHead>const _Tuple_impl<_Idx, _UHead> &_Tuple_impl<_Idx, _UHead> &_Tuple_impl_Tuple_impl<_Idx, _Head> &&const _Tuple_impl<_Idx, _Head>const _Tuple_impl<_Idx, _Head> &_UHead &&_Tuple_impl<_Idx, _Head> *_Tuple_impl<_Idx, _Head, _Tail...> &_Tuple_impl<_Idx, _UHead, _UTails...> &&_UTailsconst _Tuple_impl<_Idx, _UElements...>const _Tuple_impl<_Idx, _UElements...> &_Tuple_impl<_Idx, _UElements...> &const _Tuple_impl<_Idx, _UHead, _UTails...>const _Tuple_impl<_Idx, _UHead, _UTails...> &_Tuple_impl<_Idx, _UHead, _UTails...> &_Tuple_impl<_Idx, _Head, _Tail...> &&const _Tuple_impl<_Idx, _Head, _Tail...>const _Tuple_impl<_Idx, _Head, _Tail...> &_UTail_UTail &&const _Tailconst _Tail &_Tail &_Tuple_impl<_Idx, _Head, _Tail...> *const _Inheritedconst _Inherited &_Tuple_impl<<expression>, _Tail...> &_M_tail_Inherited &const _Head_base<_Idx, _Head, false>const _Head_base<_Idx, _Head, false> &_Head_base<_Idx, _Head, false> &_Head_base_Head_base<_Idx, _Head, false> *_Head_base<_Idx, _Head, false> &&const _Head_base<_Idx, _Head, true>const _Head_base<_Idx, _Head, true> &_Head_base<_Idx, _Head, true> &_Head_base<_Idx, _Head, true> *_Head_base<_Idx, _Head, true> &&tuple<_Args1...> &tuple<_Args2...> &pair_Args1_Indexes1_Args2_Indexes2pair<_T1, _T2> *tuple<_UElements...> &&_UElements &&const _Elementsconst _Elements &tuple<_Elements...> *_ImplicitlyDefaultConstructibleTuple_DefaultConstructibleTupletuple<> &tuple<> &&const tuple<>const tuple<> &tuple<> *uses_allocator<tuple<_Types...>, _Alloc>_Swallow_assign__tuple_concater<_Ret, _Index_tuple<>>__tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...>__tuple_concater<_Ret, _Indices, _Tpls...>_Indices__make_1st_indices<_Tp, _Tpls...>__make_1st_indices<>__make_1st_indices<<unnamed>...>__tuple_cat_result<_Tpls...>__combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>_Rem__combine_tuples<tuple<_Ts...>>__combine_tuples<>__combine_tuples<<unnamed>...>__make_tuple<_Tuple>__do_make_tuple<_Tuple>__make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>__make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>__make_tuple_impl<<unnamed>, <unnamed>, <unnamed>, <unnamed>>__tuple_compare<_Tp, _Up, __size, __size>__tuple_compare<_Tp, _Up, __i, __size>tuple_element<__i, tuple<>>tuple_element<0UL, tuple<_Head, _Tail...>>tuple_element<__i, tuple<_Head, _Tail...>>tuple_size<tuple<_Elements...>>tuple<_T1, _T2>_TC<false, _Elements...>_TC<<unnamed>, _Elements...>_Tuple_impl<_Idx, _Head>_Tuple_impl<_Idx, _Head, _Tail...>_Tuple_impl<_Idx, _Elements...>_Head_base<_Idx, _Head, false>_Head_base<_Idx, _Head, true>_Head_base<_Idx, _Head, <unnamed>>__empty_not_final__is_empty_non_tuple<tuple<_El0, _El...>>__is_empty_non_tuple<_Tp>tuple<_Elements...>_TC2<_Dummy>tuple<>__head__tail__h__tuple1__tuple2__second__tplstuple_size_v_T1s_T2s_Ts_El0_El_M_head_implignoreconst unsigned longtuple_size<tuple<>>::valuetuple index is in range__cpp_lib_make_from_tuple201606__cpp_lib_apply201603_GLIBCXX_TUPLE// _GLIBCXX_TUPLE// See stl_pair.h.../// Partial specialization for tuples// 2773. Making std::ignore constexpr// 2933. PR for LWG 2773 could be clearer// _GLIBCXX14_CONSTEXPR// of a tuple is not required.// A class (and instance) which can be used in 'tie' when an element/// swap/// tie// 2301. Why is tie not constexpr?/// tuple_cat// result tuple.// objects into the elements,  which are finally forwarded into the// Performs the actual concatenation by step-wise expanding tuple-like// type of a given set.// Helper to determine the index set for the first tuple-like// Computes the result type of tuple_cat given a set of tuple-like types.// Combines several std::tuple's into a single one.// Returns the std::tuple equivalent of a tuple-like type./// std::forward_as_tuple// 2275. Why is forward_as_tuple not constexpr?// NB: DR 705.// This class performs the comparison operations on tuples/// a const tuple rvalue./// Return a const reference to the unique element of type _Tp of/// Return a const reference to the unique element of type _Tp of a tuple./// Return a reference to the unique element of type _Tp of a tuple rvalue./// Return a reference to the unique element of type _Tp of a tuple./// Return a const rvalue reference to the ith element of a const tuple rvalue./// Return an rvalue reference to the ith element of a tuple rvalue./// Return a const reference to the ith element of a const tuple./// Return a reference to the ith element of a tuple./**
   * Error case for tuple_element: invalid index.
   *//**
   * Basis case for tuple_element: The first element is the one we're seeking.
   *//**
   * Recursive case for tuple_element: strip off the first element in
   * the tuple and retrieve the (i-1)th element of the remaining tuple.
   *//// class tuple_size// Allocator-extended constructors.// need to be constrained.// Shortcut for the cases where constructors taking _U1, _U2// Shortcut for the cases where constructors taking _T1, _T2/// Includes construction and assignment from a pair./// Partial specialization, 2-element tuple.// No-op allocator constructors.// allocator constructors.// We need the default since we're going to define no-op/* no-op */// Explicit specialization, zero-element tuple.// tuple swap// tuple assignment// must avoid creating temporaries.// Shortcut for the cases where constructors taking tuples// Shortcut for the cases where constructors taking tuple<_UElements...>// Shortcut for the cases where constructors taking _UElements...// Shortcut for the cases where constructors taking _Elements...// that it becomes dependent on the constraints.// Used for constraining the default constructor so/// Primary class template, tuple// constructors.// Concept utility functions, reused in conditionally-explicit// 2729. Missing SFINAE on std::pair::operator=// Basis case of inheritance recursion./**
   * Recursive tuple implementation. Here we store the @c Head element
   * and derive from a @c Tuple_impl containing the remaining elements
   * (which contains the @c Tail).
   *//**
   * Contains the actual implementation of the @c tuple template, stored
   * as a recursive inheritance hierarchy from the first element (most
   * derived class) to the last (least derived class). The @c Idx
   * parameter gives the 0-based index of the element stored at this
   * point in the hierarchy; we use it to implement a constant-time
   * get() operation.
   */// Use the Empty Base-class Optimization for empty, non-final types.// Using EBO for elements that are tuples causes ambiguous base errors./** @file include/tuple
 *  This is a Standard C++ Library header.
 */// <tuple> -*- C++ -*-__us__tps__a1__a2__uhead__elements/usr/include/c++/9/bits/stl_map.h<tuple>map<_Key, _Tp, _Compare, _Alloc> &const map<_Key, _Tp, _Compare, _Alloc>const map<_Key, _Tp, _Compare, _Alloc> &mapconst map<_K1, _T1, _C1, _A1>const map<_K1, _T1, _C1, _A1> &map<_K1, _T1, _C1, _A1> &_K1_C1_A1_S_get_treemultimap<_Key, _Val, _Cmp2, _Alloc> &map<_Key, _Val, _Cmp2, _Alloc> &const map<_Key, _Tp, _Compare, _Alloc> *map<_Key, _Tp, _Compare, _Alloc> *value_compinsert_or_assignkey_type &&_Key &&_Obj_Obj &&_Pair_Pair &&pair<const _Key, _Tp> &&pair<const _Key, _Tp> &try_emplacemergemultimap<_Key, _Tp, _C2, _Alloc> &&_C2multimap<_Key, _Tp, _C2, _Alloc> &map<_Key, _Tp, _C2, _Alloc> &&map<_Key, _Tp, _C2, _Alloc> &node_typeemplace_hintconst mapped_typeconst mapped_type &mapped_type &const piecewise_construct_t_DefaultConstructibleConcept<mapped_type>map<_Key, _Tp, _Compare, _Alloc> &&~mapvalue_compare_Rb_tree_merge_helper<map<_Key, _Val, _Cmp1, _Alloc>, _Cmp2>map<_Key, _Tp, _Compare, _Alloc>insert_return_typeconst_reverse_iterator_Pair_alloc_typekey_comparemapped_type__map__m__sourcemultimap<_Key, _Tp, _Compare, _Alloc>compstd::map must have the same value_type as its allocator__cpp_lib_map_insertion__cpp_lib_map_try_emplace_STL_MAP_H__cplusplus >= 201103L && defined(__STRICT_ANSI__)noexcept(__x.swap(__y))__pos != end()"map::at"/* _STL_MAP_H */// Allow std::map access to internals of compatible maps./// See std::map::swap()./// Based on operator</// Based on operator==/**
   *  @brief  Map ordering relation.
   *  @param  __x  A %map.
   *  @param  __y  A %map of the same type as @a x.
   *  @return  True iff @a x is lexicographically less than @a y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  maps.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  Map equality comparison.
   *  @param  __x  A %map.
   *  @param  __y  A %map of the same type as @a x.
   *  @return  True iff the size and elements of the maps are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  maps.  Maps are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  *//**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of read-only (constant) iterators that possibly points
       *           to the subsequence matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multimaps.
       *//**
       *  @brief Finds a subsequence matching given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Pair of iterators that possibly points to the subsequence
       *           matching given key.
       *
       *  This function is equivalent to
       *  @code
       *    std::make_pair(c.lower_bound(val),
       *                   c.upper_bound(val))
       *  @endcode
       *  (but is faster than making the calls separately).
       *
       *  This function probably only makes sense for multimaps.
       *//**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first iterator
       *           greater than key, or end().
       *//**
       *  @brief Finds the end of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return Iterator pointing to the first element
       *          greater than key, or end().
       *//**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Read-only (constant) iterator pointing to first element
       *           equal to or greater than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       *//**
       *  @brief Finds the beginning of a subsequence matching given key.
       *  @param  __x  Key of (key, value) pair to be located.
       *  @return  Iterator pointing to first element equal to or greater
       *           than key, or end().
       *
       *  This function returns the first element of a subsequence of elements
       *  that matches the given key.  If unsuccessful it returns an iterator
       *  pointing to the first element that has a greater value than given key
       *  or end() if no such element exists.
       *//**
       *  @brief  Finds whether an element with the given key exists.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  True if there is an element with the specified key.
       *//**
       *  @brief  Finds the number of elements with given key.
       *  @param  __x  Key of (key, value) pairs to be located.
       *  @return  Number of elements with specified key.
       *
       *  This function only makes sense for multimaps; for map the result will
       *  either be 0 (not present) or 1 (present).
       *//**
       *  @brief Tries to locate an element in a %map.
       *  @param  __x  Key of (key, value) %pair to be located.
       *  @return  Read-only (constant) iterator pointing to sought-after
       *           element, or end() if not found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns a constant
       *  iterator pointing to the sought after %pair. If unsuccessful it
       *  returns the past-the-end ( @c end() ) iterator.
       *//**
       *  @brief Tries to locate an element in a %map.
       *  @param  __x  Key of (key, value) %pair to be located.
       *  @return  Iterator pointing to sought-after element, or end() if not
       *           found.
       *
       *  This function takes a key and tries to locate the element with which
       *  the key matches.  If successful the function returns an iterator
       *  pointing to the sought after %pair.  If unsuccessful it returns the
       *  past-the-end ( @c end() ) iterator.
       */// [23.3.1.3] map operations/**
       *  Returns a value comparison object, built from the key comparison
       *  object out of which the %map was constructed.
       *//**
       *  Returns the key comparison object out of which the %map was
       *  constructed.
       */// observers/**
       *  Erases all elements in a %map.  Note that this function only
       *  erases the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Swaps data with another %map.
       *  @param  __x  A %map of the same element and allocator types.
       *
       *  This exchanges the elements between two maps in constant
       *  time.  (It is only swapping a pointer, an integer, and an
       *  instance of the @c Compare type (which itself is often
       *  stateless and empty), so it should be quite fast.)  Note
       *  that the global std::swap() function is specialized such
       *  that std::swap(m1,m2) will feed to this function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *//**
       *  @brief Erases a [__first,__last) range of elements from a %map.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *
       *  This function erases a sequence of elements from a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases a [first,last) range of elements from a %map.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   erased.
       *  @param __last Iterator pointing to the end of the range to
       *                be erased.
       *  @return The iterator @a __last.
       *
       *  This function erases a sequence of elements from a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases elements according to the provided key.
       *  @param  __x  Key of element to be erased.
       *  @return  The number of elements erased.
       *
       *  This function erases all the elements located by the given key from
       *  a %map.
       *  Note that this function only erases the element, and that if
       *  the element is itself a pointer, the pointed-to memory is not touched
       *  in any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief Erases an element from a %map.
       *  @param  __position  An iterator pointing to the element to be erased.
       *
       *  This function erases an element, pointed to by the given
       *  iterator, from a %map.  Note that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */// LWG 2059/**
       *  @brief Erases an element from a %map.
       *  @param  __position  An iterator pointing to the element to be erased.
       *  @return An iterator pointing to the element immediately following
       *          @a position prior to the element being erased. If no such
       *          element exists, end() is returned.
       *
       *  This function erases an element, pointed to by the given
       *  iterator, from a %map.  Note that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       *
       *  @{
       */// move-capable overload/**
       *  @brief Attempts to insert or assign a std::pair into the %map.
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                  pair should be inserted.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __obj  Argument used to generate the .second for a pair
       *                instance.
       *
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *
       *  This function attempts to insert a (key, value) %pair into the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *  If the %pair was already in the %map, the .second of the %pair
       *  is assigned from __obj.
       *
       *  Insertion requires logarithmic time.
       *//**
       *  @brief Attempts to insert or assign a std::pair into the %map.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __obj  Argument used to generate the .second for a pair
       *                instance.
       *
       *  @return  A pair, of which the first element is an iterator that
       *           points to the possibly inserted pair, and the second is
       *           a bool that is true if the pair was actually inserted.
       *
       *  This function attempts to insert a (key, value) %pair into the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *  If the %pair was already in the %map, the .second of the %pair
       *  is assigned from __obj.
       *
       *  Insertion requires logarithmic time.
       */// non-standard macro/**
       *  @brief Template function that attempts to insert a range of elements.
       *  @param  __first  Iterator pointing to the start of the range to be
       *                   inserted.
       *  @param  __last  Iterator pointing to the end of the range.
       *
       *  Complexity similar to that of the range constructor.
       */// 2354. Unnecessary copying when inserting into maps with braced-init/**
       *  @brief Attempts to insert a std::pair into the %map.
       *  @param  __position  An iterator that serves as a hint as to where the
       *                    pair should be inserted.
       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
       *               of pairs).
       *  @return An iterator that points to the element with key of
       *           @a __x (may or may not be the %pair passed in).
       *

       *  This function is not concerned about whether the insertion
       *  took place, and thus does not return a boolean like the
       *  single-argument insert() does.  Note that the first
       *  parameter is only a hint and can potentially improve the
       *  performance of the insertion process.  A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *  @{
       *//**
       *  @brief Attempts to insert a list of std::pairs into the %map.
       *  @param  __list  A std::initializer_list<value_type> of pairs to be
       *                  inserted.
       *
       *  Complexity similar to that of the range constructor.
       *//**
       *  @brief Attempts to insert a std::pair into the %map.
       *  @param __x Pair to be inserted (see std::make_pair for easy
       *	     creation of pairs).
       *
       *  @return  A pair, of which the first element is an iterator that
       *           points to the possibly inserted pair, and the second is
       *           a bool that is true if the pair was actually inserted.
       *
       *  This function attempts to insert a (key, value) %pair into the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *
       *  Insertion requires logarithmic time.
       *  @{
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param  __hint  An iterator that serves as a hint as to where the
       *                  pair should be inserted.
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __args  Arguments used to generate the .second for a new pair
       *                instance.
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args (may or may not be that
       *          std::pair).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument
       *  try_emplace() does. However, if insertion did not take place,
       *  this function has no effect.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param __k    Key to use for finding a possibly existing pair in
       *                the map.
       *  @param __args  Arguments used to generate the .second for a new pair
       *                instance.
       *
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted pair, and the second is a bool that
       *           is true if the pair was actually inserted.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *  If a %pair is not inserted, this function has no effect.
       *
       *  Insertion requires logarithmic time.
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param  __pos  An iterator that serves as a hint as to where the pair
       *                should be inserted.
       *  @param  __args  Arguments used to generate a new pair instance (see
       *	         std::piecewise_contruct for passing arguments to each
       *	         part of the pair constructor).
       *  @return An iterator that points to the element with key of the
       *          std::pair built from @a __args (may or may not be that
       *          std::pair).
       *
       *  This function is not concerned about whether the insertion took place,
       *  and thus does not return a boolean like the single-argument emplace()
       *  does.
       *  Note that the first parameter is only a hint and can potentially
       *  improve the performance of the insertion process. A bad hint would
       *  cause no gains in efficiency.
       *
       *  See
       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
       *  for more on @a hinting.
       *
       *  Insertion requires logarithmic time (if the hint is not taken).
       *//**
       *  @brief Attempts to build and insert a std::pair into the %map.
       *
       *  @param __args  Arguments used to generate a new pair instance (see
       *	        std::piecewise_contruct for passing arguments to each
       *	        part of the pair constructor).
       *
       *  @return  A pair, of which the first element is an iterator that points
       *           to the possibly inserted pair, and the second is a bool that
       *           is true if the pair was actually inserted.
       *
       *  This function attempts to build and insert a (key, value) %pair into
       *  the %map.
       *  A %map relies on unique keys and thus a %pair is only inserted if its
       *  first element (the key) is not already present in the %map.
       *
       *  Insertion requires logarithmic time.
       */// modifiers/**
       *  @brief  Access to %map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data whose key is equivalent to @a __k, if
       *           such a data is present in the %map.
       *  @throw  std::out_of_range  If no such data is present.
       */// DR 464. Suggestion for new member functions in standard containers.// __i->first is greater than or equivalent to __k./**
       *  @brief  Subscript ( @c [] ) access to %map data.
       *  @param  __k  The key for which data should be retrieved.
       *  @return  A reference to the data of the (key,data) %pair.
       *
       *  Allows for easy lookup with the subscript ( @c [] )
       *  operator.  Returns data associated with the key specified in
       *  subscript.  If the key does not exist, a pair with that key
       *  is created using default values, which is then returned.
       *
       *  Lookup requires logarithmic time.
       */// [23.3.1.2] element access/** Returns the maximum size of the %map.  *//** Returns the size of the %map.  *//** Returns true if the %map is empty.  (Thus begin() would equal
       *  end().)
      */// capacity/**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first pair in the %map.  Iteration is done in descending
       *  order according to the keys.
       *//**
       *  Returns a read-only (constant) reverse iterator that points to the
       *  last pair in the %map.  Iteration is done in descending order
       *  according to the keys.
       *//**
       *  Returns a read-only (constant) iterator that points one past the last
       *  pair in the %map.  Iteration is done in ascending order according to
       *  the keys.
       *//**
       *  Returns a read-only (constant) iterator that points to the first pair
       *  in the %map.  Iteration is done in ascending order according to the
       *  keys.
       *//**
       *  Returns a read/write reverse iterator that points to one before the
       *  first pair in the %map.  Iteration is done in descending order
       *  according to the keys.
       *//**
       *  Returns a read/write reverse iterator that points to the last pair in
       *  the %map.  Iteration is done in descending order according to the
       *  keys.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  pair in the %map.  Iteration is done in ascending order
       *  according to the keys.
       *//**
       *  Returns a read/write iterator that points to the first pair in the
       *  %map.
       *  Iteration is done in ascending order according to the keys.
       */// iterators/// Get a copy of the memory allocation object./**
       *  @brief  %Map list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %map with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %map and
       *  that the resulting %map's size is the same as the number
       *  of elements assigned.
       *//// Move assignment operator./**
       *  @brief  %Map assignment operator.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  The dtor only erases the elements, and note that if the elements
       *  themselves are pointers, the pointed-to memory is not touched in any
       *  way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Builds a %map from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __comp  A comparison functor.
       *  @param  __a  An allocator object.
       *
       *  Create a %map consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       *//**
       *  @brief  Builds a %map from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *
       *  Create a %map consisting of copies of the elements from
       *  [__first,__last).  This is linear in N if the range is
       *  already sorted, and NlogN otherwise (where N is
       *  distance(__first,__last)).
       *//// Allocator-extended range constructor./// Allocator-extended initialier-list constructor./// Allocator-extended move constructor./// Allocator-extended copy constructor./// Allocator-extended default constructor./**
       *  @brief  Builds a %map from an initializer_list.
       *  @param  __l  An initializer_list.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       *
       *  Create a %map consisting of copies of the elements in the
       *  initializer_list @a __l.
       *  This is linear in N if the range is already sorted, and NlogN
       *  otherwise (where N is @a __l.size()).
       *//**
       *  @brief  %Map move constructor.
       *
       *  The newly-created %map contains the exact contents of the moved
       *  instance. The moved instance is a valid, but unspecified, %map.
       *//**
       *  @brief  %Map copy constructor.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  @brief  Creates a %map with no elements.
       *  @param  __comp  A comparison object.
       *  @param  __a  An allocator object.
       *//**
       *  @brief  Default constructor creates no elements.
       */// (get_allocator() is also listed in this section)// [23.3.1.1] construct/copy/destroy// "functionally equivalent"// many of these are specified differently in ISO, but the following are/// The actual tree structure./// This turns a red-black tree into a [multi]map./**
   *  @brief A standard container made up of (key,value) pairs, which can be
   *  retrieved based on a key, in logarithmic time.
   *
   *  @ingroup associative_containers
   *
   *  @tparam _Key  Type of key objects.
   *  @tparam  _Tp  Type of mapped objects.
   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
   *  @tparam _Alloc  Allocator type, defaults to
   *                  allocator<pair<const _Key, _Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and an
   *  <a href="tables.html#69">associative container</a> (using unique keys).
   *  For a @c map<Key,T> the key_type is Key, the mapped_type is T, and the
   *  value_type is std::pair<const Key,T>.
   *
   *  Maps support bidirectional iterators.
   *
   *  The private tree data is declared exactly the same way for map and
   *  multimap; the distinction is made entirely in how the tree functions are
   *  called (*_unique versus *_equal, same as the standard).
  *//** @file bits/stl_map.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{map}
 */// Map implementation -*- C++ -*-/home/tanteikg/QCVE/sources/bitcoin/src/net_types.h<map><cstdint>BanMapFromJsonconst UniValueconst UniValue &UniValue &banmap_t &map<CSubNet, CBanEntry, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> &BanMapToJsonconst banmap_tconst banmap_t &CBanEntry &CBanEntry &&const CBanEntryconst CBanEntry &CBanEntryToJsonCBanEntry *nBanUntilnCreateTimenVersionCBanEntry::CURRENT_VERSIONCURRENT_VERSIONBITCOIN_NET_TYPES_HUniValueCSubNet// BITCOIN_NET_TYPES_H/**
 * Convert a JSON array to a `banmap_t` object.
 * @param[in] bans_json JSON to convert, must be as returned by `BanMapToJson()`.
 * @param[out] bans Bans list to create from the JSON.
 * @throws std::runtime_error if the JSON does not have the expected fields or they contain
 * unparsable values.
 *//**
 * Convert a `banmap_t` object to a JSON array.
 * @param[in] bans Bans list to convert.
 * @return a JSON array, similar to the one returned by the `listbanned` RPC. Suitable for
 * passing to `BanMapFromJson()`.
 *//**
     * Generate a JSON representation of this ban entry.
     * @return JSON suitable for passing to the `CBanEntry(const UniValue&)` constructor.
     *//**
     * Create a ban entry from JSON.
     * @param[in] json A JSON representation of a ban entry, as created by `ToJson()`.
     * @throw std::runtime_error if the JSON does not have the expected fields.
     */// file COPYING or http://www.opensource.org/licenses/mit-license.php.// Distributed under the MIT software license, see the accompanying// Copyright (c) 2019-2021 The Bitcoin Core developers/home/tanteikg/QCVE/sources/bitcoin/src/home/tanteikg/QCVE/sources/bitcoin/home/tanteikg/QCVE/sources/home/tanteikg/QCVE/home/tanteikg/homenCreateTimeInbans_jsonbansjson/usr/include/c++/9/bits/stl_construct.hdestroy_ndestroy_at_Destroyallocator<_Tp> &__traits_Destroy_n_Value_type__destroyvalue type is destructible_Construct_novalue_T1 *_Destroy_n_aux<true> &_Destroy_n_aux<true> &&const _Destroy_n_aux<true>const _Destroy_n_aux<true> &__destroy_n_Destroy_aux<true> &_Destroy_aux<true> &&const _Destroy_aux<true>const _Destroy_aux<true> &_Destroy_n_aux<true>_Destroy_n_aux<<unnamed>>_Destroy_aux<true>_Destroy_aux<<unnamed>>_STL_CONSTRUCT_H/* _STL_CONSTRUCT_H *//**
   * Destroy a range of objects using the supplied allocator.  For
   * nondefault allocators we do not optimize away invocation of 
   * destroy() even if _Tp has a trivial destructor.
   */// A deleted destructor is trivial, this ensures we reject such types:/**
   * Destroy a range of objects.  If the value_type of the object has
   * a trivial destructor, the compiler should optimize all of this
   * away, otherwise the objects' destructors must be invoked.
   *//**
   * Destroy the object pointed to by a pointer type.
   */// 402. wrong new expression in [some_]allocator::construct/**
   * Constructs an object in existing memory by invoking an allocated
   * object's constructor with an initializer.
   *//** @file bits/stl_construct.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// nonstandard construct and destroy functions -*- C++ -*-__location__pointer/usr/include/c++/9/bits/stl_vector.h<debug/assertions.h>vector<_Tp, _Alloc> &const vector<_Tp, _Alloc>const vector<_Tp, _Alloc> &vector_ValT_M_create_storage_Vector_base<_Tp, _Alloc> *_M_start_M_finish_M_end_of_storage_M_deallocate_Tr_M_allocate~_Vector_base_Vector_base_Vector_base<_Tp, _Alloc> &&_Tp_alloc_type &&const _Vector_base<_Tp, _Alloc>const _Vector_base<_Tp, _Alloc> *const _Tp_alloc_typeconst _Tp_alloc_type &_M_get_Tp_allocator_Tp_alloc_type &_Vector_impl_Vector_impl &&_Vector_impl *is_nothrow_default_constructible<_Tp_alloc_type>::value_M_swap_data_Vector_impl_data &_Vector_impl_data *const _Vector_impl_dataconst _Vector_impl_data &_M_copy_data_Vector_impl_data_Vector_impl_data &&element_typeelement_type *_M_data_ptr_Ptrconst vector<_Tp, _Alloc> *vector<_Tp, _Alloc> *vector<_Tp, _Alloc> &&_M_erase_at_end_S_max_size_Tp_alloc_type__diffmaxconst long9223372036854775807__gnu_cxx::__numeric_traits<ptrdiff_t>::__max__allocmaxconst unsigned long &unsigned long &const size_t &_S_check_init_len"cannot create std::vector larger than max_size()"cannot create std::vector larger than max_size()const char[49]char[49]__N("cannot create std::vector larger than max_size()")_M_check_len_M_emplace_aux_M_insert_dispatch_M_assign_dispatch_M_default_initialize_M_fill_initialize_M_range_initialize_M_allocate_and_copy_S_on_swap_Alloc_traits::propagate_on_container_swap::value || _M_get_Tp_allocator() == __x._M_get_Tp_allocator()__cbeg__offset_M_range_check~vector__rv__new_size_S_relocate__do_it_S_do_relocate_S_use_relocate_S_nothrow_relocate_Temporary_value *_M_val~_Temporary_value_Temporary_value_Never_valueless_alt<vector<_Tp, _Alloc>>_Vector_base<_Tp, _Alloc>vector<_Tp, _Alloc>_M_realloc_insert_M_insert_aux_M_range_insert_M_assign_auxemplace_back_M_thisstd::vector must have the same value_type as its allocatorstd::vector must have a non-const, non-volatile value_type_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC_GLIBCXX_ASAN_ANNOTATE_SHRINK(n)_GLIBCXX_ASAN_ANNOTATE_GREW(n)_GLIBCXX_ASAN_ANNOTATE_GROW(n)_GLIBCXX_ASAN_ANNOTATE_REINIT_STL_VECTOR_H_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR!_GLIBCXX_INLINE_VERSION_M_insert_rval_M_shrink_to_fit_M_default_append_M_fill_insert_M_fill_assign"vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)"/* _STL_VECTOR_H */// vector into a variant, but only if move assignment cannot throw./// See std::vector::swap()./**
   *  @brief  Vector ordering relation.
   *  @param  __x  A %vector.
   *  @param  __y  A %vector of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  vectors.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  Vector equality comparison.
   *  @param  __x  A %vector.
   *  @param  __y  A %vector of the same type as @a __x.
   *  @return  True iff the size and elements of the vectors are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of the
   *  vectors.  Vectors are considered equivalent if their sizes are equal,
   *  and if corresponding elements compare equal.
  */// so we need to individually move each element.// The rvalue's allocator cannot be moved and is not equal,// object's memory, resulting in a linear-time operation.// Do move assignment when it might not be possible to move source// or because the allocators are equal.// moved, either because the source's allocator will move too// Constant-time move assignment when source object's memory can be// _M_assign_aux.// Called by erase(q1,q2), clear(), resize(), _M_fill_assign,// Internal erase functions follow.// (even if std::allocator_traits::max_size says we can).// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,// Called by constructors to check initial size.// Called by _M_fill_insert, _M_insert_aux etc.// Emplacing an rvalue of the correct type can use _M_insert_rval.// Try to emplace at the end, otherwise forward to _M_insert_aux.// Either move-construct at the end, or forward to _M_insert_aux.// reallocate or move existing elements. _Arg is either _Tp& or _Tp.// Called by insert(p,x) and other functions when insertion needs to// and destroyed with _Alloc_traits::destroy().// A value_type object constructed with _Alloc_traits::construct()// Called by insert(p,x)// Called by resize(n).// the same thing.// Called by insert(p,n,x), and the range insert when it turns out to be// Called by the second insert_dispatch above// Called by the range insert to implement [23.1.1]/9// Internal insert functions follow.// to be the same thing.// Called by assign(n,t), and the range assign when it turns out// Called by the second assign_dispatch above// Called by the range assign to implement [23.1.1]/9// assignment work for the range versions.// Internal assign functions follow.  The *_aux functions do the actual// Called by the vector(n) constructor.// vector(n,value,a) constructor.// Called by the first initialize_dispatch above and by the// Called by the second initialize_dispatch above// Called by the range constructor to implement [23.1.1]/9// Internal constructor functions follow./**
       *  Memory expansion handler.  Uses the member allocation function to
       *  obtain @a n bytes of memory, and then copies [first,last) into it.
       *//**
       *  Erases all the elements.  Note that this function only erases the
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       *//**
       *  @brief  Swaps data with another %vector.
       *  @param  __x  A %vector of the same element and allocator types.
       *
       *  This exchanges the elements between two vectors in constant time.
       *  (Three pointers, so it should be quite fast.)
       *  Note that the global std::swap() function is specialized such that
       *  std::swap(v1,v2) will feed to this function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *//**
       *  @brief  Remove a range of elements.
       *  @param  __first  Iterator pointing to the first element to be erased.
       *  @param  __last  Iterator pointing to one past the last element to be
       *                  erased.
       *  @return  An iterator pointing to the element pointed to by @a __last
       *           prior to erasing (or end()).
       *
       *  This function will erase the elements in the range
       *  [__first,__last) and shorten the %vector accordingly.
       *
       *  Note This operation could be expensive and if it is
       *  frequently used the user should consider using std::list.
       *  The user is also cautioned that this function only erases
       *  the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Remove element at given position.
       *  @param  __position  Iterator pointing to element to be erased.
       *  @return  An iterator pointing to the next element (or end()).
       *
       *  This function will erase the element at the given position and thus
       *  shorten the %vector by one.
       *
       *  Note This operation could be expensive and if it is
       *  frequently used the user should consider using std::list.
       *  The user is also cautioned that this function only erases
       *  the element, and that if the element is itself a pointer,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       */// Check whether it's an integral type.  If so, it's not an iterator./**
       *  @brief  Inserts a range into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %vector before the location specified
       *  by @a pos.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts a range into the %vector.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert copies of the data in the range
       *  [__first,__last) into the %vector before the location specified
       *  by @a pos.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts a number of copies of given data into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *
       *  This function will insert a specified number of copies of
       *  the given data before the location specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts a number of copies of given data into the %vector.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a specified number of copies of
       *  the given data before the location specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts an initializer_list into the %vector.
       *  @param  __position  An iterator into the %vector.
       *  @param  __l  An initializer_list.
       *
       *  This function will insert copies of the data in the
       *  initializer_list @a l into the %vector before the location
       *  specified by @a position.
       *
       *  Note that this kind of operation could be expensive for a
       *  %vector and if it is frequently used the user should
       *  consider using std::list.
       *//**
       *  @brief  Inserts given rvalue into %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given rvalue before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       *//**
       *  @brief  Inserts given value into %vector before specified iterator.
       *  @param  __position  An iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       *//**
       *  @brief  Inserts given value into %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Note that this kind of operation
       *  could be expensive for a %vector and if it is frequently
       *  used the user should consider using std::list.
       *//**
       *  @brief  Inserts an object in %vector before specified iterator.
       *  @param  __position  A const_iterator into the %vector.
       *  @param  __args  Arguments.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert an object of type T constructed
       *  with T(std::forward<Args>(args)...) before the specified location.
       *  Note that this kind of operation could be expensive for a %vector
       *  and if it is frequently used the user should consider using
       *  std::list.
       *//**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation. It shrinks the %vector by one.
       *
       *  Note that no data is returned, and if the last element's
       *  data is needed, it should be retrieved before pop_back() is
       *  called.
       *//**
       *  @brief  Add data to the end of the %vector.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %vector and assigns the given data
       *  to it.  Due to the nature of a %vector this operation can be
       *  done in constant time if the %vector has preallocated space
       *  available.
       */// [23.2.4.3] modifiers/**
       *   Returns a pointer such that [data(), data() + size()) is a valid
       *   range.  For a non-empty %vector, data() == &front().
       */// data access/**
       *  Returns a read-only (constant) reference to the data at the
       *  last element of the %vector.
       *//**
       *  Returns a read/write reference to the data at the last
       *  element of the %vector.
       *//**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %vector.
       *//**
       *  Returns a read/write reference to the data at the first
       *  element of the %vector.
       *//**
       *  @brief  Provides access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter
       *  is first checked that it is in the range of the vector.  The
       *  function throws out_of_range if the check fails.
       *//**
       *  @brief  Provides access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *  @throw  std::out_of_range  If @a __n is an invalid index.
       *
       *  This function provides for safer data access.  The parameter
       *  is first checked that it is in the range of the vector.  The
       *  function throws out_of_range if the check fails.
       *//// Safety check used only from at()./**
       *  @brief  Subscript access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read-only (constant) reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       *//**
       *  @brief  Subscript access to the data contained in the %vector.
       *  @param __n The index of the element for which data should be
       *  accessed.
       *  @return  Read/write reference to data.
       *
       *  This operator allows for easy, array-style, data access.
       *  Note that data access with this operator is unchecked and
       *  out_of_range lookups are not defined. (For checked lookups
       *  see at().)
       */// element access/**
       *  @brief  Attempt to preallocate enough memory for specified number of
       *          elements.
       *  @param  __n  Number of elements required.
       *  @throw  std::length_error  If @a n exceeds @c max_size().
       *
       *  This function attempts to reserve enough memory for the
       *  %vector to hold the specified number of elements.  If the
       *  number requested is more than max_size(), length_error is
       *  thrown.
       *
       *  The advantage of this function is that if optimal code is a
       *  necessity and the user can determine the number of elements
       *  that will be required, the user can reserve the memory in
       *  %advance, and thus prevent a possible reallocation of memory
       *  and copying of %vector data.
       *//**
       *  Returns true if the %vector is empty.  (Thus begin() would
       *  equal end().)
       *//**
       *  Returns the total number of elements that the %vector can
       *  hold before needing to allocate more memory.
       *//**  A non-binding request to reduce capacity() to size().  *//**
       *  @brief  Resizes the %vector to the specified number of elements.
       *  @param  __new_size  Number of elements the %vector should contain.
       *  @param  __x  Data with which new elements should be populated.
       *
       *  This function will %resize the %vector to the specified
       *  number of elements.  If the number is smaller than the
       *  %vector's current size the %vector is truncated, otherwise
       *  the %vector is extended and new elements are populated with
       *  given data.
       *//**
       *  @brief  Resizes the %vector to the specified number of elements.
       *  @param  __new_size  Number of elements the %vector should contain.
       *
       *  This function will %resize the %vector to the specified
       *  number of elements.  If the number is smaller than the
       *  %vector's current size the %vector is truncated, otherwise
       *  default constructed elements are appended.
       *//**  Returns the size() of the largest possible %vector.  *//**  Returns the number of elements in the %vector.  */// [23.2.4.2] capacity/**
       *  Returns a read-only (constant) reverse iterator that points
       *  to one before the first element in the %vector.  Iteration
       *  is done in reverse element order.
       *//**
       *  Returns a read-only (constant) reverse iterator that points
       *  to the last element in the %vector.  Iteration is done in
       *  reverse element order.
       *//**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %vector.  Iteration is done in
       *  ordinary element order.
       *//**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %vector.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read/write reverse iterator that points to one
       *  before the first element in the %vector.  Iteration is done
       *  in reverse element order.
       *//**
       *  Returns a read/write reverse iterator that points to the
       *  last element in the %vector.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read/write iterator that points to the first
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       *//**
       *  @brief  Assigns an initializer list to a %vector.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %vector with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  Assigns a range to a %vector.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function fills a %vector with copies of the elements in the
       *  range [__first,__last).
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  Assigns a given value to a %vector.
       *  @param  __n  Number of elements to be assigned.
       *  @param  __val  Value to be assigned.
       *
       *  This function fills a %vector with @a __n copies of the given
       *  value.  Note that the assignment completely changes the
       *  %vector and that the resulting %vector's size is the same as
       *  the number of elements assigned.
       *//**
       *  @brief  %Vector list assignment operator.
       *  @param  __l  An initializer_list.
       *
       *  This function fills a %vector with copies of the elements in the
       *  initializer list @a __l.
       *
       *  Note that the assignment completely changes the %vector and
       *  that the resulting %vector's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  %Vector move assignment operator.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  The contents of @a __x are moved into this %vector (without copying,
       *  if the allocators permit it).
       *  Afterwards @a __x is a valid, but unspecified %vector.
       *
       *  Whether the allocator is moved depends on the allocator traits.
       *//**
       *  @brief  %Vector assignment operator.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but any unused capacity in
       *  @a __x will not be copied.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  The dtor only erases the elements, and note that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief  Builds a %vector from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __a  An allocator.
       *
       *  Create a %vector consisting of copies of the elements from
       *  [first,last).
       *
       *  If the iterators are forward, bidirectional, or
       *  random-access, then this will call the elements' copy
       *  constructor N times (where N is distance(first,last)) and do
       *  no memory reallocation.  But if only input iterators are
       *  used, then this will do at most 2N calls to the copy
       *  constructor, and logN memory reallocations.
       *//**
       *  @brief  Builds a %vector from an initializer list.
       *  @param  __l  An initializer_list.
       *  @param  __a  An allocator.
       *
       *  Create a %vector consisting of copies of the elements in the
       *  initializer_list @a __l.
       *
       *  This will call the element type's copy constructor N times
       *  (where N is @a __l.size()) and do no memory reallocation.
       *//// Move constructor with alternative allocator/// Copy constructor with alternative allocator/**
       *  @brief  %Vector move constructor.
       *
       *  The newly-created %vector contains the exact contents of the
       *  moved instance.
       *  The contents of the moved instance are a valid, but unspecified
       *  %vector.
       *//**
       *  @brief  %Vector copy constructor.
       *  @param  __x  A %vector of identical element and allocator types.
       *
       *  All the elements of @a __x are copied, but any unused capacity in
       *  @a __x  will not be copied
       *  (i.e. capacity() == size() in the new %vector).
       *
       *  The newly-created %vector uses a copy of the allocator object used
       *  by @a __x (unless the allocator traits dictate a different object).
       *//**
       *  @brief  Creates a %vector with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n copies of @a __value.
       *//**
       *  @brief  Creates a %vector with default constructed elements.
       *  @param  __n  The number of elements to initially create.
       *  @param  __a  An allocator.
       *
       *  This constructor fills the %vector with @a __n default
       *  constructed elements.
       *//**
       *  @brief  Creates a %vector with no elements.
       *  @param  __a  An allocator object.
       *//**
       *  @brief  Creates a %vector with no elements.
       */// (assign() and get_allocator() are also listed in this section)// [23.2.4.1] construct/copy/destroy// so only do it if we know the type can be move-inserted into *this.// immediate context (in __relocate_object_a's noexcept-specifier),// Instantiating std::__relocate_a might cause an error outside the// Concept requirements./**
   *  @brief A standard container which offers fixed time access to
   *  individual elements in any order.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a> with the
   *  %exception of @c push_front and @c pop_front.
   *
   *  In some terminology a %vector can be described as a dynamic
   *  C-style array, it offers fast and efficient access to individual
   *  elements in any order and saves the user from worrying about
   *  memory and size allocation.  Subscripting ( @c [] ) access is
   *  also provided as with C-style arrays.
  */// Kept for ABI compatibility.// _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR// ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)// Tell ASan when unused capacity is initialized to be valid.// Mark unused capacity as invalid after reallocation.// Mark unused capacity as valid again before deallocating it.// Used on reallocation to tell ASan unused capacity is invalid.// mark end of valid region as __curr instead of __prev.// Adjust ASan annotation for [_M_start, _M_end_of_storage) to// Enable ASan annotations for memory obtained from std::allocator.// !is_nothrow_move_constructible<_Tp_alloc_type>.// Not defaulted, to enforce noexcept(true) even when// information used by TBAA.// Do not use std::swap(_M_start, __x._M_start), etc as it loses/// See bits/stl_deque.h's _Deque_base for an explanation./** @file bits/stl_vector.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this  software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// Vector implementation -*- C++ -*-__vec/usr/include/c++/9/bits/vector.tccconst vector<bool, _Alloc>const vector<bool, _Alloc> &vector<bool, _Alloc> &_M_insert_range_M_reallocateend()vector::_M_realloc_insert"vector::_M_realloc_insert"const char[26]char[26]__old_start__old_finish__elems_before__new_start__new_finish_S_do_it__navail__builtin_unreachablevector::_M_default_append"vector::_M_default_append"__destroy_from__position.base()__old_finish - __n__n - __elems_after__elems_after__x_copy<unnamed> &vector::_M_fill_insert"vector::_M_fill_insert"const char[23]char[23]__midvector::_M_range_insert"vector::_M_range_insert"const char[24]char[24]"vector::reserve"vector::reserveconst char[16]char[16]__N("vector::reserve")this->_M_impl._M_startthis->_M_impl._M_finish__old_size_GLIBCXX_ASAN_ANNOTATE_SHRINK_GLIBCXX_ASAN_ANNOTATE_GREW_GLIBCXX_ASAN_ANNOTATE_GROW_VECTOR_TCC__tmp.end()__tmp.begin()this->_M_impl._M_finish - 2this->_M_impl._M_finish - 1*(this->_M_impl._M_finish - 1)__add__position + 1/* _VECTOR_TCC */// vector<bool>// See _M_realloc_insert above.// [res.on.arguments]).// taking the element by lvalue ref (see last bullet of C++11// to the existing vector.  This is an issue only for callers// case, where the moves could alter a new element belonging// The order of the three operations is dictated by the C++11// need to use it before _M_insert_aux moves elements around.// could alias one of the elements of the container and so we// We need to construct a temporary because something in __args...// replacement allocator cannot free existing storage// copy of it before _M_insert_aux moves elements around.// __x could be an existing element of this vector, so make a/** @file bits/vector.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{vector}
 */// Vector implementation (out of line) -*- C++ -*-/home/tanteikg/QCVE/sources/bitcoin/src/univalue/include/univalue.h<vector><string><cstring><charconv>json_isspace0x200x090x0a130x0djsonTokenIsValueJTOK_KW_NULLJTOK_KW_TRUEJTOK_KW_FALSEJTOK_NUMBER11JTOK_STRINGuvTypeNamegetJsonTokenstring &unsigned int &find_valueUniValue &&~UniValueUniValue *const UniValue *get_arrayget_objget_realget_strget_boolIntgetIntconst vector<UniValue, allocator<UniValue>>const vector<UniValue, allocator<UniValue>> &vector<UniValue, allocator<UniValue>> &getValuesconst vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &getKeyswriteObjectwriteArrayfindKeysize_t &checkTypeconst VTypeconst VType &VType &readconst basic_string_view<char, char_traits<char>>writepushKVspushKV__pushKVpush_backVItisObjectVOBJisArrayVARRisNumVNUMisStrVSTRisBool5VBOOLisFalseconst basic_string<char, char_traits<char>, allocator<char>>const basic_string<char, char_traits<char>, allocator<char>> &"1"const char[2]char[2]isTrueisNullVNULLexistsicheckObjectconst map<basic_string<char, char_traits<char>, allocator<char>>, VType, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>const map<basic_string<char, char_traits<char>, allocator<char>>, VType, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &map<basic_string<char, char_traits<char>, allocator<char>>, VType, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>> &getObjMapmap<basic_string<char, char_traits<char>, allocator<char>>, UniValue, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &getValStrgetTypesetObjectsetArraysetStrsetFloatsetIntsetNumStrsetBoolsetNullRefRef &&Tbasic_string<char, char_traits<char>, allocator<char>> &&type_errortype_error &type_error &&const type_errorconst type_error &~type_errorjtokentypeJTOK_ERR-1JTOK_NONEJTOK_OBJ_OPENJTOK_OBJ_CLOSEJTOK_ARR_OPENJTOK_ARR_CLOSEJTOK_COLONJTOK_COMMAVTypetypvalkeysvaluesNullUniValueBITCOIN_UNIVALUE_INCLUDE_UNIVALUE_H// BITCOIN_UNIVALUE_INCLUDE_UNIVALUE_H// not reached// eof// value is of unexpected type// Strict type-specific getters, these throw std::runtime_error if the// numbers are stored as C++ strings// setStr// setInt// setBool// setFloat// file COPYING or https://opensource.org/licenses/mit-license.php.// Copyright 2015 Bitcoin Core Developers// Copyright 2014 BitPay Inc./home/tanteikg/QCVE/sources/bitcoin/src/univalue/include/home/tanteikg/QCVE/sources/bitcoin/src/univaluechjttrawkeyval_strlastobjnamettokenValconsumedprettyIndentindentLevelsretIdxexpectedlenvecindexmemberTypeskv/usr/include/c++/9/bits/stl_algo.h<bits/uniform_int_dist.h><bits/stl_tempbuf.h><bits/stl_heap.h><bits/algorithmfwd.h><cstdlib>_RandomAccessIterator__rotate_BidirectionalIterator_FIterrotate_SampleIteratorsample_PopulationIterator_Distance_UniformRandomBitGenerator_UniformRandomBitGenerator &&__sample_Cat__max_element__min_element__set_symmetric_difference__set_difference__set_intersection__set_union__stable_sort__mergesearch_Searcherconst _Searcherconst _Searcher &_Searcher &for_each_n_Function__gen_two_uniform_ints_IntTypeis_permutation__is_permutation__minmax_element__is_sorted_until__count_if_Predicate__replace_copy_if__prev_permutation__next_permutation__includes__inplace_stable_sort__stable_sort_adaptive_Pointer__merge_sort_with_buffer__chunk_insertion_sort__merge_sort_loop_RandomAccessIterator1_RandomAccessIterator2__move_merge__inplace_merge__merge_without_buffer__merge_adaptive_BidirectionalIterator1__rotate_adaptive_BidirectionalIterator2__move_merge_adaptive_backward_BidirectionalIterator3__move_merge_adaptive__equal_range_CompareItTp_CompareTpIt__upper_bound__introselect__sort__introsort_loop__partial_sort__unguarded_partition_pivot__unguarded_partition__final_insertion_sort__unguarded_insertion_sort__insertion_sort__unguarded_linear_insert__partial_sort_copy__heap_select__stable_partition__stable_partition_adaptive__partition_EuclideanRingElement__gcd__reverse__unique_copy__unique__adjacent_find__remove_if__copy_n__remove_copy_if__find_end__search_n_UnaryPredicate_RandomAccessIter__search_n_aux__search__find_if_not_n_Distance &__find_if_not__find_if__trip_count__move_median_to_first_OIterunique_copy_IItertransform_BinaryOperation_UnaryOperationstable_sort_RAItersortset_unionset_symmetric_differenceset_intersectionset_differencesearch_n_FIter1_FIter2replace_ifrandom_shuffle_Generator_Generator &&_BIterpartitionpartial_sortnth_elementmin_element_LessThanComparableConcept< typename iterator_traits<_ForwardIterator>::value_type>max_elementgenerate_ngenerate_Functfor_eachfind_ifcount_ifadjacent_finduniquestable_partitionshuffle_UGenerator_UGenerator &&rotate_copyreverse_copyreversereplace_copy_ifreplace_copyremove_copy_ifremove_copyremove_ifremoveprev_permutationpartition_pointpartition_copy_OIter1_OIter2partial_sort_copynone_ofnext_permutationminmaxminmax_elementis_sorted_untilis_sortedis_partitionedinplace_mergeincludes_InputIteratorConcept<_InputIterator>_UnaryPredicateConcept<_Predicate, typename iterator_traits<_InputIterator>::value_type>find_if_notfind_endcopy_ncopy_ifclamp!(__hi < __lo)binary_searchany_ofall_of_S_chunk_size_S_threshold_RandomNumberGenerator_RandomNumberGenerator &&_UniformRandomNumberGenerator_UniformRandomNumberGenerator &&__out__g__nth__middle__pred__rand__new_value__old_value__binary_op__unary_op__searcher__predicate__b0__b1__lo__hi__buffer__buffer_size_OutputIterator1_OutputIterator2__cpp_lib_sample__cpp_lib_clamp_STL_ALGO_H_GLIBCXX_USE_C99_STDINT_TR1_GLIBCXX_HOSTED*__first1*__first2_BinaryPredicateConcept<_Compare, _Tp, typename iterator_traits<_ForwardIterator>::value_type>_LessThanOpConcept< _Tp, typename iterator_traits<_ForwardIterator>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_ForwardIterator>::value_type, _Tp>__i + 1*__i*__next*__last__result_first__result_last_BinaryPredicateConcept<_Compare, _OutputValueType, _OutputValueType>_BinaryPredicateConcept<_Compare, _InputValueType, _OutputValueType>_ConvertibleConcept<_InputValueType, _OutputValueType>_Mutable_RandomAccessIteratorConcept< _RandomAccessIterator>_LessThanComparableConcept<_OutputValueType>_LessThanOpConcept<_InputValueType, _OutputValueType>_UnaryPredicateConcept<_Predicate, typename iterator_traits<_ForwardIterator>::value_type>__result2__result1*__first_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_ForwardIterator>::value_type>__p + __n - 1__p + __n*(__p + __n - 1)__p + 1*__p_Mutable_BidirectionalIteratorConcept< _BidirectionalIterator>_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_BidirectionalIterator>::value_type>_BidirectionalIteratorConcept< _BidirectionalIterator>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator>::value_type, typename iterator_traits<_InputIterator>::value_type>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_InputIterator>::value_type, typename iterator_traits<_InputIterator>::value_type>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>_EqualityComparableConcept< typename iterator_traits<_ForwardIterator>::value_type>_EqualOpConcept< typename iterator_traits<_ForwardIterator>::value_type, _Tp>_OutputIteratorConcept<_OutputIterator2, typename iterator_traits<_InputIterator>::value_type>_OutputIteratorConcept<_OutputIterator1, typename iterator_traits<_InputIterator>::value_type>_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_InputIterator>::value_type>_EqualOpConcept< typename iterator_traits<_InputIterator>::value_type, _Tp>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator1>::value_type, typename iterator_traits<_ForwardIterator2>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_ForwardIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_InputIterator2>::value_type, typename iterator_traits<_InputIterator1>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_InputIterator2>::value_type>_OutputIteratorConcept<_OutputIterator, typename iterator_traits<_InputIterator1>::value_type>_LessThanOpConcept< typename iterator_traits<_InputIterator2>::value_type, typename iterator_traits<_InputIterator1>::value_type>_LessThanOpConcept< typename iterator_traits<_InputIterator1>::value_type, typename iterator_traits<_InputIterator2>::value_type>_BinaryPredicateConcept<_Compare, typename iterator_traits<_RandomAccessIterator>::value_type, typename iterator_traits<_RandomAccessIterator>::value_type>_LessThanComparableConcept< typename iterator_traits<_RandomAccessIterator>::value_type>_EqualityComparableConcept< typename iterator_traits<_InputIterator>::value_type>_OutputIteratorConcept<_OutputIterator, __typeof__(__gen())>_GeneratorConcept<_Generator, typename iterator_traits<_ForwardIterator>::value_type>_ConvertibleConcept<_Tp, typename iterator_traits<_ForwardIterator>::value_type>_OutputIteratorConcept<_OutputIterator, __typeof__(__binary_op(*__first1,*__first2))>_OutputIteratorConcept<_OutputIterator, __typeof__(__unary_op(*__first))>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_ForwardIterator>::value_type, _Tp>_ForwardIteratorConcept<_ForwardIterator2>_ForwardIteratorConcept<_ForwardIterator1>_EqualOpConcept< typename iterator_traits<_ForwardIterator1>::value_type, typename iterator_traits<_ForwardIterator2>::value_type>_BinaryPredicateConcept<_BinaryPredicate, typename iterator_traits<_InputIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>_EqualOpConcept< typename iterator_traits<_InputIterator>::value_type, typename iterator_traits<_ForwardIterator>::value_type>!__comp(__hi, __lo)_BinaryPredicateConcept<_Compare, typename iterator_traits<_BidirectionalIterator>::value_type, typename iterator_traits<_BidirectionalIterator>::value_type>_LessThanComparableConcept< typename iterator_traits<_BidirectionalIterator>::value_type>_GLIBCXX_MOVE3(__first1, __last1, __result)std::move(__first1, __last1, __result)__buffer_end*__last2++__last2*__last1_BidirectionalIteratorConcept< _BidirectionalIterator2>_BidirectionalIteratorConcept< _BidirectionalIterator1>/* _STL_ALGO_H *//// Take a random sample from a population.// The loop above is otherwise equivalent to this one-at-a-time version:// wrapping issues.// I.e. (__urngrange >= __unsampled_sz * __unsampled_sz) but without// two random numbers using a single distribution invocation:// If possible, we use __gen_two_uniform_ints to efficiently produce/// Selection sampling algorithm./// Reservoir sampling algorithm./**
   *  @brief  Return the maximum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the largest value
   *  according to __comp.
  *//**
   *  @brief  Return the maximum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the largest value.
  *//**
   *  @brief  Return the minimum element in a range using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  Iterator referencing the first instance of the smallest value
   *  according to __comp.
  *//**
   *  @brief  Return the minimum element in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  Iterator referencing the first instance of the smallest value.
  *//**
   *  @brief  Return the symmetric difference of two sorted ranges using
   *  comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other according to @p comp, that element is copied and the
   *  iterator advances.  If an element is contained in both ranges according
   *  to @p __comp, no elements are copied and both ranges advance.  The output
   *  range may not overlap either input range.
  *//**
   *  @brief  Return the symmetric difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  one range but not the other in order to the output range.  Iterators
   *  increment for each range.  When the current element of one range is less
   *  than the other, that element is copied and the iterator advances.  If an
   *  element is contained in both ranges, no elements are copied and both
   *  ranges advance.  The output range may not overlap either input range.
  *//**
   *  @brief  Return the difference of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second according to @p __comp, that element
   *  is copied and the iterator advances.  If the current element of the
   *  second range is less, no element is copied and the iterator advances.
   *  If an element is contained in both ranges according to @p __comp, no
   *  elements are copied and both ranges advance.  The output range may not
   *  overlap either input range.
  *//**
   *  @brief Return the difference of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  the first range but not the second in order to the output range.
   *  Iterators increment for each range.  When the current element of the
   *  first range is less than the second, that element is copied and the
   *  iterator advances.  If the current element of the second range is less,
   *  the iterator advances, but no element is copied.  If an element is
   *  contained in both ranges, no elements are copied and both ranges
   *  advance.  The output range may not overlap either input range.
  *//**
   *  @brief Return the intersection of two sorted ranges using comparison
   *  functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that iterator advances.  If an element is
   *  contained in both ranges according to @p __comp, the element from the
   *  first range is copied and both ranges advance.  The output range may not
   *  overlap either input range.
  *//**
   *  @brief Return the intersection of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  both ranges in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that iterator advances.  If an element is contained in both ranges, the
   *  element from the first range is copied and both ranges advance.  The
   *  output range may not overlap either input range.
  *//**
   *  @brief Return the union of two sorted ranges using a comparison functor.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @param  __comp    The comparison functor.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other
   *  according to @p __comp, that element is copied and the iterator advanced.
   *  If an equivalent element according to @p __comp is contained in both
   *  ranges, the element from the first range is copied and both ranges
   *  advance.  The output range may not overlap either input range.
  *//**
   *  @brief Return the union of two sorted ranges.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of second range.
   *  @param  __result  Start of output range.
   *  @return  End of the output range.
   *  @ingroup set_algorithms
   *
   *  This operation iterates over both ranges, copying elements present in
   *  each range in order to the output range.  Iterators increment for each
   *  range.  When the current element of one range is less than the other,
   *  that element is copied and the iterator advanced.  If an element is
   *  contained in both ranges, the element from the first range is copied and
   *  both ranges advance.  The output range may not overlap either input
   *  range.
  *//**
   *  @brief Sort the elements of a sequence using a predicate for comparison,
   *         preserving the relative order of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p __comp(*(i+1),*i) is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
   *  relative ordering after calling @p stable_sort().
  *//**
   *  @brief Sort the elements of a sequence, preserving the relative order
   *         of equivalent elements.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @p i in the range @p [__first,__last-1),
   *  @p *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is preserved, so any two
   *  elements @p x and @p y in the range @p [__first,__last) such that
   *  @p x<y is false and @p y<x is false will have the same relative
   *  ordering after calling @p stable_sort().
  *//**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @param  __comp    A functor to use for comparisons.
   *  @return         An iterator pointing to the first element "not less
   *                  than" @e val.
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Merges two sorted ranges.
   *  @ingroup sorting_algorithms
   *  @param  __first1  An iterator.
   *  @param  __first2  Another iterator.
   *  @param  __last1   Another iterator.
   *  @param  __last2   Another iterator.
   *  @param  __result  An iterator pointing to the end of the merged range.
   *  @return         An iterator pointing to the first element <em>not less
   *                  than</em> @e val.
   *
   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
   *  the sorted range @p [__result, __result + (__last1-__first1) +
   *  (__last2-__first2)).  Both input ranges must be sorted, and the
   *  output range must not overlap with either of the input ranges.
   *  The sort is @e stable, that is, for equivalent elements in the
   *  two ranges, elements from the first range will always come
   *  before elements from the second.
  *//**
   *  @brief Sort the elements of a sequence using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
   *  range @p [__first,__last-1).
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  *//**
   *  @brief Sort the elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the elements in the range @p [__first,__last) in ascending order,
   *  such that for each iterator @e i in the range @p [__first,__last-1),  
   *  *(i+1)<*i is false.
   *
   *  The relative ordering of equivalent elements is not preserved, use
   *  @p stable_sort() if this is needed.
  *//**
   *  @brief Sort a sequence just enough to find a particular position
   *         using a predicate for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that @p __comp(*j,*i) is false.
  *//**
   *  @brief Sort a sequence just enough to find a particular position.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __nth     Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
   *  is the same element that would have been in that position had the
   *  whole sequence been sorted. The elements either side of @p *__nth are
   *  not completely sorted, but for any iterator @e i in the range
   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
   *  holds that *j < *i is false.
  *//**
   *  @brief Sort the smallest elements of a sequence using a predicate
   *         for comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
   *  are both false.
  *//**
   *  @brief Sort the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Sorts the smallest @p (__middle-__first) elements in the range
   *  @p [first,last) and moves them to the range @p [__first,__middle). The
   *  order of the remaining elements in the range @p [__middle,__last) is
   *  undefined.
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
  *//**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [__first,middle) and false for each @p i
   *  in the range @p [middle,__last).
   *
   *  @p __pred must not modify its operand. @p partition() does not preserve
   *  the relative ordering of elements in each group, use
   *  @p stable_partition() if this is needed.
  *//**
   *  @brief Shuffle the elements of a sequence using a random number
   *         generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __rand    The RNG functor or function.
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
   *  provide a random distribution. Calling @p __rand(N) for a positive
   *  integer @p N should return a randomly chosen integer from the
   *  range [0,N).
  */// XXX rand() % N is not uniformly distributed/**
   *  @brief Randomly shuffle the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  Nothing.
   *
   *  Reorder the elements in the range @p [__first,__last) using a random
   *  distribution, so that every possible ordering of the sequence is
   *  equally likely.
  */// concept requirements -- predicates checked later/**
   *  @brief Copy a sequence, removing consecutive values using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        An input iterator.
   *  @param  __last         An input iterator.
   *  @param  __result       An output iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements for which @p __binary_pred returns
   *  true.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
  *//**
   *  @brief Copy a sequence, removing consecutive duplicate values.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  beginning at @p __result, except that only the first element is copied
   *  from groups of consecutive elements that compare equal.
   *  unique_copy() is stable, so the relative order of elements that are
   *  copied is unchanged.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
   *  
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
   *  Assignable?
  */// "the type returned by a _Generator"/**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __n      The length of the sequence.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   The end of the sequence, @p __first+__n
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__first+__n).
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
   *  DR 865. More algorithms that throw away information
  *//**
   *  @brief Assign the result of a function object to each value in a
   *         sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __gen    A function object taking no arguments and returning
   *                 std::iterator_traits<_ForwardIterator>::value_type
   *  @return   generate() returns no value.
   *
   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
   *  @p [__first,__last).
  *//**
   *  @brief Replace each value in a sequence for which a predicate returns
   *         true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   replace_if() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
   *  is true then the assignment @c *i = @p __new_value is performed.
  *//**
   *  @brief Replace each occurrence of one value in a sequence with another
   *         value.
   *  @ingroup mutating_algorithms
   *  @param  __first      A forward iterator.
   *  @param  __last       A forward iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   replace() returns no value.
   *
   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
  */// "the type returned by a _BinaryOperation"/**
   *  @brief Perform an operation on corresponding elements of two sequences.
   *  @ingroup mutating_algorithms
   *  @param  __first1     An input iterator.
   *  @param  __last1      An input iterator.
   *  @param  __first2     An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __binary_op  A binary operator.
   *  @return   An output iterator equal to @p result+(last-first).
   *
   *  Applies the operator to the corresponding elements in the two
   *  input ranges and assigns the results to successive elements of the
   *  output sequence.
   *  Evaluates @p
   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
   *  @c N in the range @p [0,__last1-__first1).
   *
   *  @p binary_op must not alter either of its arguments.
  */// "the type returned by a _UnaryOperation"/**
   *  @brief Perform an operation on a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first     An input iterator.
   *  @param  __last      An input iterator.
   *  @param  __result    An output iterator.
   *  @param  __unary_op  A unary operator.
   *  @return   An output iterator equal to @p __result+(__last-__first).
   *
   *  Applies the operator to each element in the input range and assigns
   *  the results to successive elements of the output sequence.
   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
   *  range @p [0,__last-__first).
   *
   *  @p unary_op must not alter its argument.
  *//** @brief Search a sequence using a Searcher object.
   *
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __searcher     A callable object.
   *  @return @p __searcher(__first,__last).first
  *//**
   *  @brief Search a sequence for a number of consecutive values using a
   *         predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __count        The number of consecutive values.
   *  @param  __val          The value to find.
   *  @param  __binary_pred  A binary predicate.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @p
   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
   *  @p [0,__count), or @p __last if no such iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p __count
   *  consecutive elements for which the predicate returns true.
  *//**
   *  @brief Search a sequence for a number of consecutive values.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __count  The number of consecutive values.
   *  @param  __val    The value to find.
   *  @return The first iterator @c i in the range @p
   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
   *  each @c N in the range @p [0,__count), or @p __last if no such
   *  iterator exists.
   *
   *  Searches the range @p [__first,__last) for @p count consecutive elements
   *  equal to @p __val.
  *//**
   *  @brief Search a sequence for a matching sub-sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1     A forward iterator.
   *  @param  __last1      A forward iterator.
   *  @param  __first2     A forward iterator.
   *  @param  __last2      A forward iterator.
   *  @param  __predicate  A binary predicate.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that
   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2), using @p __predicate to determine equality,
   *  and returns an iterator to the first element of the
   *  sub-sequence, or @p __last1 if no such iterator exists.
   *
   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
  *//**
   *  @brief Search a sequence for a matching sub-sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  A forward iterator.
   *  @param  __last1   A forward iterator.
   *  @param  __first2  A forward iterator.
   *  @param  __last2   A forward iterator.
   *  @return The first iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
   *  *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the first element
   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
   *  found.
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.
   *
   *  This means that the returned iterator @c i will be in the range
   *  @p [__first1,__last1-(__last2-__first2))
  *//**
   *  @brief Count the elements of a sequence for which a predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @p __pred(*i) is true.
  *//**
   *  @brief Count the number of copies of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be counted.
   *  @return   The number of iterators @c i in the range @p [__first,__last)
   *  for which @c *i == @p __value
  *//**
   *  @brief Find two adjacent values in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first         A forward iterator.
   *  @param  __last          A forward iterator.
   *  @param  __binary_pred   A binary predicate.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that
   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
   *  exists.
  *//**
   *  @brief Find two adjacent values in a sequence that are equal.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return   The first iterator @c i such that @c i and @c i+1 are both
   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
   *  or @p __last if no such iterator exists.
  *//**
   *  @brief  Find element from a set in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @param  __comp    Predicate to use.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
   *  such iterator exists.
   *

   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  *//**
   *  @brief  Find element from a set in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of match candidates.
   *  @param  __last2   End of match candidates.
   *  @return   The first iterator @c i in the range
   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for an element that is
   *  equal to some element in the range [__first2,__last2).  If
   *  found, returns an iterator in the range [__first1,__last1),
   *  otherwise returns @p __last1.
  *//**
   *  @brief Find the first element in a sequence for which a
   *         predicate is true.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
  *//**
   *  @brief Find the first occurrence of a value in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __val    The value to find.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
  *//**
   *  @brief Apply a function to every element of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __n      A value convertible to an integer.
   *  @param  __f      A unary function object.
   *  @return   `__first+__n`
   *
   *  Applies the function object `__f` to each element in the range
   *  `[first, first+n)`.  `__f` must not modify the order of the sequence.
   *  If `__f` has a return value it is ignored.
  */// N.B. [alg.foreach] says std::move(f) but it's redundant./**
   *  @brief Apply a function to every element of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __f      A unary function object.
   *  @return   @p __f
   *
   *  Applies the function object @p __f to each element in the range
   *  @p [first,last).  @p __f must not modify the order of the sequence.
   *  If @p __f has a return value it is ignored.
  */// for two successive elements at a time:// using a single distribution invocation to produce swap positions// Now we know that __last - __i is even, so we do the rest in pairs,// do the first one up front:// means an uneven number of elements /to swap/, in which case we// Since we know the range isn't empty, an even number of elements// I.e. (__urngrange >= __urange * __urange) but without wrap issues./**
   *  @brief Shuffle the elements of a sequence using a uniform random
   *         number generator.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
   *  @return  Nothing.
   *
   *  Reorders the elements in the range @p [__first,__last) using @p __g to
   *  provide random numbers.
  *//**
   *  @brief Generate two uniformly distributed integers using a
   *         single distribution invocation.
   *  @param  __b0    The upper bound for the first integer.
   *  @param  __b1    The upper bound for the second integer.
   *  @param  __g     A UniformRandomBitGenerator.
   *  @return  A pair (i, j) with i and j uniformly distributed
   *           over [0, __b0) and [0, __b1), respectively.
   *
   *  Requires: __b0 * __b1 <= __g.max() - __g.min().
   *
   *  Using uniform_int_distribution with a range that is very
   *  small relative to the range of the generator ends up wasting
   *  potentially expensively generated randomness, since
   *  uniform_int_distribution does not store leftover randomness
   *  between invocations.
   *
   *  If we know we want two integers in ranges that are sufficiently
   *  small, we can compose the ranges, use a single distribution
   *  invocation, and significantly reduce the waste.
  *//**
   *  @brief  Returns the value clamped between lo and hi.
   *  @ingroup sorting_algorithms
   *  @param  __val   A value of arbitrary type.
   *  @param  __lo    A lower limit of arbitrary type.
   *  @param  __hi    An upper limit of arbitrary type.
   *  @param  __comp  A comparison functor.
   *  @return max(__val, __lo, __comp) if __comp(__val, __hi)
   *	      or min(__val, __hi, __comp) otherwise.
   *//**
   *  @brief  Returns the value clamped between lo and hi.
   *  @ingroup sorting_algorithms
   *  @param  __val  A value of arbitrary type.
   *  @param  __lo   A lower limit of arbitrary type.
   *  @param  __hi   An upper limit of arbitrary type.
   *  @return max(__val, __lo) if __val < __hi or min(__val, __hi) otherwise.
   *//**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  *//**
   *  @brief  Checks whether a permutaion of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __last2   End of first range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __last2), beginning with ForwardIterator2 begin,
   *          such that equal(__first1, __last1, begin) returns true;
   *          otherwise, returns false.
  */// We've seen this one before.// have the same elements in the same order.// Efficiently compare identical prefixes:  O(N) if sequences/**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __pred    A binary predicate.
   *  @return true if there exists a permutation of the elements in
   *          the range [__first2, __first2 + (__last1 - __first1)),
   *          beginning with ForwardIterator2 begin, such that
   *          equal(__first1, __last1, __begin, __pred) returns true;
   *          otherwise, returns false.
  *//**
   *  @brief  Checks whether a permutation of the second sequence is equal
   *          to the first sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of first range.
   *  @param  __last1   End of first range.
   *  @param  __first2  Start of second range.
   *  @return true if there exists a permutation of the elements in the range
   *          [__first2, __first2 + (__last1 - __first1)), beginning with 
   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
   *          returns true; otherwise, returns false.
  */// rest of the list.// Establish __last2 assuming equal ranges by iterating over the// N2722 + DR 915./**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   Comparison functor.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  *//**
   *  @brief  Return a pair of iterators pointing to the minimum and maximum
   *          elements in a range.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  make_pair(m, M), where m is the first iterator i in 
   *           [__first, __last) such that no other element in the range is
   *           smaller, and where M is the last iterator i in [__first, __last)
   *           such that no other element in the range is larger.
  *//**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  *//**
   *  @brief  Determines min and max at once as an ordered pair.
   *  @ingroup sorting_algorithms
   *  @param  __a  A thing of arbitrary type.
   *  @param  __b  Another thing of arbitrary type.
   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
   *  __b) otherwise.
  *//**
   *  @brief  Determines the end of a sorted sequence using comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  *//**
   *  @brief  Determines the end of a sorted sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  An iterator pointing to the last iterator i in [__first, __last)
   *           for which the range [__first, i) is sorted.
  *//**
   *  @brief  Determines whether the elements of a sequence are sorted
   *          according to a comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A comparison functor.
   *  @return  True if the elements are sorted, false otherwise.
  *//**
   *  @brief  Determines whether the elements of a sequence are sorted.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @return  True if the elements are sorted, false otherwise.
  *//**
   *  @brief Copy a sequence, replacing each value for which a predicate
   *         returns true with another value.
   *  @ingroup mutating_algorithms
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __pred       A predicate.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p __result+(__last-__first).
   *
   *  Copies each element in the range @p [__first,__last) to the range
   *  @p [__result,__result+(__last-__first)) replacing elements for which
   *  @p __pred returns true with @p __new_value.
  *//**
   *  @brief Copy a sequence, replacing each element of one value with another
   *         value.
   *  @param  __first      An input iterator.
   *  @param  __last       An input iterator.
   *  @param  __result     An output iterator.
   *  @param  __old_value  The value to be replaced.
   *  @param  __new_value  The replacement value.
   *  @return   The end of the output sequence, @p result+(last-first).
   *
   *  Copies each element in the input range @p [__first,__last) to the
   *  output range @p [__result,__result+(__last-__first)) replacing elements
   *  equal to @p __old_value with @p __new_value.
  */// replace_if// replace/**
   *  @brief  Permute range into the previous @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the previous one of this set.  Returns true if there are
   *  more sequences to generate.  If the sequence is the smallest of the set,
   *  the largest is generated and false returned.
  *//**
   *  @brief  Permute range into the previous @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to last permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the previous one of this
   *  set.  Returns true if there are more sequences to generate.  If the
   *  sequence is the smallest of the set, the largest is generated and false
   *  returned.
  *//**
   *  @brief  Permute range into the next @e dictionary ordering using
   *          comparison functor.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @param  __comp   A comparison functor.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range [__first,__last) as a set of
   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
   *  sequence into the next one of this set.  Returns true if there are more
   *  sequences to generate.  If the sequence is the largest of the set, the
   *  smallest is generated and false returned.
  *//**
   *  @brief  Permute range into the next @e dictionary ordering.
   *  @ingroup sorting_algorithms
   *  @param  __first  Start of range.
   *  @param  __last   End of range.
   *  @return  False if wrapped to first permutation, true otherwise.
   *
   *  Treats all permutations of the range as a set of @e dictionary sorted
   *  sequences.  Permutes the current sequence into the next one of this set.
   *  Returns true if there are more sequences to generate.  If the sequence
   *  is the largest of the set, the smallest is generated and false returned.
  */// max_element// min_element// set_symmetric_difference// stable_sort// set_union// set_intersection// set_difference// merge// nth_element/**
   *  @brief Determines whether all elements of a sequence exists in a range
   *  using comparison.
   *  @ingroup set_algorithms
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @param  __comp    Comparison function to use.
   *  @return True if each element in [__first2,__last2) is contained
   *  in order within [__first1,__last1) according to comp.  False
   *  otherwise.  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1),
   *  using comp to decide.  The iterators over each range only move
   *  forward, so this is a linear algorithm.  If an element in
   *  [__first2,__last2) is not found before the search iterator
   *  reaches @p __last2, false is returned.
  *//**
   *  @brief Determines whether all elements of a sequence exists in a range.
   *  @param  __first1  Start of search range.
   *  @param  __last1   End of search range.
   *  @param  __first2  Start of sequence
   *  @param  __last2   End of sequence.
   *  @return  True if each element in [__first2,__last2) is contained in order
   *  within [__first1,__last1).  False otherwise.
   *  @ingroup set_algorithms
   *
   *  This operation expects both [__first1,__last1) and
   *  [__first2,__last2) to be sorted.  Searches for the presence of
   *  each element in [__first2,__last2) within [__first1,__last1).
   *  The iterators over each range only move forward, so this is a
   *  linear algorithm.  If an element in [__first2,__last2) is not
   *  found before the search iterator reaches @p __last2, false is
   *  returned.
  */// ranges are sorted.// that their input ranges are sorted and the postcondition that their output// set_symmetric_difference.  All of these algorithms have the precondition// Set algorithms: includes, set_union, set_intersection, set_difference,/// This is a helper function for the stable sorting routines./// This is a helper function for the __merge_sort_loop routines./**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [middle,last), and puts the result in [__first,__last).  The output will
   *  be sorted.  The sort is @e stable, that is, for equivalent
   *  elements in the two ranges, elements from the first range will always
   *  come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Merges two sorted ranges in place.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __middle  Another iterator.
   *  @param  __last    Another iterator.
   *  @return  Nothing.
   *
   *  Merges two sorted and consecutive ranges, [__first,__middle) and
   *  [__middle,__last), and puts the result in [__first,__last).  The
   *  output will be sorted.  The sort is @e stable, that is, for
   *  equivalent elements in the two ranges, elements from the first
   *  range will always come before elements from the second.
   *
   *  If enough additional memory is available, this takes (__last-__first)-1
   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
   *  distance(__first,__last).
  *//// This is a helper function for the merge routines./// This is a helper function for the __merge_adaptive routines./**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Determines whether an element exists in a range.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return True if @p __val (or its equivalent) is in [@p
   *  __first,@p __last ].
   *
   *  Note that this does not actually return an iterator to @p __val.  For
   *  that, use std::find or a container's specialized find member functions.
  *//**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
   *                   upper_bound(__first, __last, __val, __comp))
   *  @endcode
   *  but does not actually call those functions.
  *//**
   *  @brief Finds the largest subrange in which @p __val could be inserted
   *         at any place in it without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An pair of iterators defining the subrange.
   *  @ingroup binary_search_algorithms
   *
   *  This is equivalent to
   *  @code
   *    std::make_pair(lower_bound(__first, __last, __val),
   *                   upper_bound(__first, __last, __val))
   *  @endcode
   *  but does not actually call those functions.
  *//**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  *//**
   *  @brief Finds the last position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @return  An iterator pointing to the first element greater than @p __val,
   *           or end() if no elements are greater than @p __val.
   *  @ingroup binary_search_algorithms
  *//**
   *  @brief Finds the first position in which @p __val could be inserted
   *         without changing the ordering.
   *  @ingroup binary_search_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __val     The search term.
   *  @param  __comp    A functor to use for comparisons.
   *  @return An iterator pointing to the first element <em>not less
   *           than</em> @p __val, or end() if every element is less
   *           than @p __val.
   *  @ingroup binary_search_algorithms
   *
   *  The comparison function should have the same effects on ordering as
   *  the function used for the initial sort.
  */// lower_bound moved to stl_algobase.h// Place the nth largest element in its final position.// sort/// This is a helper function for the sort routine./// This is a helper function.../**
   *  @doctodo
   *  This controls some aspect of the sort routines.
  *//**
   *  @brief Copy the smallest elements of a sequence using a predicate for
   *         comparison.
   *  @ingroup sorting_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    Another input iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @param  __comp    A comparison functor.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  @p __comp(*j,*i) is false.
   *  The value returned is @p __result_first+N.
  *//**
   *  @brief Copy the smallest elements of a sequence.
   *  @ingroup sorting_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __result_first   A random-access iterator.
   *  @param  __result_last    Another random-access iterator.
   *  @return   An iterator indicating the end of the resulting sequence.
   *
   *  Copies and sorts the smallest N values from the range @p [__first,__last)
   *  to the range beginning at @p __result_first, where the number of
   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
   *  @p (__result_last-__result_first).
   *  After the sort if @e i and @e j are iterators in the range
   *  @p [__result_first,__result_first+N) such that i precedes j then
   *  *j<*i is false.
   *  The value returned is @p __result_first+N.
  */// partial_sort/// This is a helper function for the sort routines./**
   *  @brief Move elements for which a predicate is true to the beginning
   *         of a sequence, preserving relative ordering.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __pred    A predicate functor.
   *  @return  An iterator @p middle such that @p __pred(i) is true for each
   *  iterator @p i in the range @p [first,middle) and false for each @p i
   *  in the range @p [middle,last).
   *
   *  Performs the same function as @p partition() with the additional
   *  guarantee that the relative ordering of elements in each group is
   *  preserved, so any two elements @p x and @p y in the range
   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
   *  relative ordering after calling @p stable_partition().
  */// function's preconditions.// Advance past true-predicate values to satisfy this// This ensures that we only call __pred once per element.// move that element to the buffer before starting the loop.// The precondition guarantees that !__pred(__first), so/// move-assign an element onto itself./// !__pred(__first) allows us to guarantee that we don't////// and __len == distance(__first, __last)./// Requires __first != __last and !__pred(__first)// partition/**
   *  @brief Copy a sequence, rotating its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @param  __result  An output iterator.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements of the range @p [__first,__last) to the
   *  range beginning at @result, rotating the copied elements by 
   *  @p (__middle-__first) positions so that the element at @p __middle
   *  is moved to @p __result, the element at @p __middle+1 is moved
   *  to @p __result+1 and so on for each element in the range @p
   *  [__first,__last).
   *
   *  Performs 
   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */// namespace _V2/**
   *  @brief Rotate the elements of a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first   A forward iterator.
   *  @param  __middle  A forward iterator.
   *  @param  __last    A forward iterator.
   *  @return  first + (last - middle).
   *
   *  Rotates the elements of the range @p [__first,__last) by 
   *  @p (__middle - __first) positions so that the element at @p __middle
   *  is moved to @p __first, the element at @p __middle+1 is moved to
   *  @p __first+1 and so on for each element in the range
   *  @p [__first,__last).
   *
   *  This effectively swaps the ranges @p [__first,__middle) and
   *  @p [__middle,__last).
   *
   *  Performs
   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
   *  for each @p n in the range @p [0,__last-__first).
  */// DR 488. rotate throws away useful information/// This is a helper function for the rotate algorithm./**
   *  This is a helper function for the rotate algorithm specialized on RAIs.
   *  It returns the greatest common divisor of two integer values.
  *//**
   *  @brief Copy a sequence, reversing its elements.
   *  @ingroup mutating_algorithms
   *  @param  __first   A bidirectional iterator.
   *  @param  __last    A bidirectional iterator.
   *  @param  __result  An output iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Copies the elements in the range @p [__first,__last) to the
   *  range @p [__result,__result+(__last-__first)) such that the
   *  order of the elements is reversed.  For every @c i such that @p
   *  0<=i<=(__last-__first), @p reverse_copy() performs the
   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
   *  The ranges @p [__first,__last) and @p
   *  [__result,__result+(__last-__first)) must not overlap.
  *//**
   *  @brief Reverse a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A bidirectional iterator.
   *  @param  __last   A bidirectional iterator.
   *  @return   reverse() returns no value.
   *
   *  Reverses the order of the elements in the range @p [__first,__last),
   *  so that the first element becomes the last etc.
   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
   *  swaps @p *(__first+i) and @p *(__last-(i+1))
  *//**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for random access iterators.
  *//**
   *  This is an uglified reverse(_BidirectionalIterator,
   *                              _BidirectionalIterator)
   *  overloaded for bidirectional iterators.
  */// concept requirements -- iterators already checked/**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and forward iterator as result.
  *//**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for input iterators and output iterator as result.
  *//**
   *  This is an uglified
   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
   *              _BinaryPredicate)
   *  overloaded for forward iterators and output iterator as result.
  *//**
   *  @brief Remove consecutive values from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first        A forward iterator.
   *  @param  __last         A forward iterator.
   *  @param  __binary_pred  A binary predicate.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values for which @p __binary_pred returns true.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  *//**
   *  @brief Remove consecutive duplicate values from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @return  An iterator designating the end of the resulting sequence.
   *
   *  Removes all but the first element from each group of consecutive
   *  values that compare equal.
   *  unique() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  */// Do the real copy work.// Skip the beginning, if already unique./**
   *  @brief Remove elements from a sequence using a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first  A forward iterator.
   *  @param  __last   A forward iterator.
   *  @param  __pred   A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements for which @p __pred returns true are removed from the range
   *  @p [__first,__last).
   *
   *  remove_if() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  *//**
   *  @brief Remove elements from a sequence.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __value  The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  All elements equal to @p __value are removed from the range
   *  @p [__first,__last).
   *
   *  remove() is stable, so the relative order of elements that are
   *  not removed is unchanged.
   *
   *  Elements between the end of the resulting sequence and @p __last
   *  are still present, but their value is unspecified.
  *//**
   *  @brief Copy the elements of a sequence to separate output sequences
   *         depending on the truth value of a predicate.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __out_true   An output iterator.
   *  @param  __out_false  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   A pair designating the ends of the resulting sequences.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p out_true
   *  and each element for which @p __pred returns false to @p __out_false.
  *//**
   *  @brief Copies the range [first,first+n) into [result,result+n).
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __n      The number of elements to copy.
   *  @param  __result An output iterator.
   *  @return  result+n.
   *
   *  This inline function will boil down to a call to @c memmove whenever
   *  possible.  Failing that, if random access iterators are passed, then the
   *  loop count will be known (and therefore a candidate for compiler
   *  optimizations such as unrolling).
  *//**
   *  @brief Copy the elements of a sequence for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns true to the range beginning at @p __result.
   *
   *  copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  *//**
   *  @brief Copy a sequence, removing elements for which a predicate is true.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __pred    A predicate.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) for which
   *  @p __pred returns false to the range beginning at @p __result.
   *
   *  remove_copy_if() is stable, so the relative order of elements that are
   *  copied is unchanged.
  *//**
   *  @brief Copy a sequence, removing elements of a given value.
   *  @ingroup mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __result  An output iterator.
   *  @param  __value   The value to be removed.
   *  @return   An iterator designating the end of the resulting sequence.
   *
   *  Copies each element in the range @p [__first,__last) not equal
   *  to @p __value to the range beginning at @p __result.
   *  remove_copy() is stable, so the relative order of elements that
   *  are copied is unchanged.
  */// A specific debug-mode test will be necessary.../**
   *  @brief  Find the partition point of a partitioned range.
   *  @ingroup mutating_algorithms
   *  @param  __first   An iterator.
   *  @param  __last    Another iterator.
   *  @param  __pred    A predicate.
   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
   *           and @p none_of(mid, __last, __pred) are both true.
  *//**
   *  @brief  Checks whether the sequence is partitioned.
   *  @ingroup mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
   *  i.e. if all elements that satisfy @p __pred appear before those that
   *  do not.
  *//**
   *  @brief  Find the first element in a sequence for which a
   *          predicate is false.
   *  @ingroup non_mutating_algorithms
   *  @param  __first  An input iterator.
   *  @param  __last   An input iterator.
   *  @param  __pred   A predicate.
   *  @return   The first iterator @c i in the range @p [__first,__last)
   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
  *//**
   *  @brief  Checks that a predicate is true for at least one element
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if an element exists in the range @p
   *  [__first,__last) such that @p __pred is true, and false
   *  otherwise.
  *//**
   *  @brief  Checks that a predicate is false for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is false for each element in the range
   *  @p [__first,__last), and false otherwise.
  *//**
   *  @brief  Checks that a predicate is true for all the elements
   *          of a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first   An input iterator.
   *  @param  __last    An input iterator.
   *  @param  __pred    A predicate.
   *  @return  True if the check is true, false otherwise.
   *
   *  Returns true if @p __pred is true for each element in the range
   *  @p [__first,__last), and false otherwise.
  *//**
   *  @brief  Find last matching subsequence in a sequence using a predicate.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @param  __comp    The predicate to use.
   *  @return The last iterator @c i in the range @p
   *  [__first1,__last1-(__last2-__first2)) such that @c
   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
   *  exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) using comp as a predicate and returns an
   *  iterator to the first element of the sub-sequence, or @p __last1
   *  if the sub-sequence is not found.  The sub-sequence will be the
   *  last such subsequence contained in [__first,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  *//**
   *  @brief  Find last matching subsequence in a sequence.
   *  @ingroup non_mutating_algorithms
   *  @param  __first1  Start of range to search.
   *  @param  __last1   End of range to search.
   *  @param  __first2  Start of sequence to match.
   *  @param  __last2   End of sequence to match.
   *  @return   The last iterator @c i in the range
   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
   *  @p *(__first2+N) for each @c N in the range @p
   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
   *
   *  Searches the range @p [__first1,__last1) for a sub-sequence that
   *  compares equal value-by-value with the sequence given by @p
   *  [__first2,__last2) and returns an iterator to the __first
   *  element of the sub-sequence, or @p __last1 if the sub-sequence
   *  is not found.  The sub-sequence will be the last such
   *  subsequence contained in [__first1,__last1).
   *
   *  Because the sub-sequence must lie completely within the range @p
   *  [__first1,__last1) it must start at a position less than @p
   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
   *  length of the sub-sequence.  This means that the returned
   *  iterator @c i will be in the range @p
   *  [__first1,__last1-(__last2-__first2))
  */// find_end for bidirectional iterators (much faster).// find_end for forward iterators.// Failure// Success// next possible match.// __first here is always pointing to one past the last element of// the main loop.../**
   *  This is an helper function for search_n overloaded for random access
   *  iterators.
  *//**
   *  This is an helper function for search_n overloaded for forward iterators.
  */// search_n// General case.// Test for a pattern of length 1.// Test for empty ranges// search// count_if// count// adjacent_find// find_first_of// find_if// find// for_each/// iterator./// remaining range length instead of comparing against an end/// Like find_if_not(), but uses and updates a count of the/// Provided for stable_partition to use./// This is an overload used by find algos for the RAI case./// This is an overload used by find algos for the Input Iterator case./// Swaps the median value of *__a, *__b and *__c under __comp to *__result// See concept_check.h for the __glibcxx_*_requires macros.// for _Temporary_buffer// for rand/** @file bits/stl_algo.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{algorithm}
 *//*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */// Algorithm implementation -*- C++ -*-__chunk_size__step_size__comp_it_val__comp_val_it__depth_limit__pivot__out_true__out_false__unary_pred/usr/include/c++/9/bits/std_function.h<bits/refwrap.h><typeinfo>function<..(..)> &const function<..(..)>const function<..(..)> &function_Functor_Signature_ArgTypesconst _Functorconst _Functor *_Functor *targetconst type_infoconst type_info &type_info &target_typeconst function<..(..)> *function<..(..)> *const _Function_baseconst _Function_base *_Function_base *_Any_data &const _Any_dataconst _Any_data &..(*&)(..)_Manager_type &_Functor &&function<..(..)> &&_M_invoke_ArgTypes &&_M_manager_Simple_type_wrapperbad_function_call &const bad_function_callconst bad_function_call &bad_function_call~bad_function_call_Function_base &const _Function_base &_Function_base~_Function_base__destroy_functor_M_init_functor_M_not_empty_function_Classconst function<_Signature>const function<_Signature> &function<_Signature> &_M_clone_M_get_pointer_Any_data &&_M_accessconst _Any_data *_Any_data *sizeof(_Nocopy_types)_Nocopy_types &_Nocopy_types &&const _Nocopy_typesconst _Nocopy_types &_Never_valueless_alt<function<_Signature>>__function_guide_helper<..(*)(..)>__function_guide_helper<<unnamed>>function<..(..)>_Callable<function<..(..)>, _Tp>_Callable<_Func, _Res2>_Func_Res2_Invoker_type_Function_handler<..(..), _Member _Class::*>_Member_Function_handler<..(..), _Functor>_Function_handler<_Signature, _Functor>function<_Signature>__is_location_invariant<_Simple_type_wrapper<_Tp>>_Simple_type_wrapper<_Tp>_Undefined_class__is_location_invariant<_Tp>_Base_manager<_Functor>_Manager_type_Manager_operation__get_type_info__get_functor_ptr__clone_functor_Any_datamay_aliasgnu_Nocopy_types_M_invoker_M_functor_M_pod_data_M_unused_M_member_pointer_M_function_pointer_M_const_object_M_object_M_max_align__alignof__(_Nocopy_types)_M_max_size__stored_locally_GLIBCXX_STD_FUNCTION_H__cpp_rtti// _GLIBCXX_STD_FUNCTION_H// function into a variant.// 2062. Effect contradictions w/o no-throw guarantee of std::function swaps/**
   *  @brief Swap the targets of two polymorphic function object wrappers.
   *
   *  This function will not throw an %exception.
   */// [20.7.15.2.7] specialized algorithms/// @overload/**
   *  @brief Compares a polymorphic function object wrapper against 0
   *  (the NULL pointer).
   *  @returns @c false if the wrapper has no target, @c true otherwise
   *
   *  This function will not throw an %exception.
   *//**
   *  @brief Compares a polymorphic function object wrapper against 0
   *  (the NULL pointer).
   *  @returns @c true if the wrapper has no target, @c false otherwise
   *
   *  This function will not throw an %exception.
   */// [20.7.15.2.6] null pointer comparisons// Out-of-line member definitions./**
       *  @brief Access the stored target function object.
       *
       *  @return Returns a pointer to the stored target function object,
       *  if @c typeid(_Functor).equals(target_type()); otherwise, a NULL
       *  pointer.
       *
       * This function does not throw exceptions.
       *
       * @{
       *//**
       *  @brief Determine the type of the target of this function object
       *  wrapper.
       *
       *  @returns the type identifier of the target function object, or
       *  @c typeid(void) if @c !(bool)*this.
       *
       *  This function will not throw an %exception.
       */// [3.7.2.5] function target access/**
       *  @brief Invokes the function targeted by @c *this.
       *  @returns the result of the target.
       *  @throws bad_function_call when @c !(bool)*this
       *
       *  The function call operator invokes the target function object
       *  stored by @c this.
       */// [3.7.2.4] function invocation/**
       *  @brief Determine if the %function wrapper has a target.
       *
       *  @return @c true when this %function object contains a target,
       *  or @c false when it is empty.
       *
       *  This function will not throw an %exception.
       */// [3.7.2.3] function capacity/**
       *  @brief Swap the targets of two %function objects.
       *  @param __x A %function with identical call signature.
       *
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */// [3.7.2.2] function modifiers/**
       *  @brief %Function assignment to a new target.
       *  @param __f A %function object that is callable with parameters of
       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
       *  to @c Res.
       *  @return @c *this
       *
       *  This  %function object wrapper will target a copy of @a
       *  __f. If @a __f is @c reference_wrapper<F>, then this function
       *  object will contain a reference to the function object @c
       *  __f.get(). If @a __f is a NULL function pointer or NULL
       *  pointer-to-member, @c this object will be empty.
       *
       *  If @a __f is a non-NULL function pointer or an object of type @c
       *  reference_wrapper<F>, this function will not throw.
       *//**
       *  @brief %Function assignment to zero.
       *  @post @c !(bool)*this
       *  @returns @c *this
       *
       *  The target of @c *this is deallocated, leaving it empty.
       *//**
       *  @brief %Function move-assignment operator.
       *  @param __x A %function rvalue with identical call signature.
       *  @returns @c *this
       *
       *  The target of @a __x is moved to @c *this. If @a __x has no
       *  target, then @c *this will be empty.
       *
       *  If @a __x targets a function pointer or a reference to a function
       *  object, then this operation will not throw an %exception.
       *//**
       *  @brief %Function assignment operator.
       *  @param __x A %function with identical call signature.
       *  @post @c (bool)*this == (bool)x
       *  @returns @c *this
       *
       *  The target of @a __x is copied to @c *this. If @a __x has no
       *  target, then @c *this will be empty.
       *
       *  If @a __x targets a function pointer or a reference to a function
       *  object, then this operation will not throw an %exception.
       *//**
       *  @brief Builds a %function that targets a copy of the incoming
       *  function object.
       *  @param __f A %function object that is callable with parameters of
       *  type @c T1, @c T2, ..., @c TN and returns a value convertible
       *  to @c Res.
       *
       *  The newly-created %function object will target a copy of
       *  @a __f. If @a __f is @c reference_wrapper<F>, then this function
       *  object will contain a reference to the function object @c
       *  __f.get(). If @a __f is a NULL function pointer or NULL
       *  pointer-to-member, the newly-created object will be empty.
       *
       *  If @a __f is a non-NULL function pointer or an object of type @c
       *  reference_wrapper<F>, this function will not throw.
       *//**
       *  @brief %Function move constructor.
       *  @param __x A %function object rvalue with identical call signature.
       *
       *  The newly-created %function contains the target of @a __x
       *  (if it has one).
       *//**
       *  @brief %Function copy constructor.
       *  @param __x A %function object with identical call signature.
       *  @post @c bool(*this) == bool(__x)
       *
       *  The newly-created %function contains a copy of the target of @a
       *  __x (if it has one).
       *//**
       *  @brief Creates an empty function call wrapper.
       *  @post @c !(bool)*this
       *//**
       *  @brief Default construct creates an empty function call wrapper.
       *  @post @c !(bool)*this
       */// [3.7.2.1] construct/copy/destroy// performing overload resolution for copy construction/assignment.// Used so the return type convertibility checks aren't done when/**
   *  @brief Primary class template for std::function.
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */// Destroying an object located on the heap.// destruction.// Destroying a location-invariant object may still require// that cannot fit into an _Any_data structure.// Clone a function object that is not location-invariant or// an _Any_data structure.// Clone a location-invariant function object that fits within// have stored a pointer// Retrieve a pointer to the function object/// Base class of all polymorphic function object wrappers.// when casting between void pointers and pointers-to-pointers.// Simple type wrapper that helps avoid annoying const problems/**
   *  Trait identifying "location-invariant" types, meaning that the
   *  address of the object (or any of its members) will not escape.
   *  Trivially copyable types are location-invariant and users can
   *  specialize this trait for other types.
   *//**
   *  @brief Exception class thrown when class template function's
   *  operator() is called with an empty target.
   *  @ingroup exceptions
   *//** @file include/bits/std_function.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{functional}
 */// Copyright (C) 2004-2019 Free Software Foundation, Inc.// Implementation of std::function -*- C++ -*-__functor__dest__op__victim__mp__fp/usr/include/c++/9/bits/hashtable_policy.h<limits>const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache>const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> &_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache> &_Value_ExtractKey_H1_H2__cache__clp2const unsigned int__lzsizeof(size_t)sizeof(size_t) > sizeof(long)1ull1ulsize_t(1)numeric_limits<size_t>::digitsconst _Node_iterator_base<_Value, _Cache_hash_code>const _Node_iterator_base<_Value, _Cache_hash_code> &_Node_iterator_base<_Value, _Cache_hash_code> &_Cache_hash_code__distance_fw_M_equalconst __hashtableconst __hashtable &_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &_Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> &_Local_const_iteratorconst _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>const _Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> &_Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache> &const __hash_code_base__hash_code_baseconst __hash_code_base &__hash_code_base &_Hash_node<_Value, __cache> *_Local_iterator_M_get_bucket_M_curr_M_init_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> &_M_incr_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> &const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>const _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false> &_Local_iterator_base~_Local_iterator_base_Hash_node<_Value, false> *_M_h_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true> &_Hash_node<_Value, true> *_S_equals_Equalconst _Equalconst _Equal &_Equal &const _ExtractKeyconst _ExtractKey &_ExtractKey &_HashCodeType_H2 &_M_h2const _H2const _H2 &_H1 &_M_h1const _H1const _H1 &_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true> &_M_copy_code__node_type *const __node_typeconst __node_type *_M_store_code_M_bucket_index_M_hash_code_Hash_code_baseconst _Default_ranged_hashconst _Default_ranged_hash &_Default_ranged_hash &hash_functionconst _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false>const _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false> *_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false> *_S_cget_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false> &_M_v_Hash &_M_ranged_hashconst _Hashconst _Hash &_S_get_Hashtable_ebo_helper<_Nm, _Tp, false> &const _Hashtable_ebo_helper<_Nm, _Tp, false>const _Hashtable_ebo_helper<_Nm, _Tp, false> &_Hashtable_ebo_helper_OtherTp_OtherTp &&_Hashtable_ebo_helper<_Nm, _Tp, true> &const _Hashtable_ebo_helper<_Nm, _Tp, true>const _Hashtable_ebo_helper<_Nm, _Tp, true> &_Hashtable_ebo_helper<_Nm, _Tp, true> *max_load_factor_NodeGetterconst _NodeGetterconst _NodeGetter &_NodeGetter &__hashtable &_M_conjure_hashtablekey_type &_Power2_rehash_policy &_Power2_rehash_policy &&const _Power2_rehash_policyconst _Power2_rehash_policy &_Power2_rehash_policy_Power2_rehash_policy *_M_stateconst _Power2_rehash_policy *_M_need_rehash__min_bktsbool &&unsigned long &&bool &__builtin_floor1.0_S_growth_factorint &&int &pair<bool, int> &_M_bkt_for_elements__builtin_ceil_M_next_bkt__max_width(sizeof(size_t), 8);__max_bkt__bkt__bkt_count__iter__extract__to__ex__h1__h2__key__eboh__state__n_bkt__n_elt__n_ins__max_width * __CHAR_BIT____max_width * __CHAR_BIT__ - 1(__max_width * __CHAR_BIT__ - 1)9223372036854775808size_t(1) << (__max_width * __CHAR_BIT__ - 1)18446744073709551615std::size_t(-1)_Mask_range_hashing &_Mask_range_hashing &&const _Mask_range_hashingconst _Mask_range_hashing &const _Mask_range_hashing *_Mask_range_hashing *_Node_const_iterator<_Value, __constant_iterators, __cache> &_Node_const_iteratorconst _Node_iterator<_Value, __constant_iterators, __cache>const _Node_iterator<_Value, __constant_iterators, __cache> &_Node_iterator<_Value, __constant_iterators, __cache> &__node_type_Node_iterator_Node_iterator_base_Hash_node<_Value, _Cache_hash_code> *_M_nextconst _Hash_node<_Value, false>const _Hash_node<_Value, false> *_M_nxtconst _Valueconst _Value &_Value &const _Hash_node_value_base<_Value>const _Hash_node_value_base<_Value> *_Hash_node_value_base<_Value> *const _Value *_Value *_AllocNode__hashtable_alloc &_Hashtable_alloc<_NodeAlloc> &const _ReuseOrAllocNode<_NodeAlloc>const _ReuseOrAllocNode<_NodeAlloc> *_ReuseOrAllocNode<_NodeAlloc> *_M_node_allocator_M_deallocate_node_ptr_M_allocate_node~_ReuseOrAllocNode_M_deallocate_nodes_ReuseOrAllocNodeconst _ReuseOrAllocNode<_NodeAlloc> &_ReuseOrAllocNode<_NodeAlloc> &_M_deallocate_buckets__bucket_type *_Hash_node_base *_Hash_node_base **_Hashtable_alloc<_NodeAlloc> *__node_alloc_type &_NodeAlloc_NodeAlloc &_M_allocate_bucketssizeof(__bucket_type)_M_deallocate_node__nptrconst __node_alloc_typeconst __node_alloc_type &const _Hashtable_alloc<_NodeAlloc>const _Hashtable_alloc<_NodeAlloc> *_Hashtable_alloc_Hashtable_alloc<_NodeAlloc> &&const _Hashtable_alloc<_NodeAlloc> &_M_eq_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits> &_M_equals_Hashtable_base_Equality_base &_Equality_base &&const _Equality_baseconst _Equality_base &_S_is_permutation_Uiterator_Identity &_Identity &&const _Identityconst _Identity &_Default_ranged_hash &&_Mod_range_hashing &_Mod_range_hashing &&const _Mod_range_hashingconst _Mod_range_hashing &const _Mod_range_hashing *_Mod_range_hashing *_Select1st &_Select1st &&const _Select1stconst _Select1st &const _Select1st *_Select1st *_Prime_rehash_policy &_Prime_rehash_policy &&const _Prime_rehash_policyconst _Prime_rehash_policy &_Prime_rehash_policy_Prime_rehash_policy *const _Prime_rehash_policy *_Hash_node_base &_Hash_node_base &&const _Hash_node_baseconst _Hash_node_base &_Hash_node_base_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>_RehashPolicy_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, _Unique_keys>_Unique_keys_Local_const_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>__constant_iterators_Local_iterator<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __constant_iterators, __cache>_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>_Hash_code_storage<_Tp, true>_Hash_code_storage<_Tp, _IsEmpty>_IsEmpty_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>_Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>_Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>_Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, __cache_hash_code>__cache_hash_code_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, true>__hash_codehasher_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Default_ranged_hash, false>_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache_hash_code>_Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, __cache_hash_code>_Hashtable_ebo_helper<_Nm, _Tp, false>_Hashtable_ebo_helper<_Nm, _Tp, true>_Hashtable_ebo_helper<_Nm, _Tp, __use_ebo>__use_ebo_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true_type>_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false_type>_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, <unnamed>>__has_load_factor_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>_IFconsp__ireturn_type__hashtable__unique_keys_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>__node_gen_type_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, _Constant_iterators>_Constant_iterators_Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>__node_alloc_type__num__den__nodes__bkts_Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, true>_Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, false>_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits, _Unique_keys>_State_Mask_range_hashingsecond_argument_typefirst_argument_type_Node_const_iterator<_Value, __constant_iterators, __cache>_Node_iterator<_Value, __constant_iterators, __cache>_Node_iterator_base<_Value, _Cache_hash_code>_Hash_node<_Value, false>_Hash_node<_Value, true>_Hash_node<_Value, _Cache_hash_code>_Hash_node_value_base<_Value>_Hashtable_traits<_Cache_hash_code, _Constant_iterators, _Unique_keys>_AllocNode<_NodeAlloc>_ReuseOrAllocNode<_NodeAlloc>__node_alloc_traits_Hashtable_alloc<_NodeAlloc>__bucket_alloc_type_Hashtable_base<_Key, _Value, _ExtractKey, _Equal, _H1, _H2, _Hash, _Traits>__traits_typekey_equal_Equality_base_Identity__node_base *__bucket_type__node_base__hash_cached_Policy_Default_ranged_hash_Mod_range_hashing_Select1st_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>_M_bucket_count_M_bucket_M_cur_M_tp_M_next_resize_M_max_load_factormutableType must be empty_HASHTABLE_POLICY_H"_Map_base::at"// _HASHTABLE_POLICY_H// namespace __detail///@} hashtable-detail// functions.// Definitions of class template _Hashtable_alloc's out-of-line member// Deallocate the linked list of nodes pointed to by __n// Use __gnu_cxx to benefit from _S_always_equal and al./**
   * This type deals with all allocation and keeps an allocator instance through
   * inheritance to benefit from EBO when possible.
   *//// Specialization./**
   *  Primary class template  _Equality.
   *
   *  This is for implementing equality comparison for unordered
   *  containers, per N3068, by John Lakos and Pablo Halpern.
   *  Algorithmically, we follow closely the reference implementations
   *  therein.
   */// See std::is_permutation in N3068./**
   *  struct _Equality_base.
   *
   *  Common types and functions for class _Equality.
   *//**
   *  Primary class template _Hashtable_base.
   *
   *  Helper class adding management of _Equal functor to
   *  _Hash_code_base type.
   *
   *  Base class templates are:
   *    - __detail::_Hash_code_base
   *    - __detail::_Hashtable_ebo_helper
   *//// local const_iterators/// local iterators// for debug mode// for equality ops and debug mode// Partial specialization used when hash codes are not cached// the cast pointer, so no strict-aliasing violation.// As _Tp is an empty type there will be no bytes written/read through// Empty partial specialization for empty _Hash_code_base types.// can be DefaultConstructible and Assignable.// _Hash_code_base type isn't, so that _Local_iterator_base<..., false>// This type is DefaultConstructible and Assignable even if the// Uninitialized storage for a _Hash_code_base.// for equality ops/// Partial specialization used when nodes contain a cached hash code./**
   *  Primary class template _Equal_helper.
   *
   */// We need the default constructor for _Hashtable default constructor.// Gives the local iterator implementation access to _M_h2()./// typedef and accessor required by C++ 11./// caching hash codes.  H is provided but ignored.  Provides/// Specialization: hash function and range-hashing function,// default constructor.// We need the default constructor for the local iterators and _Hashtable// Gives the local iterator implementation access to _M_bucket_index()./// Provides typedef and accessor required by C++ 11./// caching of hash codes./// Specialization: hash function and range-hashing function, no/// and no definition./// combination is meaningless, so we provide only a declaration/// Specialization: ranged hash function, cache hash codes.  This// That combination is meaningless, and trying to do it is an error.// No specialization for ranged hash function while caching hash codes./// and H2 are provided but ignored.  We define a dummy hash code type./// Specialization: ranged hash function, no caching hash codes.  H1/**
   *  Primary class template _Hash_code_base.
   *
   *  Encapsulates two policy issues that aren't quite orthogonal.
   *   (1) the difference between using a ranged hash function and using
   *       the combination of a hash function and a range-hashing function.
   *       In the former case we don't have such things as hash codes, so
   *       we have a dummy type as placeholder.
   *   (2) Whether or not we cache hash codes.  Caching hash codes is
   *       meaningless if we have a ranged hash function.
   *
   *  We also put the key extraction objects here, for convenience.
   *  Each specialization derives from one or more of the template
   *  parameters to benefit from Ebo. This is important as this type
   *  is inherited in some cases by the _Local_iterator_base type used
   *  to implement local_iterator and const_local_iterator. As with
   *  any iterator type we prefer to make it as small as possible.
   *
   *  Primary template is unused except as a hook for specializations.
   *//**
   *  Primary class template _Local_iterator_base.
   *
   *  Base class for local iterators, used to iterate within a bucket
   *  but not between buckets.
   *//// Specialization not using EBO./// Specialization using EBO./**
   *  Primary class template _Hashtable_ebo_helper.
   *
   *  Helper class using EBO when it is not forbidden (the type is not
   *  final) and when it is worth it (the type is empty.)
   *//// Specialization when rehash policy provide load factor management./// Specialization when rehash policy doesn't provide load factor management./**
   *  Primary class template  _Rehash_base.
   *
   *  Give hashtable the max_load_factor functions and reserve iff the
   *  rehash policy supports it.
  *//**
   *  Primary class template _Insert.
   *
   *  Defines @c insert member functions that depend on _Hashtable policies,
   *  via partial specializations.
   *//**
   *  Primary class template _Insert_base.
   *
   *  Defines @c insert member functions appropriate to all _Hashtables.
   */// DR 761. unordered_map needs an at() member function./// Partial specialization, __unique_keys set to true./// Partial specialization, __unique_keys set to false./**
   *  Primary class template _Map_base.
   *
   *  If the hashtable has a value type of the form pair<T1, T2> and a
   *  key extraction policy (_ExtractKey) that returns the first part
   *  of the pair, the hashtable gets a mapped_type typedef.  If it
   *  satisfies those criteria and also has unique keys, then it also
   *  gets an operator[].
   */// Recurring Template Pattern" (CRTP) technique.// template _Hashtable, so we use a variant of the "Curiously// the base class templates need to access other members of class// we handle that by specializing base class templates.  Several of// affects which member functions and nested typedefs are defined;// the value of a policy class.  In some cases the policy class// because in some cases we want to do different things depending on// Base classes for std::_Hashtable.  We define these base classes// is the new bucket count.  If not, return make_pair(false, 0).// increase bucket count?  If so, return make_pair(true, n), where n// and __n_ins is number of elements to be inserted.  Do we need to// __n_bkt is current bucket count, __n_elt is current element count,// Return a bucket count appropriate for n elements// Note that it might result in max_load_factor not being respected.// as we already reach the biggest possible bucket number.// Set next resize to the max value so that we never try to rehash again// highest power of 2).// Return a bucket size no smaller than n (as long as n is not above the/// operations./// Rehash policy providing power of 2 bucket numbers. Avoids modulo// Doing two shifts avoids undefined behaviour when __lz == 0.// Equivalent to return __n ? std::ceil2(__n) : 0;/// Compute closest power of 2 not less than __n/// Range hashing function assuming that second arg is a power of 2.// Return a bucket size no smaller than n./// smallest prime that keeps the load factor small enough./// Default value for rehash policy.  Bucket size is (usually) the/// hashtable to do that composition./// h1 and h2.  So instead we'll just use a tag to tell class template/// h(k, N) = h2(h1(k), N), but that would mean making extra copies of/// function object composed from objects of type H1 and H2 such that/// Default ranged hash function H.  In principle it should be a/// into the range [0, N)./// Default range hashing function: use division to fold a large number// classes.  These are defaults for the policies.// Many of class template _Hashtable's template parameters are policy/// Node const_iterators, used to iterate through all the hashtable./// Node iterators, used to iterate through all the hashtable./// Base class for node iterators./**
   *  Specialization for nodes without caches, struct _Hash_node.
   *
   *  Base class is __detail::_Hash_node_value_base.
   *//**
   *  Specialization for nodes with caches, struct _Hash_node.
   *
   *  Base class is __detail::_Hash_node_value_base.
   *//**
   *  Primary template struct _Hash_node.
   *//**
   *  struct _Hash_node_value_base
   *
   *  Node type with the value to store.
   *//**
   *  struct _Hash_node_base
   *
   *  Nodes, used to wrap elements stored in the hash table.  A policy
   *  template parameter of class template _Hashtable controls whether
   *  nodes also store a hash code. In some cases (e.g. strings) this
   *  may be a performance win.
   *//**
   *  struct _Hashtable_traits
   *
   *  Important traits for hash tables.
   *
   *  @tparam _Cache_hash_code  Boolean value. True if the value of
   *  the hash function is stored along with the value. This is a
   *  time-space tradeoff.  Storing it may improve lookup speed by
   *  reducing the number of times we need to call the _Equal
   *  function.
   *
   *  @tparam _Constant_iterators  Boolean value. True if iterator and
   *  const_iterator are both constant iterator types. This is true
   *  for unordered_set and unordered_multiset, false for
   *  unordered_map and unordered_multimap.
   *
   *  @tparam _Unique_keys  Boolean value. True if the return value
   *  of _Hashtable::count(k) is always at most one, false if it may
   *  be an arbitrary number. This is true for unordered_set and
   *  unordered_map, false for unordered_multiset and
   *  unordered_multimap.
   */// and iterators.// Auxiliary types used for all instantiations of _Hashtable nodes// empty.// Functor recycling a pool of nodes and using allocation once the pool is// iterators, or 0/1 for input iterators.// Helper function: return distance(first, last) for forward/**
   *  @defgroup hashtable-detail Base and Implementation Classes
   *  @ingroup unordered_associative_containers
   *  @{
   */// for std::min.// for std::numeric_limits// for std::tuple, std::forward_as_tuple/** @file bits/hashtable_policy.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly.
 *  @headername{unordered_map,unordered_set}
 */// Internal policy header for unordered_set and unordered_map -*- C++ -*-/usr/include/c++/9/bits/hashtable.h<bits/hashtable_policy.h>lambda [] type at line 80156, col. 9(unnamed constructor)lambda [] type at line 80156, col. 9 &const lambda [] type at line 80156, col. 9const lambda [] type at line 80156, col. 9 &_Hash_node<_Value, value> *const lambda [] type at line 80156, col. 9 *lambda [] type at line 80156, col. 9 *_NodeGeneratorconst _NodeGeneratorconst _NodeGenerator &_NodeGenerator &__reuse_or_alloc_node_type &_ReuseOrAllocNode<type> &lambda [] type at line 80102, col. 8lambda [] type at line 80102, col. 8 &const lambda [] type at line 80102, col. 8const lambda [] type at line 80102, col. 8 &const lambda [] type at line 80102, col. 8 *lambda [] type at line 80102, col. 8 *_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> *_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> *constlambda [] type at line 80119, col. 2lambda [] type at line 80119, col. 2 &const lambda [] type at line 80119, col. 2const lambda [] type at line 80119, col. 2 &const __reuse_or_alloc_node_typeconst __reuse_or_alloc_node_type &const lambda [] type at line 80119, col. 2 *lambda [] type at line 80119, col. 2 *lambda [] type at line 80314, col. 3lambda [] type at line 80314, col. 3 &const lambda [] type at line 80314, col. 3const lambda [] type at line 80314, col. 3 &const lambda [] type at line 80314, col. 3 *lambda [] type at line 80314, col. 3 *_M_rehashconst __rehash_stateconst __rehash_state &_State &_M_rehash_aux_M_merge_multi_Compatible_Hashtable_Compatible_Hashtable &_M_reinsert_node_multi_Node_handle<_Key, _Value, type> &&_M_reinsert_noderehash_M_insert_M_emplace_M_insert_multi_node_M_insert_unique_node_M_get_previous_node_M_remove_bucket_begin_M_insert_bucket_begin_M_find_node_M_find_before_nodeconst _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits>const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> *__rehash_policyconst _RehashPolicyconst _RehashPolicy &_RehashPolicy &load_factorbucketbucket_sizemax_bucket_countbucket_countkey_eq~_Hashtable_Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &&const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash, _RehashPolicy, _Traits> &__this_alloc__that_alloc_Hashtableconst key_equalconst key_equal &__node_alloc_type &&_No_realloc__buckets__ht_n__this_n__prev_n__former_buckets__former_bucket_count__former_state_Ht_Ht &&__roan_M_element_count_M_rehash_policy__code__next_bkt__pol__ht__hf__eql__bucket_hint__exk_M_assign_elements_M_bucket_begin__builtin_expect_Hashtable_alloc<type> &_M_base_alloc_M_uses_single_bucket_RequireNotAllocatorOrIntegral_Hash_merge_helper<<unnamed>, <unnamed>, <unnamed>>const_local_iteratorlocal_iterator__hash_code_base_access__key_extract__rehash_state__rehash_type__value_alloc_traits_Keya_Valuea_Alloca_ExtractKeya_Equala_H1a_H2a_Hasha_RehashPolicya_Traitsa(captured this)_M_single_bucket_M_before_begin_M_bucketsFunctor used to map hash code to bucket index must be default constructibleCache the hash code or qualify your functors involved in hash code and bucket index computation with noexceptunordered container must have the same value_type as its allocatorunordered container must have a non-const, non-volatile value_type_HASHTABLE_H__cplusplus <= 201402Lget_allocator() == __src.get_allocator()get_allocator() == __nh.get_allocator()// _HASHTABLE_H// Used to constrain deduction guides// insertions into __prev_bkt bucket.// Check if we shall update the next bucket because of// equivalent nodes to limit the number of checks.// schedule a check as soon as we move out of the sequence of// bucket containing its before begin node must be updated. We// haven't change the bucket last node, in this case next// Inserting after a node in a bucket require to check that we// relative order.// the previously inserted one to preserve equivalent elements// Previous insert was already in this bucket, we insert after// order.// Rehash when there can be equivalent elements, preserve their relative// Rehash when there is no equivalent elements.// have to restore hash policy previous state.// A failure here means that buckets allocation failed.  We only// No rehash, restore previous state to keep a consistent state.// Deallocate nodes.// invalidated indirectly when destroying nodes.// them so that the key stays valid during the first loop. It might be// We use one loop to find all matching nodes and another to deallocate// in parameters?// 526. Is it undefined if a function in the standard changes// Look for the node before the first matching node.// We found a matching node, erase it.// this search fast.// is why we need buckets to contain the before begin to make// Look for previous node to unlink it from the erased one, this// Second allocate new node so that we don't rehash if it throws.// throws.// First compute the hash code so that we don't do anything if it// Insert v unconditionally.// Insert v if no element with its key is already present.// elements' relative positions.// beginning of the bucket to preserve equivalent// hashtable. We must insert the new node at the// The inserted node has no equivalent in the// update next bucket.// hint might be the last bucket node, in this case we need to// Insert after the node before the equivalent one.// if it is equivalent.// Find the node before an equivalent one or use hint if it exists and// already present). Take ownership of the node, deallocate it on exception.// Insert node, in bucket bkt if no rehash (assumes no element with its key// Always insert at the beginning of the bucket.// First build the node to get its hash code.// Insert the node// There is already an equivalent node, no insertion// First build the node to get access to the hash code// Second update before begin node if necessary// First update next bucket if any// Bucket is now empty// _M_before_begin.// We must update former begin bucket that is pointing to// contain _M_before_begin pointer.// beginning of the singly-linked list and the bucket will// The bucket is empty, the new node is inserted at the// after the bucket before begin.// Bucket is not empty, we just need to insert the new node// Return nullptr if no node is found.// Find the node whose key compares equal to k in the bucket n.// means that we won't find any new equivalent value.// found a non-equivalent value after an equivalent one it// All equivalent values are next to each other, if we// swapped.// Fix buckets containing the _M_before_begin pointers that can't be// Deal properly with potentially moved instances.// specializations have different members.// We define _Hash_code_base::_M_swap because different// The only base class with member variables is hash_code_base.// moved.// Update, if necessary, bucket pointing to before begin that hasn't/* alloc always equal */// Update buckets if __ht is using its single bucket.// Can't move memory, move elements then.// Then deal with other nodes.// First deal with the special first node pointed to by// Restore previous buckets.// Reuse allocated buckets and nodes.// must make sure this instance remains in a usable state.// _M_assign took care of deallocating all memory. Now we// Replacement allocator cannot free existing storage.// Definitions of class template _Hashtable's out-of-line member functions.// hash policy state to __state on exception.// Unconditionally change size of bucket array to n, restore// Helper rehash method used when keys can be non-unique.// Helper rehash method used when keys are unique.// FIXME: this deallocates the node on exception./// Re-insert an extracted node into a container with equivalent keys./// Re-insert an extracted node into a container with unique keys.// reserve, if present, comes from _Rehash_base.// DR 1189.// Set number of buckets to be appropriate for container of n element.// Erase// Insert member functions via inheritance.// Emplace// Insert with hint when keys are not unique.// Insert with hint, not used when keys are unique.// Emplace with hint, useless when keys are unique.// deallocate it on exception.// Insert node with hash code __code. Take ownership of the node,// no element with its key already present). Take ownership of the node,// Insert node with hash code __code, in bucket bkt if no rehash (assumes// Get the node before __n in the bucket __bkt// Remove the bucket first node// Insert a node at the beginning of a bucket.// Find the node before the one matching the criteria.// Find and insert helper functions and types// Bucket index computation helpers.// Lookup.// the default.// TR1.  Only useful if _RehashPolicy is something other than// Generalization of max_load_factor.  Extension, not found in// max_load_factor, if present, comes from _Rehash_base.// DR 691.// Bucket operations// hash_function, if present, comes from _Hash_code_base.// Observers// Basic container operations// Use delegating constructors.// Constructor, destructor, assignment, swap// are copy or move depends on the _NodeGenerator.// Assign *this using another _Hashtable instance. Either elements// their before begin node.// Gets bucket begin, deals with the fact that non-empty buckets contain// numerous checks in the code to avoid 0 modulus.// Note that we can't leave hashtable with 0 bucket without adding// qualified.// which is not allocated so that we can have those operations noexcept// interesting in move semantic to leave hashtable with only 1 buckets// A single bucket used when only need for 1 bucket. Especially// which must then be default constructible.// When hash codes are cached local iterator inherits from H2 functor// that local_iterator will be default constructible.// Following two static assertions are necessary to guarantee// in methods (erase, swap...) that shall not throw.// Getting a bucket index from a node shall not throw because it is used// access it.// _Hash_code_base has everything protected, so use this derived type to// Compile-time diagnostics.// Metaprogramming for picking apart hash caching.// hasher, if present, comes from _Hash_code_base/_Hashtable_base.// mapped_type, if present, comes from _Map_base./**
   *  Primary class template _Hashtable.
   *
   *  @ingroup hashtable-detail
   *
   *  @tparam _Value  CopyConstructible type.
   *
   *  @tparam _Key    CopyConstructible type.
   *
   *  @tparam _Alloc  An allocator type
   *  ([lib.allocator.requirements]) whose _Alloc::value_type is
   *  _Value.  As a conforming extension, we allow for
   *  _Alloc::value_type != _Value.
   *
   *  @tparam _ExtractKey  Function object that takes an object of type
   *  _Value and returns a value of type _Key.
   *
   *  @tparam _Equal  Function object that takes two objects of type k
   *  and returns a bool-like value that is true if the two objects
   *  are considered equal.
   *
   *  @tparam _H1  The hash function. A unary function object with
   *  argument type _Key and result type size_t. Return values should
   *  be distributed over the entire range [0, numeric_limits<size_t>:::max()].
   *
   *  @tparam _H2  The range-hashing function (in the terminology of
   *  Tavori and Dreizin).  A binary function object whose argument
   *  types and result type are all size_t.  Given arguments r and N,
   *  the return value is in the range [0, N).
   *
   *  @tparam _Hash  The ranged hash function (Tavori and Dreizin). A
   *  binary function whose argument types are _Key and size_t and
   *  whose result type is size_t.  Given arguments k and N, the
   *  return value is in the range [0, N).  Default: hash(k, N) =
   *  h2(h1(k), N).  If _Hash is anything other than the default, _H1
   *  and _H2 are ignored.
   *
   *  @tparam _RehashPolicy  Policy class with three members, all of
   *  which govern the bucket count. _M_next_bkt(n) returns a bucket
   *  count no smaller than n.  _M_bkt_for_elements(n) returns a
   *  bucket count appropriate for an element count of n.
   *  _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if the
   *  current bucket count is n_bkt and the current element count is
   *  n_elt, we need to increase the bucket count.  If so, returns
   *  make_pair(true, n), where n is the new bucket count.  If not,
   *  returns make_pair(false, <anything>)
   *
   *  @tparam _Traits  Compile-time class with three boolean
   *  std::integral_constant members:  __cache_hash_code, __constant_iterators,
   *   __unique_keys.
   *
   *  Each _Hashtable data structure has:
   *
   *  - _Bucket[]       _M_buckets
   *  - _Hash_node_base _M_before_begin
   *  - size_type       _M_bucket_count
   *  - size_type       _M_element_count
   *
   *  with _Bucket being _Hash_node* and _Hash_node containing:
   *
   *  - _Hash_node*   _M_next
   *  - Tp            _M_value
   *  - size_t        _M_hash_code if cache_hash_code is true
   *
   *  In terms of Standard containers the hashtable is like the aggregation of:
   *
   *  - std::forward_list<_Node> containing the elements
   *  - std::vector<std::forward_list<_Node>::iterator> representing the buckets
   *
   *  The non-empty buckets contain the node before the first node in the
   *  bucket. This design makes it possible to implement something like a
   *  std::forward_list::insert_after on container insertion and
   *  std::forward_list::erase_after on container erase
   *  calls. _M_before_begin is equivalent to
   *  std::forward_list::before_begin. Empty buckets contain
   *  nullptr.  Note that one of the non-empty buckets contains
   *  &_M_before_begin which is not a dereferenceable node so the
   *  node pointer in a bucket shall never be dereferenced, only its
   *  next node can be.
   *
   *  Walking through a bucket's nodes requires a check on the hash code to
   *  see if each node is still in the bucket. Such a design assumes a
   *  quite efficient hash functor and is one of the reasons it is
   *  highly advisable to set __cache_hash_code to true.
   *
   *  The container iterators are simply built from nodes. This way
   *  incrementing the iterator is perfectly efficient independent of
   *  how many empty buckets there are in the container.
   *
   *  On insert we compute the element's hash code and use it to find the
   *  bucket index. If the element must be inserted in an empty bucket
   *  we add it at the beginning of the singly linked list and make the
   *  bucket point to _M_before_begin. The bucket that used to point to
   *  _M_before_begin, if any, is updated to point to its new before
   *  begin node.
   *
   *  On erase, the simple iterator design requires using the hash
   *  functor to get the index of the bucket to update. For this
   *  reason, when __cache_hash_code is set to false the hash functor must
   *  not throw and this is enforced by a static assertion.
   *
   *  Functionality is implemented by decomposition into base classes,
   *  where the derived _Hashtable class is used in _Map_base,
   *  _Insert, _Rehash_base, and _Equality base classes to access the
   *  "this" pointer. _Hashtable_base is used in the base classes as a
   *  non-recursive, fully-completed-type so that detailed nested type
   *  information, such as iterator type and node type, can be
   *  used. This is similar to the "Curiously Recurring Template
   *  Pattern" (CRTP) technique, but uses a reconstructed, not
   *  explicitly passed, template pattern.
   *
   *  Base class templates are: 
   *    - __detail::_Hashtable_base
   *    - __detail::_Map_base
   *    - __detail::_Insert
   *    - __detail::_Rehash_base
   *    - __detail::_Equality
   */// Mandatory to have erase not throwing.// Do not cache for fast hasher./** @file bits/hashtable.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{unordered_map, unordered_set}
 */// hashtable.h header -*- C++ -*-__uk__next_n/usr/include/c++/9/ostream<bits/ostream.tcc><bits/ostream_insert.h><ios>_Ostream_Ostream &&basic_ostream<_Ch, _Up> &__is_convertible_to_basic_ostream_testbasic_ostream<_Ch, _Up> *_Chflushendsendlbasic_ostream<char, _Traits> &const unsigned charconst unsigned char *unsigned char *const signed charconst signed char *signed char *setstateconst iostatebasic_ostream<_CharT, _Traits> &&const basic_ostream<_CharT, _Traits>const basic_ostream<_CharT, _Traits> &basic_ostreambasic_iostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits> *init_M_writeconst char_typeconst char_type *__ostream_type &ios_base &__ios_type &basic_ios<_CharT, _Traits> &~basic_ostream__streambuf_type *basic_streambuf<_CharT, _Traits> *~sentrysentry__ostream_type__rvalue_ostream_type__is_insertable<_Ostream, _Tp, __void_t<decltype((<expression>))>>__is_insertable<_Ostream, _Tp, <unnamed>>__is_convertible_to_basic_ostream<_Tp>__is_convertible_to_basic_ostream_impl<_Tp, __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>__do_is_convertible_to_basic_ostream_impl__is_convertible_to_basic_ostream_impl<_Tp, <unnamed>>basic_ostream<_CharT, _Traits>off_typepos_typeint_type_ValueT_M_os_M_ok_GLIBCXX_OSTREAM_GLIBCXX_USE_LONG_LONGGCC diagnostic ignored "-Wdeprecated-declarations"seekptellpput/* _GLIBCXX_OSTREAM *//**
   *  @brief  Generic inserter for rvalue stream
   *  @param  __os  An input stream.
   *  @param  __x  A reference to the object being inserted.
   *  @return  os
   *
   *  This is just a forwarding function to allow insertion to
   *  rvalue streams since they won't bind to the inserter functions
   *  that take an lvalue reference.
  *//**
   *  @brief  Flushes the output stream.
   *
   *  This manipulator simply calls the stream's @c flush() member function.
  *//**
   *  @brief  Write a null character into the output sequence.
   *
   *  <em>Null character</em> is @c CharT() by definition.  For CharT
   *  of @c char, this correctly writes the ASCII @c NUL character
   *  string terminator.
  *//**
   *  @brief  Write a newline and flush the stream.
   *
   *  This manipulator is often mistakenly used when a simple newline is
   *  desired, leading to poor buffering performance.  See
   *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
   *  for more on this subject.
  */// Standard basic_ostream manipulators// Signed and unsigned// Partial specializations/**
   *  @brief  String inserters
   *  @param  __out  An output stream.
   *  @param  __s  A character string.
   *  @return  out
   *  @pre  @p __s must be a non-NULL pointer
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts @c traits::length(__s) characters starting
   *  at @p __s, widened if necessary, followed by any required padding (as
   *  determined by [22.2.2.2.2]).  @c __out.width(0) is then called.
  */// Specialization/**
   *  @brief  Character inserters
   *  @param  __out  An output stream.
   *  @param  __c  A character.
   *  @return  out
   *
   *  Behaves like one of the formatted arithmetic inserters described in
   *  std::basic_ostream.  After constructing a sentry object with good
   *  status, this function inserts a single character and any required
   *  padding (as determined by [22.2.2.2.2]).  @c __out.width(0) is then
   *  called.
   *
   *  If @p __c is of type @c char and the character type of the stream is not
   *  @c char, the character is widened before insertion.
  *//**
       *  @brief  Quick status checking.
       *  @return  The sentry state.
       *
       *  For ease of use, sentries may be converted to booleans.  The
       *  return value is that of the sentry state (true == okay).
      */// Can't call flush directly or else will get into recursive lock./**
       *  @brief  Possibly flushes the stream.
       *
       *  If @c ios_base::unitbuf is set in @c os.flags(), and
       *  @c std::uncaught_exception() is true, the sentry destructor calls
       *  @c flush() on the output stream.
      *//**
       *  @brief  The constructor performs preparatory work.
       *  @param  __os  The output stream to guard.
       *
       *  If the stream state is good (@a __os.good() is true), then if the
       *  stream is tied to another output stream, @c is.tie()->flush()
       *  is called to synchronize the output sequences.
       *
       *  If the stream state is still good, then the sentry state becomes
       *  true (@a okay).
      */// Data Members./**
   *  @brief  Performs setup work for output streams.
   *
   *  Objects of this class are created before all of the standard
   *  inserters are run.  It is responsible for <em>exception-safe prefix and
   *  suffix operations</em>.
  */// 27.7.3.3 Assign/swap// Non-standard constructor that does not call init()/**
       *  @brief  Changing the current write position.
       *  @param  __off  A file offset object.
       *  @param  __dir  The direction in which to seek.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
       *  If that function fails, sets failbit.
      *//**
       *  @brief  Changing the current write position.
       *  @param  __pos  A file position object.
       *  @return  *this
       *
       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If
       *  that function fails, sets failbit.
      *//**
       *  @brief  Getting the current write position.
       *  @return  A file position object.
       *
       *  If @c fail() is not false, returns @c pos_type(-1) to indicate
       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).
      *//**
       *  @brief  Synchronizing the stream buffer.
       *  @return  *this
       *
       *  If @c rdbuf() is a null pointer, changes nothing.
       *
       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,
       *  sets badbit.
      *//**
       *  @brief  Character string insertion.
       *  @param  __s  The array to insert.
       *  @param  __n  Maximum number of characters to insert.
       *  @return  *this
       *
       *  Characters are copied from @p __s and inserted into the stream until
       *  one of the following happens:
       *
       *  - @p __n characters are inserted
       *  - inserting into the output sequence fails (in this case, badbit
       *    will be set in the stream's error state)
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @brief  Core write functionality, without sentry.
       *  @param  __s  The array to insert.
       *  @param  __n  Maximum number of characters to insert.
      *//**
       *  @brief  Simple insertion.
       *  @param  __c  The character to insert.
       *  @return  *this
       *
       *  Tries to insert @p __c.
       *
       *  @note  This function is not overloaded on signed char and
       *         unsigned char.
      *//**
       *  @name Unformatted Output Functions
       *
       *  All the unformatted output functions have some common behavior.
       *  Each starts by constructing a temporary object of type
       *  std::basic_ostream::sentry.  This has several effects, concluding
       *  with the setting of a status flag; see the sentry documentation
       *  for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state.  If badbit is on in
       *  the stream's exceptions mask, the exception will be rethrown
       *  without completing its actions.
      *//**
       *  @brief  Extracting from another streambuf.
       *  @param  __sb  A pointer to a streambuf
       *
       *  This function behaves like one of the basic arithmetic extractors,
       *  in that it also constructs a sentry object and has the same error
       *  handling behavior.
       *
       *  If @p __sb is NULL, the stream will set failbit in its error state.
       *
       *  Characters are extracted from @p __sb and inserted into @c *this
       *  until one of the following occurs:
       *
       *  - the input stream reaches end-of-file,
       *  - insertion into the output sequence fails (in this case, the
       *    character that would have been inserted is not extracted), or
       *  - an exception occurs while getting a character from @p __sb, which
       *    sets failbit in the error state
       *
       *  If the function inserts no characters, failbit is set.
      *//**
       *  @brief  Pointer arithmetic inserters
       *  @param  __p A variable of pointer type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      */// 117. basic_ostream uses nonexistent num_put member functions./**
       *  @brief  Floating point arithmetic inserters
       *  @param  __f A variable of builtin floating point type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      *//**
       *  @brief Integer arithmetic inserters
       *  @param  __n A variable of builtin integral type.
       *  @return  @c *this if successful
       *
       *  These functions use the stream's current locale (specifically, the
       *  @c num_get facet) to perform numeric formatting.
      *//**
       *  @name Inserters
       *
       *  All the @c operator<< functions (aka <em>formatted output
       *  functions</em>) have some common behavior.  Each starts by
       *  constructing a temporary object of type std::basic_ostream::sentry.
       *  This can have several effects, concluding with the setting of a
       *  status flag; see the sentry documentation for more.
       *
       *  If the sentry status is good, the function tries to generate
       *  whatever data is appropriate for the type of the argument.
       *
       *  If an exception is thrown during insertion, ios_base::badbit
       *  will be turned on in the stream's error state without causing an
       *  ios_base::failure to be thrown.  The original exception will then
       *  be rethrown.
      */// The inserters for manipulators are *not* formatted output functions.// DR 60. What is a formatted input function?/**
       *  @brief  Interface for manipulators.
       *
       *  Manipulators such as @c std::endl and @c std::hex use these
       *  functions in constructs like "std::cout << std::endl".  For more
       *  information, see the iomanip header.
      *//// Safe prefix/suffix operations./**
       *  @brief  Base destructor.
       *
       *  This does very little apart from providing a virtual base dtor.
      *//**
       *  @brief  Base constructor.
       *
       *  This ctor is almost never called by the user directly, rather from
       *  derived classes' initialization lists, which pass a pointer to
       *  their own stream buffer.
      */// Non-standard Types:// Types (inherited from basic_ios):/**
   *  @brief  Template class basic_ostream.
   *  @ingroup io
   *
   *  @tparam _CharT  Type of character stream.
   *  @tparam _Traits  Traits for character type, defaults to
   *                   char_traits<_CharT>.
   *
   *  This is the base class for all output streams.  It provides text
   *  formatting of all builtin types, and communicates with any class
   *  derived from basic_streambuf to do the actual output.
  */// ISO C++ 14882: 27.6.2  Output streams/** @file include/ostream
 *  This is a Standard C++ Library header.
 */// Output streams -*- C++ -*-__pf__sb/home/tanteikg/QCVE/sources/bitcoin/src/tinyformat.h<cassert><sstream><iostream><algorithm>formatImplostream &basic_ostream<char, char_traits<char>> &const FormatArgconst FormatArg *FormatArg *origWidthconst ios_baseorigPrecisionorigFlagsorigFillconst basic_ios<char, char_traits<char>>positionalModeargIndex 0"tinyformat: Not enough conversion specifiers in format string""tinyformat: Too many conversion specifiers in format string"spacePadPositiventruncfmtEndconst FormatArg &FormatArg &arg'\0'tinyformat: Not enough conversion specifiers in format stringconst char[62]char[62]tinyformat: Too many conversion specifiers in format stringconst char[60]char[60]tmpStreamresultconst basic_ostringstream<char, char_traits<char>, allocator<char>>basic_ios<char, char_traits<char>> &const basic_ios<char, char_traits<char>> &const fmtflags2048std::ios::showposiend43'+'' 'streamStateFromFormat*fmtStart == '%'37const char[17]char[17]./tinyformat.hconst char[15]char[15]667const char[194]char[194]__PRETTY_FUNCTION__const char *tinyformat::detail::streamStateFromFormat(std::basic_ostream<char, std::char_traits<char>> &, bool &, bool &, int &, const char *, const tinyformat::detail::FormatArg *, int &, int)176std::ios::adjustfield74std::ios::basefield250std::ios::adjustfield | std::ios::basefield260std::ios::floatfield510std::ios::adjustfield | std::ios::basefield |
               std::ios::floatfield512std::ios::showbase1022std::ios::adjustfield | std::ios::basefield |
               std::ios::floatfield | std::ios::showbasestd::ios::boolalpha1023std::ios::adjustfield | std::ios::basefield |
               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha1024std::ios::showpoint2047std::ios::adjustfield | std::ios::basefield |
               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
               std::ios::showpoint4095std::ios::adjustfield | std::ios::basefield |
               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
               std::ios::showpoint | std::ios::showpos16384std::ios::uppercase20479std::ios::adjustfield | std::ios::basefield |
               std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
               std::ios::showpoint | std::ios::showpos | std::ios::uppercaseprecisionSetwidthSetwidthExtrac"tinyformat: Positional argument out of range""tinyformat: Non-positional argument used after a positional one"'0'57'9'tmpcconst char *&char *&36'$'tinyformat: Positional argument out of rangeconst char[45]char[45]tinyformat: Non-positional argument used after a positional oneconst char[64]char[64]std::ios::internalwidth35'#'1536std::ios::showpoint | std::ios::showbasestd::ios::left45'-'46'.'precision108'l'104'h'76'L'106'j'122'z'116't'intConversion"tinyformat: %n conversion spec not supported""tinyformat: Conversion spec incorrectly " "terminated by end of string"117'u'100'd'105'i'std::ios::dec111'o'std::ios::oct88'X'fallthrough120'x'112'p'std::ios::hex69'E'101'e'256std::ios::scientific70'F'102'f'std::ios::fixed65'A'97'a'std::ios::fixed | std::ios::scientific71'G'103'g'outfmtargsnumArgsfmtStart-261~std::ios::floatfield99'c'115's'110'n'tinyformat: %n conversion spec not supportedtinyformat: Conversion spec incorrectly terminated by end of stringconst char[68]char[68]printFormatStringLiteral'%'parseWidthOrPrecision"tinyformat: Not enough arguments to read variable width or precision"42'*'postinyformat: Not enough arguments to read variable width or precisionconst char[69]char[69]parseIntAndAdvanceformatTruncatedtmpconst Tconst T &T &const int &FormatListNconst FormatListN<N>const FormatListN<N> &FormatListN<N> &FormatListN<N> *FormatArg[]NArgsconst Argsconst Args &Args &Number of args must be Ninvoke"tinyformat: Cannot convert from argument type to " "integer for use as variable width or precision"tinyformat: Cannot convert from argument type to integer for use as variable width or precisionconst char[96]char[96]fmtT236is_wchar<const wchar_t *> &is_wchar<const wchar_t *> &&const is_wchar<const wchar_t *>const is_wchar<const wchar_t *> &is_wchar<wchar_t *> &is_wchar<wchar_t *> &&const is_wchar<wchar_t *>const is_wchar<wchar_t *> &FormatListN<0> &FormatListN<0> &&const FormatListN<0>const FormatListN<0> &FormatListN<0> *ossformatprintflnprintfvformatconst FormatListmakeFormatListformatValuetinyformat_wchar_is_not_supportedDummyTypecanConvertToCharcanConvertToVoidPtrFormatList &FormatList &&const FormatList &FormatListFormatList *FormatArg &&FormatArgconst T *T *toIntImpltoIntm_valueconst char[8]530int tinyformat::detail::FormatArg::toInt() constm_toIntImplconst char[12]char[12]531523const char[134]char[134]void tinyformat::detail::FormatArg::format(std::basic_ostream<char, std::char_traits<char>> &, const char *, const char *, int) constm_formatImplconst char[13]char[13]524nlistfmtBeginformat_error &format_error &&const format_errorconst format_error &~format_errorformat_error *format_errorT1const T1const T1 &T1 &makeT1tryConvertT2const T2const T2 &T2 &FormatListN<N>convertToInt<T, true>convertToInt<T, convertible>convertibleformatValueAsType<T, fmtT, true>formatValueAsType<T, fmtT, convertible>is_wchar<wchar_t[]>wchar_t[]is_wchar<const wchar_t[]>const wchar_t[]is_wchar<const wchar_t *>is_wchar<wchar_t *>is_wchar<T>is_convertible<T1, T2>FormatListN<0>FormatListRefsucceedfailm_formatterStorem_Nm_argsdummystrprintftfm::formatTINYFORMAT_FOREACH_ARGNUM(m)m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)TINYFORMAT_PASSARGS_TAIL_16, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16TINYFORMAT_PASSARGS_TAIL_15, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15TINYFORMAT_PASSARGS_TAIL_14, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14TINYFORMAT_PASSARGS_TAIL_13, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13TINYFORMAT_PASSARGS_TAIL_12, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12TINYFORMAT_PASSARGS_TAIL_11, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11TINYFORMAT_PASSARGS_TAIL_10, v2, v3, v4, v5, v6, v7, v8, v9, v10TINYFORMAT_PASSARGS_TAIL_9, v2, v3, v4, v5, v6, v7, v8, v9TINYFORMAT_PASSARGS_TAIL_8, v2, v3, v4, v5, v6, v7, v8TINYFORMAT_PASSARGS_TAIL_7, v2, v3, v4, v5, v6, v7TINYFORMAT_PASSARGS_TAIL_6, v2, v3, v4, v5, v6TINYFORMAT_PASSARGS_TAIL_5, v2, v3, v4, v5TINYFORMAT_PASSARGS_TAIL_4, v2, v3, v4TINYFORMAT_PASSARGS_TAIL_3, v2, v3TINYFORMAT_PASSARGS_TAIL_2, v2TINYFORMAT_PASSARGS_TAIL_1TINYFORMAT_PASSARGS_16v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16TINYFORMAT_PASSARGS_15v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15TINYFORMAT_PASSARGS_14v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14TINYFORMAT_PASSARGS_13v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13TINYFORMAT_PASSARGS_12v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12TINYFORMAT_PASSARGS_11v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11TINYFORMAT_PASSARGS_10v1, v2, v3, v4, v5, v6, v7, v8, v9, v10TINYFORMAT_PASSARGS_9v1, v2, v3, v4, v5, v6, v7, v8, v9TINYFORMAT_PASSARGS_8v1, v2, v3, v4, v5, v6, v7, v8TINYFORMAT_PASSARGS_7v1, v2, v3, v4, v5, v6, v7TINYFORMAT_PASSARGS_6v1, v2, v3, v4, v5, v6TINYFORMAT_PASSARGS_5v1, v2, v3, v4, v5TINYFORMAT_PASSARGS_4v1, v2, v3, v4TINYFORMAT_PASSARGS_3v1, v2, v3TINYFORMAT_PASSARGS_2v1, v2TINYFORMAT_PASSARGS_1v1TINYFORMAT_VARARGS_16const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15, const T16& v16TINYFORMAT_VARARGS_15const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14, const T15& v15TINYFORMAT_VARARGS_14const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13, const T14& v14TINYFORMAT_VARARGS_13const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12, const T13& v13TINYFORMAT_VARARGS_12const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11, const T12& v12TINYFORMAT_VARARGS_11const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10, const T11& v11TINYFORMAT_VARARGS_10const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9, const T10& v10TINYFORMAT_VARARGS_9const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8, const T9& v9TINYFORMAT_VARARGS_8const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7, const T8& v8TINYFORMAT_VARARGS_7const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6, const T7& v7TINYFORMAT_VARARGS_6const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5, const T6& v6TINYFORMAT_VARARGS_5const T1& v1, const T2& v2, const T3& v3, const T4& v4, const T5& v5TINYFORMAT_VARARGS_4const T1& v1, const T2& v2, const T3& v3, const T4& v4TINYFORMAT_VARARGS_3const T1& v1, const T2& v2, const T3& v3TINYFORMAT_VARARGS_2const T1& v1, const T2& v2TINYFORMAT_VARARGS_1const T1& v1TINYFORMAT_ARGTYPES_16class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16TINYFORMAT_ARGTYPES_15class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15TINYFORMAT_ARGTYPES_14class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14TINYFORMAT_ARGTYPES_13class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13TINYFORMAT_ARGTYPES_12class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12TINYFORMAT_ARGTYPES_11class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11TINYFORMAT_ARGTYPES_10class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10TINYFORMAT_ARGTYPES_9class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9TINYFORMAT_ARGTYPES_8class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8TINYFORMAT_ARGTYPES_7class T1, class T2, class T3, class T4, class T5, class T6, class T7TINYFORMAT_ARGTYPES_6class T1, class T2, class T3, class T4, class T5, class T6TINYFORMAT_ARGTYPES_5class T1, class T2, class T3, class T4, class T5TINYFORMAT_ARGTYPES_4class T1, class T2, class T3, class T4TINYFORMAT_ARGTYPES_3class T1, class T2, class T3TINYFORMAT_ARGTYPES_2class T1, class T2TINYFORMAT_ARGTYPES_1class T1TINYFORMAT_PASSARGS_TAIL(n)TINYFORMAT_PASSARGS_TAIL_ ## nTINYFORMAT_PASSARGS(n)TINYFORMAT_PASSARGS_ ## nTINYFORMAT_VARARGS(n)TINYFORMAT_VARARGS_ ## nTINYFORMAT_ARGTYPES(n)TINYFORMAT_ARGTYPES_ ## nTINYFORMAT_DEFINE_FORMATVALUE_CHARTINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)inline void formatValue(std::ostream& out, const char* , const char* fmtEnd, int , charType value) { switch (*(fmtEnd-1)) { case 'u': case 'd': case 'i': case 'o': case 'X': case 'x': out << static_cast<int>(value); break; default: out << value; break; } }TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTRTINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)inline void formatTruncated(std::ostream& out, type* value, int ntrunc) { std::streamsize len = 0; while (len < ntrunc && value[len] != 0) ++len; out.write(value, len); }TINYFORMAT_HIDDENTINYFORMAT_ASSERT(cond)assert(cond)TINYFORMAT_USE_VARIADIC_TEMPLATESTINYFORMAT_ERROR(reasonString)throw tinyformat::format_error(reasonString)TINYFORMAT_H_INCLUDEDtinyformatdetailtfmTINYFORMAT_ASSERTTINYFORMAT_ERROR!defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)defined(__GLIBCXX__) && __GLIBCXX__ < 20080201__APPLE___MSC_VERTINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUNDTINYFORMAT_ALLOW_WCHAR_STRINGS// TINYFORMAT_H_INCLUDED/** Format arguments and return the string or write to given std::ostream (see tinyformat::format doc for details) */// Added for Bitcoin Core:// namespace tinyformat// Added for Bitcoin Core// C++98 version/// Format list of arguments to std::cout, according to the given format string/// the result as a string./// Format list of arguments according to the given format string and return/// Format list of arguments to the stream according to given format string./// list of format arguments is held in a single function argument./// The name vformat() is chosen for the semantic similarity to vprintf(): the/// Format list of arguments to the stream according to the given format string.///   FormatListRef formatList = makeFormatList( /*...*/ );/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:/// The exact return type of this function is an implementation detail and/// Make type-agnostic format list from list of template arguments.// Primary API functions//------------------------------------------------------------------------------// namespace detail// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard// Format list subclass with fixed storage to avoid dynamic allocation/// Reference to type-opaque format list for passing to vformat()/// common interface to perform formatting as required./// information has been stripped from the arguments, leaving just enough of a/// conveniently used to pass arguments to non-template functions: All type/// A const reference to FormatList (typedef'd as FormatListRef) may be/// List of template arguments format(), held in a type-opaque way.// Restore stream state// allocates... yuck.// munging the resulting string.// it crudely by formatting into a temporary string stream and// between stream formatting and the printf() behaviour.  Simulate// The following is a special case with no direct correspondence// Format the arg into the stream.// in `streamStateFromFormat`, so do the bounds check here.// NB: argIndex may be incremented by reading variable width/precision// with `n` an integer. We detect this in `streamStateFromFormat`.// "Positional mode" means all format specs should be of the form "%n$..."// Saved stream state// the width isn't otherwise used.// iostreams, but we can approximately simulate it with the width if// padded with zeros on the left).  This isn't really supported by the// "precision" for integers gives the minimum number of digits (to be// Not supported - will cause problems!// Make %s print Booleans as "true" and "false"// Handled as special case inside formatValue()// As in boost::format, let stream decide float format.// loss for doubles.// by always setting maximum precision on MSVC to avoid precision// Workaround https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html// boost::format class for forging the way here).// Set stream flags based on conversion specifier (thanks to the// 5) We're up to the conversion specifier character.// 4) Ignore any C99 length modifier// was negative in which case the default is used.// Presence of `.` indicates precision set, unless the inferred value// 3) Parse precision// negative widths correspond to '-' flag set// Parse width// overridden by show positive sign, '+' flag.// formatted correctly, eg -00010 rather than 000-10// Use internal padding so that numeric values are// overridden by left alignment ('-' flag)// Parse flags// 2) Parse flags and width if we did not do it in previous step.// Nonzero value means that we parsed width.// value is an argument index// preceded with '0' flag.// 1) Parse an argument index (if followed by '$') or a width possibly// Reset most flags; ignore irrelevant unitbuf & skipws.// Reset stream state to defaults.// pointer to the character after the end of the current format spec.// necessary to pull out variable width and precision.  The function returns a// and ntrunc (for truncating conversions).  argIndex is incremented if// state are returned in spacePadPositive (for space padded positive numbers)// Formatting options which can't be natively represented using the ostream// string as many times as required.// numbered arguments in the argument list can be referenced from the format// In format strings containing the "%n$" form of conversion specification,// are specified in the format string.// requires that all the leading arguments, from the first to the (N-1)th,// When numbered argument specifications are used, specifying the Nth argument// unnumbered argument specifications in a format string are undefined.// can be mixed with the "%n$" form. The results of mixing numbered and// (that is, % and * ), but not both. The only exception to this is that %%// (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications// The format can contain either numbered argument conversion specifications// in an order appropriate to specific languages.// provides for the definition of format strings that select arguments// giving the position of the argument in the argument list. This feature// "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}],// the conversion specifier character % (see below) is replaced by the sequence// the argument list, rather than to the next unused argument. In this case,// Conversions can be applied to the nth argument after the format in// POSIX positional arguments extension:// positional arguments extension.// with the form "%[flags][width][.precision][length]type" with POSIX// The format mini-language recognized here is meant to be the one from C99,// Parse a format string and set the stream state accordingly.// for "%%", tack trailing % onto next literal section.// returned, or the end of string.// The position of the first % character of the next nontrivial format spec is// Skips over any occurrences of '%%', printing a literal '%' to the output.// Print literal part of format string and return next format spec position.// characters were read.// from `args[n]` in positional mode). Returns true if one or more// is read from `args[argIndex]` and `argIndex` is incremented (or read// to the next character. If an indirection is requested with `*`, the argument// Parse width or precision `n` from format string pointer `c`, and advance it// On return, c is set to one past the end of the integer.// Parse and return an integer from the string c, as atoi()// whereas a naive implementation based on inheritance does not.// each argument to be allocated as a homogeneous array inside FormatList// the type held as explicit function pointers.  This allows FormatArg's for// Type-opaque holder for an argument to format(), with associated actions on//[[[end]]]/*[[[cog
maxParams = 16

def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
    for j in range(startInd,maxParams+1):
        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
        cog.outl(lineTemplate % {'j':j, 'list':list})

makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
                  'class T%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
                  'const T%(i)d& v%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')

cog.outl()
cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
                  'v%(i)d', startInd = 2)

cog.outl()
cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
]]]*/// extra versions by hand.// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create// To rerun the code generation in place, use `cog.py -r tinyformat.h`// used in boost.preprocessor.// the need for a bunch of complex (but more general) preprocessor tricks as// using python via the excellent cog.py code generation script.  This avoids// To keep it as transparent as possible, the macros below have been generated// be just general enough for what we need.// stolen from the boost preprocessor metaprogramming library and cut down to// Tools for emulating variadic templates in C++98.  The basic idea here is// per 3.9.1: char, signed char and unsigned char are all distinct types/**//*fmtBegin*/// Overloaded version for char types to support printing as an integer// "%.4s" where at most 4 characters may be read.// Take care not to overread C strings in truncating conversions like// could otherwise lead to a crash when printing a dangling (const char*).// %p conversion it's important to avoid dereferencing the pointer, which// void* respectively and format that instead of the value itself.  For the// conversions are active we try to convert the type to a char or const// The mess here is to support the %c and %p conversions: if these// avoid unused type warning with gcc-4.8// compile time in preference to printing as a void* at runtime.// Since we don't support printing of wchar_t using "%ls", make it fail at/// conversions./// operator<< to format the type T, with special cases for the %c and %p/// By default, formatValue() uses the usual stream insertion operator/// characters, for example "%.7s" calls formatValue with ntrunc = 7./// truncating conversions, ntrunc is set to the desired maximum number of/// The format specification is provided in the range [fmtBegin, fmtEnd).  For/// the stream flags will have been modified according to the format string./// Users may override this for their own types.  When this function is called,/// Format a value into a stream, delegating to operator<< by default.// desired.// Variable formatting functions.  May be overridden for user-defined types if// char too, but these are technically unneeded for printf compatibility.// Overload for const char* and char*.  Could overload for signed & unsigned// Format at most ntrunc characters to the given stream.// Specialization for convertToInt when conversion is possible/*value*/// throws an error.// Convert an arbitrary type to integer.  The version with convertible=false// TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND// indicated by the "convertible" template parameter.// Specialized version for types that can actually be converted to fmtT, as/*out*/// should never be called.// Format the value by casting to type fmtT.  This default implementation// Detect when a type is not a wchar_t string// function matched.  Very neat, in a disgusting kind of way :)// Then we compare the sizes of the return types to check which// the overload set only if the version taking a T2 doesn't match.// Standard trick: the (...) version of tryConvert will be chosen from// Disable spurious loss of precision warnings in tryConvert(makeT1())// Try to convert a T1 to a T2 by plugging into tryConvert// two types of different size// Test whether type T1 is convertible to type T2// visibilities for static libs vs executables (see issue #25)// Workaround macOS linker warning: Xcode uses different default symbol//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html//  std::showpos is broken on old libstdc++ as provided with macOS.  See// Implementation details.// general.  If you don't define this, C++11 support is autodetected below.// Define for C++11 variadic templates which make the code shorter & more// Error handling; calls assert() by default.// Namespace alias to encourage brevity// Config section.  Customize to your liking!// Overload formatValue() for more control.// User defined types: Uses operator<< for user defined types by default.// specifiers (calls assert() by default).// format strings which are unsupported or have the wrong number of format// Error handling: Define TINYFORMAT_ERROR to customize the error handling for// --------------------------// Additional API information//   tfm::vformat(std::cout, "%s, %s %d, %.2d:%.2d\n", formatList);// via a call to the vformat() function:// The format list can now be passed into any non-template function and used//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);// example from above, we construct a FormatList using makeFormatList():// this by storing the argument list in a type-opaque way.  Continuing the// to a non-template function.  The FormatList class is provided as a way to do// Sometimes it's useful to be able to pass a list of format arguments through// example, see the implementation of printf() at the end of the source file.// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an// desired user defined function with n arguments.  To generate all 16 user// n between 1 and 16.  We can use these to define a macro which generates the// type/name pairs and argument names respectively when called with an integer// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and// internally to generate the API, but which may also be used in user code.// this bearable tinyformat comes with a set of macros which are used// writing out the same function for each desired number of arguments.  To make// Simulating variadic templates in C++98 is pretty painful since it requires// -----------------------------// User defined format functions// of printf() for super simple logging.// convenience function printfln() which appends a newline to the usual result// These are the three primary interface functions.  There is also a//   std::cout << date;//                                  weekday, month, day, hour, min);//   std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",// The other returns a std::string://               weekday, month, day, hour, min);//   tfm::format(std::cerr, "%s, %s %d, %.2d:%.2d\n",// stream:// using either of the tfm::format() functions.  One prints on a user provided// size_t using the "%d" conversion.  A similar result could be achieved// possible to print a std::string using the "%s" conversion, and a// The strange types here emphasize the type safety of the interface; it is//   tfm::printf("%1$s, %3$d. %2$s, %4$d:%5$.2d\n", weekday, month, day, hour, min);// Previous example for German usage. Arguments are reordered:// for localization because the word order may vary in different languages.// The ability to rearrange formatting arguments is an important feature// POSIX extension for positional arguments is available.//   tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);//   int min = 44;//   long hour = 14;//   size_t day = 27;//   const char* month = "July";//   std::string weekday = "Wednesday";// To print a date to std::cout for American usage:// ----------------------------// Main interface example usage// * C++98 support, with optional C++11 niceties// * Augment rather than replace the standard stream formatting mechanism//   with your projects.// * Simplicity and minimalism.  A single header file to include and distribute// * POSIX extension for positional arguments// * C99 printf() compatibility, to the extent possible using std::ostream// * Type safety and extensibility for user defined types.// header file.  Design goals include:// tinyformat.h is a type safe printf replacement library in a single C++// Tinyformat: A minimal type safe printf replacement// DEALINGS IN THE SOFTWARE.// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR// a source language processor.// works are solely in the form of machine-executable object code generated by// all derivative works of the Software, unless such copies or derivative// must be included in all copies of the Software, in whole or in part, and// the above license grant, this restriction and the following disclaimer,// The copyright notices in the Software and this entire statement, including// do so, all subject to the following:// Software, and to permit third-parties to whom the Software is furnished to// execute, and transmit the Software, and to prepare derivative works of the// this license (the "Software") to use, reproduce, display, distribute,// obtaining a copy of the software and accompanying documentation covered by// Permission is hereby granted, free of charge, to any person or organization// Boost Software License - Version 1.0// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]// tinyformat.h/usr/include/c++/9/chrono<bits/parse_numbers.h><ctime><ratio>system_clock &system_clock &&const system_clockconst system_clock &from_time_tconst time_point<system_clock, duration<signed long, ratio<1L, 1L>>>const time_point<system_clock, duration<signed long, ratio<1L, 1L>>> &time_point<system_clock, duration<signed long, ratio<1L, 1L>>> &const signed longconst signed long &signed long &const durationconst duration &duration<signed long, ratio<1L, 1L>> &to_time_tconst time_pointconst time_point &time_point<system_clock, duration<signed long, ratio<1L, 1000000000L>>> &const duration<signed long, ratio<1L, 1000000000L>>const duration<signed long, ratio<1L, 1000000000L>> &duration<signed long, ratio<1L, 1000000000L>> &const duration<signed long, ratio<1L, 1L>>nowoperator ""ns_Digitsconst long doubleconst long double &long double &operator ""usoperator ""msoperator ""minoperator ""hrep__repvalconst rep_Dur__check_overflowliteral value cannot be represented by duration typeconst time_point<_Clock, _Dur1>const time_point<_Clock, _Dur1> &time_point<_Clock, _Dur1> &const time_point<_Clock, _Dur2>const time_point<_Clock, _Dur2> &time_point<_Clock, _Dur2> &_Clock_Dur1_Dur2time_since_epoch__dur2__ct__time_pointconst duration<_Rep2, _Period2>const duration<_Rep2, _Period2> &duration<_Rep2, _Period2> &_Rep2_Period2const duration<_Rep1, _Period1>const duration<_Rep1, _Period1> &duration<_Rep1, _Period1> &_Rep1_Period1roundconst time_point<_Clock, _Dur>const time_point<_Clock, _Dur> &time_point<_Clock, _Dur> &_ToDurceilfloortime_point_cast__dur1operator%const duration<_Rep1, _Period>const duration<_Rep1, _Period> &duration<_Rep1, _Period> &const _Rep2const _Rep2 &_Rep2 &_Periodoperator/const _Rep1const _Rep1 &_Rep1 &const duration<_Rep2, _Period>const duration<_Rep2, _Period> &duration<_Rep2, _Period> &__cdabs_Repconst duration<_Rep, _Period>const duration<_Rep, _Period> &duration<_Rep, _Period> &period__to_period__to_rep__cf__cr__dc__castduration_caststeady_clock &steady_clock &&const steady_clockconst steady_clock &lowestzero_CR_CFnumden_Dur &const time_point<_Clock, _Dur> *time_point<_Clock, _Dur> *time_pointconst time_point<clock, _Dur2>const time_point<clock, _Dur2> &time_point<clock, _Dur2> &operator%=const rep &_Rep &operator/=operator*=const duration<_Rep, _Period> *duration<_Rep, _Period> *~durationdurationcommon_type<time_point<_Clock, _Duration1>, time_point<_Clock, _Duration2>>__timepoint_common_type_wrapper<__failure_type, _Clock>__timepoint_common_type_wrapper<_CT, _Clock>_CTcommon_type<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>__duration_common_type_wrapper<__failure_type, _Period1, _Period2>__duration_common_type_wrapper<_CT, _Period1, _Period2>system_clockhigh_resolution_clocksteady_clock__common_rep_t__nsecs__usecs__msecs__secs__mins__hours__dur__is_ratio<ratio<_Num, _Den>>__is_ratio<_Tp>duration_values<_Rep>treat_as_floating_point<_Rep>__disable_if_is_duration__enable_if_is_duration__is_duration<duration<_Rep, _Period>>__is_duration<_Tp>__duration_cast_impl<_ToDur, _CF, _CR, false, true>__duration_cast_impl<_ToDur, _CF, _CR, true, false>__duration_cast_impl<_ToDur, _CF, _CR, true, true>__duration_cast_impl<_ToDur, _CF, _CR, _NumIsOne, _DenIsOne>_NumIsOne_DenIsOnetime_point<_Clock, _Dur>duration<_Rep, _Period>_Duration1_Duration2_CReptreat_as_floating_point_vis_steadysystem_clock::duration::min()
		    < system_clock::duration::zero()a clock's minimum duration cannot be less than its epochperiod must be positiveperiod must be a specialization of ratiorep cannot be a duration__cpp_lib_chrono_udls_GLIBCXX_CHRONO_INT64_Tint64_t__cpp_lib_chrono201611_GLIBCXX_CHRONOchronochrono_literals_V2defined __INT64_TYPE__//_GLIBCXX_CHRONO/// @} group chrono// namespace chrono// inline namespace chrono_literals// end inline namespace _V2/**
     *  @brief Highest-resolution clock
     *
     *  This is the clock "with the shortest tick period." Alias to
     *  std::system_clock until higher-than-nanosecond definitions
     *  become feasible.
    *//**
     *  @brief Monotonic clock
     *
     *  Time returned has the property of only increasing at a uniform rate.
    */// Map to C API/**
     *  @brief System clock.
     *
     *  Time returned represents wall time from the system-wide clock.
    */// can be removed.  XXX GLIBCXX_ABI Deprecated// point, when these clocks settle down, the inlined namespaces// compatibility definitions for previous versions.  At some// code can use the latests clocks, while the library can contain// high_resolution_clock types are uniquely mangled. This way, new// defintions of system_clock, steady_clock, and// clocks, wrap inside inline namespace so that the current// To support the (forward) evolution of the library's defined// changing function signature or units.// implementation any time to provide better resolution without// implementations to change the system_clock::now()// or 9 decimal digits will be always zero? This allows later// resolution (ie nanoseconds), even if on some OSes the low 3// Why have std::system_clock always count in the highest// Why nanosecond resolution as the default?// Clocks./// time_point_cast// special values// arithmetic// observer// conversions/// time_point/// hours/// minutes/// seconds/// milliseconds/// microseconds/// nanoseconds// comparisons// DR 934.// 3050. Conversion specification problem in chrono::duration constructor// is implicitly convertible to it.// SFINAE helper to obtain common_type<_Rep1, _Rep2> only if _Rep2// 20.11.5.4 special values// 20.11.5.3 arithmetic// 20.11.5.2 observer// 3050. Conversion specification problem in chrono::duration// 20.11.5.1 construction / copy / destroy// _Period2 is an exact multiple of _Period/// duration/// duration_values/// treat_as_floating_point/// duration_cast// Primary template for duration_cast impl.// 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)// 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)/** @namespace std::chrono
   *  @brief ISO C++ 2011 entities sub-namespace for time and date.
   *//**
   * @defgroup chrono Time
   * @ingroup utilities
   *
   * Classes and functions for time.
   * @{
   */// for literals support./** @file include/chrono
 *  This is a Standard C++ Library header.
 */// Copyright (C) 2008-2019 Free Software Foundation, Inc.// <chrono> -*- C++ -*-__rep/usr/include/c++/9/bits/unique_ptr.h__invalid_typemake_unique__single_objectconst unique_ptr<_Tp, _Dp>const unique_ptr<_Tp, _Dp> &unique_ptr<_Tp, _Dp> &const unique_ptr<_Up, _Ep>const unique_ptr<_Up, _Ep> &unique_ptr<_Up, _Ep> &_Epunique_ptr<_Tp[], _Dp> &const unique_ptr<_Tp[], _Dp>const unique_ptr<_Tp[], _Dp> &unique_ptrreleaseconst deleter_typeconst deleter_type &_Dp &get_deleterdeleter_type &unique_ptr<_Up, _Ep> &&unique_ptr<_Tp[], _Dp> &&~unique_ptr_Del_DelUnrefunique_ptr<_Tp, _Dp> *deleter must be swappableunique_ptr's deleter must be invocable with a pointer_M_deleterconst unique_ptr<_Tp, _Dp> *get() != pointer()unique_ptr<_Tp, _Dp> &&__uniq_ptr_impl<_Tp, _Dp> &__uniq_ptr_impl<_Tp, _Dp> *pointer &const _Dp &const __uniq_ptr_impl<_Tp, _Dp>const __uniq_ptr_impl<_Tp, _Dp> *_Del &&__uniq_ptr_impldefault_deleteconst default_delete<_Up[]>const default_delete<_Up[]> &default_delete<_Up[]> &const default_delete<_Tp>const default_delete<_Tp> *default_delete<_Tp> *can't delete pointer to incomplete typeconst default_delete<_Up>const default_delete<_Up> &default_delete<_Up> &_Never_valueless_alt<unique_ptr<_Tp, _Del>>_MakeUniq<_Tp[]>_MakeUniq<_Tp>hash<unique_ptr<_Tp, _Dp>>unique_ptr<_Tp[], _Dp>_UPtrdeleter_type__remove_cv_DeleterConstraintunique_ptr<_Tp, _Dp>__uniq_ptr_impl<_Tp, _Dp>_Ptr<_Up, _Ep, __void_t<pointer>>_Ptr<_Up, _Ep, <unnamed>>default_delete<_Tp[]>default_delete<_Tp>_UP_pointer_UP_element_typeauto_ptr<_Up> &&auto_ptr<_Tp>unique_ptr's deleter type must be a function object type or an lvalue reference type__cpp_lib_make_unique_UNIQUE_PTR_H_GLIBCXX_USE_DEPRECATED/* _UNIQUE_PTR_H */// unique_ptr into a variant./// @} group pointer_abstractions/// Disable std::make_unique for arrays of known bound/// std::make_unique for arrays of unknown bound/// std::make_unique for single objects/// std::hash specialization for unique_ptr.// Disable copy from lvalue./// Exchange the pointer and deleter with another object./** @brief Replace the stored pointer.
       *
       * @param __p  The new pointer to store.
       *
       * The deleter will be invoked if a pointer is already owned.
       *//// Release ownership of any stored pointer.// Modifiers./// Return @c true if the stored pointer is not null./// Return a reference to the stored deleter./// Return the stored pointer./// Access an element of owned array./// Reset the %unique_ptr to empty, invoking the deleter if necessary./** @brief Assignment from another type.
       *
       * @param __u  The object to transfer ownership from, which owns a
       *             convertible pointer to an array object.
       *
       * Invokes the deleter first if this object owns a pointer.
       *//** @brief Move assignment operator.
       *
       * @param __u  The object to transfer ownership from.
       *
       * Invokes the deleter first if this object owns a pointer.
       */// Assignment./// Destructor, invokes the deleter if the stored pointer is not null./// Creates a unique_ptr that owns nothing./// Move constructor./** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an array of a type safely convertible
       * to an array of @c element_type
       * @param __d  A reference to a deleter.
       *
       * The deleter will be initialized with @p std::move(__d)
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an array of a type safely convertible
       * to an array of @c element_type
       * @param __d  A reference to a deleter.
       *
       * The deleter will be initialized with @p __d
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an array of a type safely convertible
       * to an array of @c element_type
       *
       * The deleter will be value-initialized.
       *//// Default constructor, creates a unique_ptr that owns nothing.// Constructors.// helper template for detecting a safe conversion from a raw pointer// unique_ptr// helper template for detecting a safe conversion from another// like is_base_of<_Tp, _Up> but false if unqualified types are the same// DR 740 - omit specialization for array objects with a compile time length// [unique.ptr.runtime]/// 20.7.1.3 unique_ptr for array objects with a runtime length/// Dereference the stored pointer./** @brief Assignment from another type.
       *
       * @param __u  The object to transfer ownership from, which owns a
       *             convertible pointer to a non-array object.
       *
       * Invokes the deleter first if this object owns a pointer.
       *//// Converting constructor from @c auto_ptr/** @brief Converting constructor from another type
       *
       * Requires that the pointer owned by @p __u is convertible to the
       * type of pointer owned by this object, @p __u does not own an array,
       * and @p __u has a compatible deleter type.
       */// Move constructors./** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       * @param __d  An rvalue reference to a (non-reference) deleter.
       *
       * The deleter will be initialized with @p std::move(__d)
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       * @param __d  A reference to a deleter.
       *
       * The deleter will be initialized with @p __d
       *//** Takes ownership of a pointer.
       *
       * @param __p  A pointer to an object of @c element_type
       *
       * The deleter will be value-initialized.
       *//// 20.7.1.2 unique_ptr for single objects./// Calls @c delete[] @p __ptr/** @brief Converting constructor.
       *
       * Allows conversion from a deleter for arrays of another type, such as
       * a const-qualified version of @p _Tp.
       *
       * Conversions from types derived from @c _Tp are not allowed because
       * it is unsafe to @c delete[] an array of derived types through a
       * pointer to the base type.
       *//// Default constructor/// Specialization for arrays, default_delete./// Calls @c delete @p __ptr/** @brief Converting constructor.
       *
       * Allows conversion from a deleter for arrays of another type, @p _Up,
       * only if @p _Up* is convertible to @p _Tp*.
       *//// Primary template of default_delete, used by unique_ptr/**
   * @addtogroup pointer_abstractions
   * @{
   *//** @file bits/unique_ptr.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// unique_ptr implementation -*- C++ -*-/usr/include/c++/9/bits/quoted_string.hconst _Quoted_string<basic_string<_CharT, _Traits, _Alloc> &, _CharT>const _Quoted_string<basic_string<_CharT, _Traits, _Alloc> &, _CharT> &_Quoted_string<basic_string<_CharT, _Traits, _Alloc> &, _CharT> &__ostrconst _Quoted_string<_String, _CharT>const _Quoted_string<_String, _CharT> &_Quoted_string<_String, _CharT> &_M_delim<unnamed> &&_M_string(__range)_M_escape_Stringconst _Quoted_string<const _CharT *, _CharT>const _Quoted_string<const _CharT *, _CharT> &_Quoted_string<const _CharT *, _CharT> &_Quoted_string<basic_string_view<_CharT, _Traits>, _CharT> &_Quoted_string_Quoted_string<_String, _CharT> *_Quoted_string<basic_string_view<_CharT, _Traits>, _CharT>_Quoted_string<_String, _CharT>String type must be pointer or reference_GLIBCXX_QUOTED_STRING_H/* _GLIBCXX_QUOTED_STRING_H *//**
     * @brief Extractor for delimited strings.
     *        The left and right delimiters can be different.
     *//**
     * @brief Inserter for quoted strings.
     *
     *  _GLIBCXX_RESOLVE_LIB_DEFECTS
     *  DR 2344 quoted()'s interaction with padding is unclear
     *//**
     * @brief Struct for delimited strings.
     *//** @file bits/quoted_string.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{iomanip}
 */// Helpers for quoted stream manipulators -*- C++ -*-__del__esc/usr/include/c++/9/bits/shared_ptr_base.h<bits/allocated_ptr.h>const __weak_count<_S_atomic>const __weak_count<_S_atomic> &__weak_count<_S_atomic> &const __shared_count<_S_atomic>const __shared_count<_S_atomic> &__shared_count<_S_atomic> &__make_shared_Lp__allocate_sharedconst __enable_shared_from_this<_Tp, _Lp>const __enable_shared_from_this<_Tp, _Lp> *__enable_shared_from_this<_Tp, _Lp> *__enable_shared_from_this_baseconst __shared_count<_Lp>const __shared_count<_Lp> &__shared_count<_Lp> &__weak_ptr<_Tp, _Lp> &reinterpret_pointer_castconst __shared_ptr<_Tp1, _Lp>const __shared_ptr<_Tp1, _Lp> &__shared_ptr<_Tp1, _Lp> &dynamic_pointer_castconst_pointer_caststatic_pointer_cast__shared_ptr<_Tp, _Lp> &const __shared_ptr<_Tp, _Lp>const __shared_ptr<_Tp, _Lp> &const __shared_ptr<_Tp2, _Lp>const __shared_ptr<_Tp2, _Lp> &__shared_ptr<_Tp2, _Lp> &const __shared_ptr<_Up, _Lp>const __shared_ptr<_Up, _Lp> &__shared_ptr<_Up, _Lp> &_Del *const shared_ptr<_Tp1>const shared_ptr<_Tp1> &shared_ptr<_Tp1> &const __shared_ptr<_Tp1, _Lp1>const __shared_ptr<_Tp1, _Lp1> &__shared_ptr<_Tp1, _Lp1> &_Lp1const __weak_count<_Lp>const __weak_count<_Lp> &__weak_count<_Lp> &_Sp_counted_base<_Lp> *__throw_bad_weak_ptrbad_weak_ptr()bad_weak_ptrbad_weak_ptr *_Sp_owner_less<void, void> &_Sp_owner_less<void, void> &&const _Sp_owner_less<void, void>const _Sp_owner_less<void, void> &owner_beforeelement_type &const __shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>>const __shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>> *__shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>> *const __shared_ptr<_Tp, _Lp> *__shared_ptr<_Tp, _Lp> *_M_get() != nullptr__sp_array_delete &__sp_array_delete &&const __sp_array_deleteconst __sp_array_delete &_Yp_Yp *_Sp_make_shared_tag &_Sp_make_shared_tag &&const _Sp_make_shared_tagconst _Sp_make_shared_tag &_S_eq_S_tivisibilitysizeof(type_info)_Sp_ebo_helper<_Nm, _Tp, false> &_Sp_ebo_helper_Sp_ebo_helper<_Nm, _Tp, true> &_Sp_ebo_helper<_Nm, _Tp, true> *_Sp_counted_ptr<std::nullptr_t, _S_atomic> *_Sp_counted_ptr<std::nullptr_t, _S_mutex> *_Sp_counted_ptr<std::nullptr_t, _S_single> *_Sp_counted_ptr<_Ptr, _Lp> &const _Sp_counted_ptr<_Ptr, _Lp>const _Sp_counted_ptr<_Ptr, _Lp> &_Sp_counted_ptr_M_get_deleter_M_lessconst __shared_count<_Lp> *__shared_count<_Lp> *_M_unique_M_get_use_count__shared_count~__shared_count_M_releaseunique_ptr<_Tp, _Del> &&_Sp_cp_type__allocator_type_M_a__guard_Sp_cp_type *_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> *__mem__pi_Tp *&_Deleter__weak_count<_Lp> &&~__weak_count__weak_count_M_weak_assign_Tp1 *weak_from_thisshared_from_this~__enable_shared_from_this__enable_shared_from_this<_Tp, _Lp> &const __enable_shared_from_this<_Tp, _Lp> &__enable_shared_from_thisconst __weak_ptr<_Tp1, _Lp>const __weak_ptr<_Tp1, _Lp> &__weak_ptr<_Tp1, _Lp> &expireduse_countlock__weak_ptr<_Yp, _Lp> &&__weak_ptr<_Tp, _Lp> &&const __shared_ptr<_Yp, _Lp>const __shared_ptr<_Yp, _Lp> &__shared_ptr<_Yp, _Lp> &const __weak_ptr<_Yp, _Lp>const __weak_ptr<_Yp, _Lp> &__weak_ptr<_Yp, _Lp> &const __weak_ptr<_Tp, _Lp>const __weak_ptr<_Tp, _Lp> &__weak_ptr~__weak_ptr_M_enable_shared_from_this_with_Yp2__shared_ptr_M_refcountunique_ptr<_Yp, _Del> &&__shared_ptr<_Yp, _Lp> &&__shared_ptr<_Tp, _Lp> &&__ti__refcountauto_ptr<_Yp> &&~__shared_ptr_M_add_ref_lock_nothrow_Sp_counted_base<_S_mutex> *__mutex &_Atomic_word *_M_add_ref_lockconst _Sp_counted_base<_S_single>const _Sp_counted_base<_S_single> *_Sp_counted_base<_S_single> *_M_weak_release_M_weak_add_ref_M_add_ref_copy_Sp_counted_base<_Lp> &const _Sp_counted_base<_Lp>const _Sp_counted_base<_Lp> &_Sp_counted_baseconst _Sp_counted_base<_Lp> *__atomic_load_4const volatile voidconst volatile void *const _Atomic_wordconst _Atomic_word *&_M_use_count&_M_weak_count_S_need_barriers__atomic_thread_fence~_Sp_counted_base_M_use_count(1)_M_weak_count(1)_Mutex_base<_S_mutex> &const _Mutex_base<_S_mutex>const _Mutex_base<_S_mutex> &_Mutex_basebad_weak_ptr &const bad_weak_ptrconst bad_weak_ptr &~bad_weak_ptrconst type_info *type_info *_M_alloc__guard_ptr~_Sp_counted_ptr_inplace_Sp_counted_ptr_inplace_Impl *_Impl~_Sp_counted_deleter_Sp_counted_deleter_Deleter &_M_del_Sp_counted_base<_S_atomic> *const _Sp_counted_base<_S_atomic>const _Sp_counted_base<_S_atomic> *__atomic_compare_exchange_4volatile voidvolatile void *hash<__shared_ptr<_Tp, _Lp>>owner_less<__weak_ptr<_Tp, _Lp>>owner_less<__shared_ptr<_Tp, _Lp>>_Sp_owner_less<void, void>is_transparent_Sp_owner_less<_Tp, _Tp1>__shared_ptr_access<_Tp, _Lp, true, false>__shared_ptr_access<_Tp, _Lp, false, true>__shared_ptr_access<_Tp, _Lp, <unnamed>, <unnamed>>__sp_is_constructible<_Up[], _Yp>_Up[]__sp_is_constructible<_Tp, _Yp>__sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>__sp_is_constructible_arr<_Up, _Yp, <unnamed>>__sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[]>>__sp_is_constructible_arrN<_Up, _Nm, _Yp, <unnamed>>__sp_compatible_with<_Up(*)[], const volatile _Up(*)[]>_Up(*)[]const volatile _Upconst volatile _Up[]const volatile _Up(*)[]__sp_compatible_with<_Up(*)[], volatile _Up(*)[]>volatile _Upvolatile _Up[]volatile _Up(*)[]__sp_compatible_with<_Up(*)[], const _Up(*)[]>const _Up[]const _Up(*)[]__sp_compatible_with<_Up(*)[], _Up(*)[]>__sp_compatible_with<_Yp *, _Tp *>__sp_compatible_with<_Yp_ptr, _Tp_ptr>_Yp_ptr_Tp_ptr__sp_array_delete_Sp_alloc_shared_tag<_Alloc>_Sp_make_shared_tag_Sp_ebo_helper<_Nm, _Tp, false>_Sp_ebo_helper<_Nm, _Tp, true>_Sp_ebo_helper<_Nm, _Tp, __use_ebo>_Sp_counted_ptr<_Ptr, _Lp>__shared_count<_Lp>__not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>>__not_alloc_shared_tag<_Tp>__weak_count<_Lp>owner_less<_Tp>__enable_shared_from_this<_Tp, _Lp>__shared_ptr<<unnamed>, <unnamed>>__weak_ptr<_Tp, _Lp>__shared_ptr<_Tp1, _Lp1>_Assignable_Compatible__shared_ptr<_Tp, _Lp>__weak_ptr<_Tp1, _Lp1>__has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>__has_esft_base<_Yp, <unnamed>>__esft_base_t_UniqAssignable_UniqCompatible_SafeConv_Sp_counted_base<_Lp>_Mutex_base<_S_mutex>_Mutex_base<_Lp>_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>_Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp>auto_ptr<_Tp> &&enable_shared_from_this<_Tp>auto_ptr<_Tp1> &&weak_ptr<_Tp>shared_ptr<_Tp>_M_pi_M_weak_this_M_weak_count_M_use_count__cpp_lib_shared_ptr_arrays_SHARED_PTR_BASE_Hconst _Lock_policy__cplusplus <= 201402L && _GLIBCXX_USE_DEPRECATED__p == 0 || __p != _M_ptr!extent<_Tp>::value || __i < extent<_Tp>::value__ptr != nullptr__ATOMIC_RELAXED__ATOMIC_ACQ_REL// _SHARED_PTR_BASE_H/// std::hash specialization for __shared_ptr.// 20.7.2.3.6 weak_ptr specialized algorithms.// Reference counter.// Contained pointer.// Used by __enable_shared_from_this.// in multithreaded programs __r._M_ptr may be invalidated at any point.// It is not possible to avoid spurious access violations since//  conversion may require access to *__r._M_ptr (virtual inheritance).//  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)// has a serious problem.//    { }//    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws//    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)//  template<typename _Tp1>// The "obvious" converting constructor implementation:// Constraint for assignment from shared_ptr and weak_ptr:/// dynamic_pointer_cast// delete the same object twice.// will eventually result in undefined behaviour, attempting to// shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))// The seemingly equivalent code:/// const_pointer_cast// shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))/// static_pointer_cast// shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))// 20.7.2.2.9 shared_ptr casts// 20.7.2.2.8 shared_ptr specialized algorithms.// 20.7.2.2.7 shared_ptr comparisons// No enable shared_from_this for arrays// Detect an accessible and unambiguous enable_shared_from_this base.// shared_ptr::shared_ptr(const weak_ptr&, std::nothrow_t).// This constructor is used by __weak_ptr::lock() and// This constructor is non-standard, it is used by allocate_shared.// never throws// Catch self-reset errors.// _Yp must be complete.// __shared_count::op= doesn't throw// Postcondition: use_count() == 1 and __r.get() == 0// If an exception is thrown this constructor has no effect.// _M_refcount(__r._M_refcount) did not throw.// It is now safe to copy __r._M_ptr, as// may throw// Constraint for assignment from unique_ptr:// Constraint for construction from unique_ptr:// Constraint for construction from shared_ptr and weak_ptr:// Constraint for taking ownership of a pointer of type _Yp*:// Define operator[] for shared_ptr<T[]> and shared_ptr<T[N]>.// Define operator-> for shared_ptr<cv void>.// Define operator* and operator-> for shared_ptr<T>.// otherwise, Y* shall be convertible to T*.// when T is U[], Y(*)[] shall be convertible to T*;// When T is U[N], Y(*)[N] shall be convertible to T*;// Trait to check if shared_ptr<T> can be constructed from Y*.// Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].// Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].// either Y* is convertible to T* or Y is U[N] and T is U cv [].// A pointer type Y* is said to be compatible with a pointer type T* when// Helper traits for shared_ptr of array:// Now that __weak_count is defined we can define this constructor:// Friend function injected into enclosing namespace and found by ADL// Does not throw if __r._M_get_use_count() == 0, caller must check.// Throw bad_weak_ptr when __r._M_get_use_count() == 0.// non-throwing// 2415. Inconsistency between unique_ptr and shared_ptr// Special case for unique_ptr<_Tp,_Del> to provide the strong guarantee.// Special case for auto_ptr<_Tp> to provide the strong guarantee.// Call _Deleter on __p./* is_array = */// The default deleter for shared_ptr<T[]> and shared_ptr<T[N]>.// or call a library function to do it.// type_info for this class. With RTTI enabled we can check directly,// as a real type_info object. Otherwise, check if it's the real// Check for the fake type_info first, so we don't try to access it// might still call it from __shared_ptr ctor to get the pointer out.// No longer used, but code compiled against old libstdc++ headers// To be able to call _M_ptr().// Override because the allocator needs to know the dynamic type// might throw// 2070.  allocate_shared should use allocator_traits<A>::construct// Alloc parameter is not a reference so doesn't alias anything in __args// helpers for make_shared / allocate_shared// 2400. shared_ptr's get_deleter() should use addressof()// __d(__p) must not throw.// Support for custom deleter and/or allocator// Counted ptr with no deleter or allocator support// Forward declarations.// long as it's not changed meanwhile.// Replace the current counter value with the old value + 1, as// Perform lock-free add-if-not-zero operation.// #weak + (#shared != 0)// #shared// with other threads.// No memory barrier is used here so there is no synchronization// destroy() must observe results of dispose()// See _M_release(),// Be race-detector-friendly. For more info see bits/c++config.// See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html// thread that runs destroy().// to ensure that the effects of dispose() are observed in the// There must be a memory barrier between dispose() and destroy()// Called when _M_weak_count drops to zero.// managed by *this.// Called when _M_use_count drops to zero, to release the resources// memory barriers.// The replacement atomic operations might not have the necessary// This policy is used when atomic builtins are not available.// The atomic policy uses fully-fenced builtins, single doesn't care.// Empty helper class except when the template argument is _S_mutex.// Substitute for bad_weak_ptr object in the case of -fno-exceptions./**
   *  @brief  Exception possibly thrown by @c shared_ptr.
   *  @ingroup exceptions
   *//** @file bits/shared_ptr_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// http://www.boost.org/LICENSE_1_0.txt)// accompanying file LICENSE_1_0.txt or copy at// Distributed under the Boost Software License, Version 1.0. (See//  Copyright (C) 2002 Peter Dimov//  enable_shared_from_this.hpp//  Copyright (C) 2001, 2002, 2003 Peter Dimov//  weak_ptr.hpp//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.//  shared_ptr.hpp//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.//  shared_count.hpp// GCC Note: Based on files from version 1.32.0 of the Boost library.// shared_ptr and weak_ptr implementation details -*- C++ -*-/usr/include/c++/9/bits/shared_ptr.h<bits/shared_ptr_base.h>_Tp_ncmake_sharedallocate_sharedconst enable_shared_from_this<_Tp>const enable_shared_from_this<_Tp> *enable_shared_from_this<_Tp> *weak_ptr<_Tp> &weak_ptrconst shared_ptr<_Up>const shared_ptr<_Up> &shared_ptr<_Up> &shared_ptr<_Tp> &const shared_ptr<_Tp>const shared_ptr<_Tp> &shared_ptrbasic_ostream<_Ch, _Tr> &owner_lessowner_less<void> &owner_less<void> &&const owner_less<void>const owner_less<void> &~enable_shared_from_thisenable_shared_from_this<_Tp> &const enable_shared_from_this<_Tp> &enable_shared_from_thisweak_ptr<_Yp> &&weak_ptr<_Tp> &&const shared_ptr<_Yp>const shared_ptr<_Yp> &shared_ptr<_Yp> &const weak_ptr<_Yp>const weak_ptr<_Yp> &weak_ptr<_Yp> &const weak_ptr<_Tp>const weak_ptr<_Tp> &shared_ptr<_Tp> *shared_ptr<_Yp> &&shared_ptr<_Tp> &&_Never_valueless_alt<weak_ptr<_Tp>>_Never_valueless_alt<shared_ptr<_Tp>>hash<shared_ptr<_Tp>>owner_less<weak_ptr<_Tp>>owner_less<shared_ptr<_Tp>>owner_less<void>_Constructible__cpp_lib_enable_shared_from_this__cpp_lib_shared_ptr_weak_type_SHARED_PTR_H// _SHARED_PTR_H// weak_ptr into a variant.// shared_ptr into a variant./// std::hash specialization for shared_ptr./**
   *  @brief  Create an object that is owned by a shared_ptr.
   *  @param  __args  Arguments for the @a _Tp object's constructor.
   *  @return A shared_ptr that owns the newly created object.
   *  @throw  std::bad_alloc, or an exception thrown from the
   *          constructor of @a _Tp.
   *//**
   *  @brief  Create an object that is owned by a shared_ptr.
   *  @param  __a     An allocator.
   *  @param  __args  Arguments for the @a _Tp object's constructor.
   *  @return A shared_ptr that owns the newly created object.
   *  @throw  An exception thrown from @a _Alloc::allocate or from the
   *          constructor of @a _Tp.
   *
   *  A copy of @a __a will be used to allocate memory for the shared_ptr
   *  and the new object.
   */// Found by ADL when this is an associated class./**
   *  @brief Base class allowing use of member function shared_from_this.
   *//// Partial specialization of owner_less for weak_ptr./// Partial specialization of owner_less for shared_ptr./// Void specialization of owner_less/// Primary template owner_less/**
   *  @brief  A smart pointer with weak semantics.
   *
   *  With forwarding constructors and assignment operators.
   */// 20.7.2.2.9 shared_ptr casts.// This constructor is non-standard, it is used by weak_ptr::lock()./**
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count() == 0 && get() == nullptr
       */// were possible in C++11 and C++14 but are ill-formed in C++17.// This non-standard constructor exists to support conversions that// 2399. shared_ptr's constructor from unique_ptr should be constrained/**
       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r
       *          and stores a copy of the pointer stored in @a __r.
       *  @param  __r  A weak_ptr.
       *  @post   use_count() == __r.use_count()
       *  @throw  bad_weak_ptr when __r.expired(),
       *          in which case the constructor has no effect.
       *//**
       *  @brief  Move-constructs a %shared_ptr instance from @a __r.
       *  @param  __r  A %shared_ptr rvalue.
       *  @post   *this contains the old value of @a __r, @a __r is empty.
       *//**
       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;
       *          otherwise construct a %shared_ptr that shares ownership
       *          with @a __r.
       *  @param  __r  A %shared_ptr.
       *  @post   get() == __r.get() && use_count() == __r.use_count()
       *//**
       *  @brief  Constructs a %shared_ptr instance that stores @a __p
       *          and shares ownership with @a __r.
       *  @param  __r  A %shared_ptr.
       *  @param  __p  A pointer that will remain valid while @a *__r is valid.
       *  @post   get() == __p && use_count() == __r.use_count()
       *
       *  This can be used to construct a @c shared_ptr to a sub-object
       *  of an object managed by an existing @c shared_ptr.
       *
       * @code
       * shared_ptr< pair<int,int> > pii(new pair<int,int>());
       * shared_ptr<int> pi(pii, &pii->first);
       * assert(pii.use_count() == 2);
       * @endcode
       */// Aliasing constructor/**
       *  @brief  Construct a %shared_ptr that owns a null pointer
       *          and the deleter @a __d.
       *  @param  __p  A null pointer constant.
       *  @param  __d  A deleter.
       *  @param  __a  An allocator.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw _Alloc's copy constructor and destructor must not
       *  throw.
       *
       *  The last owner will call __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
       *          and the deleter @a __d.
       *  @param  __p  A pointer.
       *  @param  __d  A deleter.
       *  @param  __a  An allocator.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw _Alloc's copy constructor and destructor must not
       *  throw.
       *
       *  __shared_ptr will release __p by calling __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns a null pointer
       *          and the deleter @a __d.
       *  @param  __p  A null pointer constant.
       *  @param  __d  A deleter.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw
       *
       *  The last owner will call __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p
       *          and the deleter @a __d.
       *  @param  __p  A pointer.
       *  @param  __d  A deleter.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.
       *
       *  Requirements: _Deleter's copy constructor and destructor must
       *  not throw
       *
       *  __shared_ptr will release __p by calling __d(__p)
       *//**
       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.
       *  @param  __p  A pointer that is convertible to element_type*.
       *  @post   use_count() == 1 && get() == __p
       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.
       *//**
       *  @brief  Construct an empty %shared_ptr.
       *  @post   use_count()==0 && get()==0
       *//**
   *  @brief  A smart pointer with reference-counted copy semantics.
   *
   *  The object pointed to is deleted when the last shared_ptr pointing to
   *  it is destroyed or reset.
  *//// 20.7.2.2.10 shared_ptr get_deleter/// 20.7.2.2.11 shared_ptr I/O/** @file
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{memory}
 */// shared_ptr and weak_ptr implementation -*- C++ -*-/home/tanteikg/QCVE/sources/bitcoin/src/addrdb.h<optional><util/fs.h><univalue.h><net_types.h>CBanDB &const CBanDBconst CBanDB &~CBanDBCBanDBCBanDB &&const pathm_banlist_jsonm_banlist_datJSON_KEYbanned_nets"banned_nets"BITCOIN_ADDRDB_HReadAnchorsconst path &path &DumpAnchorsconst vector<CAddress, allocator<CAddress>>const vector<CAddress, allocator<CAddress>> &vector<CAddress, allocator<CAddress>> &LoadAddrmanconst NetGroupManagerconst NetGroupManager &NetGroupManager &const ArgsManagerconst ArgsManager &ArgsManager &unique_ptr<AddrMan, default_delete<AddrMan>> &ReadCBanDB *WriteReadFromStreamAddrMan &CDataStream &DumpPeerAddressesconst AddrManconst AddrMan &bilingual_strNetGroupManagerCDataStreamCAddressAddrManArgsManager// BITCOIN_ADDRDB_H/**
 * Read the anchor IP address database (anchors.dat)
 *
 * Deleting anchors.dat is intentional as it avoids renewed peering to anchors after
 * an unclean shutdown and thus potential exploitation of the anchor peer policy.
 *//**
 * Dump the anchor IP address database (anchors.dat)
 *
 * Anchors are last known outgoing block-relay-only peers that are
 * tried to re-connect to on startup.
 *//** Returns an error string on failure *//**
     * Read the banlist from disk.
     * @param[out] banSet The loaded list. Set if `true` is returned, otherwise it is left
     * in an undefined state.
     * @return true on success
     *//**
     * JSON key under which the data is stored in the json database.
     *//** Access to the banlist database (banlist.json) *//** Only used by tests. */// For banmap_t// Copyright (c) 2009-2021 The Bitcoin Core developers// Copyright (c) 2009-2010 Satoshi Nakamotoanchors_db_pathanchorsnetgroupmanaddrmanbanSetban_list_pathaddrssPeers/usr/include/fcntl.h<bits/stat.h><bits/fcntl.h>posix_fallocate64posix_fallocateposix_fadvise64posix_fadviselockf64lockfcreat64creatopenat64openatopen64openfcntl64fcntlF_TESTF_TLOCKF_LOCKF_ULOCKSEEK_ENDSEEK_CURSEEK_SETF_OKX_OKW_OKR_OKS_IRWXO(S_IRWXG >> 3)S_IXOTH(S_IXGRP >> 3)S_IWOTH(S_IWGRP >> 3)S_IROTH(S_IRGRP >> 3)S_IRWXG(S_IRWXU >> 3)S_IXGRP(S_IXUSR >> 3)S_IWGRP(S_IWUSR >> 3)S_IRGRP(S_IRUSR >> 3)S_IRWXU(__S_IREAD|__S_IWRITE|__S_IEXEC)S_IXUSR__S_IEXECS_IWUSR__S_IWRITES_IRUSR__S_IREADS_ISVTX__S_ISVTXS_ISGID__S_ISGIDS_ISUID__S_ISUIDS_IFSOCK__S_IFSOCKS_IFLNK__S_IFLNKS_IFIFO__S_IFIFOS_IFREG__S_IFREGS_IFBLK__S_IFBLKS_IFCHR__S_IFCHRS_IFDIR__S_IFDIRS_IFMT__S_IFMT__OPEN_NEEDS_MODE(oflag)(((oflag) & O_CREAT) != 0 || ((oflag) & __O_TMPFILE) == __O_TMPFILE)_FCNTL_H__O_TMPFILE(defined __USE_UNIX98 || defined __USE_XOPEN2K8) && defined __S_IFSOCK__REDIRECT!defined F_LOCK && (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED \__REDIRECT_NTH__USE_FORTIFY_LEVEL > 0 && defined __fortify_function \(2)/* fcntl.h  *//* Define some inlines helping to catch common problems.  *//* Reserve storage for the data of the file associated with FD.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Advice the system about the expected behaviour of the application with
   respect to the file associated with FD.  *//* Test a region for other processes locks.  *//* Test and lock a region for exclusive use.  *//* Lock a region for exclusive use.  *//* Unlock a previously locked region.  *//* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.  *//* NOTE: These declarations also appear in <unistd.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  *//* Create and open FILE, with mode MODE.  This takes an `int' MODE
   argument because that is what `mode_t' will be widened to.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Similar to `open' but a relative path name is interpreted relative to
   the directory for which FD is a descriptor.

   NOTE: some other `openat' implementation support additional functionality
   through this interface, especially using the O_XATTR flag.  This is not
   yet supported here.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Open FILE and return a new file descriptor for it, or -1 on error.
   OFLAG determines the type of access used.  If O_CREAT or O_TMPFILE is set
   in OFLAG, the third argument is taken as a `mode_t', the mode of the
   created file.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Do the file control operation described by CMD on FD.
   The remaining arguments are interpreted depending on CMD.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* XPG *//* Seek from end of file.  *//* Seek from current position.  *//* Seek from beginning of file.  *//* XPG wants the following symbols.   <stdio.h> has the same definitions.  *//* Test for existence.  *//* Test for execute permission.  *//* Test for write permission.  *//* Test for read permission.  *//* Values for the second argument to access.
   These may be OR'd together.  *//* Verbatim from <unistd.h>.  Ugh.  *//* Read, write, and execute by others.  *//* Execute by others.  *//* Write by others.  *//* Read by others.  *//* Read, write, and execute by group.  *//* Execute by group.  *//* Write by group.  *//* Read by group.  *//* Read, write, and execute by owner.  *//* Execute by owner.  *//* Write by owner.  *//* Read by owner.  *//* Save swapped text after use (sticky bit).  This is pretty well obsolete.  *//* Set group ID on execution.  *//* Set user ID on execution.  *//* Protection bits.  *//* For XPG all symbols from <sys/stat.h> should also be available.  *//* POSIX.1-2001 specifies that these types are defined by <fcntl.h>.
   Earlier POSIX standards permitted any type ending in `_t' to be defined
   by any POSIX header, so we don't conditionalize the definitions here.  *//* Detect if open needs mode as a third argument (or for openat as a fourth
   argument).  *//* Get the definitions of O_*, F_*, FD_*: all the
   numbers and flag bits for `open', `fcntl', et al.  *//* Get __mode_t, __dev_t and __off_t  .*//* This must be early so <bits/fcntl.h> can define types winningly.  *//*
 *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
 */__fd__advise__cmd__file__mode__oflag/usr/include/unistd.h<bits/unistd_ext.h><bits/getopt_posix.h><bits/confname.h><bits/environments.h><bits/posix_opt.h>getentropyswabconst void *__restrict__void *__restrict__cryptfdatasynccopy_file_range__off64_t *syscallsbrkbrkftruncate64ftruncatetruncate64truncategetdtablesizegetpagesizesyncgethostidsyncfsfsyncgetpasschrootdaemonsetusershellendusershellgetusershellacctprofilunsigned short *revokevhangupsetdomainnamegetdomainnamesethostidsethostnamegethostnamesetlogingetlogin_rgetlogintcsetpgrptcgetpgrprmdirunlinkatunlinkreadlinkatsymlinkatreadlinksymlinklinkatlinkttyslotisattyttyname_rttynamevforkforksetresgidsetresuidgetresgid__gid_t *unsigned int *getresuid__uid_t *setegidsetregidsetgidseteuidsetreuidsetuidgroup_membergetgroups__gid_t[]unsigned int[]getegidgetgidgeteuidgetuidgetsidsetsidsetpgrpsetpgidgetpgid__getpgidgetpgrpgetppidgetpidconfstrsysconffpathconfpathconf_exitniceexecvpechar *constchar *const[]char *[]execlpexecvpexeclexecleexecvfexecveexecvedup3dup2dupgetwdget_current_dir_namegetcwdfchdirchdirfchownatlchownfchownchownpauseusleepualarmsleepalarmpipe2int[2]pipepwrite64pread64pwritepreadcloselseek64lseekfaccessateaccesseuidaccessaccessenviron__environTEMP_FAILURE_RETRY(expression)(__extension__ ({ long int __result; do __result = (long int) (expression); while (__result == -1L && errno == EINTR); __result; }))L_XTNDL_INCRL_SETSTDERR_FILENOSTDOUT_FILENOSTDIN_FILENO_XOPEN_LEGACY_XOPEN_ENH_I18N_XOPEN_UNIX_XOPEN_XPG4_XOPEN_XPG3_XOPEN_XPG2_XOPEN_XCU_VERSION_XOPEN_VERSION_POSIX2_LOCALEDEF__POSIX2_THIS_VERSION_POSIX2_SW_DEV_POSIX2_C_DEV_POSIX2_C_BIND_POSIX2_C_VERSION_POSIX2_VERSION_POSIX_VERSION_UNISTD_Hdefined __USE_XOPEN2Kdefined __USE_POSIX199506defined __USE_POSIX199309defined __USE_UNIX98defined __USE_XOPEN || defined __USE_XOPEN2Kdefined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K__intptr_t_defined__socklen_t_defined_STDIO_Hdefined __USE_MISC && !defined L_SETdefined __USE_UNIX98 || defined __USE_XOPEN2K8(defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8defined __USE_MISC || defined __USE_XOPEN_EXTENDEDdefined __USE_MISCdefined __USE_MISC || (defined __USE_XOPEN && !defined __USE_XOPEN2K)defined __USE_MISC || !defined __USE_XOPEN2Kdefined __USE_POSIX199309 \(defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \(defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCKdefined __USE_POSIX199309 || defined __USE_UNIX98defined __USE_XOPEN && !defined __USE_XOPEN2Kdefined __USE_UNIX98 && !defined __USE_XOPEN2K__USE_FORTIFY_LEVEL > 0 && defined __fortify_function(1, 2)(2, 3)(1, 3)(2, 4)/* unistd.h  *//* System-specific extensions.  *//* Define some macros helping to catch buffer overflows.  *//* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
   success or -1 on error.  *//* Unix98 requires this function to be declared here.  In other
   standards it is in <pthread.h>.  *//* Return the name of the current user.  *//* Return the name of the controlling terminal.  *//* Prior to Issue 6, the Single Unix Specification required these
   prototypes to appear in this header.  They are also found in
   <stdio.h>.  *//* Swab pairs bytes in the first N bytes of the area pointed to by
   FROM and copy the result to TO.  The value of TO must not be in the
   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
   is without partner.  *//* One-way hash PHRASE, returning a string suitable for storage in the
   user database.  SALT selects the one-way function to use, and
   ensures that no two users' hashes are the same, even if they use
   the same passphrase.  The return value points to static storage
   which will be overwritten by the next call to crypt.  *//* Use POSIX199309 *//* Synchronize at least the data part of a file with the underlying
   media.  *//* __USE_GNU *//* Copy LENGTH bytes from INFD to OUTFD.  *//* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
   set to EINTR.  *//* Use misc and F_LOCK not already defined.  *//* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  *//* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  *//* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  *//* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  *//* Use POSIX.1b || X/Open Unix || XPG6.  *//* Truncate the file FD is open on to LENGTH bytes.  *//* Use X/Open Unix || POSIX 2008.  *//* Truncate FILE to LENGTH bytes.  *//* Use misc || X/Open Unix.  *//* Return the maximum number of file descriptors
   the current process could possibly have.  *//* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  *//* Make all changes done to all files actually appear on disk.  *//* Return identifier for the current host.  *//* Make all changes done to all files on the file system associated
   with FD actually appear on disk.  *//* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Use misc || X/Open.  *//* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  *//* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  *//* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  *//* Rewind and re-read the file.  *//* Discard cached info.  *//* Successive calls return the shells listed in `/etc/shells'.  *//* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  *//* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  *//* Revoke the access of all descriptors currently open on FILE.  *//* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  *//* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  *//* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  *//* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  *//* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  *//* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  *//* Set the login name returned by `getlogin'.  *//* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Return the login name of the user.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Set the foreground process group ID of FD set PGRP_ID.  *//* Return the foreground process group ID of FD.  *//* Remove the directory PATH.  *//* Remove the link NAME relative to FD.  *//* Remove the link NAME.  *//* Like readlink but a relative PATH is interpreted relative to FD.  *//* Like symlink but a relative path in TO is interpreted relative to TOFD.  *//* Use POSIX.1-2001.  *//* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  *//* Make a symbolic link to FROM named TO.  *//* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  *//* Make a link to FROM named TO.  *//* Return the index into the active-logins file (utmp) for
   the controlling terminal.  *//* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  *//* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  *//* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  *//* Use misc or XPG < 7. *//* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  *//* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  *//* Set the real group ID, effective group ID, and saved-set group ID,
   of the calling process to RGID, EGID, and SGID, respectively.  *//* Set the real user ID, effective user ID, and saved-set user ID,
   of the calling process to RUID, EUID, and SUID, respectively.  *//* Fetch the real group ID, effective group ID, and saved-set group ID,
   of the calling process.  *//* Fetch the real user ID, effective user ID, and saved-set user ID,
   of the calling process.  *//* Set the effective group ID of the calling process to GID.  *//* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  *//* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  *//* Set the effective user ID of the calling process to UID.  *//* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  *//* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  *//* Return nonzero iff the calling process is in group GID.  *//* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  *//* Get the effective group ID of the calling process.  *//* Get the real group ID of the calling process.  *//* Get the effective user ID of the calling process.  *//* Get the real user ID of the calling process.  *//* Return the session ID of the given process.  *//* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  *//* Use misc or X/Open.  *//* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  *//* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   GNU provides the POSIX.1 function.  *//* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  *//* Get the process group ID of process PID.  *//* Get the process group ID of the calling process.  *//* Get the process ID of the calling process's parent.  *//* Get the process ID of the calling process.  *//* Get the value of the string-valued system variable NAME.  *//* Get the value of the system variable NAME.  *//* Get file-specific configuration about descriptor FD.  *//* Get file-specific configuration information about PATH.  *//* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  *//* Terminate program execution with the low-order 8 bits of STATUS.  *//* Add INC to priority of the current process.  *//* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  *//* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  *//* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  *//* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  *//* Execute PATH with arguments ARGV and environment from `environ'.  *//* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  *//* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  *//* NULL-terminated array of "NAME=VALUE" environment variables.  *//* Duplicate FD to FD2, closing FD2 and making it open on the same
   file while setting flags according to FLAGS.  *//* Duplicate FD to FD2, closing FD2 and making it open on the same file.  *//* Duplicate FD, returning a new file descriptor on the same file.  *//* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  *//* Return a malloc'd string containing the current directory name.
   If the environment variable `PWD' is set, and its value is correct,
   that value is used.  *//* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  *//* Change the process's working directory to the one FD is open on.  *//* Change the process's working directory to PATH.  *//* Use GNU.  *//* Change the owner and group of FILE relative to the directory FD is open
   on.  *//* Use X/Open Unix.  *//* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  *//* Change the owner and group of the file that FD is open on.  *//* Change the owner and group of FILE.  *//* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  *//* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  *//* Same as pipe but apply flags passed in FLAGS to the new file
   descriptors.  *//* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  *//* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.  *//* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.  *//* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  *//* Old BSD names for the same constants; just for compatibility.  *//* Seek to next hole.  *//* Seek to next data.  *//* <stdio.h> has the same definitions.  *//* Values for the WHENCE argument to lseek.  *//* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  *//* An alias for `euidaccess', used by some other systems.  *//* Test for access to NAME using the effective UID and GID
   (as normal file operations use).  *//* Test for access to NAME using the real UID and real GID.  *//* X/Open *//* The Single Unix specification says that some more types are
   available here.  *//* All functions that are not declared anywhere else.  *//* Standard error output.  *//* Standard output.  *//* Standard input.  *//* Standard file descriptors.  *//* Get the environment definitions from Unix98.  *//* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   *//* The legacy interfaces are also available.  *//* The enhanced internationalization capabilities according to XPG4.2
   are present.  *//* The X/Open Unix extensions are available.  *//* We are compatible with the old published standards as well.  *//* Commands and utilities from XPG4 are available.  *//* X/Open version number to which the library conforms.  It is selectable.  *//* If defined, the implementation supports the
   creation of locales with the localedef utility.  *//* If defined, the implementation supports the
   Software Development Utilities Option.  *//* If defined, the implementation supports the
   C Language Development Utilities Option.  *//* If defined, the implementation supports the
   C Language Bindings Option.  *//* This symbol was required until the 2001 edition of POSIX.  *//* The utilities on GNU systems also correspond to this version.  *//* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of December 2001.  *//* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  *//* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  *//*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */__salt__fildes__infd__pinoff__outfd__poutoff__sysno__delta__addr__prompt__path__nochdir__noclose__name__sample_buffer__scale__id__name_len__pgrp_id__flag__tofd__fromfd__buflen__rgid__egid__sgid__ruid__euid__suid__gid__uid__pgid__status__inc__argv__envp__fd2__group__useconds__interval__seconds__pipedes__nbytes__whence/home/tanteikg/QCVE/sources/bitcoin/src/span.h<assert.h><cstddef>const Span<unsigned long>const Span<unsigned long> &Span<unsigned long> &const Span<unsigned int>const Span<unsigned int> &Span<unsigned int> &const Span<unsigned short>const Span<unsigned short> &Span<unsigned short> &const Span<unsigned char>const Span<unsigned char> &Span<unsigned char> &const Span<byte>const Span<byte> &Span<byte> &(unnamed deduction guide)const Span<O>const Span<O> &Span<O> &const Span<C>const Span<C> &Span<C> &CC[]C(&)[]const Span<const char>const Span<const char> &Span<const char> &const Span<const byte>const Span<const byte> &Span<const byte> &const Span<const unsigned char>const Span<const unsigned char> &Span<const unsigned char> &SpanVV &&MakeUCharSpanUCharSpanCastUCharCastconst byteconst byte *byte *MakeWritableByteSpanMakeByteSpansize_bytesAsWritableBytesAsBytesAsBytePtrSpanPopBackSpan<T> &T &&T[]T(&)[]EndOrSizeC *subspanconst Span<C> *Span<C> *size() >= offsetC &const Vconst V &V &m_datam_sizeOSpan<C>is_Span<T>is_Span_int<Span<T>>is_Span_int<T>SPAN_ATTR_LIFETIMEBOUNDASSERT_IF_DEBUG(x)CONSTEXPR_IF_NOT_DEBUGconstexprBITCOIN_SPAN_HDEBUGdefined(__clang__)__has_attribute(lifetimebound)size > 0size() >= countsize() >= offset + countsize() > possize() > 0end >= begin// BITCOIN_SPAN_H/** Like the Span constructor, but for (const) unsigned char member types only. Only works for (un)signed char containers. */// Helper function to safely convert a Span to a Span<[const] unsigned char>.// Helper functions to safely cast to unsigned char pointers.// From C++20 as_bytes and as_writeable_bytes//! Where possible, please use the safer AsBytes helpers.//! Convert a data pointer to a std::byte data pointer./** Pop the last element off a span, and return a reference to that element. */// For (lvalue) references, supporting mutable output.// For the temporaries/rvalue references constructor, only supporting const output.// For the array constructor:// For the pointer/size based and iterator based constructor:// Deduction guides for Span/** Construct a Span for objects with .data() and .size() (std::string, std::array, std::vector, ...).
     *
     * This implements a subset of the functionality provided by the C++20 std::span range-based constructor.
     *
     * To prevent surprises, only Spans for constant value types are supported when passing in temporaries.
     * Note that this restriction does not exist when converting arrays or other Spans (see above).
     *//** Construct a Span from an array. This matches the corresponding C++20 std::span constructor. *//** Default assignment operator. *//** Default copy constructor. *//** Implicit conversion of spans between compatible types.
     *
     *  Specifically, if a pointer to an array of type O can be implicitly converted to a pointer to an array of type
     *  C, then permit implicit conversion of Span<O> to Span<C>. This matches the behavior of the corresponding
     *  C++20 std::span constructor.
     *
     *  For example this means that a Span<T> can be converted into a Span<const T>.
     *//** Construct a span from a begin and end pointer.
     *
     * This implements a subset of the iterator-based std::span constructor in C++20,
     * which is hard to implement without std::address_of.
     *//** Construct a span from a begin pointer and a size.
     *
     * This implements a subset of the iterator-based std::span constructor in C++20,
     * which is hard to implement without std::address_of.
     *//** A Span is an object that can refer to a contiguous sequence of objects.
 *
 * This file implements a subset of C++20's std::span.  It can be considered
 * temporary compatibility code until C++20 and is designed to be a
 * self-contained abstraction without depending on other project files. For this
 * reason, Clang lifetimebound is defined here instead of including
 * <attributes.h>, which also defines it.
 *
 * Things to be aware of when writing code that deals with Spans:
 *
 * - Similar to references themselves, Spans are subject to reference lifetime
 *   issues. The user is responsible for making sure the objects pointed to by
 *   a Span live as long as the Span is used. For example:
 *
 *       std::vector<int> vec{1,2,3,4};
 *       Span<int> sp(vec);
 *       vec.push_back(5);
 *       printf("%i\n", sp.front()); // UB!
 *
 *   may exhibit undefined behavior, as increasing the size of a vector may
 *   invalidate references.
 *
 * - One particular pitfall is that Spans can be constructed from temporaries,
 *   but this is unsafe when the Span is stored in a variable, outliving the
 *   temporary. For example, this will compile, but exhibits undefined behavior:
 *
 *       Span<const int> sp(std::vector<int>{1, 2, 3});
 *       printf("%i\n", sp.front()); // UB!
 *
 *   The lifetime of the vector ends when the statement it is created in ends.
 *   Thus the Span is left with a dangling reference, and using it is undefined.
 *
 * - Due to Span's automatic creation from range-like objects (arrays, and data
 *   types that expose a data() and size() member function), functions that
 *   accept a Span as input parameter can be called with any compatible
 *   range-like object. For example, this works:
 *
 *       void Foo(Span<const int> arg);
 *
 *       Foo(std::vector<int>{1, 2, 3}); // Works
 *
 *   This is very useful in cases where a function truly does not care about the
 *   container, and only about having exactly a range of elements. However it
 *   may also be surprising to see automatic conversions in this case.
 *
 *   When a function accepts a Span with a mutable element type, it will not
 *   accept temporaries; only variables or other references. For example:
 *
 *       void FooMut(Span<int> arg);
 *
 *       FooMut(std::vector<int>{1, 2, 3}); // Does not compile
 *       std::vector<int> baz{1, 2, 3};
 *       FooMut(baz); // Works
 *
 *   This is similar to how functions that take (non-const) lvalue references
 *   as input cannot accept temporaries. This does not work either:
 *
 *       void FooVec(std::vector<int>& arg);
 *       FooVec(std::vector<int>{1, 2, 3}); // Does not compile
 *
 *   The idea is that if a function accepts a mutable reference, a meaningful
 *   result will be present in that variable after the call. Passing a temporary
 *   is useless in that context.
 */// Copyright (c) 2018-2022 The Bitcoin Core developersaboffsetvspan/home/tanteikg/QCVE/sources/bitcoin/src/uint256.h<stdint.h><span.h><crypto/common.h>lambda [] type at line 130271, col. 58lambda [] type at line 130271, col. 58 &const lambda [] type at line 130271, col. 58const lambda [] type at line 130271, col. 58 &const lambda [] type at line 130271, col. 58 *lambda [] type at line 130271, col. 58 *uint256Srvconst base_blob<256U>const base_blob<256U> &base_blob<256U> &const base_blob<160U>const base_blob<160U> &base_blob<160U> &const base_blob<BITS>const base_blob<BITS> &base_blob<BITS> &uint160 &uint160 &&const uint160const uint160 &uint160uint160 *StreamStream &base_blob<BITS> *Unserializeconst base_blob<BITS> *SerializeGetUint64ToStringSetHexGetHexCompareSetNullIsNullbase_blobvch.size() == WIDTH./uint256.huint256 &uint256 &&const uint256const uint256 &uint256uint256 *base_blob<BITS>BITSWIDTHONEZEROSanity checkBITCOIN_UINT256_H// BITCOIN_UINT256_H/* uint256 from std::string.
 * This is a separate function because the constructor uint256(const std::string &str) can result
 * in dangerously catching uint256(0) via std::string(const char*).
 *//* uint256 from const char *.
 * This is a separate function because the constructor uint256(const char*) can result
 * in dangerously catching uint256(0).
 *//** 256-bit opaque blob.
 * @note This type is called uint256 for historical reasons only. It is an
 * opaque blob of 256 bits and has no integer operations. Use arith_uint256 if
 * those are required.
 *//** 160-bit opaque blob.
 * @note This type is called uint160 for historical reasons only. It is an opaque
 * blob of 160 bits and has no integer operations.
 *//* constructor for constants between 1 and 255 *//* construct 0 value by default *//** Template base class for fixed-sized opaque blobs. */// Copyright (c) 2009-2022 The Bitcoin Core developersvchpsz/home/tanteikg/QCVE/sources/bitcoin/src/prevector.h<string.h>unsigned char &const unsigned char &const const_iteratorconst prevector<N, T, Size, Diff>const prevector<N, T, Size, Diff> *prevector<N, T, Size, Diff> *allocated_memoryconst prevector<N, T, Size, Diff> &prevector<N, T, Size, Diff> &b1b2e1~prevectorindirect_contentsindirectnew_sizeArgs &&pendpresize_uninitializedInputIteratorptrcur_sizeincreaseprevector<N, T, Size, Diff> &&prevectoritem_ptrchange_capacity_union.indirect_contents.indirectnew_indirectsrcdstconst char[34]char[34]./prevector.hconst char[14]char[14]188new_capacity192is_directindirect_ptrdirect_ptrdirectconst_reverse_iterator &const const_iterator *const_iterator *const_iterator &reverse_iterator &iterator &const iterator *iterator *prevector<N, T, Size, Diff>SizeDiffdirect_or_indirect_union_sizechar[]alignof(char*)value_type T cannot have more restrictive alignment requirement than pointersizeof(char*)size_type cannot have more restrictive alignment requirement than pointerBITCOIN_PREVECTOR_Hpack(push, 1)pack(pop)// BITCOIN_PREVECTOR_H// representation (with capacity N and size <= N).// necessary to switch to the (more efficient) directly allocated// prevector with size <= N and capacity > N. A shrink_to_fit() call is// size and capacity > N, the result may be a still indirectly allocated// that when starting with an indirectly allocated prevector with// Erase is not allowed to the change the object's capacity. That means// If size < new_size, the added elements must be initialized explicitly.// resize_uninitialized changes the size of the prevector but does not initialize it./* FIXME: Because malloc/realloc here won't call new_handler if allocation fails, assert
                    success. These should instead use an allocator or new/delete so that handlers
                    are called as necessary, but performance would be slightly degraded by doing so. *//** Implements a drop-in replacement for std::vector<T> which stores up to N
 *  elements directly (without heap allocation). The types Size and Diff are
 *  used to store element counts, and can be any unsigned + signed type.
 *
 *  Storage layout is either:
 *  - Direct allocation:
 *    - Size _size: the number of used elements (between 0 and N)
 *    - T direct[N]: an array of N elements of type T
 *      (only the first _size are initialized).
 *  - Indirect allocation:
 *    - Size _size: the number of used elements plus N + 1
 *    - Size capacity: the number of allocated elements
 *    - T* indirect: a pointer to an array of capacity elements of type T
 *      (only the first _size are initialized).
 *
 *  The data type T must be movable by memmove/realloc(). Once we switch to C++,
 *  move constructors can be used instead.
 */// Copyright (c) 2015-2022 The Bitcoin Core developersxptr_/home/tanteikg/QCVE/sources/bitcoin/src/random.h<chrono><uint256.h><crypto/chacha20.h>RandomInitRandom_SanityCheckGetOSRandShuffleIRR &&RandAddEventconst uint32_tRandAddPeriodicGetStrongRandBytesGetRandHashGetExponentialRandmax.count() > 0./random.hconst char[11]char[11]93DGetRandomDurationGetRandGetRand only supports up to uint64_tT must be integralGetRandInternalGetRandBytesFastRandomContext *std::numeric_limits<uint64_t>::max()rand_uniform_durationChronoTprand_uniform_delayconst Tpconst Tp &Tp &randboolrand256rand32randbytesrandrangerange204const char[67]char[67]unsigned long FastRandomContext::randrange(unsigned long) noexceptbitsretrandbitsuint64_t{0}~uint64_t{0}rand64unsigned char[8]bufFastRandomContext &FastRandomContext &&const FastRandomContextconst FastRandomContext &FastRandomContextFillBitBufferRandomSeedbitbuf_sizebitbufrngrequires_seedNUM_OS_RANDOM_BYTES..(*const)(..)GetRandMillisGetRandMicrosBITCOIN_RANDOM_H// BITCOIN_RANDOM_H/**
 * Initialize global RNG state and log any CPU features that are used.
 *
 * Calling this function is optional. RNG state will be initialized when first
 * needed if it is not called.
 *//** Check that OS randomness is available and returning the requested number
 * of bytes.
 *//** Get 32 bytes of system entropy. Do not use this in application code: use
 * GetStrongRandBytes instead.
 *//* Number of random bytes returned by GetOSRand.
 * When changing this constant make sure to change all call sites, and make
 * sure that the underlying OS APIs for all platforms support the number.
 * (many cap out at 256 bytes).
 *//** More efficient than using std::shuffle on a FastRandomContext.
 *
 * This is more efficient as std::shuffle will consume entropy in groups of
 * 64 bits at the time and throw away most.
 *
 * This also works around a bug in libstdc++ std::shuffle that may cause
 * type::operator=(type&&) to be invoked on itself, which the library's
 * debug mode detects and panics on. This is a known issue, see
 * https://stackoverflow.com/questions/22915325/avoiding-self-assignment-in-stdshuffle
 */// Compatibility with the UniformRandomBitGenerator concept/* interval [0..0] *//* interval (range..0] *//* interval [0..range) *//** Generate a uniform random duration in the range from 0 (inclusive) to range (exclusive). *//** Return the time point advanced by a uniform random duration. *//** Generate a random boolean. *//** generate a random uint256. *//** Generate a random 32-bit integer. *//** Generate random bytes. *//** Generate a random integer in the range [0..range).
     * Precondition: range > 0.
     *//** Generate a random (bits)-bit integer. *//** Generate a random 64-bit integer. *//** Move a FastRandomContext. If the original one is used again, it will be reseeded. */// Do not permit copying a FastRandomContext (move it, or create a new one to get reseeded)./** Initialize with explicit seed (only for testing) *//**
 * Fast randomness source. This is seeded once with secure random data, but
 * is completely deterministic and does not gather more entropy after that.
 *
 * This class is not thread-safe.
 *//**
 * Gathers entropy from the low bits of the time at which events occur. Should
 * be called with a uint32_t describing the event at the time an event occurs.
 *
 * Thread-safe.
 *//**
 * Gather entropy from various expensive sources, and feed them to the PRNG state.
 *
 * Thread-safe.
 *//**
 * Gather entropy from various sources, feed it into the internal PRNG, and
 * generate random data using it.
 *
 * This function will cause failure whenever the OS RNG fails.
 *
 * Thread-safe.
 *//**
 * Return a timestamp in the future sampled from an exponential distribution
 * (https://en.wikipedia.org/wiki/Exponential_distribution). This distribution
 * is memoryless and should be used for repeated network events (e.g. sending a
 * certain type of message) to minimize leaking information to observers.
 *
 * The probability of an event occurring before time x is 1 - e^-(x/a) where a
 * is the average interval between events.
 * */// call site to specify the type of the return value.// type than the function argument. So std::common_type is used to force the// is dangerous, because the desired return value generally has a different// Having the compiler infer the template argument from the function argument/** Generate a uniform random duration in the range [0..max). Precondition: max.count() > 0 *//** Generate a uniform random integer of type T in the range [0..nMax)
 *  nMax defaults to std::numeric_limits<T>::max()
 *  Precondition: nMax > 0, T is an integral type, no larger than uint64_t
 *//** Generate a uniform random integer in the range [0..range). Precondition: range > 0 *//**
 * Generate random data via the internal PRNG.
 *
 * These functions are designed to be fast (sub microsecond), but do not necessarily
 * meaningfully add entropy to the PRNG state.
 *
 * Thread-safe.
 *//**
 * Overall design of the RNG and entropy sources.
 *
 * We maintain a single global 256-bit RNG state for all high-quality randomness.
 * The following (classes of) functions interact with that state by mixing in new
 * entropy, and optionally extracting random output from it:
 *
 * - The GetRand*() class of functions, as well as construction of FastRandomContext objects,
 *   perform 'fast' seeding, consisting of mixing in:
 *   - A stack pointer (indirectly committing to calling thread and call stack)
 *   - A high-precision timestamp (rdtsc when available, c++ high_resolution_clock otherwise)
 *   - 64 bits from the hardware RNG (rdrand) when available.
 *   These entropy sources are very fast, and only designed to protect against situations
 *   where a VM state restore/copy results in multiple systems with the same randomness.
 *   FastRandomContext on the other hand does not protect against this once created, but
 *   is even faster (and acceptable to use inside tight loops).
 *
 * - The GetStrongRand*() class of function perform 'slow' seeding, including everything
 *   that fast seeding includes, but additionally:
 *   - OS entropy (/dev/urandom, getrandom(), ...). The application will terminate if
 *     this entropy source fails.
 *   - Another high-precision timestamp (indirectly committing to a benchmark of all the
 *     previous sources).
 *   These entropy sources are slower, but designed to make sure the RNG state contains
 *   fresh data that is unpredictable to attackers.
 *
 * - RandAddPeriodic() seeds everything that fast seeding includes, but additionally:
 *   - A high-precision timestamp
 *   - Dynamic environment data (performance monitoring, ...)
 *   - Strengthen the entropy for 10 ms using repeated SHA512.
 *   This is run once every minute.
 *
 * On first use of the RNG (regardless of what function is called first), all entropy
 * sources used in the 'slow' seeder are included, but also:
 * - 256 bits from the hardware RNG (rdseed or rdrand) when available.
 * - Dynamic environment data (performance monitoring, ...)
 * - Static environment data
 * - Strengthen the entropy for 100 ms using repeated SHA512.
 *
 * When mixing in new entropy, H = SHA512(entropy || old_rng_state) is computed, and
 * (up to) the first 32 bytes of H are produced as output, while the last 32 bytes
 * become the new RNG state.
*/nMaxent32fromseedfDeterministicevent_infobytesaverage_interval/usr/include/c++/9/bits/atomic_base.h<bits/atomic_lockfree_defines.h>kill_dependencyatomic_signal_fencealways_inline__atomic_signal_fenceatomic_thread_fence__cmpexch_failure_order65535__memory_order_mask4294901760__memory_order_modifier_mask__cmpexch_failure_order2memory_order_acq_relmemory_order_acquirememory_order_releasememory_order_relaxedoperator&operator|fetch_subfetch_addcompare_exchange_strong__pointer_type &_PTp_PTp *_PTp *&loadstoreis_lock_freeoperator _PTp *__atomic_base__atomic_base<_PTp *> &const __atomic_base<_PTp *>const __atomic_base<_PTp *> &~__atomic_base_M_type_size_S_initmemory_order_seq_cstvolatile atomic_flagvolatile atomic_flag *atomic_flag *__atomic_clearvolatile __atomic_flag_basevolatile __atomic_flag_base *__atomic_flag_base *volatile __atomic_flag_data_typevolatile __atomic_flag_data_type *bool *__b != memory_order_consume__b != memory_order_acquire__b != memory_order_acq_rel__atomic_flag_data_type *test_and_set__atomic_test_and_setatomic_flagatomic_flag &const atomic_flagconst atomic_flag &~atomic_flag__atomic_flag_base &__atomic_flag_base &&const __atomic_flag_baseconst __atomic_flag_base &fetch_xorfetch_orfetch_and__int_type &_ITp_ITp &volatile __atomic_base<_ITp>volatile __atomic_base<_ITp> *__atomic_base<_ITp> *__b2__atomic_compare_exchange_n__b2 != memory_order_release__b2 != memory_order_acq_rel__b2 <= __b1compare_exchange_weak__atomic_exchange_nconst volatile __atomic_base<_ITp>const volatile __atomic_base<_ITp> *__atomic_load_n__b != memory_order_releaseconst __atomic_base<_ITp>const __atomic_base<_ITp> *__atomic_store_n__atomic_is_lock_freeconst volatile __int_typeconst __int_typeoperator^=operator|=operator&=__mod__p1__p2__m1__m2operator _ITp__atomic_base<_ITp> &const __atomic_base<_ITp> &__atomic_base<_PTp *>__pointer_type__atomic_flag_base__atomic_flag_data_type__atomic_base<_ITp>__int_type__memory_order_modifier0x0ffff0xffff0000__memory_order_hle_acquire655360x10000__memory_order_hle_release1310720x20000memory_ordermemory_order_consumeatomic<_Tp *>_S_alignmentatomic<_Tp>_IntTp_M_iATOMIC_FLAG_INIT{ 0 }ATOMIC_VAR_INIT(_VI){ _VI }_GLIBCXX_ATOMIC_BASE_H_GLIBCXX_ALWAYS_INLINE__GCC_ATOMIC_TEST_AND_SET_TRUEVAL == 1__GCC_ATOMIC_TEST_AND_SET_TRUEVAL/// @} group atomics// Produce a fake, minimally aligned pointer.// Requires __pointer_type convertible to _M_p.// Factored out to facilitate explicit specialization./// Partial specialization for pointer types.// Use a fake, minimally aligned pointer.// Requires __int_type convertible to _M_i.// memory access expect.// 8 bytes, since that is what GCC built-in functions for atomic// NB: Assuming _ITp is an integral scalar type that is 1, 2, 4, or// atomic_wchar_t  wchar_t// atomic_char32_t char32_t// atomic_char16_t char16_t// atomic_char8_t  char8_t// atomic_ullong   unsigned long long// atomic_llong    long long// atomic_ulong    unsigned long// atomic_long     long// atomic_uint     unsigned int// atomic_int      int// atomic_ushort   unsigned short// atomic_short    short// atomic_uchar    unsigned char// atomic_schar    signed char// atomic_char     char// atomic_bool     bool// For each of the integral types, define atomic_[integral type] struct/// Base class for atomic integrals.// Conversion to ATOMIC_FLAG_INIT./// atomic_flag/**
   *  @brief Base type for atomic_flag.
   *
   *  Base type is POD with data, allowing atomic_flag to derive from
   *  it and meet the standard layout type requirement. In addition to
   *  compatibility with a C interface, this allows different
   *  implementations of atomic_flag to use the same atomic operation
   *  functions, via a standard conversion to the __atomic_flag_base
   *  argument.
  *//* The target's "set" value for test-and-set may not be exactly 1.  */// Base types for atomics./// kill_dependency// Drop release ordering as per [atomics.types.operations.req]/21/// Enumeration for memory_order/**
   * @defgroup atomics Atomics
   *
   * Components for performing atomic operations.
   * @{
   *//** @file bits/atomic_base.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{atomic}
 */// -*- C++ -*- header./home/tanteikg/QCVE/sources/bitcoin/src/serialize.h<prevector.h><set><memory><compat/endian.h>GetSerializeSizeManyGetSerializeSizeWriteCompactSizeCSizeComputer &SerWriteTypeType &&FnFn &&SerReadSerReadWriteManyArgArg &&UnserializeManyconst Argconst Arg &Arg &SerializeManyunique_ptr<const T, default_delete<const T>> &const unique_ptr<const T, default_delete<const T>>const unique_ptr<const T, default_delete<const T>> &shared_ptr<const T> &const shared_ptr<const T>const shared_ptr<const T> &set<K, Pred, A> &KPredAconst set<K, Pred, A>const set<K, Pred, A> &map<K, T, Pred, A> &const map<K, T, Pred, A>const map<K, T, Pred, A> &pair<K, T> &const pair<K, T>const pair<K, T> &vector<T, A> &Unserialize_implconst vector<T, A>const vector<T, A> &Serialize_implconst bool &prevector<N, T, uint32_t, int32_t> &const prevector<N, T, uint32_t, int32_t>const prevector<N, T, uint32_t, int32_t> &basic_string<C, char_traits<C>, allocator<C>> &const basic_string<C, char_traits<C>, allocator<C>>const basic_string<C, char_traits<C>, allocator<C>> &UsingFormatterReadVarIntModeWriteVarIntGetSizeOfVarIntchSizenSizeRet253non-canonical ReadCompactSize()"non-canonical ReadCompactSize()"const char[32]2540x10000u42949672960x100000000ULL33554432MAX_SIZEReadCompactSize(): size too large"ReadCompactSize(): size too large"ReadCompactSize255GetSizeOfCompactSizesizeof(unsigned char)std::numeric_limits<uint16_t>::max()sizeof(uint16_t)sizeof(unsigned char) + sizeof(uint16_t)4294967295std::numeric_limits<unsigned int>::max()sizeof(unsigned int)sizeof(unsigned char) + sizeof(unsigned int)sizeof(uint64_t)sizeof(unsigned char) + sizeof(uint64_t)unsigned char(&)[]char(&)[]uint64_t &int64_t &uint32_t &int32_t &signed int &uint16_t &unsigned short &int16_t &signed short &uint8_t &int8_t &signed char &const unsigned char[]const unsigned char(&)[]const char[]const char(&)[]Xconst Xconst X &X &ReadWriteAsHelperuint64_t *ser_readdata64ser_readdata32beuint32_t *ser_readdata32ser_readdata16beuint16_t *ser_readdata16uint8_t *ser_readdata8ser_writedata64ser_writedata32beser_writedata32ser_writedata16beser_writedata16ser_writedata8const CSizeComputerconst CSizeComputer &CSizeComputerCSizeComputer &&GetVersionconst CSizeComputer *CSizeComputer *seekformatternSize_nSizenVersionInallocated5000000MAX_VECTOR_ALLOCATEUnserVectorFormatter<Formatter> *Vector element size too largeelemSerCompactSizeWriter &CompactSizeWriter &&const CompactSizeWriterconst CompactSizeWriter &CompactSizeWriterCompactSizeWriter *LOSSYUChronoFormatter<U, LOSSY> *uCompactSizeFormatter<RangeCheck> *CompactSize only supports 64-bit integers and belowCompactSize only supported for unsigned integersRangeCheckCompactSize exceeds limit of type"CompactSize exceeds limit of type"I &BigEndianBytesCustomUintFormatter<Bytes, BigEndian> *Assigned type too smallconst uint64_tCustomUintFormatter value out of range"CustomUintFormatter value out of range"const char[39]char[39]Wrapper<Formatter, T> *const Wrapper<Formatter, T>const Wrapper<Formatter, T> *WrapperCheckVarIntModeCSerActionUnserialize &CSerActionUnserialize &&const CSerActionUnserializeconst CSerActionUnserialize &ForReadconst CSerActionUnserialize *CSerActionUnserialize *CSerActionSerialize &CSerActionSerialize &&const CSerActionSerializeconst CSerActionSerialize &const CSerActionSerialize *CSerActionSerialize *DefaultFormatter &DefaultFormatter &&const DefaultFormatterconst DefaultFormatter &deserialize_type &deserialize_type &&const deserialize_typeconst deserialize_type &VectorFormatter<Formatter>LimitedStringFormatter<Limit>LimitChronoFormatter<U, LOSSY>CompactSizeFormatter<RangeCheck>CustomUintFormatter<Bytes, BigEndian>VarIntFormatter<Mode>Wrapper<Formatter, T>CheckVarIntMode<Mode, I>VarIntModeDEFAULTNONNEGATIVE_SIGNEDSER_NETWORK1 << 0(1 << 0)SER_DISK1 << 1(1 << 1)SER_GETHASH1 << 2(1 << 2)CSerActionUnserializeCSerActionSerializeDefaultFormatterdeserialize_typen_inser_actionfnisosmitemrange_checkMAXm_objectdeserialize0x02000000CustomUintFormatter Bytes out of rangeWrapper needs an lvalue reference type TLIMITED_STRING(obj,n)Using<LimitedStringFormatter<n>>(obj)COMPACTSIZE(obj)Using<CompactSizeFormatter<true>>(obj)VARINT(obj)Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj)VARINT_MODE(obj,mode)Using<VarIntFormatter<mode>>(obj)SERIALIZE_METHODS(cls,obj)template<typename Stream> void Serialize(Stream& s) const { static_assert(std::is_same<const cls&, decltype(*this)>::value, "Serialize type mismatch"); Ser(s, *this); } template<typename Stream> void Unserialize(Stream& s) { static_assert(std::is_same<cls&, decltype(*this)>::value, "Unserialize type mismatch"); Unser(s, *this); } FORMATTER_METHODS(cls, obj)FORMATTER_METHODS(cls,obj)template<typename Stream> static void Ser(Stream& s, const cls& obj) { SerializationOps(obj, s, CSerActionSerialize()); } template<typename Stream> static void Unser(Stream& s, cls& obj) { SerializationOps(obj, s, CSerActionUnserialize()); } template<typename Stream, typename Type, typename Operation> static inline void SerializationOps(Type& obj, Stream& s, Operation ser_action)SER_WRITE(obj,code)::SerWrite(s, ser_action, obj, [&](Stream& s, const Type& obj) { code; })SER_READ(obj,code)::SerRead(s, ser_action, obj, [&](Stream& s, typename std::remove_const<Type>::type& obj) { code; })READWRITEAS(type,obj)(::SerReadWriteMany(s, ser_action, ReadWriteAsHelper<type>(obj)))READWRITE(__VA_ARGS__...)(::SerReadWriteMany(s, ser_action, __VA_ARGS__))BITCOIN_SERIALIZE_HCHAR_EQUALS_INT8// BITCOIN_SERIALIZE_H/** Pretend _nSize bytes are written, without specifying them. *//* ::GetSerializeSize implementations
 *
 * Computing the serialized size of objects is done through a special stream
 * object of type CSizeComputer, which only records the number of bytes written
 * to it.
 *
 * If your Serialize or SerializationOp method has non-trivial overhead for
 * serialization, it may be worthwhile to implement a specialized version for
 * CSizeComputer, which uses the s.seek() method to record bytes that would
 * be written instead.
 *//**
 * Support for SERIALIZE_METHODS and READWRITE macro.
 *//**
 * shared_ptr
 *//**
 * unique_ptr
 *//**
 * set
 *//**
 * map
 *//**
 * pair
 */// Limit size per read so bogus size value won't cause out of memory// due to std::vector's special casing for bool arguments.// std::vector<bool>::const_iterator does not result in a const bool&// A special case for std::vector<bool>, as dereferencing/**
 * vector
 *//**
 * prevector
 *//**
 * string
 *//** Default formatter. Serializes objects as themselves.
 *
 * The vector/prevector serialization code passes this to VectorFormatter
 * to enable reusing that logic. It shouldn't be needed elsewhere.
 *//**
 * If none of the specialized versions above matched, default to calling member function.
 *//**
 * vector
 * vectors of unsigned char are a special case and are intended to be serialized as a single opaque blob.
 *//**
 * prevector
 * prevectors of unsigned char are a special case and are intended to be serialized as a single opaque blob.
 *//**
 *  string
 *//**
 * Forward declarations
 */// X MiB of data to make us allocate X+5 Mib.// Instead, allocate in 5MiB batches, so that an attacker actually needs to provide// For DoS prevention, do not blindly allocate as much as the stream claims to contain./** Formatter to serialize/deserialize vector elements using another formatter
 *
 * Example:
 *   struct X {
 *     std::vector<uint64_t> v;
 *     SERIALIZE_METHODS(X, obj) { READWRITE(Using<VectorFormatter<VarInt>>(obj.v)); }
 *   };
 * will define a struct that contains a vector of uint64_t, which is serialized
 * as a vector of VarInt-encoded integers.
 *
 * V is not required to be an std::vector type. It works for any class that
 * exposes a value_type, size, reserve, emplace_back, back, and const iterators.
 */// Lossy deserialization does not make sense, so force Wnarrowing/** Formatter for integers in CompactSize format. *//** Serialization wrapper class for custom integers and enums.
 *
 * It permits specifying the serialized size (1 to 8 bytes) and endianness.
 *
 * Use the big endian mode for values that are stored in memory in native
 * byte order, but serialized in big endian notation. This is only intended
 * to implement serializers that are compatible with existing formats, and
 * its use is not recommended for new data structures.
 *//** Serialization wrapper class for integers in VarInt format. *//** Cause serialization/deserialization of an object to be done using a specified formatter class.
 *
 * To use this, you need a class Formatter that has public functions Ser(stream, const object&) for
 * serialization, and Unser(stream, object&) for deserialization. Serialization routines (inside
 * READWRITE, or directly with << and >> operators), can then use Using<Formatter>(object).
 *
 * This works by constructing a Wrapper<Formatter, T>-wrapped version of object, where T is
 * const during serialization, and non-const during deserialization, which maintains const
 * correctness.
 *//** Simple wrapper class to serialize objects using a formatter; used by Using(). *//**
 * Mode for encoding VarInts.
 *
 * Currently there is no support for signed encodings. The default mode will not
 * compile with signed values, and the legacy "nonnegative signed" mode will
 * accept signed values, but improperly encode and decode them if they are
 * negative. In the future, the DEFAULT mode could be extended to support
 * negative numbers in a backwards compatible way, and additional modes could be
 * added to support different varint formats (e.g. zigzag encoding).
 *//**
 * Variable-length integers: bytes are a MSB base-128 encoding of the number.
 * The high bit in each byte signifies whether another digit follows. To make
 * sure the encoding is one-to-one, one is subtracted from all but the last digit.
 * Thus, the byte sequence a[] with length len, where all but the last byte
 * has bit 128 set, encodes the number:
 *
 *  (a[len-1] & 0x7F) + sum(i=1..len-1, 128^i*((a[len-i-1] & 0x7F)+1))
 *
 * Properties:
 * * Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)
 * * Every integer has exactly one encoding
 * * Encoding does not depend on size of original integer type
 * * No redundancy: every (infinite) byte sequence corresponds to a list
 *   of encoded integers.
 *
 * 0:         [0x00]  256:        [0x81 0x00]
 * 1:         [0x01]  16383:      [0xFE 0x7F]
 * 127:       [0x7F]  16384:      [0xFF 0x00]
 * 128:  [0x80 0x00]  16511:      [0xFF 0x7F]
 * 255:  [0x80 0x7F]  65535: [0x82 0xFE 0x7F]
 * 2^32:           [0x8E 0xFE 0xFE 0xFF 0x00]
 *//**
 * Decode a CompactSize-encoded variable-length integer.
 *
 * As these are primarily used to encode the size of vector-like serializations, by default a range
 * check is performed. When used as a generic number encoding, range_check should be set to false.
 *//**
 * Compact Size
 * size <  253        -- 1 byte
 * size <= USHRT_MAX  -- 3 bytes  (253 + 2 bytes)
 * size <= UINT_MAX   -- 5 bytes  (254 + 4 bytes)
 * size >  UINT_MAX   -- 9 bytes  (255 + 8 bytes)
 */// char serialization forbidden. Use uint8_t or int8_t/**
 * Implement the Serialize and Unserialize methods by delegating to a single templated
 * static method that takes the to-be-(de)serialized object as a parameter. This approach
 * has the advantage that the constness of the object becomes a template parameter, and
 * thus allows a single implementation that sees the object as const for serializing
 * and non-const for deserializing, without casts.
 *//**
 * Implement the Ser and Unser methods needed for implementing a formatter (see Using below).
 *
 * Both Ser and Unser are delegated to a single static method SerializationOps, which is polymorphic
 * in the serialized/deserialized type (allowing it to be const when serializing, and non-const when
 * deserializing).
 *
 * Example use:
 *   struct FooFormatter {
 *     FORMATTER_METHODS(Class, obj) { READWRITE(obj.val1, VARINT(obj.val2)); }
 *   }
 *   would define a class FooFormatter that defines a serialization of Class objects consisting
 *   of serializing its val1 member using the default serialization, and its val2 member using
 *   VARINT serialization. That FooFormatter can then be used in statements like
 *   READWRITE(Using<FooFormatter>(obj.bla)).
 *///! Convert the reference base type to X, without changing constness or reference type.// primary actions// i.e. anything that supports .read(Span<std::byte>) and .write(Span<const std::byte>)// Templates for serializing to anything that looks like a stream,//////////////////////////////////////////////////////////////////*
 * Lowest-level serialization and conversion.
 *//**
 * Dummy data type to identify deserializing constructors.
 *
 * By convention, a constructor of a type T with signature
 *
 *   template <typename Stream> T::T(deserialize_type, Stream& s)
 *
 * is a deserializing constructor, which builds the type by
 * deserializing it from s. If T contains const fields, this
 * is likely the only way to do so.
 *//** Maximum amount of memory (in bytes) to allocate at once when deserializing vectors. *//**
 * The maximum size of a serialized object in bytes or number of elements
 * (for eg vectors) when the size is encoded as CompactSize.
 */tp/home/tanteikg/QCVE/sources/bitcoin/src/util/string.h<locale><util/spanparsing.h>PREFIX_LENconst array<uint8_t, PREFIX_LEN>const array<uint8_t, PREFIX_LEN> &array<uint8_t, PREFIX_LEN> &HasPrefixContainsNoNULstring_view &basic_string_view<char, char_traits<char>> &(__begin)(__end)lambda [] type at line 138101, col. 30lambda [] type at line 138101, col. 30 &&lambda [] type at line 138101, col. 30 &const lambda [] type at line 138101, col. 30const lambda [] type at line 138101, col. 30 &_FUNoperator std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> (*)(const std::string &)const lambda [] type at line 138101, col. 30 *lambda [] type at line 138101, col. 30 *- "- "MakeUnorderedListconst __normal_iterator<const basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const char(&)[2]char(&)[2]
"\n"Joinconst Cconst C &Sconst Sconst S &S &UnaryOptrue}const auto &RemovePrefixconst basic_string_view<char, char_traits<char>> &RemovePrefixViewTrimString 
	" \f\n\r\t\v"TrimStringViewstd::string::nposSplitStringReplaceAllBITCOIN_UTIL_STRING_H// BITCOIN_UTIL_STRING_H/**
 * Check whether a container begins with the given prefix.
 *//**
 * Locale-independent version of std::to_string
 *//**
 * Check if a string does not contain any embedded NUL (\0) characters
 *//**
 * Create an unordered multi-line list of items.
 *//**
 * Join all container items. Typically used to concatenate strings but accepts
 * containers with elements of any type.
 *
 * @param container The items to join
 * @param separator The separator
 * @param unary_op  Apply this operator to each item
 */// Copyright (c) 2019-2022 The Bitcoin Core developers/home/tanteikg/QCVE/sources/bitcoin/src/utilitemsprefixpatternseparatorssepseparatorunary_opin_outsubstitute/home/tanteikg/QCVE/sources/bitcoin/src/netaddress.h<util/string.h><util/strencodings.h><tinyformat.h><serialize.h><random.h><crypto/siphash.h><compat/compat.h><config/bitcoin-config.h>MaybeFlipIPv6toCJDNSconst CServiceconst CService &CService &const CSubNetconst CSubNet &CSubNet &const CNetAddrconst CNetAddr &CNetAddr &OnionToStringCServiceHash &const CServiceHashconst CServiceHash &CServiceHashCServiceHash &&const CServiceHash *CServiceHash *CSipHasher &const CSipHasherCNetAddr &&~CNetAddrCNetAddr *CNetAddrbip155_netaddress_sizeMAX_ADDRV2_SIZEAddress too long: %u > %u"Address too long: %u > %u"prevector<16U, unsigned char, unsigned int, signed int> &NET_IPV6const prevector<16U, unsigned char, unsigned int, signed int>const prevector<16U, unsigned char, unsigned int, signed int> &const array<unsigned char, 6UL>const array<unsigned char, 6UL> &array<unsigned char, 6UL> &NET_INTERNALADDR_INTERNAL_SIZEconst array<unsigned char, 12UL>const array<unsigned char, 12UL> &array<unsigned char, 12UL> &ADDR_IPV6_SIZE0x0UnserializeV2Streamuint8_t[16]unsigned char[16]V1_SERIALIZATION_SIZEserializeduint8_t(&)[16]unsigned char(&)[16]UnserializeV1StreamUnserializeV1Arrayconst unsigned char[16]const unsigned char(&)[16]const CNetAddr *BIP155Network::IPV6static_cast<uint8_t>(BIP155Network::IPV6)SerializeV2StreamSerializeV1StreamSerializeV1Arrayprefix_sizem_addr.size() == sizeof(arr)prefix_size + m_addr.size() == sizeof(arr)const char[29]char[29]./netaddress.h319const char[61]char[61]void CNetAddr::SerializeV1Array(unsigned char (&)[16]) constNET_IPV412sizeof(IPV4_IN_IPV6_PREFIX)const char[43]char[43]324sizeof(INTERNAL_IN_IPV6_PREFIX)330NET_ONIONNET_I2PNET_CJDNSNET_UNROUTABLENET_MAX340SetNetFromBIP155NetworkGetBIP155NetworkSetI2PSetTorIsRelayableGetIn6Addrin6_addr *const in6_addrconst in6_addr &in6_addr &GetReachabilityFromGetAddrBytesHasLinkedIPv4GetLinkedIPv4GetNetClassGetInAddrin_addr *ToStringAddrGetNetworkIsAddrV1CompatibleIsValidIsInternalIsRoutableIsLocalIsCJDNSIsI2PIsTorIsHeNetIsRFC6145IsRFC6052IsRFC4862IsRFC7343IsRFC4843IsRFC4380IsRFC4193IsRFC3964IsRFC3927IsRFC3849IsRFC5737IsRFC6598IsRFC2544IsRFC1918IsIPv6IsIPv4IsBindAnySetSpecialSetInternalSetLegacyIPv6CSubNet &&~CSubNetMatchCService &&~CServiceCService *CServiceOperationType &salt_k0salt_k1arrUsing<BigEndianFormatter<2>>(obj.port)portSerializationOpsUnserialize type mismatchconst CService *Serialize type mismatchconst sockaddr_in6const sockaddr_in6 &sockaddr_in6 &ToStringAddrPortGetKeySetSockAddrconst sockaddrconst sockaddr *sockaddr *GetSockAddrsocklen_t *GetPortconst sockaddr_inconst sockaddr_in &sockaddr_in &const in_addrconst in_addr &in_addr &SetIPBIP155NetworkIPV4IPV6TORV2TORV3I2PCJDNSNetworkm_salt_k1m_salt_k0validnetmasknetworkm_scope_idm_netm_addrI2P_SAM31_PORTADDR_CJDNS_SIZEADDR_I2P_SIZEADDR_TORV3_SIZEADDR_IPV4_SIZEINTERNAL_IN_IPV6_PREFIXunsigned char[6]0xFD1070x6B1360x880xC01350x870x24TORV2_IN_IPV6_PREFIX2160xD81260x7E2350xEB670x43IPV4_IN_IPV6_PREFIXunsigned char[12]0x000xFFADDRV2_FORMAT5368709120x20000000BITCOIN_NETADDRESS_Hdefined(HAVE_CONFIG_H)HAVE_CONFIG_H// BITCOIN_NETADDRESS_H// host order/** A combination of a network address (CNetAddr) and a (TCP) port *//**
     * Construct a single-host subnet.
     * @param[in] addr The sole address to be contained in the subnet, can also be non-IPv[46].
     *//**
     * Construct from a given network start and mask.
     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is
     * created.
     * @param[in] mask Network mask, must be of the same type as `addr` and not contain 0-bits
     * followed by 1-bits. Otherwise an invalid subnet is created.
     *//**
     * Construct from a given network start and number of bits (CIDR mask).
     * @param[in] addr Network start. Must be IPv4 or IPv6, otherwise an invalid subnet is
     * created.
     * @param[in] mask CIDR mask, must be in [0, 32] for IPv4 addresses and in [0, 128] for
     * IPv6 addresses. Otherwise an invalid subnet is created.
     *//**
     * Construct an invalid subnet (empty, `Match()` always returns false).
     *//// Is this value valid? (only used to signal parse errors)/// Netmask, in network byte order/// Network (base) address// will not be gossiped, but continue reading next addresses from the stream.// Mimic a default-constructed CNetAddr object which is !IsValid() and thus// ignore the address - unserialize as !IsValid().// If we receive an unknown BIP155 network id (from the future?) then// encoding). Unserialize as !IsValid(), thus ignoring them.// IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1// disk.// gossiped but could be coming from addrman, when unserializing from// Recognize NET_INTERNAL embedded in IPv6, such addresses are not// Do some special checks on IPv6 addresses./**
     * Unserialize from a ADDRv2 / BIP155 format.
     *//**
     * Unserialize from a pre-ADDRv2/BIP155 format from a stream.
     */// ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).// Use SetLegacyIPv6() so that m_net is set correctly. For example/**
     * Unserialize from a pre-ADDRv2/BIP155 format from an array.
     *
     * This function is only called from UnserializeV1Stream() and is a wrapper
     * for SetLegacyIPv6(); however, we keep it for symmetry with
     * SerializeV1Array() to have pairs of ser/unser functions and to make clear
     * that if one is altered, a corresponding reverse modification should be
     * applied to the other.
     */// serialize such addresses from addrman.// Serialize NET_INTERNAL as embedded in IPv6. We need to/**
     * Serialize as ADDRv2 / BIP155.
     *//**
     * Serialize in pre-ADDRv2/BIP155 format to a stream.
     */// Serialize ONION, I2P and CJDNS as all-zeros.// no default case, so the compiler can warn about missing cases/**
     * Serialize in pre-ADDRv2/BIP155 format to an array.
     *//**
     * Set `m_net` from the provided BIP155 network id and size after validation.
     * @retval true the network was recognized, is valid and `m_net` was set
     * @retval false not recognised (from future?) and should be silently ignored
     * @throws std::ios_base::failure if the network is one of the BIP155 founding
     * networks (id 1..6) with wrong address size.
     *//**
     * Get the BIP155 network id of this address.
     * Must not be called for IsInternal() objects.
     * @returns BIP155 network id, except TORV2 which is no longer supported.
     *//**
     * Maximum size of an address as defined in BIP155 (in bytes).
     * This is only the size of the address, not the entire CNetAddr object
     * when serialized.
     *//**
     * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).
     *//**
     * BIP155 network ids recognized by this software.
     *//**
     * Parse an I2P address and set this object to it.
     * @param[in] addr Address to parse, must be a valid C string, for example
     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.
     * @returns Whether the operation was successful.
     * @see CNetAddr::IsI2P()
     *//**
     * Parse a Tor address and set this object to it.
     * @param[in] addr Address to parse, must be a valid C string, for example
     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion.
     * @returns Whether the operation was successful.
     * @see CNetAddr::IsTor()
     *//**
     * Unserialize from a stream.
     *//**
     * Serialize to a stream.
     *//**
     * Whether this address should be relayed to other peers even if we can't reach it ourselves.
     *///! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).//! For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32./**
     * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.
     */// IPv6 Hurricane Electric - https://he.net (2001:0470::/36)// IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)// IPv6 well-known prefix for IPv4-embedded address (64:FF9B::/96)// IPv6 autoconfig (FE80::/64)// IPv6 ORCHIDv2 (2001:20::/28)// IPv6 ORCHID (deprecated) (2001:10::/28)// IPv6 Teredo tunnelling (2001::/32)// IPv6 unique local (FC00::/7)// IPv6 6to4 tunnelling (2002::/16)// IPv4 autoconfig (169.254.0.0/16)// IPv6 documentation address (2001:0DB8::/32)// IPv4 documentation addresses (192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24)// IPv4 ISP-level NAT (100.64.0.0/10)// IPv4 inter-network communications (198.18.0.0/15)// IPv4 private networks (10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12)// IPv6 address (not mapped IPv4, not Tor)// IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)// INADDR_ANY equivalent/**
     * Parse a Tor or I2P address and set this object to it.
     * @param[in] addr Address to parse, for example
     * pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion or
     * ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p.
     * @returns Whether the operation was successful.
     * @see CNetAddr::IsTor(), CNetAddr::IsI2P()
     *//**
     * Set from a legacy IPv6 address.
     * Legacy IPv6 address may be a normal IPv6 address, or another address
     * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy
     * `addr` encoding.
     *//**
     * Scope id if scoped/link-local IPV6 address.
     * See https://tools.ietf.org/html/rfc4007
     *//**
     * Network to which this address belongs.
     *//**
     * Raw representation of the network address.
     * In network byte order (big endian) for IPv4 and IPv6.
     *//**
 * Network address.
 *//// SAM 3.1 and earlier do not support specifying ports and force the port to 0./// Size of "internal" (NET_INTERNAL) address (in bytes)./// Size of CJDNS address (in bytes)./// Size of I2P address (in bytes)./// as used in BIP155, without the checksum and the version byte./// Size of TORv3 address (in bytes). This is the length of just the address/// Size of IPv6 address (in bytes)./// Size of IPv4 address (in bytes).// 0xFD + sha256("bitcoin")[0:5]./// fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses./// Such dummy IPv6 addresses are guaranteed to not be publicly routable as they/// The prefix comes from 0xFD + SHA256("bitcoin")[0:5]./// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155)./// Prefix of an IPv6 address when it contains an embedded "internal" address./// Prefix of an IPv6 address when it contains an embedded TORv2 address./// Prefix of an IPv6 address when it contains an embedded IPv4 address./// Dummy value to indicate the number of NET_* constants./// them in AddrMan to keep track of which DNS seeds were used./// A set of addresses that represent the hash of a string or FQDN. We use/// CJDNS/// I2P/// TOR (v2 or v3)/// IPv6/// IPv4/// Addresses from these networks are not publicly routable on the global Internet./**
 * A network type.
 * @note An address may belong to more than one network, for example `10.0.0.1`
 * belongs to both `NET_UNROUTABLE` and `NET_IPV4`.
 * Keep these sequential starting from 0 and `NET_MAX` as the last entry.
 * We have loops like `for (int i = 0; i < NET_MAX; ++i)` that expect to iterate
 * over all enum values and also `GetExtNetwork()` "extends" this enum by
 * introducing standalone constants starting from `NET_MAX`.
 *//**
 * A flag that is ORed into the protocol version to designate that addresses
 * should be serialized in (unserialized from) v2 format (BIP155).
 * Make sure that this does not collide with any of the values in `version.h`
 * or with `SERIALIZE_TRANSACTION_NO_WITNESS`.
 */ipv6Addrpaddraddrlenipv4Addripmaskpossible_bip155_netpipv6AddrscopepaddrPartnerpipv4Addripv6/home/tanteikg/QCVE/sources/bitcoin/src/netgroup.h<netaddress.h>~NetGroupManagerNetGroupManager &&GetMappedASGetGroupGetAsmapChecksumNetGroupManager *const vector<bool, allocator<bool>>vector<bool, allocator<bool>> &&vector<bool, allocator<bool>> &m_asmapBITCOIN_NETGROUP_H// BITCOIN_NETGROUP_H/** Compressed IP->ASN mapping, loaded from a file when a node starts.
     *
     * This mapping is then used for bucketing nodes in Addrman and for
     * ensuring we connect to a diverse set of peers in Connman. The map is
     * empty if no file was provided.
     *
     * If asmap is provided, nodes will be bucketed by AS they belong to, in
     * order to make impossible for a node to connect to several nodes hosted
     * in a single AS. This is done in response to Erebus attack, but also to
     * generally diversify the connections every node creates, especially
     * useful when a large fraction of nodes operate under a couple of cloud
     * providers.
     *
     * If a new asmap is provided, the existing addrman records are
     * re-bucketed.
     *
     * This is initialized in the constructor, const, and therefore is
     * thread-safe. *//**
     *  Get the autonomous system on the BGP path to address.
     *
     *  The ip->AS mapping depends on how asmap is constructed.
     *//**
     * Get the canonical identifier of the network group for address.
     *
     * The groups are assigned in a way where it should be costly for an attacker to
     * obtain addresses with many different group identifiers, even if it is cheap
     * to obtain addresses with the same identifier.
     *
     * @note No two connections will be attempted to addresses with the same network
     *       group.
     *//** Get a checksum identifying the asmap being used. *//**
 * Netgroup manager
 */// Copyright (c) 2021 The Bitcoin Core developersasmapaddress/home/tanteikg/QCVE/sources/bitcoin/src/script/script.h<climits><attributes.h>BuildScriptTsTs &&CheckMinimalPushconst vector<unsigned char, allocator<unsigned char>>const vector<unsigned char, allocator<unsigned char>> &vector<unsigned char, allocator<unsigned char>> &IsOpSuccessconst opcodetypeconst opcodetype &opcodetype &GetScriptOpvector<unsigned char, allocator<unsigned char>> *GetOpNameToByteVectorscriptnum_error &scriptnum_error &&const scriptnum_errorconst scriptnum_error &~scriptnum_errorscriptnum_error *scriptnum_errorCScriptWitness &CScriptWitness &&const CScriptWitnessconst CScriptWitness &~CScriptWitnessCScriptWitness *CScriptWitnessconst CScriptWitness *CScript &CScript &&const CScriptconst CScript &~CScriptCScript *CScriptprevector<28U, unsigned char, unsigned int, signed int> *IsUnspendableconst CScript *const prevector<28U, unsigned char, unsigned int, signed int>const prevector<28U, unsigned char, unsigned int, signed int> *OP_RETURN10000MAX_SCRIPT_SIZEHasValidOpsIsPushOnlyIsWitnessProgramIsPayToWitnessScriptHashIsPayToScriptHashGetSigOpCountEncodeOP_Nn >= 0 && n <= 16const char[18]char[18]./script/script.hstatic opcodetype CScript::EncodeOP_N(int)OP_081OP_1DecodeOP_Nopcode >= OP_1 && opcode <= OP_1696507static int CScript::DecodeOP_N(opcodetype)80OP_1 - 1(int)(OP_1 - 1)GetOpOP_PUSHDATA10xff0xffffuint8_t[2]unsigned char[2]_data77OP_PUSHDATA2sizeof(_data)uint8_t[4]unsigned char[4]78OP_PUSHDATA4const CScriptNumconst CScriptNum &CScriptNum &CScript::operator<<(): invalid opcode"CScript::operator<<(): invalid opcode"const char[38]char[38]CScriptNum &&CScriptNumCScriptNum *set_vch1280x800x80ULLserializeconst int64_tconst int64_t &negabsvalueunsigned char &&getvchconst CScriptNum *GetInt64getint2147483647std::numeric_limits<int>::max()-2147483648std::numeric_limits<int>::min()rhs == 0 || (rhs > 0 && m_value >= std::numeric_limits<int64_t>::min() + rhs) || (rhs < 0 && m_value <= std::numeric_limits<int64_t>::max() + rhs)-9223372036854775808const char[147]char[147]318const char[56]CScriptNum &CScriptNum::operator-=(const signed long &)rhs == 0 || (rhs > 0 && m_value <= std::numeric_limits<int64_t>::max() - rhs) || (rhs < 0 && m_value >= std::numeric_limits<int64_t>::min() - rhs)/home/tanteikg/QCVE/sources/bitcoin/src/scriptopcodepcopcodeRetvchRetrhs310CScriptNum &CScriptNum::operator+=(const signed long &)m_value != std::numeric_limits<int64_t>::min()const char[47]char[47]297const char[41]char[41]CScriptNum CScriptNum::operator-() constnDefaultMaxNumSizescript number overflow"script number overflow"1270x7fnon-minimally encoded script number"non-minimally encoded script number"const char[36]char[36]push_int64(OP_1 - 1)opcodetypeOP_FALSE0x4c0x4d0x4eOP_1NEGATE790x4fOP_RESERVED0x500x51OP_TRUEOP_2820x52OP_3830x53OP_4840x54OP_5850x55OP_6860x56OP_7870x57OP_80x58OP_9890x59OP_10900x5aOP_11910x5bOP_12920x5cOP_130x5dOP_14940x5eOP_15950x5fOP_160x60OP_NOP0x61OP_VER980x62OP_IF0x63OP_NOTIF0x64OP_VERIF0x65OP_VERNOTIF0x66OP_ELSE0x67OP_ENDIF0x68OP_VERIFY0x690x6aOP_TOALTSTACK0x6bOP_FROMALTSTACK0x6cOP_2DROP1090x6dOP_2DUP0x6eOP_3DUP0x6fOP_2OVER0x70OP_2ROT1130x71OP_2SWAP1140x72OP_IFDUP0x73OP_DEPTH0x74OP_DROP0x75OP_DUP1180x76OP_NIP1190x77OP_OVER0x78OP_PICK1210x79OP_ROLL0x7aOP_ROT1230x7bOP_SWAP1240x7cOP_TUCK1250x7dOP_CAT0x7eOP_SUBSTROP_LEFTOP_RIGHT1290x81OP_SIZE1300x82OP_INVERT1310x83OP_AND1320x84OP_OR1330x85OP_XOR1340x86OP_EQUALOP_EQUALVERIFYOP_RESERVED11370x89OP_RESERVED21380x8aOP_1ADD1390x8bOP_1SUB1400x8cOP_2MUL1410x8dOP_2DIV1420x8eOP_NEGATE1430x8fOP_ABS1440x90OP_NOT1450x91OP_0NOTEQUAL1460x92OP_ADD1470x93OP_SUB1480x94OP_MUL1490x95OP_DIV1500x96OP_MOD1510x97OP_LSHIFT1520x98OP_RSHIFT1530x99OP_BOOLAND1540x9aOP_BOOLOR1550x9bOP_NUMEQUAL1560x9cOP_NUMEQUALVERIFY1570x9dOP_NUMNOTEQUAL1580x9eOP_LESSTHAN1590x9fOP_GREATERTHAN1600xa0OP_LESSTHANOREQUAL1610xa1OP_GREATERTHANOREQUAL1620xa2OP_MIN1630xa3OP_MAX1640xa4OP_WITHIN1650xa5OP_RIPEMD1601660xa6OP_SHA11670xa7OP_SHA2561680xa8OP_HASH1601690xa9OP_HASH2561700xaaOP_CODESEPARATOR1710xabOP_CHECKSIG1720xacOP_CHECKSIGVERIFY1730xadOP_CHECKMULTISIG1740xaeOP_CHECKMULTISIGVERIFY1750xafOP_NOP10xb0OP_CHECKLOCKTIMEVERIFY1770xb1OP_NOP2OP_CHECKSEQUENCEVERIFY1780xb2OP_NOP3OP_NOP41790xb3OP_NOP51800xb4OP_NOP61810xb5OP_NOP71820xb6OP_NOP81830xb7OP_NOP91840xb8OP_NOP101850xb9OP_CHECKSIGADD1860xbaOP_INVALIDOPCODEstackMAX_OPCODEVALIDATION_WEIGHT_OFFSET50VALIDATION_WEIGHT_PER_SIGOP_PASSEDANNEX_TAGLOCKTIME_MAX0xFFFFFFFFULOCKTIME_THRESHOLD500000000MAX_STACK_SIZE1000MAX_PUBKEYS_PER_MULTI_A999MAX_PUBKEYS_PER_MULTISIGMAX_OPS_PER_SCRIPT201MAX_SCRIPT_ELEMENT_SIZE520BITCOIN_SCRIPT_SCRIPT_HCScriptBase// BITCOIN_SCRIPT_SCRIPT_H// Otherwise invoke CScript::operator<<.// If it is a CScript, extend ret with it. Move or copy the first element instead./** Build a script by concatenating other scripts, or any argument accepted by CScript::operator<<. *//** Test for OP_SUCCESSx opcodes as defined by BIP342. */// Some compilers complain without a default constructor// encoding them as a CScript that pushes them.// Note that this encodes the data elements being pushed, rather than// The default prevector::clear() does not release memory/**
     * Returns whether the script is guaranteed to fail at execution,
     * regardless of the initial stack. This allows outputs to be pruned
     * instantly when entering the UTXO set.
     *//** Check if the script contains valid OP_CODES *//** Called by IsStandardTx and P2SH/BIP62 VerifyScript (which makes it consensus-critical). *//**
     * Accurately count sigOps, including sigOps in
     * pay-to-script-hash transactions:
     *//**
     * Pre-version-0.6, Bitcoin always counted CHECKMULTISIGs
     * as 20 sigops. With pay-to-script-hash, that changed:
     * CHECKMULTISIGs serialized in scriptSigs are
     * counted more accurately, assuming they are of the form
     *  ... OP_N CHECKMULTISIG ...
     *//** Encode/decode small integers: *//** Delete non-existent operator to defend against future introduction */// e.g. via prevector// delete non-existent constructor to defend against future introduction/** Serialized script, used inside transaction inputs and outputs *//**
 * We use a prevector for the script to reduce the considerable memory overhead
 *  of vectors in cases where they normally contain a small number of small elements.
 * Tests in October 2015 showed use of this reduced dbcache memory usage by 23%
 *  and made an initial sync 13% faster.
 */// the result's msb and return a negative.// If the input vector's most significant byte is 0x80, remove it from//    converting to an integral.//    0x80 to it, since it will be subtracted and interpreted as a negative when//    - If the most significant byte is < 0x80 and the value is negative, add//    new 0x80 byte that will be popped off when converting to an integral.//    - If the most significant byte is >= 0x80 and the value is negative, push a//    new zero-byte to make the significant byte < 0x80 again.//    - If the most significant byte is >= 0x80 and the value is positive, push a// (big-endian).// is +-255, which encode to 0xff00 and 0xff80 respectively.// it would conflict with the sign bit. An example of this case// significant bit of the second-most-significant-byte is set// One exception: if there's more than one byte and the most// negative-zero encoding, 0x80.// then we're not minimal. Note how this test also rejects the// If the most-significant-byte - excluding the sign bit - is zero// number of bytes.// Check that the number is encoded with the minimum possible/**
 * Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.
 * The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],
 * but results may overflow (and are valid as long as they are not used in a subsequent
 * numeric operation). CScriptNum enforces those semantics by storing results as
 * an int64 and allowing out-of-range values to be returned as a vector of bytes but
 * throwing an exception if arithmetic is done or the result is interpreted as an integer.
 */// Maximum value that an opcode can be// Opcode added by BIP 342 (Tapscript)// expansion// crypto// numeric// bit logic// splice ops// stack ops// control// push value/** Script opcodes */// How much weight budget is added to the witness size (Tapscript only, see BIP 342).// Validation weight per passing signature (Tapscript only, see BIP 342).// has meanings independent of the script// and the first byte of the last element is 0x50, this last element is called annex, and// Tag for input annex. If there are at least two witness elements for a transaction input,// SEQUENCE_FINAL).// checking is disabled (by setting all input sequence numbers to// transaction with this lock time will never be valid unless lock time// Maximum nLockTime. Since a lock time indicates the last invalid timestamp, a// Tue Nov  5 00:53:20 1985 UTC// otherwise as UNIX timestamp.// Threshold for nLockTime: below this value it is interpreted as block number,// Maximum number of values on script interpreter stack// Maximum script length in bytes/** The limit of keys in OP_CHECKSIGADD-based scripts. It is due to the stack limit in BIP342. */// Maximum number of public keys per multisig// Maximum number of non-push operations per script// Maximum number of bytes pushable to the stackfRequireMinimalnMaxNumSizepbeginpendinputsinversionprogramscriptSigfAccuratepvchRet/home/tanteikg/QCVE/sources/bitcoin/src/primitives/transaction.h<numeric><script/script.h><consensus/amount.h>const GenTxidconst GenTxid &GenTxid &const tuple<const bool &, const uint256 &>const tuple<const bool &, const uint256 &> &tuple<const bool &, const uint256 &> &MakeTransactionRefTxTx &&const CTransactionconst CTransaction &CTransaction &CalculateOutputValueTxTypeconst TxTypeconst TxType &TxType &SerializeTransactionUnserializeTransactionconst CTxOutconst CTxOut &CTxOut &const prevector<28U, unsigned char, unsigned int, signed int> &prevector<28U, unsigned char, unsigned int, signed int> &const CTxInconst CTxIn &CTxIn &const COutPointconst COutPoint &COutPoint &cmpGenTxid &&GenTxidGetHashconst GenTxid *GenTxid *IsWtxidWtxidTxid~CTransactionCTransactionCTransaction &&HasWitnessconst CTransaction *CTransaction *const vector<CTxIn, allocator<CTxIn>>IsCoinBaseGetTotalSizeGetValueOutGetWitnessHashconst vector<CTxOut, allocator<CTxOut>>CMutableTransaction &&const CMutableTransactionconst CMutableTransaction &CMutableTransaction &~CMutableTransactionCMutableTransactionconst CMutableTransaction *CMutableTransaction *ComputeWitnessHashComputeHashCTxOut &&~CTxOutCTxOutconst CTxOut *CTxOut *const CAmountconst CAmount &CTxIn &&~CTxInCTxInSEQUENCE_FINALCTxIn *COutPoint &&COutPointconst COutPoint *COutPoint *NULL_INDEXconst int32_tm_hashm_is_wtxidnLockTimevoutvinm_witness_hashscriptPubKeynValuescriptWitnessnSequenceprevoutSERIALIZE_TRANSACTION_NO_WITNESS10737418240x40000000SEQUENCE_LOCKTIME_GRANULARITYSEQUENCE_LOCKTIME_MASK0x0000ffffSEQUENCE_LOCKTIME_TYPE_FLAG2241943041 << 22(1 << 22)SEQUENCE_LOCKTIME_DISABLE_FLAG1U21474836481U << 31(1U << 31)MAX_SEQUENCE_NONFINAL4294967294SEQUENCE_FINAL - 10xffffffffstd::numeric_limits<uint32_t>::max()BITCOIN_PRIMITIVES_TRANSACTION_Hobj.nValue, obj.scriptPubKeyobj.prevout, obj.scriptSig, obj.nSequenceobj.hash, obj.n// BITCOIN_PRIMITIVES_TRANSACTION_H/** A generic txid reference (txid or wtxid). *//** Compute the hash of this CMutableTransaction. This is computed on the
     * fly, as opposed to GetHash() in CTransaction, which uses a cached result.
     *//** A mutable version of CTransaction. *//**
     * Get the total transaction size in bytes, including witness data.
     * "Total Size" defined in BIP141 and BIP144.
     * @return Total transaction size in bytes
     */// Return sum of txouts./** This deserializing constructor is provided instead of an Unserialize method.
     *  Unserialize is not possible, since it would require overwriting const fields. *//** Convert a CMutableTransaction into a CTransaction. *//** Memory only. */// structure, including the hash.// and bypass the constness. This is safe, as they update the entire// actually immutable; deserialization and assignment are implemented,// without updating the cached hash value. However, CTransaction is not// The local variables are made const to prevent unintended modification// Default transaction version./** The basic transaction that is broadcasted on the network and contained in
 * blocks.  A transaction can contain multiple inputs and outputs.
 *//* Use extended format in case witnesses are to be serialized. *//* Check whether witnesses need to be serialized. */// Consistency check/* Unknown flag in the serialization *//* It's illegal to encode witnesses when all witness stacks are empty. *//* The witness flag is present, and we support witnesses. *//* We read a non-empty vin. Assume a normal vout follows. *//* We read a dummy or an empty vin. *//* Try to read the vin. In case the dummy is there, this will be read as an empty vector. *//**
 * Basic transaction serialization format:
 * - int32_t nVersion
 * - std::vector<CTxIn> vin
 * - std::vector<CTxOut> vout
 * - uint32_t nLockTime
 *
 * Extended transaction serialization format:
 * - int32_t nVersion
 * - unsigned char dummy = 0x00
 * - unsigned char flags (!= 0)
 * - std::vector<CTxIn> vin
 * - std::vector<CTxOut> vout
 * - if (flags & 1):
 *   - CScriptWitness scriptWitness; (deserialized into CTxIn)
 * - uint32_t nLockTime
 *//** An output of a transaction.  It contains the public key that the next input
 * must be able to sign with to claim it.
 *//**
     * In order to use the same number of bits to encode roughly the
     * same wall-clock duration, and because blocks are naturally
     * limited to occur every 600s on average, the minimum granularity
     * for time-based relative lock-time is fixed at 512 seconds.
     * Converting from CTxIn::nSequence to seconds is performed by
     * multiplying by 512 = 2^9, or equivalently shifting up by
     * 9 bits. *//**
     * If CTxIn::nSequence encodes a relative lock-time, this mask is
     * applied to extract that lock-time from the sequence field. *//**
     * If CTxIn::nSequence encodes a relative lock-time and this flag
     * is set, the relative lock-time has units of 512 seconds,
     * otherwise it specifies blocks with a granularity of 1. *//**
     * If this flag is set, CTxIn::nSequence is NOT interpreted as a
     * relative lock-time.
     * It skips SequenceLocks() for any input that has it set (BIP 68).
     * It fails OP_CHECKSEQUENCEVERIFY/CheckSequence() for any input that has
     * it set (BIP 112).
     */// version to be set to 2, or higher.// Below flags apply in the context of BIP 68. BIP 68 requires the tx/**
     * This is the maximum sequence number that enables both nLockTime and
     * OP_CHECKLOCKTIMEVERIFY (BIP 65).
     * It has SEQUENCE_LOCKTIME_DISABLE_FLAG set (BIP 68/112).
     *//**
     * Setting nSequence to this value for every input in a transaction
     * disables nLockTime/IsFinalTx().
     * It fails OP_CHECKLOCKTIMEVERIFY/CheckLockTime() for any input that has
     * it set (BIP 65).
     * It has SEQUENCE_LOCKTIME_DISABLE_FLAG set (BIP 68/112).
     *///!< Only serialized through CTransaction/** An input of a transaction.  It contains the location of the previous
 * transaction's output that it claims and a signature that matches the
 * output's public key.
 *//** An outpoint - a combination of a transaction hash and an index n into its vout *//**
 * A flag that is ORed into the protocol version to designate that a transaction
 * should be (un)serialized without witness data.
 * Make sure that this does not collide with any of the values in `version.h`
 * or with `ADDRV2_FORMAT`.
 *//home/tanteikg/QCVE/sources/bitcoin/src/primitivesis_wtxidhashInnIntxIntxnValueInscriptPubKeyInhashPrevTxnOutscriptSigInnSequenceInprevoutIn/home/tanteikg/QCVE/sources/bitcoin/src/streams.h<cstdio><util/overflow.h><support/allocators/zeroafterfree.h>FindByteCBufferedFile *const vector<byte, allocator<byte>>CBufferedFile &SetLimitSetPosbufsizeGetPosconst CBufferedFileconst CBufferedFile *SkipTofile_pos >= m_read_pos./streams.h716const char[42]char[42]void CBufferedFile::SkipTo(unsigned long)(unnamed local variable)byte *&&buffer_pointerpair<byte *, unsigned long> &&pair<byte *, unsigned long> &byte *&eofFILE *_IO_FILE *fcloseGetTypeconst CBufferedFile &CBufferedFile~CBufferedFileRewind limit must be less than buffer size"Rewind limit must be less than buffer size"std::byte{0}byte &AdvanceStreamm_read_pos <= nSrcPos653const char[82]char[82]std::pair<std::byte *, unsigned long> CBufferedFile::AdvanceStream(unsigned long)Attempt to position past buffer limit"Attempt to position past buffer limit"buffer_offsetbuffer_availablebytes_until_source_posadvanceconst unsigned long[3]unsigned long[3]const unsigned long *FillreadNownAvailnBytesCBufferedFile::Fill: end of file"CBufferedFile::Fill: end of file"const char[33]char[33]CBufferedFile::Fill: fread failed"CBufferedFile::Fill: fread failed"Flush~BitStreamWriterBitStreamWriterOStreamOStream &BitStreamReaderIStreamIStream &SpanReader &const SpanReaderconst SpanReader &SpanReaderSpanReader &&SpanReader *SpanReader::read(): end of data"SpanReader::read(): end of data"const SpanReader *CVectorWriter &const CVectorWriterconst CVectorWriter &CVectorWriterCVectorWriter &&const CVectorWriter *CVectorWriter *nPos <= vchData.size()void CVectorWriter::write(Span<const std::byte>)nOverwriteconst __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>>const __normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> &__normal_iterator<unsigned char *, vector<unsigned char, allocator<unsigned char>>> &OverrideStream<Stream> *Stream *const OverrideStream<Stream>const OverrideStream<Stream> *OverrideStream<Stream> &OverrideStreamCDataStream &&const CDataStreamconst CDataStream &~CDataStreamCDataStream *~DataStreamDataStream *const CDataStream *SetVersionDataStream &DataStream &&const DataStreamconst DataStream &DataStreamXorjconst DataStream *nPosfile_posfileInnBufSizenRewindInnTypeInnbitsostreamistreamvchDataInnPosInstream_nType_nVersion_spconst __normal_iterator<byte *, vector<byte, zero_after_free_allocator<byte>>>const __normal_iterator<byte *, vector<byte, zero_after_free_allocator<byte>>> &__normal_iterator<byte *, vector<byte, zero_after_free_allocator<byte>>> &next_read_posconst optional<unsigned long>const vector<byte, zero_after_free_allocator<byte>>DataStream::ignore(): end of data"DataStream::ignore(): end of data"DataStream::read(): end of data"DataStream::read(): end of data"in_availRewindCompactvalue_type{}const __normal_iterator<const byte *, vector<byte, zero_after_free_allocator<byte>>>CAutoFile &const CAutoFileconst CAutoFile &~CAutoFileCAutoFile *CAutoFileAutoFile *CAutoFile::operator>>: file handle is nullptr"CAutoFile::operator>>: file handle is nullptr"const char[46]char[46]CAutoFile::operator<<: file handle is nullptr"CAutoFile::operator<<: file handle is nullptr"const CAutoFile *AutoFile &AutoFile::write: file handle is nullptr"AutoFile::write: file handle is nullptr"const char[40]AutoFile::write: write failed"AutoFile::write: write failed"const char[30]char[30]AutoFile::ignore: file handle is nullptr"AutoFile::ignore: file handle is nullptr"unsigned char[4096]4096nNowsizeof(data)AutoFile::ignore: end of file"AutoFile::ignore: end of file"AutoFile::read: fread failed"AutoFile::read: fread failed"AutoFile::read: file handle is nullptr"AutoFile::read: file handle is nullptr"AutoFile::read: end of file"AutoFile::read: end of file"const char[28]char[28]const AutoFileconst AutoFile *Getretval0}const AutoFile &AutoFile~AutoFileBitStreamWriter<OStream>BitStreamReader<IStream>OverrideStream<Stream>vchBufnRewindnReadLimitm_read_posnSrcPosnTypem_offsetm_bufferm_ostream8}m_istreamm_versionm_typevchDatastreamfileBITCOIN_STREAMS_H// BITCOIN_STREAMS_H//! search for a given byte in the stream, and remain positioned on it// Unserialize from this stream//! no argument removes the limit//! prevent reading beyond a certain position// can't go this far forward, go as far as possible// rewinding too far, rewind as far as possible//! rewind to a given reading position//! return the current reading position//! Use SetPos() to back up in the stream, not SkipTo().//! Move the read position ahead in the stream to the given position.//! read a number of bytes//! check whether we're at the end of the source file// Disallow copies// If there are no bytes available, read from the file.//! beginning at that pointer.//! (which may be less than the requested length) that may be accessed//! Return a pointer to the available buffer data and the number of bytes//! filling the buffer from the file so that at least one byte is available.//! Advance the stream's read pointer (m_read_pos) by up to 'length' bytes,//! read data from the source to fill the buffer//!< the buffer//!< how many bytes we guarantee to rewind//!< up to which position we're allowed to read//!< how many bytes have been read from this//!< how many bytes have been read from source//!< source file/** Non-refcounted RAII wrapper around a FILE* that implements a ring buffer to
 *  deserialize from. It guarantees the ability to rewind a given number of bytes.
 *
 *  Will automatically close the file when it goes out of scope if not null.
 *  If you need to close the file early, use file.fclose() instead of fclose(file).
 */// Serialize to this stream// Stream subset/** Return true if the wrapped FILE* is nullptr, false otherwise.
     *//** Get wrapped FILE* without transfer of ownership.
     * @note Ownership of the FILE* will remain with this class. Use this only if the scope of the
     * AutoFile outlives use of the passed pointer.
     *//** Get wrapped FILE* with transfer of ownership.
     * @note This will invalidate the AutoFile object, and makes it the responsibility of the caller
     * of this function to clean up the returned FILE*.
     *//** Non-refcounted RAII wrapper for FILE*
 *
 * Will automatically close the file when it goes out of scope if not null.
 * If you're returning the file pointer, return file.release().
 * If you need to close the file early, use file.fclose() instead of fclose(file).
 *//** Flush any unwritten bits to the output stream, padding with 0's to the
     * next byte boundary.
     *//** Write the nbits least significant bits of a 64-bit int to the output
     * stream. Data is buffered until it completes an octet.
     *//// written to is at this offset from the most significant bit position./// Write() calls and not yet flushed to the stream. The next bit to be/// Number of high order bits in m_buffer already written by previous/// written buffer when m_offset reaches 8 or Flush() is called./// Buffered byte waiting to be written to the output stream. The byte is/** Read the specified number of bits from the stream. The data is returned
     * in the nbits least significant bits of a 64-bit uint.
     *//// most significant bit position./// Read() calls. The next bit to be returned is at this offset from the/// Number of high order bits in m_buffer already returned by previous/// buffer when m_offset reaches 8./// Buffered byte read in from the input stream. A new byte is read into the// for each byte Xor'd -- much slower than need be.// way instead of doing a %, which would effectively be a division// important that we calculate `j`, i.e. the `key` index in this// This potentially acts on very many bytes of data, so it's/**
     * XOR the contents of this stream with a certain key.
     *
     * @param[in] key    The key used to XOR the data in this stream.
     */// Special case: stream << stream concatenates like stream += stream// Write to the end of the buffer// Ignore from the beginning of the buffer// Read from the beginning of the buffer// Rewind by n characters if the buffer hasn't been compacted yet// Total rewind if no size is passed// Vector subset/** Double ended buffer combining vector and stream-like interfaces.
 *
 * >> and << read and write unformatted data using the above serialization templates.
 * Fills with data in linear time; some stringstream implementations take N^2 time.
 *//**
     * @param[in]  type Serialization Type
     * @param[in]  version Serialization Version (including any flags)
     * @param[in]  data Referenced byte vector to overwrite/append
     *//** Minimal stream for reading from an existing byte array by Span.
 *//*
 * (other params same as above)
 * @param[in]  args  A list of items to serialize starting at nPosIn.
*//*
 * @param[in]  nTypeIn Serialization Type
 * @param[in]  nVersionIn Serialization Version (including any flags)
 * @param[in]  vchDataIn  Referenced byte vector to overwrite/append
 * @param[in]  nPosIn Starting position. Vector index where writes should start. The vector will initially
 *                    grow as necessary to max(nPosIn, vec.size()). So to append, use vec.size().
*//* Minimal stream for overwriting and/or appending to an existing byte vector
 *
 * The referenced vector will grow as necessary
 */num_ignorefilenew/home/tanteikg/QCVE/sources/bitcoin/src/util/time.hChronoSanityCheckMillisToTimevalFormatISO8601DateFormatISO8601DateTimeGetTimeNowGetMockTimeSetMockTimeGetTimeMilliscount_microsecondsconst duration<signed long, ratio<1L, 1000000L>>count_millisecondsconst duration<signed long, ratio<1L, 1000L>>count_secondsTicksSinceEpochTimepointDurationDur2TicksDur1UninterruptibleSleepconst microsecondsconst microseconds &duration<signed long, ratio<1L, 1000000L>> &NodeClockNodeClock &NodeClock &&const NodeClockconst NodeClock &time_point<NodeClock, duration<signed long, ratio<1L, 1000000000L>>> &SystemClockSteadyClockBITCOIN_UTIL_TIME_H// BITCOIN_UTIL_TIME_H/** Sanity check epoch match normal Unix epoch *//**
 * Convert milliseconds to a struct timeval for e.g. select.
 *//**
 * ISO 8601 formatting is preferred. Use the FormatISO8601{DateTime,Date}
 * helper functions if possible.
 *//** DEPRECATED, see GetTime *//**
 * Return the current time point cast to the given precision. Only use this
 * when an exact precision is needed, otherwise use T::clock::now() directly.
 *//** For testing *//** For testing. Set e.g. with the setmocktime rpc, or -mocktime argument *//**
 * DEPRECATED
 * Use SetMockTime with chrono type
 *
 * @param[in] nMockTimeIn Time in seconds.
 *//** Returns the system time (not mockable) *//**
 * DEPRECATED
 * Use either ClockType::now() or Now<TimePointType>() if a cast is needed.
 * ClockType is
 * - SteadyClock/std::chrono::steady_clock for steady time
 * - SystemClock/std::chrono::system_clock for system time
 * - NodeClock                             for mockable system time
 *//**
 * Helper to count the seconds of a duration/time_point.
 *
 * All durations/time_points should be using std::chrono and calling this should generally
 * be avoided in code. Though, it is still preferred to an inline t.count() to
 * protect against a reliance on the exact type of t.
 *
 * This helper is used to convert durations/time_points before passing them over an
 * interface that doesn't support std::chrono (e.g. RPC, debug log, or the GUI)
 */// unused/** Return current system time or mocked time, if set *//** Mockable clock in the context of tests, otherwise the system clock */// IWYU pragma: exportdmsnTimeoutnTimemock_time_innMockTimeIn/home/tanteikg/QCVE/sources/bitcoin/src/protocol.h<util/time.h><streams.h><primitives/transaction.h>lambda [] type at line 143891, col. 13lambda [] type at line 143891, col. 13 &const lambda [] type at line 143891, col. 13const lambda [] type at line 143891, col. 13 &const lambda [] type at line 143891, col. 13 *lambda [] type at line 143891, col. 13 *obj.nServices = static_cast<ServiceFlags>(services_tmp)nServiceslambda [] type at line 143889, col. 13lambda [] type at line 143889, col. 13 &const lambda [] type at line 143889, col. 13const lambda [] type at line 143889, col. 13 &const Typeconst Type &const lambda [] type at line 143889, col. 13 *lambda [] type at line 143889, col. 13 *services_tmp = obj.nServicesToGenTxidconst CInvconst CInv &CInv &const CAddressconst CAddress &CAddress &const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &const NodeSecondsconst NodeSeconds &MayHaveUsefulAddressDBNODE_NETWORKNODE_NETWORK_LIMITEDHasAllDesirableServiceFlagsSetServiceFlagsIBDCacheGetDesirableServiceFlagsserviceFlagsToStrgetAllNetMessageTypesCInv &&CInvIsGenBlkMsgconst CInv *CInv *MSG_BLOCKMSG_FILTERED_BLOCKMSG_CMPCT_BLOCK1073741826MSG_WITNESS_BLOCKIsGenTxMsgMSG_TXMSG_WTX1073741825MSG_WITNESS_TXIsMsgWitnessBlkIsMsgCmpctBlkIsMsgFilteredBlkIsMsgWtxIsMsgBlkIsMsgTxGetCommandCMessageHeader &CMessageHeader &&const CMessageHeaderconst CMessageHeader &CMessageHeaderIsCommandValidconst MessageStartCharsMESSAGE_START_SIZEconst MessageStartChars &unsigned char(&)[4]CAddress &&~CAddressCAddress *!(s.GetType() & SER_GETHASH)./protocol.h399use_v2stored_format_versions.GetType() & SER_NETWORK220000DISK_VERSION_INITDISK_VERSION_ADDRV2524287DISK_VERSION_IGNORE_MASK4294443008~DISK_VERSION_IGNORE_MASKUnsupported CAddress disk format version"Unsupported CAddress disk format version"421Using<LossyChronoFormatter<uint32_t>>(obj.nTime)Using<CompactSizeFormatter<false>>(services_tmp)Using<CustomUintFormatter<8>>(obj.nServices)services_tmpconst CAddress *GetDataMsgUNDEFINEDMSG_WITNESS_FLAGMSG_BLOCK | MSG_WITNESS_FLAGMSG_TX | MSG_WITNESS_FLAGMessageStartCharsServiceFlagsNODE_NONENODE_BLOOMNODE_WITNESS1 << 3(1 << 3)NODE_COMPACT_FILTERS1 << 6(1 << 6)1 << 10(1 << 10)CHECKSUM_SIZEpchChecksumnMessageSizeCOMMAND_SIZEpchCommandpchMessageStartconst secondsconst seconds &SENDTXRCNCLWTXIDRELAYCFCHECKPTGETCFCHECKPTCFHEADERSGETCFHEADERSCFILTERGETCFILTERSBLOCKTXNGETBLOCKTXNCMPCTBLOCKSENDCMPCTFEEFILTERSENDHEADERSFILTERCLEARFILTERADDFILTERLOADNOTFOUNDPONGPINGservices&ipInnServicesInMEMPOOLGETADDRBLOCKHEADERSTXGETHEADERSGETBLOCKSMERKLEBLOCKGETDATAINVSENDADDRV2ADDRV2ADDRVERACKVERSIONMSG_TYPE_MASK10737418230xffffffff >> 2301 << 30HEADER_SIZEMESSAGE_START_SIZE + COMMAND_SIZEMESSAGE_SIZE_SIZEMESSAGE_START_SIZE + COMMAND_SIZE + MESSAGE_SIZE_SIZE24MESSAGE_START_SIZE + COMMAND_SIZE + MESSAGE_SIZE_SIZE + CHECKSUM_SIZECHECKSUM_OFFSETMESSAGE_SIZE_OFFSETMESSAGE_SIZE_OFFSET + MESSAGE_SIZE_SIZE291 << 290b00000000'00000111'11111111'11111111TIME_INIT100000000DISK_VERSION_ADDRV2 & DISK_VERSION_IGNORE_MASK(DISK_VERSION_ADDRV2 & DISK_VERSION_IGNORE_MASK)(DISK_VERSION_ADDRV2 & DISK_VERSION_IGNORE_MASK) == 0DISK_VERSION_ADDRV2 must not be covered by DISK_VERSION_IGNORE_MASKDISK_VERSION_INIT & ~DISK_VERSION_IGNORE_MASK(DISK_VERSION_INIT & ~DISK_VERSION_IGNORE_MASK)(DISK_VERSION_INIT & ~DISK_VERSION_IGNORE_MASK) == 0DISK_VERSION_INIT must be covered by DISK_VERSION_IGNORE_MASKBITCOIN_PROTOCOL_HNetMsgTypeobj.type, obj.hashobj.pchMessageStart, obj.pchCommand, obj.nMessageSize, obj.pchChecksum// BITCOIN_PROTOCOL_H/** Convert a TX/WITNESS_TX/WTX CInv to a GenTxid. */// Combined-message helper methods// Single-message helper methods/** inv message data */// MSG_FILTERED_WITNESS_BLOCK = MSG_FILTERED_BLOCK | MSG_WITNESS_FLAG,// use and remains unused.// MSG_FILTERED_WITNESS_BLOCK is defined in BIP144 as reserved for future//!< Defined in BIP144//!< Defined in BIP152//!< Defined in BIP37// The following can only occur in getdata. Invs always use TX/WTX or BLOCK.//!< Defined in BIP 339/** getdata / inv message types.
 * These numbers are defined by the protocol. When adding a new value, be sure
 * to mention it in the respective BIP.
 *//** getdata message type flags *///! Serialized as uint64_t in V1, and as CompactSize in V2.//! Always included in serialization. The behavior is unspecified if the value is not representable as uint32_t.// Invoke V1/V2 serializer for CService parent object.// nServices is serialized as CompactSize in V2; as uint64_t in V1.// exists in the stream.// the value of ADDRV2_FORMAT in the stream version, as no explicitly encoded version// In the network serialization format, the encoding (v1 or v2) is determined directly by// Only support v2 deserialization if ADDRV2_FORMAT is set.// ignore low bits// whether V2 is chosen/permitted at all.// that's part of the serialization itself. ADDRV2_FORMAT in the stream version only determines// In the disk serialization format, the encoding (v1 or v2) is determined by a flag version// ambiguous what that would mean. Make sure no code relying on that is introduced:// be hashed (except through CHashWriter in addrdb.cpp, which sets SER_DISK), and it's// CAddress has a distinct network serialization and a disk serialization, but it should never/** The version number written in disk serialized addresses to indicate V2 serializations.
     * It must be exactly 1<<29, as that is the value that historical versions used for this
     * (they used their internal ADDRV2_FORMAT flag here). *//** Historically, CAddress disk serialization stored the CLIENT_VERSION, optionally OR'ed with
     *  the ADDRV2_FORMAT flag to indicate V2 serialization. The first field has since been
     *  disentangled from client versioning, and now instead:
     *  - The low bits (masked by DISK_VERSION_IGNORE_MASK) store the fixed value DISK_VERSION_INIT,
     *    (in case any code exists that treats it as a client version) but are ignored on
     *    deserialization.
     *  - The high bits (masked by ~DISK_VERSION_IGNORE_MASK) store actual serialization information.
     *    Only 0 or DISK_VERSION_ADDRV2 (equal to the historical ADDRV2_FORMAT) are valid now, and
     *    any other value triggers a deserialization failure. Other values can be added later if
     *    needed.
     *
     *  For disk deserialization, ADDRV2_FORMAT in the stream version signals that ADDRV2
     *  deserialization is permitted, but the actual format is determined by the high bits in the
     *  stored version field. For network serialization, the stream version having ADDRV2_FORMAT or
     *  not determines the actual format used (as it has no embedded version number).
     *//** A CService with information about it as peer *//**
 * Checks if a peer with the given service flags may be capable of having a
 * robust address-storage DB.
 *//**
 * A shortcut for (services & GetDesirableServiceFlags(services))
 * == GetDesirableServiceFlags(services), ie determines whether the given
 * set of service flags are sufficient for a peer to be "relevant".
 *//** Set the current IBD status in order to figure out the desirable service flags *//**
 * Gets the set of service flags which are "desirable" for a given peer.
 *
 * These are the flags which are required for a peer to support for them
 * to be "interesting" to us, ie for us to wish to use one of our few
 * outbound connection slots for or for us to wish to prioritize keeping
 * their connection around.
 *
 * Relevant service flags may be peer- and state-specific in that the
 * version of the peer may determine which flags are required (eg in the
 * case of NODE_NETWORK_LIMITED where we seek out NODE_NETWORK peers
 * unless they set NODE_NETWORK_LIMITED and we are out of IBD, in which
 * case NODE_NETWORK_LIMITED suffices).
 *
 * Thus, generally, avoid calling with peerServices == NODE_NONE, unless
 * state-specific flags must absolutely be avoided. When called with
 * peerServices == NODE_NONE, the returned desirable service flags are
 * guaranteed to not change dependent on state - ie they are suitable for
 * use when describing peers which we know to be desirable, but for which
 * we do not have a confirmed set of service flags.
 *
 * If the NODE_NONE return value is changed, contrib/seeds/makeseeds.py
 * should be updated appropriately to filter for the same nodes.
 *//**
 * Convert service flags (a bitmask of NODE_*) to human readable strings.
 * It supports unknown service flags which will be returned as "UNKNOWN[...]".
 * @param[in] flags multiple NODE_* bitwise-OR-ed together
 */// BIP process.// do not actually support. Other service bits should be allocated via the// collisions and other cases where nodes may be advertising a service they// unauthenticated advertisements, so your code must be robust against// bitcoin-development mailing list. Remember that service bits are just// isn't getting used, or one not being used much, and notify the// Bits 24-31 are reserved for temporary experiments. Just pick a bit that// See BIP159 for details on how this is implemented.// serving the last 288 (2 day) blocks// NODE_NETWORK_LIMITED means the same as NODE_NETWORK with the limitation of only// See BIP157 and BIP158 for details on how this is implemented.// NODE_COMPACT_FILTERS means the node will service basic block filter requests.// witness data.// NODE_WITNESS indicates that a node can be asked for blocks and transactions including// but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION)// Bitcoin Core nodes used to support this by default, without advertising this bit,// NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections.// set by all Bitcoin Core non pruned nodes, and is unset by SPV clients or other light clients.// NODE_NETWORK means that the node is capable of serving the complete block chain. It is currently// Nothing// NOTE: When adding here, be sure to update serviceFlagToStr too/** nServices flags *//* Get a vector of all valid message types (see above) */// namespace NetMsgType/**
 * Contains a 4-byte version number and an 8-byte salt.
 * The salt is used to compute short txids needed for efficient
 * txreconciliation, as described by BIP 330.
 *//**
 * Indicates that a node prefers to relay transactions via wtxid, rather than
 * txid.
 * @since protocol version 70016 as described by BIP 339.
 *//**
 * cfcheckpt is a response to a getcfcheckpt request containing a vector of
 * evenly spaced filter headers for blocks on the requested chain.
 *//**
 * getcfcheckpt requests evenly spaced compact filter headers, enabling
 * parallelized download and validation of the headers between them.
 * Only available with service bit NODE_COMPACT_FILTERS as described by
 * BIP 157 & 158.
 *//**
 * cfheaders is a response to a getcfheaders request containing a filter header
 * and a vector of filter hashes for each subsequent block in the requested range.
 *//**
 * getcfheaders requests a compact filter header and the filter hashes for a
 * range of blocks, which can then be used to reconstruct the filter headers
 * for those blocks.
 * Only available with service bit NODE_COMPACT_FILTERS as described by
 * BIP 157 & 158.
 *//**
 * cfilter is a response to a getcfilters request containing a single compact
 * filter.
 *//**
 * getcfilters requests compact filters for a range of blocks.
 * Only available with service bit NODE_COMPACT_FILTERS as described by
 * BIP 157 & 158.
 *//**
 * Contains a BlockTransactions.
 * Sent in response to a "getblocktxn" message.
 * @since protocol version 70014 as described by BIP 152
 *//**
 * Contains a BlockTransactionsRequest
 * Peer should respond with "blocktxn" message.
 * @since protocol version 70014 as described by BIP 152
 *//**
 * Contains a CBlockHeaderAndShortTxIDs object - providing a header and
 * list of "short txids".
 * @since protocol version 70014 as described by BIP 152
 *//**
 * Contains a 1-byte bool and 8-byte LE version number.
 * Indicates that a node is willing to provide blocks via "cmpctblock" messages.
 * May indicate that a node prefers to receive new block announcements via a
 * "cmpctblock" message rather than an "inv", depending on message contents.
 * @since protocol version 70014 as described by BIP 152
 *//**
 * The feefilter message tells the receiving peer not to inv us any txs
 * which do not meet the specified min fee rate.
 * @since protocol version 70013 as described by BIP133
 *//**
 * Indicates that a node prefers to receive new block announcements via a
 * "headers" message rather than an "inv".
 * @since protocol version 70012 as described by BIP130.
 *//**
 * The filterclear message tells the receiving peer to remove a previously-set
 * bloom filter.
 * @since protocol version 70001 as described by BIP37.
 *   Only available with service bit NODE_BLOOM since protocol version
 *   70011 as described by BIP111.
 *//**
 * The filteradd message tells the receiving peer to add a single element to a
 * previously-set bloom filter, such as a new public key.
 * @since protocol version 70001 as described by BIP37.
 *   Only available with service bit NODE_BLOOM since protocol version
 *   70011 as described by BIP111.
 *//**
 * The filterload message tells the receiving peer to filter all relayed
 * transactions and requested merkle blocks through the provided filter.
 * @since protocol version 70001 as described by BIP37.
 *   Only available with service bit NODE_BLOOM since protocol version
 *   70011 as described by BIP111.
 *//**
 * The notfound message is a reply to a getdata message which requested an
 * object the receiving node does not have available for relay.
 * @since protocol version 70001.
 *//**
 * The pong message replies to a ping message, proving to the pinging node that
 * the ponging node is still alive.
 * @since protocol version 60001 as described by BIP31.
 *//**
 * The ping message is sent periodically to help confirm that the receiving
 * peer is still connected.
 *//**
 * The mempool message requests the TXIDs of transactions that the receiving
 * node has verified as valid but which have not yet appeared in a block.
 * @since protocol version 60002.
 *//**
 * The getaddr message requests an addr message from the receiving node,
 * preferably one with lots of IP addresses of other receiving nodes.
 *//**
 * The block message transmits a single serialized block.
 *//**
 * The headers message sends one or more block headers to a node which
 * previously requested certain headers with a getheaders message.
 * @since protocol version 31800.
 *//**
 * The tx message transmits a single transaction.
 *//**
 * The getheaders message requests a headers message that provides block
 * headers starting from a particular point in the block chain.
 * @since protocol version 31800.
 *//**
 * The getblocks message requests an inv message that provides block header
 * hashes starting from a particular point in the block chain.
 *//**
 * The merkleblock message is a reply to a getdata message which requested a
 * block using the inventory type MSG_MERKLEBLOCK.
 * @since protocol version 70001 as described by BIP37.
 *//**
 * The getdata message requests one or more data objects from another node.
 *//**
 * The inv message (inventory message) transmits one or more inventories of
 * objects known to the transmitting peer.
 *//**
 * The sendaddrv2 message signals support for receiving ADDRV2 messages (BIP155).
 * It also implies that its sender can encode as ADDRV2 and would send ADDRV2
 * instead of ADDR to a peer that has signaled ADDRV2 support by sending SENDADDRV2.
 *//**
 * The addrv2 message relays connection information for peers on the network just
 * like the addr message, but is extended to allow gossiping of longer node
 * addresses (see BIP155).
 *//**
 * The addr (IP address) message relays connection information for peers on the
 * network.
 *//**
 * The verack message acknowledges a previously-received version message,
 * informing the connecting node that it can begin to send other messages.
 *//**
 * The version message provides information about the transmitting node to the
 * receiving node at the beginning of a connection.
 *//**
 * Bitcoin protocol message types. When adding new message types, don't forget
 * to update allNetMessageTypes in protocol.cpp.
 *//** Construct a P2P message header from message-start characters, a command and the size of the message.
     * @note Passing in a `pszCommand` longer than COMMAND_SIZE will result in a run-time assertion error.
     *//** Message header.
 * (4) message start.
 * (12) command.
 * (4) size.
 * (4) checksum.
 */invtypeInstatusflagspchMessageStartInpszCommandnMessageSizeIn/home/tanteikg/QCVE/sources/bitcoin/src/addrman.h<protocol.h><netgroup.h>InvalidAddrManVersionError &InvalidAddrManVersionError &&const InvalidAddrManVersionErrorconst InvalidAddrManVersionError &~InvalidAddrManVersionErrorInvalidAddrManVersionError *InvalidAddrManVersionErrorFindAddressEntryAddressPosition &const AddressPositionconst AddressPosition &AddressPositionAddressPosition &&AddressPosition *const tuple<const bool &, const int &, const int &, const int &>const tuple<const bool &, const int &, const int &, const int &> &tuple<const bool &, const int &, const int &, const int &> &SetServicesConnectedGetAddrSelectSelectTriedCollisionResolveCollisionsAttemptGoodAdd~AddrManAddrManImplpositionmultiplicitytriedconst unique_ptr<AddrManImpl, default_delete<AddrManImpl>>m_implDEFAULT_ADDRMAN_CONSISTENCY_CHECKSBITCOIN_ADDRMAN_H// BITCOIN_ADDRMAN_H/** Test-only function
     * Find the address record in AddrMan and return information about its
     * position.
     * @param[in] addr       The address record to look up.
     * @return               Information about the address record in AddrMan
     *                       or nullopt if address is not found.
     *///! Update an entry's service bits./** We have successfully connected to this peer. Calling this function
     *  updates the CAddress's nTime, which is used in our IsTerrible()
     *  decisions and gossiped to peers. Callers should be careful that updating
     *  this information doesn't leak topology information to network spies.
     *
     *  net_processing calls this function when it *disconnects* from a peer to
     *  not leak information about currently connected peers.
     *
     * @param[in]   addr     The address of the peer we were connected to
     * @param[in]   time     The time that we were last connected to this peer
     *//**
     * Return all or many randomly selected addresses, optionally by network.
     *
     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).
     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).
     * @param[in] network        Select only addresses of this network (nullopt = all).
     *
     * @return                   A vector of randomly selected addresses from vRandom.
     *//**
     * Choose an address to connect to.
     *
     * @param[in] new_only Whether to only select addresses from the new table. Passing `true` returns
     *                     an address from the new table or an empty pair. Passing `false` will return an
     *                     address from either the new or tried table (it does not guarantee a tried entry).
     * @param[in] network  Select only addresses of this network (nullopt = all)
     * @return    CAddress The record for the selected peer.
     *            seconds  The last time we attempted to connect to that peer.
     *//**
     * Randomly select an address in the tried table that another address is
     * attempting to evict.
     *
     * @return CAddress The record for the selected tried peer.
     *         seconds  The last time we attempted to connect to that peer.
     *///! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.//! Mark an entry as connection attempted to./**
     * Mark an address record as accessible and attempt to move it to addrman's tried table.
     *
     * @param[in] addr            Address record to attempt to move to tried table.
     * @param[in] time            The time that we were last connected to this peer.
     * @return    true if the address is successfully moved from the new table to the tried table.
     *//**
     * Attempt to add one or more addresses to addrman's new table.
     *
     * @param[in] vAddr           Address records to attempt to add.
     * @param[in] source          The address of the node that sent us these addr records.
     * @param[in] time_penalty    A "time penalty" to apply to the address record's nTime. If a peer
     *                            sends us an address record with nTime=n, then we'll add it to our
     *                            addrman with nTime=(n - time_penalty).
     * @return    true if at least one address is successfully added. *//**
    * Return size information about addrman.
    *
    * @param[in] net              Select addresses only from specified network (nullopt = all)
    * @param[in] in_new           Select addresses only from one table (true = new, false = tried, nullopt = both)
    * @return                     Number of unique addresses that match specified options.
    *//** Stochastic address manager
 *
 * Design goals:
 *  * Keep the address tables in-memory, and asynchronously dump the entire table to peers.dat.
 *  * Make sure no (localized) attacker can fill the entire table with his nodes/addresses.
 *
 * To that end:
 *  * Addresses are organized into buckets that can each store up to 64 entries.
 *    * Addresses to which our node has not successfully connected go into 1024 "new" buckets.
 *      * Based on the address range (/16 for IPv4) of the source of information, or if an asmap is provided,
 *        the AS it belongs to (for IPv4/IPv6), 64 buckets are selected at random.
 *      * The actual bucket is chosen from one of these, based on the range in which the address itself is located.
 *      * The position in the bucket is chosen based on the full address.
 *      * One single address can occur in up to 8 different buckets to increase selection chances for addresses that
 *        are seen frequently. The chance for increasing this multiplicity decreases exponentially.
 *      * When adding a new address to an occupied position of a bucket, it will not replace the existing entry
 *        unless that address is also stored in another bucket or it doesn't meet one of several quality criteria
 *        (see IsTerrible for exact criteria).
 *    * Addresses of nodes that are known to be accessible go into 256 "tried" buckets.
 *      * Each address range selects at random 8 of these buckets.
 *      * The actual bucket is chosen from one of these, based on the full address.
 *      * When adding a new good address to an occupied position of a bucket, a FEELER connection to the
 *        old address is attempted. The old entry is only replaced and moved back to the "new" buckets if this
 *        attempt was unsuccessful.
 *    * Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not
 *      be observable by adversaries.
 *    * Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman
 *      configuration option will introduce (expensive) consistency checks for the entire data structure.
 */// located.// In certain edge cases, this may not be where the address is currently// populated based on the first source who sent the address.// If the address is in the new table, the bucket and position are// ADDRMAN_NEW_BUCKETS_PER_ADDRESS// Addresses in the new table can have multiplicity between 1 and// Addresses in the tried table should always have a multiplicity of 1.// Whether the address is in the new or tried table/** Test-only struct, capturing info about an address in AddrMan *//** Default for -checkaddrman */// Copyright (c) 2012-2022 The Bitcoin Core developers// Copyright (c) 2012 Pieter Wuillemsgtried_inmultiplicity_inbucket_inposition_ins_max_addressesmax_pctnew_onlyfCountFailurevAddrsourcetime_penaltynetin_newdeterministicconsistency_check_ratio/home/tanteikg/QCVE/sources/bitcoin/src/primitives/block.hCBlockLocator &CBlockLocator &&const CBlockLocatorconst CBlockLocator &~CBlockLocatorCBlockLocatorconst CBlockLocator *CBlockLocator *vector<uint256, allocator<uint256>> &&vector<uint256, allocator<uint256>> &CBlock &CBlock &&const CBlockconst CBlock &~CBlockCBlock *CBlockGetBlockHeaderconst CBlock *blockconst CBlockHeaderconst CBlockHeader *CBlockHeader *const CBlockHeader &CBlockHeader &CBlockHeader &&CBlockHeaderGetBlockTimeTimeconst uint32_t &vHavenNoncenBitshashMerkleRoothashPrevBlockfCheckedvtxBITCOIN_PRIMITIVES_BLOCK_Hobj.vHaveobj.vtxobj.nVersion, obj.hashPrevBlock, obj.hashMerkleRoot, obj.nTime, obj.nBits, obj.nNonce// BITCOIN_PRIMITIVES_BLOCK_H/** Describes a place in the block chain to another node such that if the
 * other node doesn't have the same branch, it can find a recent common trunk.
 * The further back it is, the further before the fork it may be.
 */// memory only// network and disk// header/** Nodes collect new transactions into a block, hash them into a hash tree,
 * and scan through nonce values to make the block's hash satisfy proof-of-work
 * requirements.  When they solve the proof-of-work, they broadcast the block
 * to everyone and the block is added to the block chain.  The first transaction
 * in the block is a special one that creates a new coin owned by the creator
 * of the block.
 */haveheader/home/tanteikg/QCVE/sources/bitcoin/src/util/hash_type.hconst BaseHash<HashType>const BaseHash<HashType> &BaseHash<HashType> &operator std::vector<unsigned char, std::allocator<unsigned char>>BaseHashHashTypeconst HashTypeconst HashType &HashType &BaseHash<HashType> *BaseHash<HashType>BITCOIN_UTIL_HASH_TYPE_H// BITCOIN_UTIL_HASH_TYPE_H// Copyright (c) 2020-2021 The Bitcoin Core developers/usr/include/c++/9/mutex<bits/unique_lock.h><bits/std_mutex.h><system_error><exception>__once_proxycall_onceonce_flag &_L1_L1 &_L2_L2 &_L3_L3 &try_lock_Lock1_Lock1 &_Lock2_Lock2 &_Lock3_Lock3 &__try_to_lock_Lock_Lock &const once_flagconst once_flag &once_flagscoped_lock<_Mutex> &const scoped_lock<_Mutex>const scoped_lock<_Mutex> &scoped_lock~scoped_lockmutex_type &_Mutex_Mutex &scoped_lock<> &const scoped_lock<>const scoped_lock<> &scoped_lock<> *scoped_lock<_MutexTypes...> &const scoped_lock<_MutexTypes...>const scoped_lock<_MutexTypes...> &_MutexTypes_MutexTypes &__do_try_locktuple<_Lock &...> &_M_timedlockconst __gthread_time_tconst __gthread_time_t &recursive_timed_mutex *__gthread_recursive_mutex_t *pthread_mutex_t *const __gthread_time_t *__recursive_mutex_base *__native_type *native_handleunlocktry_lock_untilconst time_point<_Clock, _Duration>const time_point<_Clock, _Duration> &time_point<_Clock, _Duration> &_Durationtry_lock_for__erecursive_timed_mutex &const recursive_timed_mutexconst recursive_timed_mutex &recursive_timed_mutex~recursive_timed_mutextimed_mutex *__gthread_mutex_t *__mutex_base *timed_mutex &const timed_mutexconst timed_mutex &timed_mutex~timed_mutex_M_try_lock_untilconst time_point<__clock_t, _Duration>const time_point<__clock_t, _Duration> &time_point<__clock_t, _Duration> &_M_try_lock_forrecursive_mutex *recursive_mutex &const recursive_mutexconst recursive_mutex &recursive_mutex~recursive_mutex__recursive_mutex_base__recursive_mutex_base &const __recursive_mutex_baseconst __recursive_mutex_base &__native_typescoped_lock<_Mutex>mutex_typescoped_lock<>scoped_lock<_MutexTypes...>__try_lock_impl<_Idx, false>__try_lock_impl<_Idx, _Continue>_Continuenative_handle_type__timed_mutex_impl<_Derived>_Derived__clock_t_M_once __GTHREAD_ONCE_INIT_M_device_M_devices_M_mutexPTHREAD_MUTEX_RECURSIVE_NP__once_call__once_callable__cpp_lib_scoped_lock_GLIBCXX_MUTEX! _GTHREAD_USE_MUTEX_TIMEDLOCK_GLIBCXX_HAVE_TLS_GLIBCXX_HAS_GTHREADS__GTHREAD_RECURSIVE_MUTEX_INIT_GTHREAD_USE_MUTEX_TIMEDLOCK// _GLIBCXX_MUTEX/// @} group mutexes// _GLIBCXX_HAS_GTHREADS// NOLINT: PR 82481// 2442. call_once() shouldn't DECAY_COPY()/// call_once/// Deleted assignment operator/// Deleted copy constructor/// Constructor/// once_flag// calling thread owns mutex/** @brief A scoped lock type for multiple lockable objects.
   *
   * A scoped_lock controls mutex ownership within a scope, releasing
   * ownership in the destructor.
   *//** @brief Generic lock.
   *  @param __l1 Meets Lockable requirements (try_lock() may throw).
   *  @param __l2 Meets Lockable requirements (try_lock() may throw).
   *  @param __l3 Meets Lockable requirements (try_lock() may throw).
   *  @throw An exception thrown by an argument's lock() or try_lock() member.
   *  @post All arguments are locked.
   *
   *  All arguments are locked via a sequence of calls to lock(), try_lock()
   *  and unlock().  If the call exits via an exception any locks that were
   *  obtained will be released.
   *//** @brief Generic try_lock.
   *  @param __l1 Meets Lockable requirements (try_lock() may throw).
   *  @param __l2 Meets Lockable requirements (try_lock() may throw).
   *  @param __l3 Meets Lockable requirements (try_lock() may throw).
   *  @return Returns -1 if all try_lock() calls return true. Otherwise returns
   *          a 0-based index corresponding to the argument that returned false.
   *  @post Either all arguments are locked, or none will be.
   *
   *  Sequentially calls try_lock() on each argument.
   */// [thread.timedmutex.recursive]/3// Returns true if the mutex is unlocked or is locked by _M_caller.// Predicate type that tests whether the current thread can lock a mutex./// recursive_timed_mutex/// timed_mutex// !_GTHREAD_USE_MUTEX_TIMEDLOCK// XXX EINVAL, EAGAIN, EBUSY// EINVAL, EAGAIN, EBUSY, EINVAL, EDEADLK(may)/// The standard timed mutex type./// The standard recursive mutex type.// XXX EAGAIN, ENOMEM, EPERM, EBUSY(may), EINVAL(may)// Common base class for std::recursive_mutex and std::recursive_timed_mutex/**
   * @ingroup mutexes
   * @{
   *//** @file include/mutex
 *  This is a Standard C++ Library header.
 */// Copyright (C) 2003-2019 Free Software Foundation, Inc.// <mutex> -*- C++ -*-__once__l1__l2__l3__locks__atime__rtime/home/tanteikg/QCVE/sources/bitcoin/src/util/settings.hMapMap &&KeyKey &&FindKeyOnlyHasDefaultSectionSettingconst Settingsconst Settings &Settings &GetSettingsListGetSettingWriteSettingsconst map<basic_string<char, char_traits<char>, allocator<char>>, UniValue, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const map<basic_string<char, char_traits<char>, allocator<char>>, UniValue, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &ReadSettingsSettingsSpan &SettingsSpan &&const SettingsSpanconst SettingsSpan &SettingsSpannegatedlast_negatedconst SettingsValueconst SettingsValue *SettingsSpan *const SettingsValue &Settings &&~SettingsSettingsSettingsValuero_configrw_settingscommand_line_optionsforced_settingsBITCOIN_UTIL_SETTINGS_Hutil// BITCOIN_UTIL_SETTINGS_H// namespace util//! Map lookup helper.//!< Number of negated values.//!< True if the last value is negated.//!< True if there are any non-negated values.//!< Pointer to end of values.//!< Pointer to first non-negated value.//! considered negated.//! The last boolean `false` value in the list and all earlier values are//! Accessor for list of settings that skips negated values when iterated over.//! ignored unintentionally.//! This is used to provide user warnings about values that might be getting//!//! overridden by a higher priority command-line or network section value.//! Return true if a setting is set in the default config file section, and not//! specified multiple times, return a list of all the values specified.//! Get combined setting value similar to GetSetting(), except if setting was//!                         for GetChainName//! @param get_chain_name - enable special backwards compatible behavior//!                               files.//!                               read-only config and read-write settings//!                               command line). Only return settings in the//!                               settings values and values specified on the//! @param ignore_nonpersistent - ignore non-persistent settings values (forced//!                                        [section] keywords)//!                                        of the config file (part before any//! @param ignore_default_section_config - ignore values in the default section//! arguments, runtime read-write settings, and the read-only config file.//! Get settings value from combined sources: forced settings, command line//! Write settings file.//! Read settings file.//! Map of config section name and setting name to list of config file values.//! Map of setting name to read-write file setting value.//! Map of setting name to list of command line values.//! Map of setting name to forced setting value.//! read-only configuration file, and a read-write runtime settings file.//! Stored settings. This struct combines settings from the command line, a//!       https://github.com/bitcoin/bitcoin/pull/15934/files#r337691812)//!       from UniValue. (An implementation with boost::variant was posted at//!       isNull() methods can be substituted if there's a need to move away//!       getInt<int64_t>(), get_bool(), isNum(), isBool(), isFalse(), isTrue() and//!       be assigned strings, int64_t, and bool values and has get_str(),//!       serialized in a readable format. But any other variant type that can//! @note UniValue is used here for convenience and because it can be easily//! Settings value type (string/integer/boolean/null variant).settingssectionignore_default_section_configignore_nonpersistentget_chain_namepatherrors/usr/include/c++/9/bits/stl_list.hlist<_Tp, _Alloc> &&_M_check_equal_allocatorslist<_Tp, _Alloc> &list<_Tp, _Alloc> *_M_dec_size_M_unhook_Node *_List_node<_Tp> *_M_hook_M_inc_size_M_transfer_M_initialize_dispatch_StrictWeakOrderingsplicepop_frontemplace_frontpush_frontconst list<_Tp, _Alloc>const list<_Tp, _Alloc> *~listconst list<_Tp, _Alloc> &_S_distance~_List_base_List_base<_Tp, _Alloc> *_M_move_nodes_List_base<_Tp, _Alloc> &&_List_base_Node_alloc_type &&const _Node_alloc_typeconst _Node_alloc_type &_Node_alloc_type &_M_distanceconst _List_node_baseconst _List_node_base *_List_node_base *_M_size_M_set_size_M_get_size_List_impl_List_impl &&_List_impl *is_nothrow_default_constructible<_Node_alloc_type>::value_List_const_iterator<function<..(..)>> &_List_iterator<function<..(..)>> &_List_const_iterator<_Tp> &_List_iterator<_Tp> &__distanceconst _List_const_iterator<_Tp>const _List_const_iterator<_Tp> *_List_const_iterator<_Tp> *_List_const_iterator_List_iterator<_Tp> *_List_iterator_List_node_header &const _List_node_headerconst _List_node_header &_List_node_header_M_base_List_node_header *_List_node_header &&_List_node_base *const__xnode_List_node_base &_List_node_base &&const _List_node_base &_M_reverselist<_Tp, _Alloc>__remove_return_type_Node_alloc_traits_Node_alloc_type_Tp_alloc_traits_List_base<_Tp, _Alloc>_List_node<_Tp>_List_const_iterator<_Tp>_List_iterator<_Tp>_List_node_base_M_prevstd::list must have the same value_type as its allocatorstd::list must have a non-const, non-volatile value_type_GLIBCXX_LIST_REMOVE_RETURN_TYPE_TAG_STL_LIST_H_M_resize_pos_M_clear/* _STL_LIST_H */// Detect when distance is used to compute the size of the whole list./// See std::list::swap()./**
   *  @brief  List ordering relation.
   *  @param  __x  A %list.
   *  @param  __y  A %list of the same type as @a __x.
   *  @return  True iff @a __x is lexicographically less than @a __y.
   *
   *  This is a total ordering relation.  It is linear in the size of the
   *  lists.  The elements must be comparable with @c <.
   *
   *  See std::lexicographical_compare() for how the determination is made.
  *//**
   *  @brief  List equality comparison.
   *  @param  __x  A %list.
   *  @param  __y  A %list of the same type as @a __x.
   *  @return  True iff the size and elements of the lists are equal.
   *
   *  This is an equivalence relation.  It is linear in the size of
   *  the lists.  Lists are considered equivalent if their sizes are
   *  equal, and if corresponding elements compare equal.
  */// The rvalue's allocator cannot be moved, or is not equal,// Used to implement resize.// To implement the splice (and merge) bits of N1599.// Erases element at position given.// Inserts new element at position given and with value given.// Moves the elements from [first,last) before position.// Internal assign functions follow.// Called by resize(sz).// Called by list(n).// Called by list(n,v,a), and the range constructor when it turns out/**
       *  @brief  Sort the elements according to comparison function.
       *
       *  Sorts the elements of this list in NlogN time.  Equivalent
       *  elements remain in list order.
       *//**
       *  @brief  Sort the elements.
       *
       *  Sorts the elements of this list in NlogN time.  Equivalent
       *  elements remain in list order.
       *//**
       *  @brief  Reverse the elements in list.
       *
       *  Reverse the order of elements in the list in linear time.
       *//**
       *  @brief  Merge sorted lists according to comparison function.
       *  @tparam _StrictWeakOrdering Comparison function defining
       *  sort order.
       *  @param  __x  Sorted list to merge.
       *  @param  __comp  Comparison functor.
       *
       *  Assumes that both @a __x and this list are sorted according to
       *  StrictWeakOrdering.  Merges elements of @a __x into this list
       *  in sorted order, leaving @a __x empty when complete.  Elements
       *  in this list precede elements in @a __x that are equivalent
       *  according to StrictWeakOrdering().
       *//**
       *  @brief  Merge sorted lists.
       *  @param  __x  Sorted list to merge.
       *
       *  Assumes that both @a __x and this list are sorted according to
       *  operator<().  Merges elements of @a __x into this list in
       *  sorted order, leaving @a __x empty when complete.  Elements in
       *  this list precede elements in @a __x that are equal.
       *//**
       *  @brief  Remove consecutive elements satisfying a predicate.
       *  @tparam _BinaryPredicate  Binary predicate function or object.
       *
       *  For each consecutive set of elements [first,last) that
       *  satisfy predicate(first,i) where i is an iterator in
       *  [first,last), remove all but the first one.  Remaining
       *  elements stay in list order.  Note that this function only
       *  erases the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Remove consecutive duplicate elements.
       *
       *  For each consecutive set of elements with the same value,
       *  remove all but the first one.  Remaining elements stay in
       *  list order.  Note that this function only erases the
       *  elements, and that if the elements themselves are pointers,
       *  the pointed-to memory is not touched in any way.  Managing
       *  the pointer is the user's responsibility.
       *//**
       *  @brief  Remove all elements satisfying a predicate.
       *  @tparam  _Predicate  Unary predicate function or object.
       *
       *  Removes every element in the list for which the predicate
       *  returns true.  Remaining elements stay in list order.  Note
       *  that this function only erases the elements, and that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief  Remove all elements equal to value.
       *  @param  __value  The value to remove.
       *
       *  Removes every element in the list equal to @a value.
       *  Remaining elements stay in list order.  Note that this
       *  function only erases the elements, and that if the elements
       *  themselves are pointers, the pointed-to memory is not
       *  touched in any way.  Managing the pointer is the user's
       *  responsibility.
       *//**
       *  @brief  Insert range from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __first  Const_iterator referencing the start of range in x.
       *  @param  __last  Const_iterator referencing the end of range in x.
       *
       *  Removes elements in the range [__first,__last) and inserts them
       *  before @a __position in constant time.
       *
       *  Undefined if @a __position is in [__first,__last).
       *//**
       *  @brief  Insert range from another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *  @param  __first  Iterator referencing the start of range in x.
       *  @param  __last  Iterator referencing the end of range in x.
       *
       *  Removes elements in the range [__first,__last) and inserts them
       *  before @a __position in constant time.
       *
       *  Undefined if @a __position is in [__first,__last).
       *//**
       *  @brief  Insert element from another %list.
       *  @param  __position  Const_iterator referencing the element to
       *                      insert before.
       *  @param  __x  Source list.
       *  @param  __i  Const_iterator referencing the element to move.
       *
       *  Removes the element in list @a __x referenced by @a __i and
       *  inserts it into the current list before @a __position.
       *//**
       *  @brief  Insert element from another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *  @param  __i  Iterator referencing the element to move.
       *
       *  Removes the element in list @a __x referenced by @a __i and
       *  inserts it into the current list before @a __position.
       *//**
       *  @brief  Insert contents of another %list.
       *  @param  __position  Iterator referencing the element to insert before.
       *  @param  __x  Source list.
       *
       *  The elements of @a __x are inserted in constant time in front of
       *  the element referenced by @a __position.  @a __x becomes an empty
       *  list.
       *
       *  Requires this != @a __x.
       */// [23.2.2.4] list operations/**
       *  Erases all the elements.  Note that this function only erases
       *  the elements, and that if the elements themselves are
       *  pointers, the pointed-to memory is not touched in any way.
       *  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Swaps data with another %list.
       *  @param  __x  A %list of the same element and allocator types.
       *
       *  This exchanges the elements between two lists in constant
       *  time.  Note that the global std::swap() function is
       *  specialized such that std::swap(l1,l2) will feed to this
       *  function.
       *
       *  Whether the allocators are swapped depends on the allocator traits.
       *//**
       *  @brief  Remove a range of elements.
       *  @param  __first  Iterator pointing to the first element to be erased.
       *  @param  __last  Iterator pointing to one past the last element to be
       *                erased.
       *  @return  An iterator pointing to the element pointed to by @a last
       *           prior to erasing (or end()).
       *
       *  This function will erase the elements in the range @a
       *  [first,last) and shorten the %list accordingly.
       *
       *  This operation is linear time in the size of the range and only
       *  invalidates iterators/references to the element being removed.
       *  The user is also cautioned that this function only erases the
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer
       *  is the user's responsibility.
       *//**
       *  @brief  Remove element at given position.
       *  @param  __position  Iterator pointing to element to be erased.
       *  @return  An iterator pointing to the next element (or end()).
       *
       *  This function will erase the element at the given position and thus
       *  shorten the %list by one.
       *
       *  Due to the nature of a %list this operation can be done in
       *  constant time, and only invalidates iterators/references to
       *  the element being removed.  The user is also cautioned that
       *  this function only erases the element, and that if the element
       *  is itself a pointer, the pointed-to memory is not touched in
       *  any way.  Managing the pointer is the user's responsibility.
       *//**
       *  @brief  Inserts a range into the %list.
       *  @param  __position  An iterator into the %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function will insert copies of the data in the range [@a
       *  first,@a last) into the %list before the location specified by
       *  @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts a range into the %list.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert copies of the data in the range [@a
       *  first,@a last) into the %list before the location specified by
       *  @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts a number of copies of given data into the %list.
       *  @param  __position  An iterator into the %list.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *
       *  This function will insert a specified number of copies of the
       *  given data before the location specified by @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts a number of copies of given data into the %list.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __n  Number of elements to be inserted.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert a specified number of copies of the
       *  given data before the location specified by @a position.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts the contents of an initializer_list into %list
       *          before specified const_iterator.
       *  @param  __p  A const_iterator into the %list.
       *  @param  __l  An initializer_list of value_type.
       *  @return  An iterator pointing to the first element inserted
       *           (or __position).
       *
       *  This function will insert copies of the data in the
       *  initializer_list @a l into the %list before the location
       *  specified by @a p.
       *
       *  This operation is linear in the number of elements inserted and
       *  does not invalidate iterators and references.
       *//**
       *  @brief  Inserts given rvalue into %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given rvalue before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
	*//**
       *  @brief  Inserts given value into %list before specified iterator.
       *  @param  __position  An iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
       *//**
       *  @brief  Inserts given value into %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __x  Data to be inserted.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert a copy of the given value before
       *  the specified location.  Due to the nature of a %list this
       *  operation can be done in constant time, and does not
       *  invalidate iterators and references.
       *//**
       *  @brief  Constructs object in %list before specified iterator.
       *  @param  __position  A const_iterator into the %list.
       *  @param  __args  Arguments.
       *  @return  An iterator that points to the inserted data.
       *
       *  This function will insert an object of type T constructed
       *  with T(std::forward<Args>(args)...) before the specified
       *  location.  Due to the nature of a %list this operation can
       *  be done in constant time, and does not invalidate iterators
       *  and references.
       *//**
       *  @brief  Removes last element.
       *
       *  This is a typical stack operation.  It shrinks the %list by
       *  one.  Due to the nature of a %list this operation can be done
       *  in constant time, and only invalidates iterators/references to
       *  the element being removed.
       *
       *  Note that no data is returned, and if the last element's data
       *  is needed, it should be retrieved before pop_back() is called.
       *//**
       *  @brief  Add data to the end of the %list.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the end of the %list and assigns the given data to
       *  it.  Due to the nature of a %list this operation can be done
       *  in constant time, and does not invalidate iterators and
       *  references.
       *//**
       *  @brief  Removes first element.
       *
       *  This is a typical stack operation.  It shrinks the %list by
       *  one.  Due to the nature of a %list this operation can be done
       *  in constant time, and only invalidates iterators/references to
       *  the element being removed.
       *
       *  Note that no data is returned, and if the first element's data
       *  is needed, it should be retrieved before pop_front() is
       *  called.
       *//**
       *  @brief  Add data to the front of the %list.
       *  @param  __x  Data to be added.
       *
       *  This is a typical stack operation.  The function creates an
       *  element at the front of the %list and assigns the given data
       *  to it.  Due to the nature of a %list this operation can be
       *  done in constant time, and does not invalidate iterators and
       *  references.
       */// [23.2.2.3] modifiers/**
       *  Returns a read-only (constant) reference to the data at the last
       *  element of the %list.
       *//**
       *  Returns a read/write reference to the data at the last element
       *  of the %list.
       *//**
       *  Returns a read-only (constant) reference to the data at the first
       *  element of the %list.
       *//**
       *  Returns a read/write reference to the data at the first
       *  element of the %list.
       *//**
       *  @brief Resizes the %list to the specified number of elements.
       *  @param __new_size Number of elements the %list should contain.
       *  @param __x Data with which new elements should be populated.
       *
       *  This function will %resize the %list to the specified number
       *  of elements.  If the number is smaller than the %list's
       *  current size the %list is truncated, otherwise the %list is
       *  extended and new elements are populated with given data.
       *//**
       *  @brief Resizes the %list to the specified number of elements.
       *  @param __new_size Number of elements the %list should contain.
       *
       *  This function will %resize the %list to the specified number
       *  of elements.  If the number is smaller than the %list's
       *  current size the %list is truncated, otherwise default
       *  constructed elements are appended.
       *//**  Returns the size() of the largest possible %list.  *//**  Returns the number of elements in the %list.  *//**
       *  Returns true if the %list is empty.  (Thus begin() would equal
       *  end().)
       */// [23.2.2.2] capacity/**
       *  Returns a read-only (constant) reverse iterator that points to one
       *  before the first element in the %list.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read-only (constant) reverse iterator that points to
       *  the last element in the %list.  Iteration is done in reverse
       *  element order.
       *//**
       *  Returns a read-only (constant) iterator that points one past
       *  the last element in the %list.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read-only (constant) iterator that points to the
       *  first element in the %list.  Iteration is done in ordinary
       *  element order.
       *//**
       *  Returns a read/write reverse iterator that points to one
       *  before the first element in the %list.  Iteration is done in
       *  reverse element order.
       *//**
       *  Returns a read/write reverse iterator that points to the last
       *  element in the %list.  Iteration is done in reverse element
       *  order.
       *//**
       *  Returns a read/write iterator that points one past the last
       *  element in the %list.  Iteration is done in ordinary element
       *  order.
       *//**
       *  Returns a read/write iterator that points to the first element in the
       *  %list.  Iteration is done in ordinary element order.
       *//**
       *  @brief  Assigns an initializer_list to a %list.
       *  @param  __l  An initializer_list of value_type.
       *
       *  Replace the contents of the %list with copies of the elements
       *  in the initializer_list @a __l.  This is linear in __l.size().
       *//**
       *  @brief  Assigns a range to a %list.
       *  @param  __first  An input iterator.
       *  @param  __last   An input iterator.
       *
       *  This function fills a %list with copies of the elements in the
       *  range [@a __first,@a __last).
       *
       *  Note that the assignment completely changes the %list and
       *  that the resulting %list's size is the same as the number of
       *  elements assigned.
       *//**
       *  @brief  Assigns a given value to a %list.
       *  @param  __n  Number of elements to be assigned.
       *  @param  __val  Value to be assigned.
       *
       *  This function fills a %list with @a __n copies of the given
       *  value.  Note that the assignment completely changes the %list
       *  and that the resulting %list's size is the same as the number
       *  of elements assigned.
       *//**
       *  @brief  %List initializer list assignment operator.
       *  @param  __l  An initializer_list of value_type.
       *
       *  Replace the contents of the %list with copies of the elements
       *  in the initializer_list @a __l.  This is linear in l.size().
       *//**
       *  @brief  %List move assignment operator.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  The contents of @a __x are moved into this %list (without copying).
       *
       *  Afterwards @a __x is a valid, but unspecified %list
       *
       *  Whether the allocator is moved depends on the allocator traits.
       *//**
       *  @brief  %List assignment operator.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  All the elements of @a __x are copied.
       *
       *  Whether the allocator is copied depends on the allocator traits.
       *//**
       *  No explicit dtor needed as the _Base dtor takes care of
       *  things.  The _Base dtor only erases the elements, and note
       *  that if the elements themselves are pointers, the pointed-to
       *  memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       *//**
       *  @brief  Builds a %list from a range.
       *  @param  __first  An input iterator.
       *  @param  __last  An input iterator.
       *  @param  __a  An allocator object.
       *
       *  Create a %list consisting of copies of the elements from
       *  [@a __first,@a __last).  This is linear in N (where N is
       *  distance(@a __first,@a __last)).
       *//**
       *  @brief  Builds a %list from an initializer_list
       *  @param  __l  An initializer_list of value_type.
       *  @param  __a  An allocator object.
       *
       *  Create a %list consisting of copies of the elements in the
       *  initializer_list @a __l.  This is linear in __l.size().
       *//**
       *  @brief  %List move constructor.
       *
       *  The newly-created %list contains the exact contents of the moved
       *  instance. The contents of the moved instance are a valid, but
       *  unspecified %list.
       *//**
       *  @brief  %List copy constructor.
       *  @param  __x  A %list of identical element and allocator types.
       *
       *  The newly-created %list uses a copy of the allocation object used
       *  by @a __x (unless the allocator traits dictate a different object).
       *//**
       *  @brief  Creates a %list with copies of an exemplar element.
       *  @param  __n  The number of elements to initially create.
       *  @param  __value  An element to copy.
       *  @param  __a  An allocator object.
       *
       *  This constructor fills the %list with @a __n copies of @a __value.
       *//**
       *  @brief  Creates a %list with default constructed elements.
       *  @param  __n  The number of elements to initially create.
       *  @param  __a  An allocator object.
       *
       *  This constructor fills the %list with @a __n default
       *  constructed elements.
       *//**
       *  @brief  Creates a %list with no elements.
       *  @param  __a  An allocator object.
       *//**
       *  @brief  Creates a %list with no elements.
       */// [23.2.2.1] construct/copy/destroy// count the number of nodes// dummy implementations used when the size is not stored// return the stored size/**
       *  @param  __args  An instance of user data.
       *
       *  Allocates space for a new node and constructs a copy of
       *  @a __args in it.
       */// iterator types.// Note that pointers-to-_Node's can be ctor-converted to/**
   *  @brief A standard container with linear time access to elements,
   *  and fixed time insertion/deletion at any point in the sequence.
   *
   *  @ingroup sequences
   *
   *  @tparam _Tp  Type of element.
   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
   *
   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
   *  <a href="tables.html#66">reversible container</a>, and a
   *  <a href="tables.html#67">sequence</a>, including the
   *  <a href="tables.html#68">optional sequence requirements</a> with the
   *  %exception of @c at and @c operator[].
   *
   *  This is a @e doubly @e linked %list.  Traversal up and down the
   *  %list requires linear time, but adding and removing elements (or
   *  @e nodes) is done in constant time, regardless of where the
   *  change takes place.  Unlike std::vector and std::deque,
   *  random-access iterators are not provided, so subscripting ( @c
   *  [] ) access is not allowed.  For algorithms which only need
   *  sequential access, this lack makes no difference.
   *
   *  Also unlike the other standard containers, std::list provides
   *  specialized algorithms %unique to linked lists, such as
   *  splicing, sorting, and in-place reversal.
   *
   *  A couple points on memory allocation for list<Tp>:
   *
   *  First, we never actually allocate a Tp, we allocate
   *  List_node<Tp>'s and trust [20.1.5]/4 to DTRT.  This is to ensure
   *  that after elements from %list<X,Alloc1> are spliced into
   *  %list<X,Alloc2>, destroying the memory of the second %list is a
   *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.
   *
   *  Second, a %list conceptually represented as
   *  @code
   *    A <---> B <---> C <---> D
   *  @endcode
   *  is actually circular; a link exists between A and D.  The %list
   *  class holds (as its only data member) a private list::iterator
   *  pointing to @e D, not to @e A!  To get to the head of the %list,
   *  we start at the tail and move forward by one.  When this member
   *  iterator's next/previous pointers refer to itself, the %list is
   *  %empty.
  */// This is what actually destroys the list.// Used when allocator !is_always_equal.// Used when allocator is_always_equal.// else caller must move individual elements.// The only member points to the %list element.// Must downcast from List_node_base to _List_node to get to value./**
   *  @brief A list::const_iterator.
   *
   *  All the functions are op overloads.
  */// Must downcast from _List_node_base to _List_node to get to value./**
   *  @brief A list::iterator.
   *
   *  All the functions are op overloads.
  *//// An actual node in the %list./// The %list node header./// Common part of a node in the %list.// downcasting.// "needless" static_cast'ing later on, but it's all safe// effort to reduce code duplication.  This results in some// types; the latter publicly inherits from the former in an// Supporting structures are split into common and templated/** @file bits/stl_list.h
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{list}
 */// List implementation -*- C++ -*-/usr/include/c++/9/bits/list.tcc__ret_Node__cur_GLIBCXX20_ONLY_GLIBCXX20_ONLY(__expr)_LIST_TCC__removed__removed++/* _LIST_TCC */// Do nothing if the list has length 0 or 1.// 300. list::merge() specification incomplete// }//   return end();//   __newsize -= size();// } else {//   return std::next(begin(), __new_size);//   __new_size = 0;// if (__new_size < size()) {// Equivalent to the following, but performed optimally:// and set __new_size to the number of new elements that must be appended.// erasing elements (depending whether the list is growing or shrinking),// Return a const_iterator indicating the position to start inserting or/** @file bits/list.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername{list}
 */// List implementation (out of line) -*- C++ -*-/home/tanteikg/QCVE/sources/bitcoin/src/common/args.h<list><iosfwd><util/settings.h><sync.h>HelpMessageOptHelpMessageGroupSetupHelpOptionsHelpRequestedSettingToBoolSettingToIntSettingToStringInterpretValueconst KeyInfoconst KeyInfo &KeyInfo &const string *basic_string<char, char_traits<char>, allocator<char>> *InterpretKeyIsSwitchCharAbsPathForConfigValGetConfigFileCheckDataDirOptionlogArgsPrefixconst map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &GetDataDirLogArgsLockSettingsGetPersistentSettingWriteSettingsFilevector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *ReadSettingsFileGetSettingsPathpath *GetArgFlagsGetHelpMessageClearArgsArgsManager *cs_argscriticalblock__COUNTER__UniqueLockcriticalblock0AnnotatedMixin<recursive_mutex> &RecursiveMutex &./common/args.h350AddHiddenArgsAddCommandAddArgconst OptionsCategoryconst OptionsCategory &OptionsCategory &GetChainNameForceSetArgSoftSetBoolArgSoftSetArgGetBoolArgGetIntArgGetPathArgGetArgIsArgNegatedIsArgSetGetArgsClearPathCacheGetDataDirNetconst ArgsManager *GetDataDirBaseGetBlocksDirPathGetUnrecognizedSectionsGetUnsuitableSectionOnlyArgsReadConfigFilesGetConfigFilePathParseParametersconst char *constconst char *const[]SelectConfigNetwork~ArgsManagerUseDefaultSectionReadConfigStreamistream &KeyInfo &&~KeyInfoKeyInfoCommand &Command &&const Commandconst Command &~CommandCommandSectionInfo &SectionInfo &&const SectionInfoconst SectionInfo &~SectionInfoSectionInfo~ArgArg *FlagsALLOW_ANY0x01DISALLOW_NEGATIONDISALLOW_ELISION0x40DEBUG_ONLY0x100NETWORK_ONLY0x200SENSITIVE0x400COMMAND0x800OptionsCategoryOPTIONSCONNECTIONWALLETWALLET_DEBUG_TESTZMQDEBUG_TESTCHAINPARAMSNODE_RELAYBLOCK_CREATIONRPCGUICOMMANDSREGISTER_COMMANDSHIDDENm_cached_network_datadir_pathm_cached_datadir_pathm_cached_blocks_pathm_config_sectionsm_accept_any_commandm_available_argsm_network_only_argsm_networkm_commandm_settingsfalse}commandm_linem_filem_namem_flagsm_help_textm_help_paramgArgsBITCOIN_SETTINGS_FILENAMEBITCOIN_CONF_FILENAMEBITCOIN_COMMON_ARGS_HcommonWIN32// BITCOIN_COMMON_ARGS_H// namespace common/**
 * Format a string to be used as option description in help messages
 *
 * @param option Option message (e.g. "-rpcuser=<user>")
 * @param message Option description (e.g. "Username for JSON-RPC connections")
 * @return the formatted string
 *//**
 * Format a string to be used as group of options in help messages
 *
 * @param message Group name (e.g. "RPC server options:")
 * @return the formatted string
 *//** Add help options to the args manager *//**
 * @return true if help has been requested via a command-line arg
 */// Helper function for LogArgs()./**
     * Get data directory path
     *
     * @param net_specific Append network identifier to the returned path
     * @return Absolute path on success, otherwise an empty path when a non-directory path would be returned
     *//**
     * Log the config file options and the command line arguments,
     * useful for troubleshooting.
     *//**
     * Access settings with lock held.
     *//**
     * Get current setting from config file or read/write settings file,
     * ignoring nonpersistent command line or forced settings values.
     *//**
     * Write settings file or backup settings file. Push errors to vector, or
     * log them if null.
     *//**
     * Read settings file. Push errors to vector, or log them if null.
     *//**
     * Get settings file path, or return false if read-write settings were
     * disabled with -nosettings.
     *//**
     * Return Flags for known arg.
     * Return nullopt for unknown arg.
     *//**
     * Get the help string
     *//**
     * Clear available arguments
     *//**
     * Add many hidden arguments
     *//**
     * Add subcommand
     *//**
     * Add argument
     *//**
     * Returns the appropriate chain name from the program arguments.
     * @return CBaseChainParams::MAIN by default; raises runtime error if an invalid combination is given.
     */// been set. Also called directly in testing.// Forces an arg setting. Called by SoftSetArg() if the arg hasn't already/**
     * Set a boolean argument if it doesn't already have a value
     *
     * @param strArg Argument to set (e.g. "-foo")
     * @param fValue Value (e.g. false)
     * @return true if argument gets set, false if it already had a value
     *//**
     * Set an argument if it doesn't already have a value
     *
     * @param strArg Argument to set (e.g. "-foo")
     * @param strValue Value (e.g. "1")
     * @return true if argument gets set, false if it already had a value
     *//**
     * Return boolean argument or default value
     *
     * @param strArg Argument to get (e.g. "-foo")
     * @param fDefault (true or false)
     * @return command-line argument or default value
     *//**
     * Return integer argument or default value
     *
     * @param strArg Argument to get (e.g. "-foo")
     * @param nDefault (e.g. 1)
     * @return command-line argument (0 if invalid number) or default value
     *//**
     * Return path argument or default value
     *
     * @param arg Argument to get a path from (e.g., "-datadir", "-blocksdir" or "-walletdir")
     * @param default_value Optional default value to return instead of the empty path.
     * @return normalized path if argument is set, with redundant "." and ".."
     * path components and trailing separators removed (see patharg unit test
     * for examples or implementation for details). If argument is empty or not
     * set, default_value is returned unchanged.
     *//**
     * Return string argument or default value
     *
     * @param strArg Argument to get (e.g. "-foo")
     * @param strDefault (e.g. "1")
     * @return command-line argument or default value
     *//**
     * Return true if the argument was originally passed as a negated option,
     * i.e. -nofoo.
     *
     * @param strArg Argument to get (e.g. "-foo")
     * @return true if the argument was passed negated
     *//**
     * Return true if the given argument has been manually set
     *
     * @param strArg Argument to get (e.g. "-foo")
     * @return true if the argument has been set
     *//**
     * Return a vector of strings of the given argument
     *
     * @param strArg Argument to get (e.g. "-foo")
     * @return command-line arguments
     *//**
     * Clear cached directory paths
     *//**
     * Get data directory path with appended network identifier
     *
     * @return Absolute path on success, otherwise an empty path when a non-directory path would be returned
     *//**
     * Get data directory path
     *
     * @return Absolute path on success, otherwise an empty path when a non-directory path would be returned
     *//**
     * Get blocks directory path
     *
     * @return Blocks path which is network specific
     *//**
     * Get the command and command args (returns std::nullopt if no command provided)
     *//**
         * If command is non-empty: Any args that followed it
         * If command is empty: The unregistered command and any args that followed it
         *//** The command (if one has been registered with AddCommand), or empty *//**
     * Log warnings for unrecognized section names in the config file.
     *//**
     * Log warnings for options in m_section_only_args when
     * they are specified in the default section but not overridden
     * on the command line or in a network-specific section in the
     * config file.
     *//**
     * Return config file path (read-only)
     *//**
     * Select the network in use
     *//**
     * Get list of setting values.
     *//**
     * Get setting value.
     *
     * Result will be null if setting was unset, true if "-setting" argument was passed
     * false if "-nosetting" argument was passed, and a string if a "-setting=value"
     * argument was passed.
     *//**
     * Returns true if settings values from the default section should be used,
     * depending on the current network and whether the setting is
     * network-specific.
     */// This argument's value is sensitive (such as a password)./* Some options would cause cross-contamination if values for
         * mainnet were used while running on regtest/testnet (or vice-versa).
         * Setting them as NETWORK_ONLY ensures that sharing a config file
         * between mainnet and regtest/testnet won't cause problems due to these
         * parameters by accident. *///!< disallow -foo syntax that doesn't assign any value//!< disallow -nofoo syntax// ALLOW_LIST = 0x10,     //!< unimplemented, draft implementation in #16545// ALLOW_STRING = 0x08,   //!< unimplemented, draft implementation in #16545// ALLOW_INT = 0x04,      //!< unimplemented, draft implementation in #16545// ALLOW_BOOL = 0x02,     //!< unimplemented, draft implementation in #16545//!< disable validation/**
     * Flags controlling how config and command line arguments are validated and
     * interpreted.
     */// Always the last option to avoid printing these in the help/**
 * Most paths passed as configuration arguments are treated as relative to
 * the datadir if they are not absolute.
 *
 * @param args Parsed arguments and settings.
 * @param path The path to be conditionally prefixed with datadir.
 * @param net_specific Use network specific datadir variant
 * @return The normalized path.
 */// Return true if -datadir option points to a valid directory or is not specified.// Copyright (c) 2023 The Bitcoin Core developers/home/tanteikg/QCVE/sources/bitcoin/src/commonoptionmessagenet_specificbackupfilepathtempcmdhelpcatstrArgstrValuefValuefDefaultnDefaultdefault_valuestrDefaulterrorignore_invalid_keysargcargvconfiguration_file_path/home/tanteikg/QCVE/sources/bitcoin/src/hash.h<version.h><crypto/sha256.h><crypto/ripemd160.h>SourceSource &RIPEMD160CRIPEMD160 &TaggedHashBIP32Hashconst ChainCodeconst ChainCode &const unsigned char[32]unsigned char[32]unsigned char[64]MurmurHash3SHA256Uint256SerializeHashHash160HashHashedSourceWriter<Source> *HashedSourceWriter<Source> &HashedSourceWriterCHashVerifier<Source> *CHashVerifier<Source> &byte[1024]Source *CHashVerifierHashVerifier<Source> &HashVerifierCHash160 &CHash160 &&const CHash160const CHash160 &CHash160ResetCHash160 *CSHA256 &Finalizeoutput.size() == OUTPUT_SIZE./hash.hconst char[9]char[9]void CHash160::Finalize(Span<unsigned char>)CSHA256::OUTPUT_SIZECHash256 &CHash256 &&const CHash256const CHash256 &CHash256CHash256 *void CHash256::Finalize(Span<unsigned char>)CHashWriter &const CHashWriterconst CHashWriter &CHashWriterCHashWriter &&const CHashWriter *CHashWriter *HashWriterHashWriter *HashWriter &HashWriter &&const HashWriterconst HashWriter &GetCheapHashGetSHA256HashedSourceWriter<Source>CHashVerifier<Source>HashVerifier<Source>ChainCodem_sourceshactxOUTPUT_SIZECRIPEMD160::OUTPUT_SIZEBITCOIN_HASH_H// BITCOIN_HASH_H/** Compute the 160-bit RIPEMD-160 hash of an array. *//** Return a HashWriter primed for tagged hashes (as specified in BIP 340).
 *
 * The returned object will have SHA256(tag) written to it twice (= 64 bytes).
 * A tagged hash can be computed by feeding the message into this object, and
 * then calling HashWriter::GetSHA256().
 *//** Single-SHA256 a 32-byte input (represented as uint256). *//** Compute the 256-bit hash of an object's serialization. *//** Writes data to an underlying source stream, while hashing the written data. *//** Reads data from an underlying stream, while hashing the read data. *//**
     * Returns the first 64 bits from the resulting hash.
     *//** Compute the SHA256 hash of all data written to this object.
     *
     * Invalidates this object.
     *//** Compute the double-SHA256 hash of all data written to this object.
     *
     * Invalidates this object.
     *//** A writer stream (for serialization) that computes a 256-bit hash. *//** Compute the 160-bit hash an object. *//** Compute the 256-bit hash of the concatenation of two objects. *//** Compute the 256-bit hash of an object. *//** A hasher class for Bitcoin's 160-bit hash (SHA-256 + RIPEMD-160). *//** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */source_num_bytesinputoutputin1in2tagchainCodenChildnHashSeedvDataToHash/home/tanteikg/QCVE/sources/bitcoin/src/logging.h<unordered_map><mutex><functional><atomic><threadsafety.h>"ERROR: %s\n", tfm::format(fmt, args...)BCLog::LogFlags::NONEBCLog::Level::None__func__./logging.h263ERROR: %s
Logger &const Loggerlog_msgfmterrError ""Error \""const runtime_error" while formatting log message: "\" while formatting log message: "LogPrintf_const LogFlagsconst LevelGetLogCategoryLogFlags &LogAcceptCategoryLogInstancelambda [] type at line 153628, col. 52lambda [] type at line 153628, col. 52 &&lambda [] type at line 153628, col. 52 &const lambda [] type at line 153628, col. 52const lambda [] type at line 153628, col. 52 &const LogCategoryconst LogCategory &LogCategory &const lambda [] type at line 153628, col. 52 *lambda [] type at line 153628, col. 52 *const Logger &~LoggerLoggerDefaultShrinkDebugFileLogLevelToStrLogLevelsStringLogCategoriesStringconst Logger *Logger *const vector<LogCategory, allocator<LogCategory>>const vector<LogCategory, allocator<LogCategory>> &vector<LogCategory, allocator<LogCategory>> &const __normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>>const char(&)[3]char(&)[3], ", "LogCategoriesListWillLogCategoryLevelWillLogCategoryDisableCategoryEnableCategoryGetCategoryMaskconst __atomic_base<unsigned int>SetLogLevelLogLevelSetCategoryLogLevelconst unordered_map<LogFlags, Level, hash<LogFlags>, equal_to<LogFlags>, allocator<pair<const LogFlags, Level>>>const unordered_map<LogFlags, Level, hash<LogFlags>, equal_to<LogFlags>, allocator<pair<const LogFlags, Level>>> &unordered_map<LogFlags, Level, hash<LogFlags>, equal_to<LogFlags>, allocator<pair<const LogFlags, Level>>> &StdMutex &CategoryLevelsShrinkDebugFileDisconnectTestLoggerStartLoggingDeleteCallbackPushBackCallbackEnabledLogPrintStrLogTimestampStrLogCategory &&~LogCategoryLogCategory *LogCategoryLogFlagsNONENET1 <<  0(1 <<  0)TOR1 <<  1(1 <<  1)1 <<  2(1 <<  2)HTTP1 <<  3(1 <<  3)BENCH1 <<  4(1 <<  4)1 <<  5(1 <<  5)WALLETDB1 <<  6(1 <<  6)1 <<  7(1 <<  7)ESTIMATEFEE1 <<  8(1 <<  8)ADDRMAN1 <<  9(1 <<  9)SELECTCOINSREINDEX1 << 11(1 << 11)1 << 12(1 << 12)RAND81921 << 13(1 << 13)PRUNE141 << 14(1 << 14)PROXY327681 << 15(1 << 15)MEMPOOLREJ1 << 16(1 << 16)LIBEVENT171 << 17(1 << 17)COINDB182621441 << 18(1 << 18)QT195242881 << 19(1 << 19)LEVELDB10485761 << 20(1 << 20)VALIDATION2120971521 << 21(1 << 21)IPC2383886081 << 23(1 << 23)UTIL251 << 25(1 << 25)BLOCKSTORE26671088641 << 26(1 << 26)TXRECONCILIATION271342177281 << 27(1 << 27)SCAN282684354561 << 28(1 << 28)ALL(uint32_t)0~(uint32_t)0LevelTraceDebugInfoWarningErrorNonem_reopen_filem_file_pathactivecategorym_log_sourcelocationsDEFAULT_LOGSOURCELOCATIONSm_log_threadnamesDEFAULT_LOGTHREADNAMESm_log_time_microsDEFAULT_LOGTIMEMICROSm_log_timestampsDEFAULT_LOGTIMESTAMPSm_print_to_filem_print_to_consolem_print_callbacksm_categoriesm_log_levelDEFAULT_LOG_LEVELm_category_log_levelsm_started_new_linem_bufferingm_msgs_before_openm_fileoutm_csfLogIPsDEFAULT_DEBUGLOGFILEDEFAULT_LOGIPSLevel::DebugLogPrintLevel(category,level,__VA_ARGS__...)do { if (LogAcceptCategory((category), (level))) { LogPrintLevel_(category, level, __VA_ARGS__); } } while (0)LogPrint(category,__VA_ARGS__...)do { if (LogAcceptCategory((category), BCLog::Level::Debug)) { LogPrintLevel_(category, BCLog::Level::None, __VA_ARGS__); } } while (0)LogPrintfCategory(category,__VA_ARGS__...)LogPrintLevel_(category, BCLog::Level::None, __VA_ARGS__)LogPrintf(__VA_ARGS__...)LogPrintLevel_(BCLog::LogFlags::NONE, BCLog::Level::None, __VA_ARGS__)LogPrintLevel_(category,level,__VA_ARGS__...)LogPrintf_(__func__, __FILE__, __LINE__, category, level, __VA_ARGS__)BITCOIN_LOGGING_HBCLogDEBUG_LOCKCONTENTION// BITCOIN_LOGGING_H// Log conditionally, prefixing the output with the passed category name and severity level.// Log conditionally, prefixing the output with the passed category name.// evaluating arguments when logging for the category is not enabled.// Use a macro instead of a function for conditional logging to prevent// Log unconditionally, prefixing the output with the passed category name.// Log unconditionally./* Original format string will have newline so don't add one here */// peer can fill up a user's disk with debug.log entries.// unconditionally log to debug.log! It should not be the case that an inbound// Be conservative when using LogPrintf/error or other things which/** Return true if str parses as a log category and set the flag *//** Return true if log accepts specified category, at the specified level. */// namespace BCLog//! Returns the string representation of a log level.//! Returns a string with all user-selectable log levels./** Returns a string with the log categories in alphabetical order. *//** Returns a vector of the log categories in alphabetical order. *//** Only for testing *//** Start logging (and flush all buffered messages) *//** Delete a connection *//** Connect a slot to the print signal and return the connection *//** Returns whether logs will be written to any output *//** Send a string to the log output *//** Slots that connect to the print signal *//** Log categories bitfield. *///! level lower than `m_log_level` will be ignored.//! If there is no category-specific log level, all logs with a severity//! Category-specific log level. Overrides `m_log_level`./**
         * m_started_new_line is a state variable that will suppress printing of
         * the timestamp when multiple calls are made that don't end in a
         * newline.
         *///!< Buffer messages before logging can be started.// Can not use Mutex from sync.h because in debug mode it would cause a deadlock when a potential deadlock was detected// Internal use only// Default// Reasonably noisy logging, but still usable in production// High-volume or detailed logging for development/debugginglevellevelsitfunlogging_functionsource_filesource_lineflagcategory_strlevel_str/home/tanteikg/QCVE/sources/bitcoin/src/util/types.hALWAYS_FALSEBITCOIN_UTIL_TYPES_H// BITCOIN_UTIL_TYPES_H/home/tanteikg/QCVE/sources/bitcoin/src/logging/timer.h<util/types.h><util/macros.h><logging.h>LogMsgTimer<TimeType> *end_timeconst optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>%s: %s"%s: %s"const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &%s: %s (%is)"%s: %s (%is)%s: %s (%.2fms)"%s: %s (%.2fms)"%s: %s (%.2fs)"%s: %s (%.2fs)"Logfull_msg"%s\n", full_msgm_log_categoryBCLog::LogFlags::ALL./logging/timer.h%s
~Timer%s completed"%s completed"completed"completed"const char[10]char[10]Timer%s started"%s started"time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&time_point &Timer<TimeType>TimeTypem_message_on_completionm_titlem_prefixm_start_tLOG_TIME_SECONDS(end_msg)BCLog::Timer<std::chrono::seconds> UNIQUE_NAME(logging_timer)(__func__, end_msg)LOG_TIME_MILLIS_WITH_CATEGORY_MSG_ONCE(end_msg,log_category)BCLog::Timer<std::chrono::milliseconds> UNIQUE_NAME(logging_timer)(__func__, end_msg, log_category, false)LOG_TIME_MILLIS_WITH_CATEGORY(end_msg,log_category)BCLog::Timer<std::chrono::milliseconds> UNIQUE_NAME(logging_timer)(__func__, end_msg, log_category)LOG_TIME_MICROS_WITH_CATEGORY(end_msg,log_category)BCLog::Timer<std::chrono::microseconds> UNIQUE_NAME(logging_timer)(__func__, end_msg, log_category)BITCOIN_LOGGING_TIMER_H// BITCOIN_LOGGING_TIMER_H/* msg_on_completion=*///! Whether to output the message again on completion.//! outputting the timing log when a particular debug= category is specified.//! Forwarded on to LogPrint if specified - has the effect of only//! A descriptive message of what is being timed.//! Log prefix; usually the name of the function this was created in.//! (instead of being filtered by category).//! If log_category is left as the default, end_msg will log unconditionally//! RAII-style object that outputs timing information to logs./home/tanteikg/QCVE/sources/bitcoin/src/loggingend_msglog_categorymsg_on_completion/home/tanteikg/QCVE/sources/bitcoin/src/netbase.h<util/sock.h>underlyingIsBadPortSocks5const ProxyCredentialsconst ProxyCredentials *ProxyCredentials *const Sockconst Sock &Sock &InterruptSocks5ConnectThroughProxyconst Proxyconst Proxy &Proxy &ConnectSocketDirectlyCreateSockTCPLookupSubNetLookupNumericLookupvector<CService, allocator<CService>> &LookupHostvector<CNetAddr, allocator<CNetAddr>> &GetNameProxyHaveNameProxySetNameProxyIsProxyGetProxySetProxyGetNetworkNamesGetNetworkNameParseNetworkWrappedGetAddrInfoConnectionDirection &ProxyCredentials &ProxyCredentials &&const ProxyCredentials &~ProxyCredentialsProxyCredentialsProxy &&~ProxyProxyconst Proxy *Proxy *randomize_credentials(false)ConnectionDirectionIn1U << 0(1U << 0)Out1U << 1(1U << 1)BothIn | Out(In | Out)passwordusernamerandomize_credentialsproxyCreateSockg_dns_lookupDEFAULT_NAME_LOOKUPDEFAULT_CONNECT_TIMEOUT5000fNameLookupnConnectTimeoutBITCOIN_NETBASE_H// BITCOIN_NETBASE_H/**
 * Determine if a port is "bad" from the perspective of attempting to connect
 * to a node on that port.
 * @see doc/p2p-bad-ports.md
 * @param[in] port Port to check.
 * @returns whether the port is bad
 *//**
 * Connect to a specified destination service through an already connected
 * SOCKS5 proxy.
 *
 * @param strDest The destination fully-qualified domain name.
 * @param port The destination port.
 * @param auth The credentials with which to authenticate with the specified
 *             SOCKS5 proxy.
 * @param socket The SOCKS5 proxy socket.
 *
 * @returns Whether or not the operation succeeded.
 *
 * @note The specified SOCKS5 proxy socket must already be connected to the
 *       SOCKS5 proxy.
 *
 * @see <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC1928: SOCKS Protocol
 *      Version 5</a>
 *//**
 * Connect to a specified destination service through a SOCKS5 proxy by first
 * connecting to the SOCKS5 proxy.
 *
 * @param proxy The SOCKS5 proxy.
 * @param strDest The destination service to which to connect.
 * @param port The destination port.
 * @param sock The socket on which to connect to the SOCKS5 proxy.
 * @param nTimeout Wait this many milliseconds for the connection to the SOCKS5
 *                 proxy to be established.
 * @param[out] outProxyConnectionFailed Whether or not the connection to the
 *                                      SOCKS5 proxy failed.
 *
 * @returns Whether or not the operation succeeded.
 *//**
 * Try to connect to the specified service on the specified socket.
 *
 * @param addrConnect The service to which to connect.
 * @param sock The socket on which to connect.
 * @param nTimeout Wait this many milliseconds for the connection to be
 *                 established.
 * @param manual_connection Whether or not the connection was manually requested
 *                          (e.g. through the addnode RPC)
 *
 * @returns Whether or not a connection was successfully made.
 *//**
 * Socket factory. Defaults to `CreateSockTCP()`, but can be overridden by unit tests.
 *//**
 * Create a TCP socket in the given address family.
 * @param[in] address_family The socket is created in the same address family as this address.
 * @return pointer to the created Sock object or unique_ptr that owns nothing in case of failure
 *//**
 * Parse and resolve a specified subnet string into the appropriate internal
 * representation.
 *
 * @param[in]  subnet_str  A string representation of a subnet of the form
 *                         `network address [ "/", ( CIDR-style suffix | netmask ) ]`
 *                         e.g. "2001:db8::/32", "192.0.2.0/255.255.255.0" or "8.8.8.8".
 * @param[out] subnet_out  Internal subnet representation, if parsable/resolvable
 *                         from `subnet_str`.
 * @returns whether the operation succeeded or not.
 *//**
 * Resolve a service string with a numeric IP to its first corresponding
 * service.
 *
 * @returns The resulting CService if the resolution was successful, [::]:0 otherwise.
 *
 * @see Lookup(const std::string&, std::vector<CService>&, uint16_t, bool, unsigned int, DNSLookupFn)
 *      for additional parameter descriptions.
 *//**
 * Resolve a service string to its first corresponding service.
 *
 * @see Lookup(const std::string&, std::vector<CService>&, uint16_t, bool, unsigned int, DNSLookupFn)
 *      for additional parameter descriptions.
 *//**
 * Resolve a service string to its corresponding service.
 *
 * @param name    The string representing a service. Could be a name or a
 *                numerical IP address (IPv6 addresses should be in their
 *                disambiguated bracketed form), optionally followed by a uint16_t port
 *                number. (e.g. example.com:8333 or
 *                [2001:db8:85a3:8d3:1319:8a2e:370:7348]:420)
 * @param[out] vAddr The resulting services to which the specified service string
 *                   resolved.
 * @param portDefault The default port for resulting services if not specified
 *                    by the service string.
 * @param fAllowLookup Whether or not hostname lookups are permitted. If yes,
 *                     external queries may be performed.
 * @param nMaxSolutions The maximum number of results we want, specifying 0
 *                      means "as many solutions as we get."
 *
 * @returns Whether or not the service string successfully resolved to any
 *          resulting services.
 *//**
 * Resolve a host string to its first corresponding network address.
 *
 * @see LookupHost(const std::string&, std::vector<CNetAddr>&, uint16_t, bool, DNSLookupFn)
 *      for additional parameter descriptions.
 *//**
 * Resolve a host string to its corresponding network addresses.
 *
 * @param name    The string representing a host. Could be a name or a numerical
 *                IP address (IPv6 addresses in their bracketed form are
 *                allowed).
 * @param[out] vIP The resulting network addresses to which the specified host
 *                 string resolved.
 *
 * @returns Whether or not the specified host string successfully resolved to
 *          any resulting network addresses.
 *
 * @see Lookup(const std::string&, std::vector<CService>&, uint16_t, bool, unsigned int, DNSLookupFn)
 *      for additional parameter descriptions.
 *//**
 * Set the name proxy to use for all connections to nodes specified by a
 * hostname. After setting this proxy, connecting to a node specified by a
 * hostname won't result in a local lookup of said hostname, rather, connect to
 * the node by asking the name proxy for a proxy connection to the hostname,
 * effectively delegating the hostname lookup to the specified proxy.
 *
 * This delegation increases privacy for those who set the name proxy as they no
 * longer leak their external hostname queries to their DNS servers.
 *
 * @returns Whether or not the operation succeeded.
 *
 * @note SOCKS5's support for UDP-over-SOCKS5 has been considered, but no SOCK5
 *       server in common use (most notably Tor) actually implements UDP
 *       support, and a DNS resolver is beyond the scope of this project.
 *//** Return a vector of publicly routable Network names; optionally append NET_UNROUTABLE. *//**
 * Wrapper for getaddrinfo(3). Do not use directly: call Lookup/LookupHost/LookupNumeric/LookupSubNet.
 *//** Credentials for proxy authentication *///! -dns default//! -timeout default_proxy_randomize_credentialsstrDestauthsocketinterruptsockoutProxyConnectionFailedaddrConnectmanual_connectionaddress_familysubnet_strsubnet_outportDefaultdns_lookup_functionfAllowLookupnMaxSolutionsvIPnameProxyOutaddrProxyproxyInfoOutappend_unroutableallow_lookup/home/tanteikg/QCVE/sources/bitcoin/src/util/fs_helpers.hGetDefaultDataDirTryCreateDirectoriesReleaseDirectoryLocksGetFileSizestd::numeric_limits<std::streamsize>::max()CheckDiskSpaceDirIsWritableUnlockDirectoryLockDirectoryRenameOverAllocateFileRangeRaiseFileDescriptorLimitTruncateFileDirectoryCommitFileCommitBITCOIN_UTIL_FS_HELPERS_H// BITCOIN_UTIL_FS_HELPERS_H/** Release all directory locks. This is used for unit testing only, at runtime
 * the global destructor will take care of the locks.
 *//** Get the size of a file by scanning it.
 *
 * @param[in] path The file path
 * @param[in] max Stop seeking beyond this limit
 * @return The file size or max
 *//**
 * Rename src to dest.
 * @return true if the rename was successful.
 *//**
 * Sync directory contents. This is required on some environments to ensure that
 * newly created files are committed to disk.
 *//**
 * Ensure file contents are fully committed to disk, using a platform-specific
 * feature analogous to fsync().
 */// Copyright (c) 2009-2023 The Bitcoin Core developersdiradditional_bytesdirectorylockfile_nameprobe_onlydestnMinFDdirname/home/tanteikg/QCVE/sources/bitcoin/src/util/translation.hconst bilingual_strconst bilingual_str &bilingual_str &TranslateArg_Untranslatedbilingual_str &&bilingual_str *~bilingual_strconst bilingual_str *translatedoriginalG_TRANSLATION_FUNBITCOIN_UTIL_TRANSLATION_H// BITCOIN_UTIL_TRANSLATION_H/**
 * Translation function.
 * If no translation function is set, simply return the input.
 *//** Translate a message to the native language of the user. */// Provide an overload of tinyformat::format which can take bilingual_str arguments./** Mark a bilingual_str as untranslated *//**
 * Bilingual messages:
 *   - in GUI: user's native language + untranslated (i.e. English)
 *   - in log and stderr: untranslated only
 */lhscompiled as c++/usr/include/c++/9/cstdint/usr/include/x86_64-linux-gnu/c++/9/bits/c++config.h/usr/include/x86_64-linux-gnu/c++/9/bits/os_defines.h/usr/include/stdc-predef.h/usr/include/x86_64-linux-gnu/sys/cdefs.h/usr/include/x86_64-linux-gnu/bits/wordsize.h/usr/include/x86_64-linux-gnu/bits/long-double.h/usr/include/x86_64-linux-gnu/gnu/stubs.h/usr/include/x86_64-linux-gnu/gnu/stubs-64.h/usr/include/x86_64-linux-gnu/c++/9/bits/cpu_defines.h/usr/include/c++/9/pstl/pstl_config.h/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h/usr/include/stdint.h/usr/include/x86_64-linux-gnu/bits/libc-header-start.h/usr/include/x86_64-linux-gnu/bits/types.h/usr/include/x86_64-linux-gnu/bits/timesize.h/usr/include/x86_64-linux-gnu/bits/typesizes.h/usr/include/x86_64-linux-gnu/bits/time64.h/usr/include/x86_64-linux-gnu/bits/wchar.h/usr/include/x86_64-linux-gnu/bits/stdint-intn.h/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h/usr/include/c++/9/map/usr/include/c++/9/bits/functexcept.h/usr/include/c++/9/bits/exception_defines.h/usr/include/c++/9/bits/cpp_type_traits.h/usr/include/c++/9/ext/type_traits.h33/usr/include/c++/9/ext/numeric_traits.h34/usr/include/c++/9/bits/stl_pair.h/usr/include/c++/9/bits/move.h/usr/include/c++/9/bits/concept_check.h/usr/include/c++/9/type_traits/usr/include/c++/9/bits/stl_iterator_base_types.h39/usr/include/c++/9/bits/stl_iterator_base_funcs.h/usr/include/c++/9/debug/assertions.h41/usr/include/c++/9/bits/ptr_traits.h/usr/include/c++/9/debug/debug.h44/usr/include/c++/9/bits/predefined_ops.h/usr/include/c++/9/bits/allocator.h/usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h47/usr/include/c++/9/ext/new_allocator.h/usr/include/c++/9/new49/usr/include/c++/9/exception/usr/include/c++/9/bits/exception.h51/usr/include/c++/9/bits/exception_ptr.h52/usr/include/c++/9/bits/cxxabi_init_exception.h5354/usr/include/c++/9/typeinfo55/usr/include/c++/9/bits/hash_bytes.h/usr/include/c++/9/bits/nested_exception.h/usr/include/c++/9/bits/memoryfwd.h59/usr/include/c++/9/bits/stl_function.h60/usr/include/c++/9/backward/binders.h61/usr/include/c++/9/ext/alloc_traits.h62/usr/include/c++/9/bits/alloc_traits.h/usr/include/c++/9/bits/node_handle.h66/usr/include/c++/9/bits/stl_relops.h68/usr/include/c++/9/initializer_list/usr/include/c++/9/stdexcept/usr/include/c++/9/string/usr/include/c++/9/bits/stringfwd.h72/usr/include/c++/9/bits/char_traits.h73/usr/include/c++/9/bits/postypes.h/usr/include/c++/9/cwchar75/usr/include/wchar.h/usr/include/x86_64-linux-gnu/bits/floatn.h/usr/include/x86_64-linux-gnu/bits/floatn-common.h/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h/usr/include/x86_64-linux-gnu/bits/types/wint_t.h/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h/usr/include/x86_64-linux-gnu/bits/types/__FILE.h/usr/include/x86_64-linux-gnu/bits/types/FILE.h/usr/include/x86_64-linux-gnu/bits/types/locale_t.h/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h/usr/include/c++/9/bits/localefwd.h/usr/include/x86_64-linux-gnu/c++/9/bits/c++locale.h/usr/include/c++/9/clocale/usr/include/locale.h/usr/include/x86_64-linux-gnu/bits/locale.h/usr/include/c++/9/iosfwd/usr/include/c++/9/cctype/usr/include/ctype.h/usr/include/x86_64-linux-gnu/bits/endian.h/usr/include/x86_64-linux-gnu/bits/endianness.h/usr/include/c++/9/bits/ostream_insert.h/usr/include/c++/9/bits/cxxabi_forced.h/usr/include/c++/9/ext/atomicity.h/usr/include/x86_64-linux-gnu/c++/9/bits/gthr.h/usr/include/x86_64-linux-gnu/c++/9/bits/gthr-default.h/usr/include/pthread.h/usr/include/x86_64-linux-gnu/bits/types/time_t.h/usr/include/x86_64-linux-gnu/bits/sched.h/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h/usr/include/x86_64-linux-gnu/bits/cpu-set.h/usr/include/x86_64-linux-gnu/bits/time.h/usr/include/x86_64-linux-gnu/bits/timex.h/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h/usr/include/x86_64-linux-gnu/bits/setjmp.h/usr/include/x86_64-linux-gnu/c++/9/bits/atomic_word.h/usr/include/c++/9/string_view/usr/include/c++/9/limits/usr/include/c++/9/bits/string_view.tcc/usr/include/c++/9/ext/string_conversions.h/usr/include/c++/9/cstdlib/usr/include/stdlib.h/usr/include/x86_64-linux-gnu/bits/waitflags.h/usr/include/x86_64-linux-gnu/bits/waitstatus.h/usr/include/endian.h/usr/include/x86_64-linux-gnu/bits/byteswap.h/usr/include/x86_64-linux-gnu/bits/uintn-identity.h/usr/include/x86_64-linux-gnu/sys/select.h/usr/include/x86_64-linux-gnu/bits/select.h/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h/usr/include/alloca.h/usr/include/x86_64-linux-gnu/bits/stdlib-float.h/usr/include/c++/9/bits/std_abs.h/usr/include/c++/9/cstdio/usr/include/stdio.h/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h/usr/include/x86_64-linux-gnu/bits/stdio_lim.h/usr/include/x86_64-linux-gnu/bits/sys_errlist.h/usr/include/c++/9/cerrno/usr/include/errno.h/usr/include/x86_64-linux-gnu/bits/errno.h/usr/include/linux/errno.h/usr/include/x86_64-linux-gnu/asm/errno.h/usr/include/asm-generic/errno.h/usr/include/asm-generic/errno-base.h/usr/include/x86_64-linux-gnu/bits/types/error_t.h/usr/include/c++/9/bits/basic_string.tcc/usr/include/c++/9/bits/enable_special_members.h/usr/include/c++/9/bits/uses_allocator.h187/usr/include/c++/9/bits/stl_multimap.h189/usr/include/c++/9/bits/erase_if.h190191/usr/include/c++/9/charconv193/usr/include/x86_64-linux-gnu/c++/9/bits/error_constants.h194195/usr/include/c++/9/cstring196/usr/include/string.h197198199/usr/include/strings.h200/usr/include/c++/9/vector202203/usr/include/c++/9/bits/stl_uninitialized.h205/usr/include/c++/9/bits/stl_bvector.h206207/home/tanteikg/QCVE/sources/bitcoin/src/util/fs.h208209/usr/include/c++/9/algorithm210211212/usr/include/c++/9/bits/algorithmfwd.h213/usr/include/c++/9/bits/stl_heap.h214/usr/include/c++/9/bits/stl_tempbuf.h215/usr/include/c++/9/bits/uniform_int_dist.h/usr/include/c++/9/pstl/glue_algorithm_defs.h217/usr/include/c++/9/functional218/usr/include/c++/9/bits/refwrap.h219220/usr/include/c++/9/unordered_map221222223/usr/include/c++/9/bits/unordered_map.h224/usr/include/c++/9/pstl/execution_defs.h225/usr/include/c++/9/iostream226227/usr/include/c++/9/ios228/usr/include/c++/9/bits/ios_base.h229/usr/include/c++/9/bits/locale_classes.h230/usr/include/c++/9/bits/locale_classes.tcc231/usr/include/c++/9/system_error232/usr/include/c++/9/streambuf233/usr/include/c++/9/bits/streambuf.tcc234/usr/include/c++/9/bits/basic_ios.h/usr/include/c++/9/bits/locale_facets.h/usr/include/c++/9/cwctype237/usr/include/wctype.h238/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h239240/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_base.h241/usr/include/c++/9/bits/streambuf_iterator.h242/usr/include/x86_64-linux-gnu/c++/9/bits/ctype_inline.h243/usr/include/c++/9/bits/locale_facets.tcc244/usr/include/c++/9/bits/basic_ios.tcc245/usr/include/c++/9/bits/ostream.tcc246/usr/include/c++/9/istream247/usr/include/c++/9/bits/istream.tcc248/usr/include/c++/9/sstream249/usr/include/c++/9/bits/sstream.tcc/usr/include/c++/9/cassert251/usr/include/assert.h252/usr/include/c++/9/filesystem/usr/include/c++/9/bits/fs_fwd.h/usr/include/c++/9/ratio257/usr/include/c++/9/ctime258/usr/include/c++/9/bits/parse_numbers.h259/usr/include/c++/9/bits/fs_path.h/usr/include/c++/9/locale261/usr/include/c++/9/bits/locale_facets_nonio.h262/usr/include/x86_64-linux-gnu/c++/9/bits/time_members.h264/usr/include/x86_64-linux-gnu/c++/9/bits/messages_members.h265/usr/include/libintl.h266/usr/include/c++/9/bits/codecvt.h267/usr/include/c++/9/bits/locale_facets_nonio.tcc268/usr/include/c++/9/bits/locale_conv.h269270/usr/include/c++/9/iomanip271272/usr/include/c++/9/codecvt273/usr/include/c++/9/ext/concurrence.h274275276/usr/include/c++/9/bits/allocated_ptr.h277/usr/include/c++/9/bits/fs_dir.h278/usr/include/c++/9/bits/fs_ops.h279280281/home/tanteikg/QCVE/sources/bitcoin/src/config/bitcoin-config.h282/home/tanteikg/QCVE/sources/bitcoin/src/compat/compat.h283284/usr/include/x86_64-linux-gnu/bits/fcntl.h285/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h286/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h287288/usr/include/linux/falloc.h289/usr/include/x86_64-linux-gnu/bits/stat.h290/usr/include/x86_64-linux-gnu/sys/mman.h291292/usr/include/x86_64-linux-gnu/bits/mman.h293/usr/include/x86_64-linux-gnu/bits/mman-map-flags-generic.h294/usr/include/x86_64-linux-gnu/bits/mman-linux.h295/usr/include/x86_64-linux-gnu/bits/mman-shared.h296/usr/include/x86_64-linux-gnu/sys/socket.h298/usr/include/x86_64-linux-gnu/bits/socket.h299300/usr/include/x86_64-linux-gnu/bits/socket_type.h301/usr/include/x86_64-linux-gnu/bits/sockaddr.h302/usr/include/x86_64-linux-gnu/asm/socket.h303/usr/include/asm-generic/socket.h304/usr/include/linux/posix_types.h305/usr/include/linux/stddef.h306/usr/include/x86_64-linux-gnu/asm/posix_types.h307/usr/include/x86_64-linux-gnu/asm/posix_types_64.h/usr/include/asm-generic/posix_types.h309/usr/include/x86_64-linux-gnu/asm/bitsperlong.h/usr/include/asm-generic/bitsperlong.h311/usr/include/x86_64-linux-gnu/asm/sockios.h312/usr/include/asm-generic/sockios.h313/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h314/usr/include/net/if.h315/usr/include/netinet/in.h316/usr/include/x86_64-linux-gnu/bits/in.h317/usr/include/netinet/tcp.h320/usr/include/arpa/inet.h321/usr/include/ifaddrs.h322/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h323/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h325/usr/include/limits.h326327/usr/include/x86_64-linux-gnu/bits/posix1_lim.h329/usr/include/x86_64-linux-gnu/bits/local_lim.h/usr/include/linux/limits.h331/usr/include/x86_64-linux-gnu/bits/posix2_lim.h332/usr/include/x86_64-linux-gnu/bits/xopen_lim.h333/usr/include/x86_64-linux-gnu/bits/uio_lim.h334/usr/include/netdb.h335/usr/include/rpc/netdb.h336337/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h338339/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h/usr/include/x86_64-linux-gnu/bits/netdb.h341342/usr/include/x86_64-linux-gnu/bits/posix_opt.h343/usr/include/x86_64-linux-gnu/bits/environments.h344345346/usr/include/x86_64-linux-gnu/bits/confname.h347/usr/include/x86_64-linux-gnu/bits/getopt_posix.h348/usr/include/x86_64-linux-gnu/bits/getopt_core.h349/usr/include/x86_64-linux-gnu/bits/unistd_ext.h351/home/tanteikg/QCVE/sources/bitcoin/src/crypto/siphash.h352353/home/tanteikg/QCVE/sources/bitcoin/src/crypto/common.h354/home/tanteikg/QCVE/sources/bitcoin/src/compat/endian.h355/home/tanteikg/QCVE/sources/bitcoin/src/compat/byteswap.h356/usr/include/byteswap.h357358359/usr/include/c++/9/cstddef360361362363364365366367368369/home/tanteikg/QCVE/sources/bitcoin/src/crypto/chacha20.h370371372373374375/usr/include/c++/9/memory376/usr/include/c++/9/bits/stl_raw_storage_iter.h377/usr/include/c++/9/bits/shared_ptr_atomic.h378379/usr/include/c++/9/bits/atomic_lockfree_defines.h380/usr/include/c++/9/backward/auto_ptr.h381/usr/include/c++/9/pstl/glue_memory_defs.h382/usr/include/c++/9/set383/usr/include/c++/9/bits/stl_set.h384/usr/include/c++/9/bits/stl_multiset.h385/home/tanteikg/QCVE/sources/bitcoin/src/util/strencodings.h386387/home/tanteikg/QCVE/sources/bitcoin/src/util/spanparsing.h388389390391392/home/tanteikg/QCVE/sources/bitcoin/src/consensus/amount.h393394/home/tanteikg/QCVE/sources/bitcoin/src/attributes.h395396/usr/include/c++/9/climits397398/usr/include/c++/9/numeric/usr/include/c++/9/bits/stl_numeric.h400/usr/include/c++/9/pstl/glue_numeric_defs.h401402/home/tanteikg/QCVE/sources/bitcoin/src/support/allocators/zeroafterfree.h403/home/tanteikg/QCVE/sources/bitcoin/src/support/cleanse.h404405/home/tanteikg/QCVE/sources/bitcoin/src/util/overflow.h406407408409/home/tanteikg/QCVE/sources/bitcoin/src/chainparams.h410/home/tanteikg/QCVE/sources/bitcoin/src/kernel/chainparams.h411/home/tanteikg/QCVE/sources/bitcoin/src/consensus/params.h412413414/usr/include/c++/9/iterator415/usr/include/c++/9/bits/stream_iterator.h416/home/tanteikg/QCVE/sources/bitcoin/src/chainparamsbase.h417/home/tanteikg/QCVE/sources/bitcoin/src/clientversion.h418/home/tanteikg/QCVE/sources/bitcoin/src/util/macros.h419420/home/tanteikg/QCVE/sources/bitcoin/src/sync.h/home/tanteikg/QCVE/sources/bitcoin/src/threadsafety.h422423/usr/include/c++/9/bits/std_mutex.h424/usr/include/c++/9/bits/unique_lock.h425/usr/include/c++/9/condition_variable426/usr/include/c++/9/thread427428429/usr/include/c++/9/list430431432433/home/tanteikg/QCVE/sources/bitcoin/src/crypto/ripemd160.h434435/home/tanteikg/QCVE/sources/bitcoin/src/crypto/sha256.h436437/home/tanteikg/QCVE/sources/bitcoin/src/version.h438439/usr/include/c++/9/atomic440441442443/home/tanteikg/QCVE/sources/bitcoin/src/util/sock.h444/home/tanteikg/QCVE/sources/bitcoin/src/util/threadinterrupt.h445446447448/home/tanteikg/QCVE/sources/bitcoin/src/addrdb.cpp<util/translation.h><util/fs_helpers.h><netbase.h><logging/timer.h><hash.h><common/args.h><clientversion.h><chainparams.h><addrman.h><addrdb.h>rb"rb"fileinDbNotFoundErrorDbNotFoundError *DataData &DeserializeFileDBverifierpchMsgTmpconst CChainParamsconst CChainParams &CChainParams &sizeof(pchMsgTmp)Invalid network magic number"Invalid network magic number"hashTmpChecksum mismatch, data corrupted"Checksum mismatch, data corrupted"DeserializeDBconst uint16_trandvtmpfnconst unsigned shortconst unsigned short &%s.%04x"%s.%04x"const uint16_t &pathTmpwb"wb"fileout%s: Failed to open file %s"%s: Failed to open file %s"const Dataconst Data &%s: Failed to flush file %s"%s: Failed to flush file %s"%s: Rename-into-place failed"%s: Rename-into-place failed"SerializeFileDBhashwriterconst exceptionconst exception &exception &e%s: Serialize or I/O error - %s"%s: Serialize or I/O error - %s"SerializeDBDbNotFoundError &DbNotFoundError &&const DbNotFoundErrorconst DbNotFoundError &~DbNotFoundError"Loaded %i addresses from %s\n", anchors.size(), fs::quoted(fs::PathToString(anchors_db_path.filename()))259900CLIENT_VERSION537130812CLIENT_VERSION | ADDRV2_FORMATconst _Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>const _Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char> &_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char> &addrdb.cppLoaded %i addresses from %s
strprintf("Flush %d outbound block-relay-only peer addresses to anchors.dat", anchors.size())tfm::format("Flush %d outbound block-relay-only peer addresses to anchors.dat", anchors.size())logging_timerlogging_timer2Flush %d outbound block-relay-only peer addresses to anchors.datconst char[65]char[65]"anchors"check_addrmanconst signed intconst signed int &-checkaddrman"-checkaddrman"1000000unique_ptr<AddrMan, default_delete<AddrMan>> &&__single_object &startpath_addrpeers.dat"peers.dat""Loaded %i addresses from peers.dat  %dms\n", addrman->Size(), Ticks<std::chrono::milliseconds>(SteadyClock::now() - start)const unique_ptr<AddrMan, default_delete<AddrMan>>Loaded %i addresses from peers.dat  %dms
const AddrMan *AddrMan *"Creating peers.dat because the file was not found (%s)\n", fs::quoted(fs::PathToString(path_addr))Creating peers.dat because the file was not found (%s)
.bak".bak"Failed to rename invalid peers.dat file. Please move or delete it and try again."Failed to rename invalid peers.dat file. Please move or delete it and try again."const char[81]char[81]"Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak\n", fs::quoted(fs::PathToString(path_addr))Creating new peers.dat because the file version was not compatible (%s). Original backed up to peers.dat.bak
const char[110]char[110]const char *const &const char(&)[42]char(&)[42]Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start."Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start."const char[219]char[219]https://github.com/bitcoin/bitcoin/issuesPACKAGE_BUGREPORT~pathpathAddrpeers"peers""banlist.dat ignored because it can only be read by " PACKAGE_NAME " version 22.x. Remove %s to silence this warning.\n", fs::quoted(fs::PathToString(m_banlist_dat))"banlist.dat ignored because it can only be read by " "Bitcoin Core" " version 22.x. Remove %s to silence this warning.\n", fs::quoted(fs::PathToString(m_banlist_dat))banlist.dat ignored because it can only be read by Bitcoin Core version 22.x. Remove %s to silence this warning.
const char[114]char[114]"Cannot load banlist %s: %s\n", fs::PathToString(m_banlist_json), errerrconst __normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>>const __normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &__normal_iterator<basic_string<char, char_traits<char>, allocator<char>> *, vector<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>> &Cannot load banlist %s: %s
const runtime_error &runtime_error &"Cannot parse banlist %s: %s\n", fs::PathToString(m_banlist_json), e.what()Cannot parse banlist %s: %s
const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>[1]pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>[1]const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> *pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> *%s"%s".dat".dat".json".json"/*consistency_check_ratio=*//*deterministic=*/// Addrman can be in an inconsistent state after failure, reset it// If the JSON banlist does not exist, then recreate it// open input file, and associate with CAutoFile// verify checksum// de-serialize data// ... verify the network matches ours// de-serialize file header (network specific magic number) and ..// replace existing file, if any, with new file// Serialize// open temp output file, and associate with CAutoFile// Generate random temporary filename// Write and commit header, datafCheckSumpair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &~pairinitializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &initializer_list_M_len_M_arrayTimer<duration<signed long, ratio<1L, 1L>>>Timer<duration<signed long, ratio<1L, 1L>>> &const Timer<duration<signed long, ratio<1L, 1L>>>const Timer<duration<signed long, ratio<1L, 1L>>> &CHashVerifier<Stream>vector<CService, allocator<CService>>unique_ptr<Sock, default_delete<Sock>>enable_if_toptional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_same<TimeType, duration<signed long, ratio<1L, 1L>>>is_same<TimeType, duration<signed long, ratio<1L, 1000L>>>is_same<TimeType, duration<signed long, ratio<1L, 1000000L>>>optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &__normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>>const LogCategory *__normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>> &__normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>> &&const __normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>> &__normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>> *list<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>list<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &list<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &&allocator<basic_string<char, char_traits<char>, allocator<char>>> &_List_node<basic_string<char, char_traits<char>, allocator<char>>> *atomic<Level>~functionlist<function<..(..)>, allocator<function<..(..)>>>list<function<..(..)>, allocator<function<..(..)>>> &list<function<..(..)>, allocator<function<..(..)>>> &&allocator<function<..(..)>> &_List_node<function<..(..)>> *unordered_map<LogFlags, Level, hash<LogFlags>, equal_to<LogFlags>, allocator<pair<const LogFlags, Level>>>~unordered_mapunordered_multimap<LogFlags, Level, _H2, _P2, allocator<pair<const LogFlags, Level>>> &&_P2unordered_multimap<LogFlags, Level, _H2, _P2, allocator<pair<const LogFlags, Level>>> &unordered_map<LogFlags, Level, _H2, _P2, allocator<pair<const LogFlags, Level>>> &&unordered_map<LogFlags, Level, _H2, _P2, allocator<pair<const LogFlags, Level>>> &LogFlags &&unordered_mapconst hasherconst hasher &hash<LogFlags> &allocator<pair<const LogFlags, Level>> &equal_to<LogFlags> &vector<LogCategory, allocator<LogCategory>>allocator<LogCategory> &optional<UniValue>optional<basic_string<char, char_traits<char>, allocator<char>>>_List_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>_List_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &const _List_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>const _List_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> &_List_base<function<..(..)>, allocator<function<..(..)>>>_List_base<function<..(..)>, allocator<function<..(..)>>> &const _List_base<function<..(..)>, allocator<function<..(..)>>>const _List_base<function<..(..)>, allocator<function<..(..)>>> &_List_iterator<function<..(..)>>_List_iterator<function<..(..)>> &&const _List_iterator<function<..(..)>>const _List_iterator<function<..(..)>> &_List_iterator<function<..(..)>> *_List_const_iterator<function<..(..)>>_List_const_iterator<function<..(..)>> &&const _List_const_iterator<function<..(..)>>const _List_const_iterator<function<..(..)>> &map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> *map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> *multimap<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &&multimap<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &&map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &const less<basic_string<char, char_traits<char>, allocator<char>>>const less<basic_string<char, char_traits<char>, allocator<char>>> &less<basic_string<char, char_traits<char>, allocator<char>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &map<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const map<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const map<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> *map<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> *multimap<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &&multimap<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &map<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &&map<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &tuple<const bool &, const int &, const int &, const int &>tuple<const bool &, const int &, const int &, const int &> &&unique_ptr<AddrManImpl, default_delete<AddrManImpl>>default_delete<AddrManImpl> &optional<bool>optional<bool> &optional<bool> &&const optional<bool>const optional<bool> &pair<CAddress, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>>>optional<Network>optional<Network> &optional<Network> &&const optional<Network>const optional<Network> &optional<AddressPosition>is_same<const CAddress &, const CAddress &>is_sameis_same<const CAddress &, const CAddress &> &is_same<const CAddress &, const CAddress &> &&const is_same<const CAddress &, const CAddress &>const is_same<const CAddress &, const CAddress &> &is_same<CAddress &, CAddress &>is_same<CAddress &, CAddress &> &is_same<CAddress &, CAddress &> &&const is_same<CAddress &, CAddress &>const is_same<CAddress &, CAddress &> &Wrapper<CompactSizeFormatter<false>, unsigned long &>Wrapper<CompactSizeFormatter<false>, unsigned long &> &const Wrapper<CompactSizeFormatter<false>, unsigned long &>const Wrapper<CompactSizeFormatter<false>, unsigned long &> &Wrapper<CompactSizeFormatter<false>, unsigned long &> &&duration<double, ratio<1L, 1L>>const duration<double, ratio<1L, 1L>>const duration<double, ratio<1L, 1L>> &duration<double, ratio<1L, 1L>> &duration<double, ratio<1L, 1000L>>const duration<double, ratio<1L, 1000L>>const duration<double, ratio<1L, 1000L>> &duration<double, ratio<1L, 1000L>> &is_same<const CService &, const CService &>is_same<const CService &, const CService &> &is_same<const CService &, const CService &> &&const is_same<const CService &, const CService &>const is_same<const CService &, const CService &> &is_same<CService &, CService &>is_same<CService &, CService &> &is_same<CService &, CService &> &&const is_same<CService &, CService &>const is_same<CService &, CService &> &Wrapper<CompactSizeFormatter<true>, const unsigned long &>Wrapper<CompactSizeFormatter<true>, const unsigned long &> &const Wrapper<CompactSizeFormatter<true>, const unsigned long &>const Wrapper<CompactSizeFormatter<true>, const unsigned long &> &Wrapper<CompactSizeFormatter<true>, const unsigned long &> &&Wrapper<CompactSizeFormatter<true>, unsigned long &>Wrapper<CompactSizeFormatter<true>, unsigned long &> &const Wrapper<CompactSizeFormatter<true>, unsigned long &>const Wrapper<CompactSizeFormatter<true>, unsigned long &> &Wrapper<CompactSizeFormatter<true>, unsigned long &> &&numeric_limits<type>numeric_limits<I>is_unsigned<I>Span<unsigned short>unsigned short[]unsigned short(&)[]Span<unsigned int>unsigned int(&)[]Span<unsigned long>unsigned long[]unsigned long(&)[]optional<bilingual_str>optional<bilingual_str> &optional<bilingual_str> &&const optional<bilingual_str>const optional<bilingual_str> &~optionalunique_ptr<AddrMan, default_delete<AddrMan>>default_delete<AddrMan> &__constructible_from<char[10], void>char(&&)[10]..(*)(..))[10]__constructible_from__constructible_from<char[10], void> &__constructible_from<char[10], void> &&const __constructible_from<char[10], void>const __constructible_from<char[10], void> &basic_ostream<_Ch, _Tr>basic_ostringstream<_CharT, _Traits, allocator<_CharT>>duration<signed long, ratio<60L, 1L>>time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> *_Insert_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>_Insert_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Insert_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &&const _Insert_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Insert_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &remove_reference_tremove_cv_tmap<basic_string<char, char_traits<char>, allocator<char>>, UniValue, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const map<basic_string<char, char_traits<char>, allocator<char>>, UniValue, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> *map<basic_string<char, char_traits<char>, allocator<char>>, UniValue, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> *multimap<basic_string<char, char_traits<char>, allocator<char>>, UniValue, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&multimap<basic_string<char, char_traits<char>, allocator<char>>, UniValue, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &map<basic_string<char, char_traits<char>, allocator<char>>, UniValue, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&map<basic_string<char, char_traits<char>, allocator<char>>, UniValue, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &map<basic_string<char, char_traits<char>, allocator<char>>, VType, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>>vector<UniValue, allocator<UniValue>>allocator<UniValue> &_Vector_base<UniValue, allocator<UniValue>>_Vector_base<UniValue, allocator<UniValue>> &const _Vector_base<UniValue, allocator<UniValue>>const _Vector_base<UniValue, allocator<UniValue>> &_Vector_base<LogCategory, allocator<LogCategory>>_Vector_base<LogCategory, allocator<LogCategory>> &const _Vector_base<LogCategory, allocator<LogCategory>>const _Vector_base<LogCategory, allocator<LogCategory>> &map<CSubNet, CBanEntry, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>>const map<CSubNet, CBanEntry, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>>const map<CSubNet, CBanEntry, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> *map<CSubNet, CBanEntry, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>> *multimap<CSubNet, CBanEntry, _C2, allocator<pair<const CSubNet, CBanEntry>>> &&multimap<CSubNet, CBanEntry, _C2, allocator<pair<const CSubNet, CBanEntry>>> &map<CSubNet, CBanEntry, _C2, allocator<pair<const CSubNet, CBanEntry>>> &&map<CSubNet, CBanEntry, _C2, allocator<pair<const CSubNet, CBanEntry>>> &const less<CSubNet>const less<CSubNet> &less<CSubNet> &allocator<pair<const CSubNet, CBanEntry>> &__tuple_compare<tuple<_TElements...>, tuple<_UElements...>, 0UL, <expression>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &&const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &&const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &_Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, less<CSubNet>, allocator<pair<const CSubNet, CBanEntry>>>_Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, _Compare2, allocator<pair<const CSubNet, CBanEntry>>> &_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>_Rb_tree_iterator<pair<const CSubNet, CBanEntry>> &&const _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>const _Rb_tree_iterator<pair<const CSubNet, CBanEntry>> &_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>> &&const _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>const _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>> &_Optional_payload_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>_Optional_payload_base<Network>_Optional_payload_base<bool>_Optional_payload_base<bilingual_str>_Optional_payload<bilingual_str, true, false, false>const _Optional_payload_base<bilingual_str>const _Optional_payload_base<bilingual_str> &_Optional_payload_base<bilingual_str> &_Optional_payload_base<bilingual_str> &&hash<type>allocator<_CharT>allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>>allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>> &allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>> &&const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>>const allocator_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>> &allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &allocator_traits<allocator<UniValue>>allocator_traits<allocator<UniValue>> &allocator_traits<allocator<UniValue>> &&const allocator_traits<allocator<UniValue>>const allocator_traits<allocator<UniValue>> &allocator_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>>allocator_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>> &allocator_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>> &&const allocator_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>>const allocator_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>> &allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>> &allocator_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>allocator_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &allocator_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &&const allocator_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>const allocator_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &allocator<_Hash_node<pair<const LogFlags, Level>, false>> &allocator_traits<allocator<function<..(..)>>>allocator_traits<allocator<function<..(..)>>> &allocator_traits<allocator<function<..(..)>>> &&const allocator_traits<allocator<function<..(..)>>>const allocator_traits<allocator<function<..(..)>>> &allocator_traits<allocator<_List_node<function<..(..)>>>>allocator_traits<allocator<_List_node<function<..(..)>>>> &allocator_traits<allocator<_List_node<function<..(..)>>>> &&const allocator_traits<allocator<_List_node<function<..(..)>>>>const allocator_traits<allocator<_List_node<function<..(..)>>>> &allocator<_List_node<function<..(..)>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &&const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &&const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const allocator_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &allocator_traits<allocator<LogCategory>>allocator_traits<allocator<LogCategory>> &allocator_traits<allocator<LogCategory>> &&const allocator_traits<allocator<LogCategory>>const allocator_traits<allocator<LogCategory>> &allocator_traits<allocator<pair<const CSubNet, CBanEntry>>>allocator_traits<allocator<pair<const CSubNet, CBanEntry>>> &allocator_traits<allocator<pair<const CSubNet, CBanEntry>>> &&const allocator_traits<allocator<pair<const CSubNet, CBanEntry>>>const allocator_traits<allocator<pair<const CSubNet, CBanEntry>>> &__rebind<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node_base *, void>__rebind<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node_base *, void> &__rebind<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node_base *, void> &&const __rebind<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node_base *, void>const __rebind<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node_base *, void> &__rebind<allocator<pair<const LogFlags, Level>>, _Hash_node<pair<const LogFlags, Level>, false>, void>__rebind<allocator<pair<const LogFlags, Level>>, _Hash_node<pair<const LogFlags, Level>, false>, void> &__rebind<allocator<pair<const LogFlags, Level>>, _Hash_node<pair<const LogFlags, Level>, false>, void> &&const __rebind<allocator<pair<const LogFlags, Level>>, _Hash_node<pair<const LogFlags, Level>, false>, void>const __rebind<allocator<pair<const LogFlags, Level>>, _Hash_node<pair<const LogFlags, Level>, false>, void> &allocator<char16_t>allocatorconst allocator<_Tp1>const allocator<_Tp1> &allocator<_Tp1> &rebind<_Tp1>allocator<char32_t>allocator<UniValue>allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>allocator<pair<const LogFlags, Level>>allocator<_Hash_node<pair<const LogFlags, Level>, false>>allocator<function<..(..)>>allocator<_List_node<function<..(..)>>>allocator<LogCategory>allocator<pair<const CSubNet, CBanEntry>>allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>allocator<char>allocator<wchar_t>new_allocator<UniValue>new_allocator<UniValue> &const new_allocator<UniValue>const new_allocator<UniValue> &new_allocatorconst new_allocator<_Tp1>const new_allocator<_Tp1> &new_allocator<_Tp1> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>const new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &new_allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>new_allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>> &const new_allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>const new_allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>> &new_allocator<pair<const LogFlags, Level>>new_allocator<pair<const LogFlags, Level>> &const new_allocator<pair<const LogFlags, Level>>const new_allocator<pair<const LogFlags, Level>> &new_allocator<_Hash_node<pair<const LogFlags, Level>, false>>new_allocator<_Hash_node<pair<const LogFlags, Level>, false>> &const new_allocator<_Hash_node<pair<const LogFlags, Level>, false>>const new_allocator<_Hash_node<pair<const LogFlags, Level>, false>> &new_allocator<function<..(..)>>new_allocator<function<..(..)>> &const new_allocator<function<..(..)>>const new_allocator<function<..(..)>> &new_allocator<_List_node<function<..(..)>>>new_allocator<_List_node<function<..(..)>>> &const new_allocator<_List_node<function<..(..)>>>const new_allocator<_List_node<function<..(..)>>> &new_allocator<LogCategory>new_allocator<LogCategory> &const new_allocator<LogCategory>const new_allocator<LogCategory> &new_allocator<pair<const CSubNet, CBanEntry>>new_allocator<pair<const CSubNet, CBanEntry>> &const new_allocator<pair<const CSubNet, CBanEntry>>const new_allocator<pair<const CSubNet, CBanEntry>> &new_allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>new_allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> &const new_allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>const new_allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> &MillisecondsDoubleSecondsDoublebanmap_tminutes__declvaldeclvaloptional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> *initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *const piecewise_construct_t &piecewise_construct_t &tuple<basic_string<char, char_traits<char>, allocator<char>> &&> &&tuple<basic_string<char, char_traits<char>, allocator<char>> &&> &const char(&)[16]char(&)[16]CHashVerifier<CDataStream> &optional<bilingual_str> *..(*)(..))[42]unique_ptr<AddrMan, default_delete<AddrMan>> *const unique_ptr<AddrMan, default_delete<AddrMan>> *operator newoperator deletedefault_delete<AddrMan> &&Timer<duration<signed long, ratio<1L, 1L>>> *vector<CAddress, allocator<CAddress>> *allocator<CAddress> &_Vector_base<CAddress, allocator<CAddress>> *vector<CAddress, allocator<CAddress>> &&_Vector_base<CAddress, allocator<CAddress>> &&const vector<CAddress, allocator<CAddress>> *const _Vector_base<CAddress, allocator<CAddress>>const _Vector_base<CAddress, allocator<CAddress>> *std::numeric_limits<T>::max()_Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true> *_Optional_base_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>> *const _Optional_base_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>>const _Optional_base_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>> *const optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> *const _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>const _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true> *atomicatomic<Level> *list<function<..(..)>, allocator<function<..(..)>>> *const list<function<..(..)>, allocator<function<..(..)>>>const list<function<..(..)>, allocator<function<..(..)>>> *const _List_base<function<..(..)>, allocator<function<..(..)>>> *_List_base<function<..(..)>, allocator<function<..(..)>>> *const _List_node_header *_List_const_iterator<function<..(..)>> *unordered_map<LogFlags, Level, hash<LogFlags>, equal_to<LogFlags>, allocator<pair<const LogFlags, Level>>> *_Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &const _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &_Hashtable *_Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *const _Hashtableconst _Hashtable &const atomic<Level>const atomic<Level> *sizeof(_Tp)Level *__atomic_load;const Level *const Level &Level &const __atomic_base<unsigned int> *__atomic_base<unsigned int> *const __int_type *const vector<LogCategory, allocator<LogCategory>> *vector<LogCategory, allocator<LogCategory>> *const _Vector_base<LogCategory, allocator<LogCategory>> *_Vector_base<LogCategory, allocator<LogCategory>> *const LogCategory *constconst LogCategory *const &LogCategory *&const __normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>> *operator intHashedSourceWriter<CAutoFile> &CHashVerifier<CAutoFile> &optional<bool> *optional<Network> *const char[170]char[170]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = HashedSourceWriter<CAutoFile>; Type = const CAddress; Operation = CSerActionSerialize]const unsigned int &const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &lambda [] type at line 143889, col. 13 &&lambda [] type at line 143891, col. 13 &&const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &> &Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &> &const ServiceFlagsconst ServiceFlags &ServiceFlags &HashedSourceWriter<CAutoFile> *OverrideStream<HashedSourceWriter<CAutoFile>> &const char[161]char[161]static void CAddress::SerializationOps(Type &, Stream &, Operation) [with Stream = CHashVerifier<CAutoFile>; Type = CAddress; Operation = CSerActionUnserialize]Wrapper<ChronoFormatter<unsigned int, true>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &&NodeSeconds &Wrapper<ChronoFormatter<unsigned int, true>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &Wrapper<CustomUintFormatter<8, false>, ServiceFlags &> &&Wrapper<CustomUintFormatter<8, false>, ServiceFlags &> &CHashVerifier<CAutoFile> *OverrideStream<CHashVerifier<CAutoFile>> &const Wrapper<CustomUintFormatter<2, true>, const unsigned short &>const Wrapper<CustomUintFormatter<2, true>, const unsigned short &> &Wrapper<CustomUintFormatter<2, true>, const unsigned short &> &Wrapper<CustomUintFormatter<2, true>, unsigned short &> &&Wrapper<CustomUintFormatter<2, true>, unsigned short &> &const OverrideStream<HashedSourceWriter<CAutoFile>>const OverrideStream<CHashVerifier<CAutoFile>>Span<unsigned char> &&INTERNAL_IN_IPV6_PREFIX.size()prevector<16U, unsigned char, unsigned int, signed int> *const prevector<16U, unsigned char, unsigned int, signed int> *const array<unsigned char, 6UL> *array<unsigned char, 6UL> *__is_path_srcconst char(&)[10]char(&)[10]const _Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char> *_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char> *const char *const *const unsigned short *const char(*)[16]char(*)[16]const char(&)[12]char(&)[12]const char(*)[12]char(*)[12]const signed long *signed long *const char(*)[42]char(*)[42]const double *double *_Hash_node<pair<const LogFlags, Level>, false> *const _Hash_code_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false>const _Hash_code_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false> *_Hash_code_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false> *const hash<LogFlags>const hash<LogFlags> &const __hash_enum<LogFlags, true>const LogFlags &noexcept(declval<const _H1&>()(declval<const _Key&>()))noexcept(declval<const _H2&>()((__hash_code)0,
						    (std::size_t)0))noexcept(declval<const _H1&>()(declval<const _Key&>()))
		  && noexcept(declval<const _H2&>()((__hash_code)0,
						    (std::size_t)0))const pair<const LogFlags, Level>const pair<const LogFlags, Level> &pair<const LogFlags, Level> &const _Hash_node_value_base<pair<const LogFlags, Level>>const _Hash_node_value_base<pair<const LogFlags, Level>> *_Hash_node_value_base<pair<const LogFlags, Level>> *vector<UniValue, allocator<UniValue>> *const vector<UniValue, allocator<UniValue>> *const _Vector_base<UniValue, allocator<UniValue>> *_Vector_base<UniValue, allocator<UniValue>> *vector<UniValue, allocator<UniValue>> &&_Vector_base<UniValue, allocator<UniValue>> &&const allocator<UniValue>const allocator<UniValue> &_Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>> *const allocator<basic_string<char, char_traits<char>, allocator<char>>>const allocator<basic_string<char, char_traits<char>, allocator<char>>> &const _Vector_base<basic_string<char, char_traits<char>, allocator<char>>, allocator<basic_string<char, char_traits<char>, allocator<char>>>>pointer()const allocator<CAddress>const allocator<CAddress> &const new_allocator<CAddress>__test__helperAddrManImpl *AddrManImpl *constAddrManImpl *const &AddrManImpl *&const default_delete<AddrManImpl>const default_delete<AddrManImpl> &AddrMan *constAddrMan *const &AddrMan *&const default_delete<AddrMan>const default_delete<AddrMan> &_S_test_S_min_alignmentsizeof(_Tp) - 1(sizeof(_Tp) - 1)sizeof(_Tp) & (sizeof(_Tp) - 1)(sizeof(_Tp) & (sizeof(_Tp) - 1))sizeof(_Tp) > 16(sizeof(_Tp) & (sizeof(_Tp) - 1)) || sizeof(_Tp) > 16(sizeof(_Tp) & (sizeof(_Tp) - 1)) || sizeof(_Tp) > 16
	? 0 : sizeof(_Tp)alignof(_Tp)_S_min_alignment > alignof(_Tp)_S_min_alignment > alignof(_Tp) ? _S_min_alignment : alignof(_Tp)is_always_lock_freecommon_type<double, signed long>common_typecommon_type<double, signed long> &common_type<double, signed long> &&const common_type<double, signed long>const common_type<double, signed long> &__success_type<unsigned short>__success_type<unsigned short> &__success_type<unsigned short> &&const __success_type<unsigned short>const __success_type<unsigned short> &__success_type<double>__success_type<double> &__success_type<double> &&const __success_type<double>const __success_type<double> &__alloc_traits<allocator<LogCategory>, LogCategory>__alloc_traits__alloc_traits<allocator<LogCategory>, LogCategory> &__alloc_traits<allocator<LogCategory>, LogCategory> &&const __alloc_traits<allocator<LogCategory>, LogCategory>const __alloc_traits<allocator<LogCategory>, LogCategory> &rebind<_Tp>__alloc_traits<allocator<UniValue>, UniValue>__alloc_traits<allocator<UniValue>, UniValue> &__alloc_traits<allocator<UniValue>, UniValue> &&const __alloc_traits<allocator<UniValue>, UniValue>const __alloc_traits<allocator<UniValue>, UniValue> &__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>> &__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>> &&const __normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>const __normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>> &__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>> *initializer_list<pair<const LogFlags, Level>>initializer_list<pair<const LogFlags, Level>> &initializer_list<pair<const LogFlags, Level>> &&const initializer_list<pair<const LogFlags, Level>>const initializer_list<pair<const LogFlags, Level>> &_Hash_node_value_base<pair<const LogFlags, Level>>_Hash_node_value_base<pair<const LogFlags, Level>> &_Hash_node_value_base<pair<const LogFlags, Level>> &&const _Hash_node_value_base<pair<const LogFlags, Level>> &_Hash_node_value_base__hash_enum<LogFlags, true>__hash_enum<LogFlags, true> &__hash_enum<LogFlags, true> &&const __hash_enum<LogFlags, true> &_Hash_code_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false>_Hash_code_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false> &_Hash_code_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false> &&const _Hash_code_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false> &convertToInt<double, true>convertToInt<double, true> &convertToInt<double, true> &&const convertToInt<double, true>const convertToInt<double, true> &convertToInt<char[42], false>convertToInt<char[42], false> &convertToInt<char[42], false> &&const convertToInt<char[42], false>const convertToInt<char[42], false> &convertToInt<signed long, true>convertToInt<signed long, true> &convertToInt<signed long, true> &&const convertToInt<signed long, true>const convertToInt<signed long, true> &convertToInt<unsigned long, true>convertToInt<unsigned long, true> &convertToInt<unsigned long, true> &&const convertToInt<unsigned long, true>const convertToInt<unsigned long, true> &convertToInt<char[12], false>convertToInt<char[12], false> &convertToInt<char[12], false> &&const convertToInt<char[12], false>const convertToInt<char[12], false> &convertToInt<char[16], false>convertToInt<char[16], false> &convertToInt<char[16], false> &&const convertToInt<char[16], false>const convertToInt<char[16], false> &convertToInt<unsigned short, true>convertToInt<unsigned short, true> &convertToInt<unsigned short, true> &&const convertToInt<unsigned short, true>const convertToInt<unsigned short, true> &convertToInt<const char *, false>convertToInt<const char *, false> &convertToInt<const char *, false> &&const convertToInt<const char *, false>const convertToInt<const char *, false> &convertToInt<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, false>convertToInt<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, false> &convertToInt<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, false> &&const convertToInt<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, false>const convertToInt<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, false> &Wrapper<CustomUintFormatter<2, true>, unsigned short &>const Wrapper<CustomUintFormatter<2, true>, unsigned short &>const Wrapper<CustomUintFormatter<2, true>, unsigned short &> &Wrapper<CustomUintFormatter<2, true>, const unsigned short &>Wrapper<CustomUintFormatter<2, true>, const unsigned short &> &&OverrideStream<CHashVerifier<CAutoFile>>const OverrideStream<CHashVerifier<CAutoFile>> &OverrideStream<CHashVerifier<CAutoFile>> &&Wrapper<CustomUintFormatter<8, false>, ServiceFlags &>const Wrapper<CustomUintFormatter<8, false>, ServiceFlags &>const Wrapper<CustomUintFormatter<8, false>, ServiceFlags &> &Wrapper<ChronoFormatter<unsigned int, true>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>const Wrapper<ChronoFormatter<unsigned int, true>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>const Wrapper<ChronoFormatter<unsigned int, true>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &OverrideStream<HashedSourceWriter<CAutoFile>>const OverrideStream<HashedSourceWriter<CAutoFile>> &OverrideStream<HashedSourceWriter<CAutoFile>> &&Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &> &&Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> &&__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 0UL, 4UL>__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 0UL, 4UL> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 0UL, 4UL> &&const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 0UL, 4UL>const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 0UL, 4UL> &CHashVerifier<CAutoFile>const CHashVerifier<CAutoFile>const CHashVerifier<CAutoFile> &CHashVerifier<CAutoFile> &&HashedSourceWriter<CAutoFile>const HashedSourceWriter<CAutoFile>const HashedSourceWriter<CAutoFile> &HashedSourceWriter<CAutoFile> &&_Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>>const equal_to<LogFlags>const equal_to<LogFlags> &_Optional_base_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>>_Optional_base_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>> &_Optional_base_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>> &&const _Optional_base_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, _Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>> &CHashVerifier<CDataStream>const CHashVerifier<CDataStream>const CHashVerifier<CDataStream> &CHashVerifier<CDataStream> &&tuple<basic_string<char, char_traits<char>, allocator<char>> &&>const tuple<basic_string<char, char_traits<char>, allocator<char>> &&>const tuple<basic_string<char, char_traits<char>, allocator<char>> &&> &__enable_if_tpropagate_on_container_move_assignmentconst _Rb_tree_node<pair<const CSubNet, CBanEntry>>const _Rb_tree_node<pair<const CSubNet, CBanEntry>> &_Rb_tree_node<pair<const CSubNet, CBanEntry>> &const _Rb_tree_node<pair<const CSubNet, CBanEntry>> *_Rb_tree_node<pair<const CSubNet, CBanEntry>> *const pair<const CSubNet, CBanEntry>const pair<const CSubNet, CBanEntry> &pair<const CSubNet, CBanEntry> &const pair<const CSubNet, CBanEntry> *pair<const CSubNet, CBanEntry> *const _List_node<function<..(..)>>const _List_node<function<..(..)>> &_List_node<function<..(..)>> &const _List_node<function<..(..)>> *const _Hash_node<pair<const LogFlags, Level>, false>const _Hash_node<pair<const LogFlags, Level>, false> &_Hash_node<pair<const LogFlags, Level>, false> &const _Hash_node<pair<const LogFlags, Level>, false> *const pair<const LogFlags, Level> *pair<const LogFlags, Level> *const _List_node<basic_string<char, char_traits<char>, allocator<char>>>const _List_node<basic_string<char, char_traits<char>, allocator<char>>> &_List_node<basic_string<char, char_traits<char>, allocator<char>>> &const _List_node<basic_string<char, char_traits<char>, allocator<char>>> *const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> *const pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>const pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>> &pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>> &const pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>> *pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>> *const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> *const pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>const pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>> &pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>> &const pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>> *pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>> *const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &const _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *_Rb_tree_node<pair<const CSubNet, CBanEntry>>__allocator_baseis_always_equalrebind<_Hash_node_base *>rebind<_Hash_node_base *> &rebind<_Hash_node_base *> &&const rebind<_Hash_node_base *>const rebind<_Hash_node_base *> &rebind<_Hash_node<pair<const LogFlags, Level>, false>>rebind<_Hash_node<pair<const LogFlags, Level>, false>> &rebind<_Hash_node<pair<const LogFlags, Level>, false>> &&const rebind<_Hash_node<pair<const LogFlags, Level>, false>>const rebind<_Hash_node<pair<const LogFlags, Level>, false>> &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>_Rb_tree_node_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&_Hash_node<pair<const LogFlags, Level>, false>_Hash_node<pair<const LogFlags, Level>, false> &&_Hash_noderebind_allocrebind_traitspropagate_on_container_swappropagate_on_container_copy_assignmentconst_void_pointervoid_pointer_Storage<bilingual_str, false>_Storage<bilingual_str, false> &const _Storage<bilingual_str, false>const _Storage<bilingual_str, false> &_Empty_byte &_Empty_byte &&const _Empty_byteconst _Empty_byte &_Storage<bool, true>_Storage<bool, true> &_Storage<bool, true> &&const _Storage<bool, true>const _Storage<bool, true> &_Storage<Network, true>_Storage<Network, true> &_Storage<Network, true> &&const _Storage<Network, true>const _Storage<Network, true> &_Storage<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>_Storage<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &_Storage<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const _Storage<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const _Storage<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &_Rb_tree<CSubNet, pair<const CSubNet, CBanEntry>, _Select1st<pair<const CSubNet, CBanEntry>>, _Compare2, allocator<pair<const CSubNet, CBanEntry>>>_Select1st<pair<const CSubNet, CBanEntry>>pair<const CSubNet, CBanEntry>_Compatible_tree__same_value_type_Rb_tree_impl<less<CSubNet>, true>_Rb_tree_impl<less<CSubNet>, true> &const _Rb_tree_impl<less<CSubNet>, true>const _Rb_tree_impl<less<CSubNet>, true> &~_Rb_tree_impl_Alloc_traits_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>_Rb_tree_impl<less<basic_string<char, char_traits<char>, allocator<char>>>, true>_Rb_tree_impl<less<basic_string<char, char_traits<char>, allocator<char>>>, true> &const _Rb_tree_impl<less<basic_string<char, char_traits<char>, allocator<char>>>, true>const _Rb_tree_impl<less<basic_string<char, char_traits<char>, allocator<char>>>, true> &_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Compare2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &first_typeconst first_typeconst first_type &first_type &_Pair2const _Pair2const _Pair2 &_Pair2 &_Rb_tree_impl<less<basic_string<char, char_traits<char>, allocator<char>>>, true> *_Alloc_node &const _Alloc_node &_Alloc_node &&map<CSubNet, CBanEntry, _C2, allocator<pair<const CSubNet, CBanEntry>>>multimap<CSubNet, CBanEntry, _C2, allocator<pair<const CSubNet, CBanEntry>>>pair<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, bool>pair<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>pair<_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>>less<CSubNet>lessless<CSubNet> &&_Rep_type_Vector_impl &const _Vector_implconst _Vector_impl &~_Vector_impl_Baseallocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>>map<basic_string<char, char_traits<char>, allocator<char>>, UniValue, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>multimap<basic_string<char, char_traits<char>, allocator<char>>, UniValue, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, bool>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>pair<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>pair<const LogFlags, Level>__hashtable_basetime_point<clock, _Dur2>__uniq_ptr_impl<AddrMan, default_delete<AddrMan>>__uniq_ptr_impl<AddrMan, default_delete<AddrMan>> &__uniq_ptr_impl<AddrMan, default_delete<AddrMan>> &&const __uniq_ptr_impl<AddrMan, default_delete<AddrMan>>const __uniq_ptr_impl<AddrMan, default_delete<AddrMan>> &default_delete<AddrMan>__safe_conversion_up_Enable_copy_move<true, true, true, true, optional<bilingual_str>>_Enable_copy_move<true, true, true, true, optional<bilingual_str>> &_Enable_copy_move<true, true, true, true, optional<bilingual_str>> &&const _Enable_copy_move<true, true, true, true, optional<bilingual_str>>const _Enable_copy_move<true, true, true, true, optional<bilingual_str>> &_Optional_base<bilingual_str, false, false>~_Optional_base_Optional_base<bilingual_str, false, false> *__not_self__not_tagis_Span_int<byte[1024]>is_Span_intis_Span_int<byte[1024]> &is_Span_int<byte[1024]> &&const is_Span_int<byte[1024]>const is_Span_int<byte[1024]> &is_Span<byte[1024]>is_Spanis_Span<byte[1024]> &is_Span<byte[1024]> &&const is_Span<byte[1024]>const is_Span<byte[1024]> &is_Span_int<byte *>is_Span_int<byte *> &is_Span_int<byte *> &&const is_Span_int<byte *>const is_Span_int<byte *> &is_Span<byte *>is_Span<byte *> &is_Span<byte *> &&const is_Span<byte *>const is_Span<byte *> &is_Span_int<Span<byte>>is_Span_int<Span<byte>> &is_Span_int<Span<byte>> &&const is_Span_int<Span<byte>>const is_Span_int<Span<byte>> &is_Span<Span<byte>>is_Span<Span<byte>> &is_Span<Span<byte>> &&const is_Span<Span<byte>>const is_Span<Span<byte>> &is_Span_int<Span<unsigned long>>is_Span_int<Span<unsigned long>> &is_Span_int<Span<unsigned long>> &&const is_Span_int<Span<unsigned long>>const is_Span_int<Span<unsigned long>> &is_Span<Span<unsigned long>>is_Span<Span<unsigned long>> &is_Span<Span<unsigned long>> &&const is_Span<Span<unsigned long>>const is_Span<Span<unsigned long>> &is_Span_int<unsigned long *>is_Span_int<unsigned long *> &is_Span_int<unsigned long *> &&const is_Span_int<unsigned long *>const is_Span_int<unsigned long *> &is_Span<unsigned long *>is_Span<unsigned long *> &is_Span<unsigned long *> &&const is_Span<unsigned long *>const is_Span<unsigned long *> &is_Span<V>is_Span_int<Span<unsigned int>>is_Span_int<Span<unsigned int>> &is_Span_int<Span<unsigned int>> &&const is_Span_int<Span<unsigned int>>const is_Span_int<Span<unsigned int>> &is_Span<Span<unsigned int>>is_Span<Span<unsigned int>> &is_Span<Span<unsigned int>> &&const is_Span<Span<unsigned int>>const is_Span<Span<unsigned int>> &is_Span_int<unsigned int *>is_Span_int<unsigned int *> &is_Span_int<unsigned int *> &&const is_Span_int<unsigned int *>const is_Span_int<unsigned int *> &is_Span<unsigned int *>is_Span<unsigned int *> &is_Span<unsigned int *> &&const is_Span<unsigned int *>const is_Span<unsigned int *> &is_Span_int<Span<unsigned short>>is_Span_int<Span<unsigned short>> &is_Span_int<Span<unsigned short>> &&const is_Span_int<Span<unsigned short>>const is_Span_int<Span<unsigned short>> &is_Span<Span<unsigned short>>is_Span<Span<unsigned short>> &is_Span<Span<unsigned short>> &&const is_Span<Span<unsigned short>>const is_Span<Span<unsigned short>> &is_Span_int<unsigned short *>is_Span_int<unsigned short *> &is_Span_int<unsigned short *> &&const is_Span_int<unsigned short *>const is_Span_int<unsigned short *> &is_Span<unsigned short *>is_Span<unsigned short *> &is_Span<unsigned short *> &&const is_Span<unsigned short *>const is_Span<unsigned short *> &is_Span<const Wrapper<CustomUintFormatter<2, true>, const unsigned short &>>is_Span<const Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &is_Span<const Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &&const is_Span<const Wrapper<CustomUintFormatter<2, true>, const unsigned short &>>const is_Span<const Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &is_Span_int<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>>is_Span_int<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &is_Span_int<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &&const is_Span_int<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>>const is_Span_int<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &is_Span<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>>is_Span<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &is_Span<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &&const is_Span<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>>const is_Span<Wrapper<CustomUintFormatter<2, true>, const unsigned short &>> &is_Span<const prevector<16U, unsigned char, unsigned int, signed int>>is_Span<const prevector<16U, unsigned char, unsigned int, signed int>> &is_Span<const prevector<16U, unsigned char, unsigned int, signed int>> &&const is_Span<const prevector<16U, unsigned char, unsigned int, signed int>>const is_Span<const prevector<16U, unsigned char, unsigned int, signed int>> &is_Span_int<prevector<16U, unsigned char, unsigned int, signed int>>is_Span_int<prevector<16U, unsigned char, unsigned int, signed int>> &is_Span_int<prevector<16U, unsigned char, unsigned int, signed int>> &&const is_Span_int<prevector<16U, unsigned char, unsigned int, signed int>>const is_Span_int<prevector<16U, unsigned char, unsigned int, signed int>> &is_Span<prevector<16U, unsigned char, unsigned int, signed int>>is_Span<prevector<16U, unsigned char, unsigned int, signed int>> &is_Span<prevector<16U, unsigned char, unsigned int, signed int>> &&const is_Span<prevector<16U, unsigned char, unsigned int, signed int>>const is_Span<prevector<16U, unsigned char, unsigned int, signed int>> &is_Span<const unsigned char[16]>is_Span<const unsigned char[16]> &is_Span<const unsigned char[16]> &&const is_Span<const unsigned char[16]>const is_Span<const unsigned char[16]> &is_Span_int<unsigned char[16]>is_Span_int<unsigned char[16]> &is_Span_int<unsigned char[16]> &&const is_Span_int<unsigned char[16]>const is_Span_int<unsigned char[16]> &is_Span<unsigned char[16]>is_Span<unsigned char[16]> &is_Span<unsigned char[16]> &&const is_Span<unsigned char[16]>const is_Span<unsigned char[16]> &is_Span<const Wrapper<CompactSizeFormatter<true>, const unsigned long &>>is_Span<const Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &is_Span<const Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &&const is_Span<const Wrapper<CompactSizeFormatter<true>, const unsigned long &>>const is_Span<const Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &is_Span_int<Wrapper<CompactSizeFormatter<true>, const unsigned long &>>is_Span_int<Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &is_Span_int<Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &&const is_Span_int<Wrapper<CompactSizeFormatter<true>, const unsigned long &>>const is_Span_int<Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &is_Span<Wrapper<CompactSizeFormatter<true>, const unsigned long &>>is_Span<Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &is_Span<Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &&const is_Span<Wrapper<CompactSizeFormatter<true>, const unsigned long &>>const is_Span<Wrapper<CompactSizeFormatter<true>, const unsigned long &>> &is_Span<const unsigned char>is_Span<const unsigned char> &is_Span<const unsigned char> &&const is_Span<const unsigned char>const is_Span<const unsigned char> &is_Span_int<unsigned char>is_Span_int<unsigned char> &is_Span_int<unsigned char> &&const is_Span_int<unsigned char>const is_Span_int<unsigned char> &is_Span<unsigned char>is_Span<unsigned char> &is_Span<unsigned char> &&const is_Span<unsigned char>const is_Span<unsigned char> &is_Span<const CNetAddr>is_Span<const CNetAddr> &is_Span<const CNetAddr> &&const is_Span<const CNetAddr>const is_Span<const CNetAddr> &is_Span_int<CNetAddr>is_Span_int<CNetAddr> &is_Span_int<CNetAddr> &&const is_Span_int<CNetAddr>const is_Span_int<CNetAddr> &is_Span<CNetAddr>is_Span<CNetAddr> &is_Span<CNetAddr> &&const is_Span<CNetAddr>const is_Span<CNetAddr> &is_Span<const CService>is_Span<const CService> &is_Span<const CService> &&const is_Span<const CService>const is_Span<const CService> &is_Span_int<CService>is_Span_int<CService> &is_Span_int<CService> &&const is_Span_int<CService>const is_Span_int<CService> &is_Span<CService>is_Span<CService> &is_Span<CService> &&const is_Span<CService>const is_Span<CService> &is_Span<const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>>is_Span<const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &is_Span<const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &&const is_Span<const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>>const is_Span<const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &is_Span_int<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>>is_Span_int<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &is_Span_int<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &&const is_Span_int<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>>const is_Span_int<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &is_Span<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>>is_Span<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &is_Span<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &&const is_Span<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>>const is_Span<Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &>> &is_Span<const Wrapper<CompactSizeFormatter<false>, unsigned long &>>is_Span<const Wrapper<CompactSizeFormatter<false>, unsigned long &>> &is_Span<const Wrapper<CompactSizeFormatter<false>, unsigned long &>> &&const is_Span<const Wrapper<CompactSizeFormatter<false>, unsigned long &>>const is_Span<const Wrapper<CompactSizeFormatter<false>, unsigned long &>> &is_Span_int<Wrapper<CompactSizeFormatter<false>, unsigned long &>>is_Span_int<Wrapper<CompactSizeFormatter<false>, unsigned long &>> &is_Span_int<Wrapper<CompactSizeFormatter<false>, unsigned long &>> &&const is_Span_int<Wrapper<CompactSizeFormatter<false>, unsigned long &>>const is_Span_int<Wrapper<CompactSizeFormatter<false>, unsigned long &>> &is_Span<Wrapper<CompactSizeFormatter<false>, unsigned long &>>is_Span<Wrapper<CompactSizeFormatter<false>, unsigned long &>> &is_Span<Wrapper<CompactSizeFormatter<false>, unsigned long &>> &&const is_Span<Wrapper<CompactSizeFormatter<false>, unsigned long &>>const is_Span<Wrapper<CompactSizeFormatter<false>, unsigned long &>> &is_Span<const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>is_Span<const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &&const is_Span<const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>const is_Span<const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span_int<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>is_Span_int<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span_int<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &&const is_Span_int<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>const is_Span_int<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>is_Span<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &&const is_Span<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>>const is_Span<Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &>> &is_Span<const unsigned int>is_Span<const unsigned int> &is_Span<const unsigned int> &&const is_Span<const unsigned int>const is_Span<const unsigned int> &is_Span_int<unsigned int>is_Span_int<unsigned int> &is_Span_int<unsigned int> &&const is_Span_int<unsigned int>const is_Span_int<unsigned int> &is_Span<unsigned int>is_Span<unsigned int> &is_Span<unsigned int> &&const is_Span<unsigned int>const is_Span<unsigned int> &is_Span<const CAddress>is_Span<const CAddress> &is_Span<const CAddress> &&const is_Span<const CAddress>const is_Span<const CAddress> &is_Span_int<CAddress>is_Span_int<CAddress> &is_Span_int<CAddress> &&const is_Span_int<CAddress>const is_Span_int<CAddress> &is_Span<CAddress>is_Span<CAddress> &is_Span<CAddress> &&const is_Span<CAddress>const is_Span<CAddress> &is_Span_int<unsigned char *>is_Span_int<unsigned char *> &is_Span_int<unsigned char *> &&const is_Span_int<unsigned char *>const is_Span_int<unsigned char *> &is_Span<unsigned char *>is_Span<unsigned char *> &is_Span<unsigned char *> &&const is_Span<unsigned char *>const is_Span<unsigned char *> &is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>>is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>> &is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>> &&const is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>>const is_Span_int<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>> &is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>>is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>> &is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>> &&const is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>>const is_Span<Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>> &is_Span<const vector<CAddress, allocator<CAddress>>>is_Span<const vector<CAddress, allocator<CAddress>>> &is_Span<const vector<CAddress, allocator<CAddress>>> &&const is_Span<const vector<CAddress, allocator<CAddress>>>const is_Span<const vector<CAddress, allocator<CAddress>>> &is_Span_int<vector<CAddress, allocator<CAddress>>>is_Span_int<vector<CAddress, allocator<CAddress>>> &is_Span_int<vector<CAddress, allocator<CAddress>>> &&const is_Span_int<vector<CAddress, allocator<CAddress>>>const is_Span_int<vector<CAddress, allocator<CAddress>>> &is_Span<vector<CAddress, allocator<CAddress>>>is_Span<vector<CAddress, allocator<CAddress>>> &is_Span<vector<CAddress, allocator<CAddress>>> &&const is_Span<vector<CAddress, allocator<CAddress>>>const is_Span<vector<CAddress, allocator<CAddress>>> &is_Span_int<array<unsigned char, 32UL>>is_Span_int<array<unsigned char, 32UL>> &is_Span_int<array<unsigned char, 32UL>> &&const is_Span_int<array<unsigned char, 32UL>>const is_Span_int<array<unsigned char, 32UL>> &is_Span<array<unsigned char, 32UL>>is_Span<array<unsigned char, 32UL>> &is_Span<array<unsigned char, 32UL>> &&const is_Span<array<unsigned char, 32UL>>const is_Span<array<unsigned char, 32UL>> &is_Span_int<Span<unsigned char>>is_Span_int<Span<unsigned char>> &is_Span_int<Span<unsigned char>> &&const is_Span_int<Span<unsigned char>>const is_Span_int<Span<unsigned char>> &is_Span<Span<unsigned char>>is_Span<Span<unsigned char>> &is_Span<Span<unsigned char>> &&const is_Span<Span<unsigned char>>const is_Span<Span<unsigned char>> &is_Span<const uint256>is_Span<const uint256> &is_Span<const uint256> &&const is_Span<const uint256>const is_Span<const uint256> &is_Span<const AddrMan>is_Span<const AddrMan> &is_Span<const AddrMan> &&const is_Span<const AddrMan>const is_Span<const AddrMan> &is_Span_int<AddrMan>is_Span_int<AddrMan> &is_Span_int<AddrMan> &&const is_Span_int<AddrMan>const is_Span_int<AddrMan> &is_Span<AddrMan>is_Span<AddrMan> &is_Span<AddrMan> &&const is_Span<AddrMan>const is_Span<AddrMan> &is_Span<const unsigned char[4]>const unsigned char[4]is_Span<const unsigned char[4]> &is_Span<const unsigned char[4]> &&const is_Span<const unsigned char[4]>const is_Span<const unsigned char[4]> &is_Span_int<unsigned char[4]>is_Span_int<unsigned char[4]> &is_Span_int<unsigned char[4]> &&const is_Span_int<unsigned char[4]>const is_Span_int<unsigned char[4]> &is_Span<unsigned char[4]>is_Span<unsigned char[4]> &is_Span<unsigned char[4]> &&const is_Span<unsigned char[4]>const is_Span<unsigned char[4]> &is_Span<const array<unsigned char, 32UL>>const array<unsigned char, 32UL>is_Span<const array<unsigned char, 32UL>> &is_Span<const array<unsigned char, 32UL>> &&const is_Span<const array<unsigned char, 32UL>>const is_Span<const array<unsigned char, 32UL>> &CompactSizeFormatter<true>CompactSizeFormatter<true> &CompactSizeFormatter<true> &&const CompactSizeFormatter<true>const CompactSizeFormatter<true> &__is_float__is_harmonicCompactSizeFormatter<false>CompactSizeFormatter<false> &CompactSizeFormatter<false> &&const CompactSizeFormatter<false>const CompactSizeFormatter<false> &_Enable_copy_move<true, true, true, true, optional<Network>>_Enable_copy_move<true, true, true, true, optional<Network>> &_Enable_copy_move<true, true, true, true, optional<Network>> &&const _Enable_copy_move<true, true, true, true, optional<Network>>const _Enable_copy_move<true, true, true, true, optional<Network>> &_Optional_base<Network, true, true>_Enable_copy_move<true, true, true, true, optional<bool>>_Enable_copy_move<true, true, true, true, optional<bool>> &_Enable_copy_move<true, true, true, true, optional<bool>> &&const _Enable_copy_move<true, true, true, true, optional<bool>>const _Enable_copy_move<true, true, true, true, optional<bool>> &_Optional_base<bool, true, true>__uniq_ptr_impl<AddrManImpl, default_delete<AddrManImpl>>__uniq_ptr_impl<AddrManImpl, default_delete<AddrManImpl>> &__uniq_ptr_impl<AddrManImpl, default_delete<AddrManImpl>> &&const __uniq_ptr_impl<AddrManImpl, default_delete<AddrManImpl>>const __uniq_ptr_impl<AddrManImpl, default_delete<AddrManImpl>> &default_delete<AddrManImpl>default_delete<AddrManImpl> &&_Tuple_impl<0UL, const bool &, const int &, const int &, const int &>_Tuple_impl<0UL, _UHead, _UTails...> &&const _Tuple_impl<0UL, _UElements...>const _Tuple_impl<0UL, _UElements...> &_Tuple_impl<0UL, _UElements...> &const _Tuple_impl<0UL, _UHead, _UTails...>const _Tuple_impl<0UL, _UHead, _UTails...> &_Tuple_impl<0UL, _UHead, _UTails...> &_Tuple_impl<0UL, const bool &, const int &, const int &, const int &> &&const _Tuple_impl<0UL, const bool &, const int &, const int &, const int &>const _Tuple_impl<0UL, const bool &, const int &, const int &, const int &> &_Tuple_impl<0UL, const bool &, const int &, const int &, const int &> &_TNTC_TMCT_TMC_TCC_Inheritedmap<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>multimap<basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, bool>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>pair<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>multimap<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, _C2, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, bool>pair<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>pair<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>_List_impl &const _List_implconst _List_impl &~_List_implpair<_Node_iterator<pair<const LogFlags, Level>, false, false>, bool>unordered_map<LogFlags, Level, _H2, _P2, allocator<pair<const LogFlags, Level>>>unordered_multimap<LogFlags, Level, _H2, _P2, allocator<pair<const LogFlags, Level>>>equal_to<LogFlags>equal_toequal_to<LogFlags> &&hash<LogFlags>hash<LogFlags> &&_List_node<function<..(..)>>_List_node_List_node<function<..(..)>> &&_Maybe_unary_or_binary_function<void, const basic_string<char, char_traits<char>, allocator<char>> &>_Maybe_unary_or_binary_function_Maybe_unary_or_binary_function<void, const basic_string<char, char_traits<char>, allocator<char>> &> &_Maybe_unary_or_binary_function<void, const basic_string<char, char_traits<char>, allocator<char>> &> &&const _Maybe_unary_or_binary_function<void, const basic_string<char, char_traits<char>, allocator<char>> &>const _Maybe_unary_or_binary_function<void, const basic_string<char, char_traits<char>, allocator<char>> &> &_Callable<type, __invoke_result<type &, const basic_string<char, char_traits<char>, allocator<char>> &>>_Callable<_Functor, __invoke_result<_Functor &, const basic_string<char, char_traits<char>, allocator<char>> &>>_List_node<basic_string<char, char_traits<char>, allocator<char>>>remove_reference<function<..(..)> &>remove_reference<function<..(..)> &> &remove_reference<function<..(..)> &> &&const remove_reference<function<..(..)> &>const remove_reference<function<..(..)> &> &_Enable_copy_move<true, true, true, true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>_Enable_copy_move<true, true, true, true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &_Enable_copy_move<true, true, true, true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const _Enable_copy_move<true, true, true, true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const _Enable_copy_move<true, true, true, true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &_Optional_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true>default_delete<Sock>allocator<CService>_MakeUniq<AddrMan>_MakeUniq<AddrMan> &_MakeUniq<AddrMan> &&const _MakeUniq<AddrMan>const _MakeUniq<AddrMan> &__add_lvalue_reference_helper<AddrMan, true>__is_referenceable<_Tp>::value__add_lvalue_reference_helper<AddrMan, true> &__add_lvalue_reference_helper<AddrMan, true> &&const __add_lvalue_reference_helper<AddrMan, true>const __add_lvalue_reference_helper<AddrMan, true> &__pair_base<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>_PCCFP_PCCP~allocatorallocator<_List_node<function<..(..)>>> *_Optional_payload<bilingual_str, false, false, false> *_Optional_payload<bilingual_str, true, false, false> *_Optional_payload_base<bilingual_str> *allocator<UniValue> *allocator<LogCategory> *allocator<CAddress> *allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> *const new_allocator<CAddress> *new_allocator<CAddress> *size_t(__PTRDIFF_MAX__)164703072086692425size_t(__PTRDIFF_MAX__) / sizeof(_Tp)alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__std::align_val_t(alignof(_Tp))static_cast<const void*>(0)__alnew_allocator<LogCategory> *new_allocator<_List_node<function<..(..)>>> *const new_allocator<_List_node<function<..(..)>>> *new_allocator<_Hash_node<pair<const LogFlags, Level>, false>> *const new_allocator<_Hash_node<pair<const LogFlags, Level>, false>> *new_allocator<UniValue> *const new_allocator<UniValue> *new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> *const new_allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> *const UniValue *constconst UniValue *const &UniValue *&__uninitialized_copy_aconst _Hashtable_ebo_helper<0, _Select1st, true>const _Hashtable_ebo_helper<0, _Select1st, true> &_Hashtable_ebo_helper<0, _Select1st, true> &forwardconst _Hashtable_ebo_helper<1, hash<LogFlags>, true>const _Hashtable_ebo_helper<1, hash<LogFlags>, true> &_Hashtable_ebo_helper<1, hash<LogFlags>, true> &const _Hashtable_ebo_helper<2, _Mod_range_hashing, true>const _Hashtable_ebo_helper<2, _Mod_range_hashing, true> &_Hashtable_ebo_helper<2, _Mod_range_hashing, true> &const __hash_enum<LogFlags, true> *__hash_enum<LogFlags, true> *DummyType()detail::is_convertible<T,char>::valuedetail::is_convertible<T, const void*>::valuecanConvertToVoidPtr && *(fmtEnd-1) == 'p'canConvertToChar && *(fmtEnd-1) == 'c'const Span<unsigned long> *Span<unsigned long> *sizeof(C)const Span<unsigned int> *Span<unsigned int> *const Span<unsigned short> *Span<unsigned short> *const Span<unsigned char> *Span<unsigned char> *Wrapper<CompactSizeFormatter<true>, unsigned long &> *const array<unsigned char, 12UL> *array<unsigned char, 12UL> *Wrapper<CompactSizeFormatter<true>, const unsigned long &> *OverrideStream<CHashVerifier<CAutoFile>> *const OverrideStream<CHashVerifier<CAutoFile>> *OverrideStream<HashedSourceWriter<CAutoFile>> *const OverrideStream<HashedSourceWriter<CAutoFile>> *Wrapper<CompactSizeFormatter<false>, unsigned long &> *_Optional_base<Network, true, true> *_Optional_base<bool, true, true> *__atomic_store__addressofconst _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *__node_alloc_traits::_S_propagate_on_copy_assign()_Hashtable_alloc<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> *const _Hashtable_alloc<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>__node_alloc_traits::_S_always_equal()!__node_alloc_traits::_S_always_equal()const allocator<_Hash_node<pair<const LogFlags, Level>, false>>const allocator<_Hash_node<pair<const LogFlags, Level>, false>> &!__node_alloc_traits::_S_always_equal()
	      && __this_alloc != __that_alloc_Hashtable_base<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &const _Hashtable_base<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>const _Hashtable_base<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &_Hashtable_base<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *lambda [] type at line 80102, col. 8 &&lambda [] type at line 80119, col. 2 &&_ReuseOrAllocNode<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &operator std::__detail::_Hash_node<std::pair<const BCLog::LogFlags, BCLog::Level>, false> *(*)(const std::__detail::_ReuseOrAllocNode<std::allocator<std::__detail::_Hash_node<std::pair<const BCLog::LogFlags, BCLog::Level>, false>>> &, const std::__detail::_Hash_node<std::pair<const BCLog::LogFlags, BCLog::Level>, false> *)_Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> *constlambda [] type at line 80314, col. 3 &&const _List_const_iterator<function<..(..)>> *const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> *const duration<double, ratio<1L, 1L>> *duration<double, ratio<1L, 1L>> *is_nothrow_constructible_v<_Stored_type, _Args...>_Storage<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> *const _Optional_payload_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const unsigned char(&)[4]AddrMan *&&CHashVerifier<CDataStream> *_Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> *const _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *const initializer_list<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *is_nothrow_constructible_vis_nothrow_constructible<_Tp, _Args...>::valuesizeof(tryConvert(makeT1()))sizeof(succeed)sizeof(tryConvert(makeT1())) == sizeof(succeed)const void *constconst void *const &void *&const char &char &..(*)(..))[16]..(*)(..))[12]is_trivially_move_constructible_vis_trivially_move_constructible<_Tp>::valueis_trivially_copy_constructible_vis_trivially_copy_constructible<_Tp>::value__and_v__and_<_Bn...>::valueis_move_constructible_vis_move_constructible<_Tp>::valueis_copy_constructible_vis_copy_constructible<_Tp>::valueis_trivially_destructible_vis_trivially_destructible<_Tp>::valuesucceed &succeed &&const succeedconst succeed &fail &fail &&const failconst fail &is_trivially_destructible<bilingual_str>is_trivially_destructibleis_trivially_destructible<bilingual_str> &is_trivially_destructible<bilingual_str> &&const is_trivially_destructible<bilingual_str>const is_trivially_destructible<bilingual_str> &is_trivially_destructible<bool>is_trivially_destructible<bool> &is_trivially_destructible<bool> &&const is_trivially_destructible<bool>const is_trivially_destructible<bool> &is_trivially_destructible<Network>is_trivially_destructible<Network> &is_trivially_destructible<Network> &&const is_trivially_destructible<Network>const is_trivially_destructible<Network> &is_trivially_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_trivially_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_trivially_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_trivially_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_copy_assignable<bilingual_str>is_copy_assignableis_copy_assignable<bilingual_str> &is_copy_assignable<bilingual_str> &&const is_copy_assignable<bilingual_str>const is_copy_assignable<bilingual_str> &is_copy_constructible<bilingual_str>is_copy_constructibleis_copy_constructible<bilingual_str> &is_copy_constructible<bilingual_str> &&const is_copy_constructible<bilingual_str>const is_copy_constructible<bilingual_str> &__and_<is_copy_constructible<bilingual_str>, is_copy_assignable<bilingual_str>>__and___and_<is_copy_constructible<bilingual_str>, is_copy_assignable<bilingual_str>> &__and_<is_copy_constructible<bilingual_str>, is_copy_assignable<bilingual_str>> &&const __and_<is_copy_constructible<bilingual_str>, is_copy_assignable<bilingual_str>>const __and_<is_copy_constructible<bilingual_str>, is_copy_assignable<bilingual_str>> &is_move_assignable<bilingual_str>is_move_assignableis_move_assignable<bilingual_str> &is_move_assignable<bilingual_str> &&const is_move_assignable<bilingual_str>const is_move_assignable<bilingual_str> &is_move_constructible<bilingual_str>is_move_constructibleis_move_constructible<bilingual_str> &is_move_constructible<bilingual_str> &&const is_move_constructible<bilingual_str>const is_move_constructible<bilingual_str> &__and_<is_move_constructible<bilingual_str>, is_move_assignable<bilingual_str>>__and_<is_move_constructible<bilingual_str>, is_move_assignable<bilingual_str>> &__and_<is_move_constructible<bilingual_str>, is_move_assignable<bilingual_str>> &&const __and_<is_move_constructible<bilingual_str>, is_move_assignable<bilingual_str>>const __and_<is_move_constructible<bilingual_str>, is_move_assignable<bilingual_str>> &is_trivially_copy_constructible<bilingual_str>is_trivially_copy_constructibleis_trivially_copy_constructible<bilingual_str> &is_trivially_copy_constructible<bilingual_str> &&const is_trivially_copy_constructible<bilingual_str>const is_trivially_copy_constructible<bilingual_str> &is_trivially_move_constructible<bilingual_str>is_trivially_move_constructibleis_trivially_move_constructible<bilingual_str> &is_trivially_move_constructible<bilingual_str> &&const is_trivially_move_constructible<bilingual_str>const is_trivially_move_constructible<bilingual_str> &is_copy_assignable<Network>is_copy_assignable<Network> &is_copy_assignable<Network> &&const is_copy_assignable<Network>const is_copy_assignable<Network> &is_copy_constructible<Network>is_copy_constructible<Network> &is_copy_constructible<Network> &&const is_copy_constructible<Network>const is_copy_constructible<Network> &__and_<is_copy_constructible<Network>, is_copy_assignable<Network>>__and_<is_copy_constructible<Network>, is_copy_assignable<Network>> &__and_<is_copy_constructible<Network>, is_copy_assignable<Network>> &&const __and_<is_copy_constructible<Network>, is_copy_assignable<Network>>const __and_<is_copy_constructible<Network>, is_copy_assignable<Network>> &is_move_assignable<Network>is_move_assignable<Network> &is_move_assignable<Network> &&const is_move_assignable<Network>const is_move_assignable<Network> &is_move_constructible<Network>is_move_constructible<Network> &is_move_constructible<Network> &&const is_move_constructible<Network>const is_move_constructible<Network> &__and_<is_move_constructible<Network>, is_move_assignable<Network>>__and_<is_move_constructible<Network>, is_move_assignable<Network>> &__and_<is_move_constructible<Network>, is_move_assignable<Network>> &&const __and_<is_move_constructible<Network>, is_move_assignable<Network>>const __and_<is_move_constructible<Network>, is_move_assignable<Network>> &is_trivially_copy_constructible<Network>is_trivially_copy_constructible<Network> &is_trivially_copy_constructible<Network> &&const is_trivially_copy_constructible<Network>const is_trivially_copy_constructible<Network> &is_trivially_move_constructible<Network>is_trivially_move_constructible<Network> &is_trivially_move_constructible<Network> &&const is_trivially_move_constructible<Network>const is_trivially_move_constructible<Network> &is_copy_assignable<bool>is_copy_assignable<bool> &is_copy_assignable<bool> &&const is_copy_assignable<bool>const is_copy_assignable<bool> &is_copy_constructible<bool>is_copy_constructible<bool> &is_copy_constructible<bool> &&const is_copy_constructible<bool>const is_copy_constructible<bool> &__and_<is_copy_constructible<bool>, is_copy_assignable<bool>>__and_<is_copy_constructible<bool>, is_copy_assignable<bool>> &__and_<is_copy_constructible<bool>, is_copy_assignable<bool>> &&const __and_<is_copy_constructible<bool>, is_copy_assignable<bool>>const __and_<is_copy_constructible<bool>, is_copy_assignable<bool>> &is_move_assignable<bool>is_move_assignable<bool> &is_move_assignable<bool> &&const is_move_assignable<bool>const is_move_assignable<bool> &is_move_constructible<bool>is_move_constructible<bool> &is_move_constructible<bool> &&const is_move_constructible<bool>const is_move_constructible<bool> &__and_<is_move_constructible<bool>, is_move_assignable<bool>>__and_<is_move_constructible<bool>, is_move_assignable<bool>> &__and_<is_move_constructible<bool>, is_move_assignable<bool>> &&const __and_<is_move_constructible<bool>, is_move_assignable<bool>>const __and_<is_move_constructible<bool>, is_move_assignable<bool>> &is_trivially_copy_constructible<bool>is_trivially_copy_constructible<bool> &is_trivially_copy_constructible<bool> &&const is_trivially_copy_constructible<bool>const is_trivially_copy_constructible<bool> &is_trivially_move_constructible<bool>is_trivially_move_constructible<bool> &is_trivially_move_constructible<bool> &&const is_trivially_move_constructible<bool>const is_trivially_move_constructible<bool> &is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &__and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>__and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const __and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const __and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &__and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>__and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const __and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const __and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &is_trivially_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_trivially_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_trivially_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_trivially_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_trivially_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_trivially_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_trivially_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_nothrow_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_nothrow_constructibleis_nothrow_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_nothrow_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_nothrow_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_nothrow_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &__duration_cast_impl<duration<signed long, ratio<1L, 1000L>>, ratio<1L, 1000000L>, signed long, true, false>__duration_cast_impl<duration<signed long, ratio<1L, 1000L>>, ratio<1L, 1000000L>, signed long, true, false> &__duration_cast_impl<duration<signed long, ratio<1L, 1000L>>, ratio<1L, 1000000L>, signed long, true, false> &&const __duration_cast_impl<duration<signed long, ratio<1L, 1000L>>, ratio<1L, 1000000L>, signed long, true, false>const __duration_cast_impl<duration<signed long, ratio<1L, 1000L>>, ratio<1L, 1000000L>, signed long, true, false> &ratio_divide__duration_cast_impl<duration<double, ratio<1L, 1L>>, ratio<1L, 1000000000L>, double, true, false>__duration_cast_impl<duration<double, ratio<1L, 1L>>, ratio<1L, 1000000000L>, double, true, false> &__duration_cast_impl<duration<double, ratio<1L, 1L>>, ratio<1L, 1000000000L>, double, true, false> &&const __duration_cast_impl<duration<double, ratio<1L, 1L>>, ratio<1L, 1000000000L>, double, true, false>const __duration_cast_impl<duration<double, ratio<1L, 1L>>, ratio<1L, 1000000000L>, double, true, false> &FormatListN<3>FormatListN<3> &const FormatListN<3>const FormatListN<3> &FormatArg[3]_Hashtable_ebo_helper<0, equal_to<LogFlags>, true>_Hashtable_ebo_helper<0, equal_to<LogFlags>, true> &_Hashtable_ebo_helper<0, equal_to<LogFlags>, true> &&const _Hashtable_ebo_helper<0, equal_to<LogFlags>, true>const _Hashtable_ebo_helper<0, equal_to<LogFlags>, true> &_ReuseOrAllocNode<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>const _ReuseOrAllocNode<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>const _ReuseOrAllocNode<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &_Hashtable_alloc<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 1UL, 4UL>__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 1UL, 4UL> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 1UL, 4UL> &&const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 1UL, 4UL>const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 1UL, 4UL> &FormatListN<2>FormatListN<2> &const FormatListN<2>const FormatListN<2> &FormatArg[2]formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *, false>formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *, false> &formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *, false> &&const formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *, false>const formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *, false> &formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char, false>formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char, false> &formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char, false> &&const formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char, false>const formatValueAsType<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char, false> &is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *>is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *> &is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *> &&const is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *>const is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, const void *> &is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char>is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char> &is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char> &&const is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char>const is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, char> &formatValueAsType<const char *, const void *, true>formatValueAsType<const char *, const void *, true> &formatValueAsType<const char *, const void *, true> &&const formatValueAsType<const char *, const void *, true>const formatValueAsType<const char *, const void *, true> &formatValueAsType<const char *, char, false>formatValueAsType<const char *, char, false> &formatValueAsType<const char *, char, false> &&const formatValueAsType<const char *, char, false>const formatValueAsType<const char *, char, false> &is_convertible<const char *, const void *>is_convertible<const char *, const void *> &is_convertible<const char *, const void *> &&const is_convertible<const char *, const void *>const is_convertible<const char *, const void *> &is_convertible<const char *, char>is_convertible<const char *, char> &is_convertible<const char *, char> &&const is_convertible<const char *, char>const is_convertible<const char *, char> &formatValueAsType<unsigned short, const void *, false>formatValueAsType<unsigned short, const void *, false> &formatValueAsType<unsigned short, const void *, false> &&const formatValueAsType<unsigned short, const void *, false>const formatValueAsType<unsigned short, const void *, false> &formatValueAsType<unsigned short, char, true>formatValueAsType<unsigned short, char, true> &formatValueAsType<unsigned short, char, true> &&const formatValueAsType<unsigned short, char, true>const formatValueAsType<unsigned short, char, true> &is_convertible<unsigned short, const void *>is_convertible<unsigned short, const void *> &is_convertible<unsigned short, const void *> &&const is_convertible<unsigned short, const void *>const is_convertible<unsigned short, const void *> &is_convertible<unsigned short, char>is_convertible<unsigned short, char> &is_convertible<unsigned short, char> &&const is_convertible<unsigned short, char>const is_convertible<unsigned short, char> &formatValueAsType<char[16], const void *, true>formatValueAsType<char[16], const void *, true> &formatValueAsType<char[16], const void *, true> &&const formatValueAsType<char[16], const void *, true>const formatValueAsType<char[16], const void *, true> &formatValueAsType<char[16], char, false>formatValueAsType<char[16], char, false> &formatValueAsType<char[16], char, false> &&const formatValueAsType<char[16], char, false>const formatValueAsType<char[16], char, false> &is_convertible<char[16], const void *>is_convertible<char[16], const void *> &is_convertible<char[16], const void *> &&const is_convertible<char[16], const void *>const is_convertible<char[16], const void *> &is_convertible<char[16], char>is_convertible<char[16], char> &is_convertible<char[16], char> &&const is_convertible<char[16], char>const is_convertible<char[16], char> &formatValueAsType<char[12], const void *, true>formatValueAsType<char[12], const void *, true> &formatValueAsType<char[12], const void *, true> &&const formatValueAsType<char[12], const void *, true>const formatValueAsType<char[12], const void *, true> &formatValueAsType<char[12], char, false>formatValueAsType<char[12], char, false> &formatValueAsType<char[12], char, false> &&const formatValueAsType<char[12], char, false>const formatValueAsType<char[12], char, false> &is_convertible<char[12], const void *>is_convertible<char[12], const void *> &is_convertible<char[12], const void *> &&const is_convertible<char[12], const void *>const is_convertible<char[12], const void *> &is_convertible<char[12], char>is_convertible<char[12], char> &is_convertible<char[12], char> &&const is_convertible<char[12], char>const is_convertible<char[12], char> &formatValueAsType<unsigned long, const void *, false>formatValueAsType<unsigned long, const void *, false> &formatValueAsType<unsigned long, const void *, false> &&const formatValueAsType<unsigned long, const void *, false>const formatValueAsType<unsigned long, const void *, false> &formatValueAsType<unsigned long, char, true>formatValueAsType<unsigned long, char, true> &formatValueAsType<unsigned long, char, true> &&const formatValueAsType<unsigned long, char, true>const formatValueAsType<unsigned long, char, true> &is_convertible<unsigned long, const void *>is_convertible<unsigned long, const void *> &is_convertible<unsigned long, const void *> &&const is_convertible<unsigned long, const void *>const is_convertible<unsigned long, const void *> &is_convertible<unsigned long, char>is_convertible<unsigned long, char> &is_convertible<unsigned long, char> &&const is_convertible<unsigned long, char>const is_convertible<unsigned long, char> &formatValueAsType<signed long, const void *, false>formatValueAsType<signed long, const void *, false> &formatValueAsType<signed long, const void *, false> &&const formatValueAsType<signed long, const void *, false>const formatValueAsType<signed long, const void *, false> &formatValueAsType<signed long, char, true>formatValueAsType<signed long, char, true> &formatValueAsType<signed long, char, true> &&const formatValueAsType<signed long, char, true>const formatValueAsType<signed long, char, true> &is_convertible<signed long, const void *>is_convertible<signed long, const void *> &is_convertible<signed long, const void *> &&const is_convertible<signed long, const void *>const is_convertible<signed long, const void *> &is_convertible<signed long, char>is_convertible<signed long, char> &is_convertible<signed long, char> &&const is_convertible<signed long, char>const is_convertible<signed long, char> &formatValueAsType<char[42], const void *, true>formatValueAsType<char[42], const void *, true> &formatValueAsType<char[42], const void *, true> &&const formatValueAsType<char[42], const void *, true>const formatValueAsType<char[42], const void *, true> &formatValueAsType<char[42], char, false>formatValueAsType<char[42], char, false> &formatValueAsType<char[42], char, false> &&const formatValueAsType<char[42], char, false>const formatValueAsType<char[42], char, false> &is_convertible<char[42], const void *>is_convertible<char[42], const void *> &is_convertible<char[42], const void *> &&const is_convertible<char[42], const void *>const is_convertible<char[42], const void *> &is_convertible<char[42], char>is_convertible<char[42], char> &is_convertible<char[42], char> &&const is_convertible<char[42], char>const is_convertible<char[42], char> &formatValueAsType<double, const void *, false>formatValueAsType<double, const void *, false> &formatValueAsType<double, const void *, false> &&const formatValueAsType<double, const void *, false>const formatValueAsType<double, const void *, false> &formatValueAsType<double, char, true>formatValueAsType<double, char, true> &formatValueAsType<double, char, true> &&const formatValueAsType<double, char, true>const formatValueAsType<double, char, true> &is_convertible<double, const void *>is_convertible<double, const void *> &is_convertible<double, const void *> &&const is_convertible<double, const void *>const is_convertible<double, const void *> &is_convertible<double, char>is_convertible<double, char> &is_convertible<double, char> &&const is_convertible<double, char>const is_convertible<double, char> &_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, UniValue>_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &_PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &&const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, UniValue>const _PCC<true, const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &_MoveCopyPair__implicit_CopyMovePair_ImplicitlyMoveConvertiblePair_MoveConstructiblePair_ImplicitlyConvertiblePair_ConstructiblePair_PCC<<expression>, const basic_string<char, char_traits<char>, allocator<char>>, UniValue>__is_referenceable<AddrMan>__is_referenceable__is_referenceable<AddrMan> &__is_referenceable<AddrMan> &&const __is_referenceable<AddrMan>const __is_referenceable<AddrMan> &enable_if<true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &>enable_if<true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &> &enable_if<true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &> &&const enable_if<true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &>const enable_if<true, optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &> &__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, type>>__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>__not___not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const __not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const __not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &_Optional_payload<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true, true>const _Optional_payload_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &_Optional_payload_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &_Optional_payload_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&_Optional_payload<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true, true> &_Optional_payload<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true, true> &&const _Optional_payload<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true, true>const _Optional_payload<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true, true> &iterator_traits<const LogCategory *>iterator_traits<const LogCategory *> &iterator_traits<const LogCategory *> &&const iterator_traits<const LogCategory *>const iterator_traits<const LogCategory *> &_List_iterator<basic_string<char, char_traits<char>, allocator<char>>>_List_const_iterator<basic_string<char, char_traits<char>, allocator<char>>>reverse_iterator<_List_const_iterator<basic_string<char, char_traits<char>, allocator<char>>>>reverse_iterator<_List_iterator<basic_string<char, char_traits<char>, allocator<char>>>>__invoke_result<_Functor &, const basic_string<char, char_traits<char>, allocator<char>> &>_Functor &__invoke_result<type &, const basic_string<char, char_traits<char>, allocator<char>> &>unary_function<const basic_string<char, char_traits<char>, allocator<char>> &, void>unary_function<const basic_string<char, char_traits<char>, allocator<char>> &, void> &unary_function<const basic_string<char, char_traits<char>, allocator<char>> &, void> &&const unary_function<const basic_string<char, char_traits<char>, allocator<char>> &, void>const unary_function<const basic_string<char, char_traits<char>, allocator<char>> &, void> &reverse_iterator<_List_const_iterator<function<..(..)>>>reverse_iterator<_List_iterator<function<..(..)>>>__aligned_membuf<function<..(..)>>__aligned_membuf<function<..(..)>> &__aligned_membuf<function<..(..)>> &&const __aligned_membuf<function<..(..)>>const __aligned_membuf<function<..(..)>> &_Tp2 *__umap_hashtable_Local_iterator<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Local_const_iterator<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false, false>_Node_handle<LogFlags, pair<const LogFlags, Level>, allocator<_Hash_node<pair<const LogFlags, Level>, false>>>_Node_insert_return<_Node_iterator<pair<const LogFlags, Level>, false, false>, _Node_handle<LogFlags, pair<const LogFlags, Level>, allocator<_Hash_node<pair<const LogFlags, Level>, false>>>>binary_function<LogFlags, LogFlags, bool>binary_function<LogFlags, LogFlags, bool> &binary_function<LogFlags, LogFlags, bool> &&const binary_function<LogFlags, LogFlags, bool>const binary_function<LogFlags, LogFlags, bool> &__normal_iterator<LogCategory *, vector<LogCategory, allocator<LogCategory>>>reverse_iterator<__normal_iterator<const LogCategory *, vector<LogCategory, allocator<LogCategory>>>>reverse_iterator<__normal_iterator<LogCategory *, vector<LogCategory, allocator<LogCategory>>>>__alloc_traits<allocator<function<..(..)>>, function<..(..)>>__alloc_traits<allocator<function<..(..)>>, function<..(..)>> &__alloc_traits<allocator<function<..(..)>>, function<..(..)>> &&const __alloc_traits<allocator<function<..(..)>>, function<..(..)>>const __alloc_traits<allocator<function<..(..)>>, function<..(..)>> &__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &&const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &__pair_base<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>__pair_base<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &&const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &__pair_base<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>__pair_base<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>__normal_iterator<const shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>const shared_ptr<const CTransaction>const shared_ptr<const CTransaction> *shared_ptr<const CTransaction> *reverse_iterator<__normal_iterator<const shared_ptr<const CTransaction> *, vector<shared_ptr<const CTransaction>, allocator<shared_ptr<const CTransaction>>>>>_TC<value, const bool &, const int &, const int &, const int &>_TC<<expression>, const bool &, const int &, const int &, const int &>__and_<is_convertible<pointer, AddrManImpl *>, __not_<is_array<_Up>>>tuple<AddrManImpl *, default_delete<AddrManImpl>>tuple<AddrManImpl *, default_delete<AddrManImpl>> &&const tuple<AddrManImpl *, default_delete<AddrManImpl>>const tuple<AddrManImpl *, default_delete<AddrManImpl>> &tuple<AddrManImpl *, default_delete<AddrManImpl>> &_Ptr<AddrManImpl, default_delete<AddrManImpl>, void>_Ptr<AddrManImpl, default_delete<AddrManImpl>, void> &_Ptr<AddrManImpl, default_delete<AddrManImpl>, void> &&const _Ptr<AddrManImpl, default_delete<AddrManImpl>, void>const _Ptr<AddrManImpl, default_delete<AddrManImpl>, void> &__not_<is_same<optional<bool>, type>>_Optional_payload<bool, true, true, true>const _Optional_payload_base<bool>const _Optional_payload_base<bool> &_Optional_payload_base<bool> &_Optional_payload_base<bool> &&_Optional_payload<bool, true, true, true> &_Optional_payload<bool, true, true, true> &&const _Optional_payload<bool, true, true, true>const _Optional_payload<bool, true, true, true> &_Optional_base_impl<bool, _Optional_base<bool, true, true>>_Optional_base_impl<bool, _Optional_base<bool, true, true>> &_Optional_base_impl<bool, _Optional_base<bool, true, true>> &&const _Optional_base_impl<bool, _Optional_base<bool, true, true>>const _Optional_base_impl<bool, _Optional_base<bool, true, true>> &__not_<is_same<optional<Network>, type>>_Optional_payload<Network, true, true, true>const _Optional_payload_base<Network>const _Optional_payload_base<Network> &_Optional_payload_base<Network> &_Optional_payload_base<Network> &&_Optional_payload<Network, true, true, true> &_Optional_payload<Network, true, true, true> &&const _Optional_payload<Network, true, true, true>const _Optional_payload<Network, true, true, true> &_Optional_base_impl<Network, _Optional_base<Network, true, true>>_Optional_base_impl<Network, _Optional_base<Network, true, true>> &_Optional_base_impl<Network, _Optional_base<Network, true, true>> &&const _Optional_base_impl<Network, _Optional_base<Network, true, true>>const _Optional_base_impl<Network, _Optional_base<Network, true, true>> &treat_as_floating_point<double>treat_as_floating_pointtreat_as_floating_point<double> &treat_as_floating_point<double> &&const treat_as_floating_point<double>const treat_as_floating_point<double> &_Tuple_impl<1UL, const int &, const int &, const int &>_Tuple_impl<1UL, _UHead, _UTails...> &&const _Tuple_impl<1UL, _UElements...>const _Tuple_impl<1UL, _UElements...> &_Tuple_impl<1UL, _UElements...> &const _Tuple_impl<1UL, _UHead, _UTails...>const _Tuple_impl<1UL, _UHead, _UTails...> &_Tuple_impl<1UL, _UHead, _UTails...> &_Tuple_impl<1UL, const int &, const int &, const int &> &&const _Tuple_impl<1UL, const int &, const int &, const int &>const _Tuple_impl<1UL, const int &, const int &, const int &> &_Tuple_impl<1UL, const int &, const int &, const int &> &_Tuple_impl<2UL, const int &, const int &>_Tuple_impl<2UL, _UHead, _UTails...> &&const _Tuple_impl<2UL, _UElements...>const _Tuple_impl<2UL, _UElements...> &_Tuple_impl<2UL, _UElements...> &const _Tuple_impl<2UL, _UHead, _UTails...>const _Tuple_impl<2UL, _UHead, _UTails...> &_Tuple_impl<2UL, _UHead, _UTails...> &_Tuple_impl<2UL, const int &, const int &> &&const _Tuple_impl<2UL, const int &, const int &>const _Tuple_impl<2UL, const int &, const int &> &_Tuple_impl<2UL, const int &, const int &> &_Tuple_impl<3UL, const int &>_Tuple_impl<3UL, _UHead> &&const _Tuple_impl<3UL, _UHead>const _Tuple_impl<3UL, _UHead> &_Tuple_impl<3UL, _UHead> &_Tuple_impl<3UL, const int &> &&const _Tuple_impl<3UL, const int &>const _Tuple_impl<3UL, const int &> &_Tuple_impl<3UL, const int &> &_Tuple_impl<0UL, AddrManImpl *, default_delete<AddrManImpl>>_Tuple_impl<0UL, AddrManImpl *, default_delete<AddrManImpl>> &&const _Tuple_impl<0UL, AddrManImpl *, default_delete<AddrManImpl>>const _Tuple_impl<0UL, AddrManImpl *, default_delete<AddrManImpl>> &_Tuple_impl<0UL, AddrManImpl *, default_delete<AddrManImpl>> &_Tuple_impl<1UL, default_delete<AddrManImpl>>_Tuple_impl<1UL, _UHead> &&const _Tuple_impl<1UL, _UHead>const _Tuple_impl<1UL, _UHead> &_Tuple_impl<1UL, _UHead> &_Tuple_impl<1UL, default_delete<AddrManImpl>> &&const _Tuple_impl<1UL, default_delete<AddrManImpl>>const _Tuple_impl<1UL, default_delete<AddrManImpl>> &_Tuple_impl<1UL, default_delete<AddrManImpl>> &_Tuple_impl<0UL, AddrMan *, default_delete<AddrMan>>_Tuple_impl<0UL, AddrMan *, default_delete<AddrMan>> &&const _Tuple_impl<0UL, AddrMan *, default_delete<AddrMan>>const _Tuple_impl<0UL, AddrMan *, default_delete<AddrMan>> &_Tuple_impl<0UL, AddrMan *, default_delete<AddrMan>> &_Tuple_impl<1UL, default_delete<AddrMan>>_Tuple_impl<1UL, default_delete<AddrMan>> &&const _Tuple_impl<1UL, default_delete<AddrMan>>const _Tuple_impl<1UL, default_delete<AddrMan>> &_Tuple_impl<1UL, default_delete<AddrMan>> &Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &> &const Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &>const Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &> &Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &> &&__not_<is_same<optional<bilingual_str>, type>>_Optional_payload<bilingual_str, false, false, false>_Optional_base_impl<bilingual_str, _Optional_base<bilingual_str, false, false>>_Optional_base_impl<bilingual_str, _Optional_base<bilingual_str, false, false>> &_Optional_base_impl<bilingual_str, _Optional_base<bilingual_str, false, false>> &&const _Optional_base_impl<bilingual_str, _Optional_base<bilingual_str, false, false>>const _Optional_base_impl<bilingual_str, _Optional_base<bilingual_str, false, false>> &__and_<is_convertible<pointer, AddrMan *>, __not_<is_array<_Up>>>tuple<AddrMan *, default_delete<AddrMan>>tuple<AddrMan *, default_delete<AddrMan>> &&const tuple<AddrMan *, default_delete<AddrMan>>const tuple<AddrMan *, default_delete<AddrMan>> &tuple<AddrMan *, default_delete<AddrMan>> &_Ptr<AddrMan, default_delete<AddrMan>, void>_Ptr<AddrMan, default_delete<AddrMan>, void> &_Ptr<AddrMan, default_delete<AddrMan>, void> &&const _Ptr<AddrMan, default_delete<AddrMan>, void>const _Ptr<AddrMan, default_delete<AddrMan>, void> &__normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>>__normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>> &__normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>> &&const __normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>>const __normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>> &__normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>>__normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>> &__normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>> &&const __normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>>const __normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>> &__normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>> *reverse_iterator<__normal_iterator<const CAddress *, vector<CAddress, allocator<CAddress>>>>reverse_iterator<__normal_iterator<CAddress *, vector<CAddress, allocator<CAddress>>>>_Node_iterator<pair<const LogFlags, Level>, false, false>_Node_const_iterator<pair<const LogFlags, Level>, false, false>__alloc_rebind_AllocNode<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>__pair_base<const LogFlags, Level>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &__alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const __alloc_traits<allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &__pair_base<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>__pair_base<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>__normal_iterator<UniValue *, vector<UniValue, allocator<UniValue>>>reverse_iterator<__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>>reverse_iterator<__normal_iterator<UniValue *, vector<UniValue, allocator<UniValue>>>>__alloc_traits<allocator<pair<const CSubNet, CBanEntry>>, pair<const CSubNet, CBanEntry>>__alloc_traits<allocator<pair<const CSubNet, CBanEntry>>, pair<const CSubNet, CBanEntry>> &__alloc_traits<allocator<pair<const CSubNet, CBanEntry>>, pair<const CSubNet, CBanEntry>> &&const __alloc_traits<allocator<pair<const CSubNet, CBanEntry>>, pair<const CSubNet, CBanEntry>>const __alloc_traits<allocator<pair<const CSubNet, CBanEntry>>, pair<const CSubNet, CBanEntry>> &binary_function<CSubNet, CSubNet, bool>binary_function<CSubNet, CSubNet, bool> &binary_function<CSubNet, CSubNet, bool> &&const binary_function<CSubNet, CSubNet, bool>const binary_function<CSubNet, CSubNet, bool> &__pair_base<_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>>__pair_base<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const __alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_Base_key_comparereverse_iterator<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>reverse_iterator<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>>_Node_insert_return<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, value_type>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const basic_string<char, char_traits<char>, allocator<char>>>unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const basic_string<char, char_traits<char>, allocator<char>>> &unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const basic_string<char, char_traits<char>, allocator<char>>> &&const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const basic_string<char, char_traits<char>, allocator<char>>>const unary_function<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const basic_string<char, char_traits<char>, allocator<char>>> &__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>reverse_iterator<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>reverse_iterator<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>_Node_insert_return<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>, value_type>__alloc_traits<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>, _Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>reverse_iterator<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>reverse_iterator<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>_Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>>_Node_insert_return<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Node_handle<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>>>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>, value_type>__alloc_traits<allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>, _Rb_tree_node<pair<const CSubNet, CBanEntry>>>_Rb_tree_key_compare<less<CSubNet>>_Rb_tree_key_compare<less<CSubNet>> &const _Rb_tree_key_compare<less<CSubNet>>const _Rb_tree_key_compare<less<CSubNet>> &reverse_iterator<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>reverse_iterator<_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>>_Node_handle<CSubNet, pair<const CSubNet, CBanEntry>, allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>>_Node_insert_return<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Node_handle<CSubNet, pair<const CSubNet, CBanEntry>, allocator<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>>>is_same<pair<const CSubNet, CBanEntry>, value_type>__pair_base<const CSubNet, CBanEntry>pair<_Node_const_iterator<pair<const LogFlags, Level>, false, false>, _Node_const_iterator<pair<const LogFlags, Level>, false, false>>pair<_Node_iterator<pair<const LogFlags, Level>, false, false>, _Node_iterator<pair<const LogFlags, Level>, false, false>>pair<const basic_string<char, char_traits<char>, allocator<char>>, VType>remove_const_tallocator_traits<allocator<pair<const LogFlags, Level>>>allocator_traits<allocator<pair<const LogFlags, Level>>> &allocator_traits<allocator<pair<const LogFlags, Level>>> &&const allocator_traits<allocator<pair<const LogFlags, Level>>>const allocator_traits<allocator<pair<const LogFlags, Level>>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &unsigned char[120]remove_reference<const char *const &>remove_reference<const char *const &> &remove_reference<const char *const &> &&const remove_reference<const char *const &>const remove_reference<const char *const &> &remove_reference<UniValue>remove_reference<UniValue> &remove_reference<UniValue> &&const remove_reference<UniValue>const remove_reference<UniValue> &_Tuple_impl<0UL, basic_string<char, char_traits<char>, allocator<char>> &&>_Tuple_impl<0UL, _UHead> &&const _Tuple_impl<0UL, _UHead>const _Tuple_impl<0UL, _UHead> &_Tuple_impl<0UL, _UHead> &_Tuple_impl<0UL, basic_string<char, char_traits<char>, allocator<char>> &&> &&const _Tuple_impl<0UL, basic_string<char, char_traits<char>, allocator<char>> &&>const _Tuple_impl<0UL, basic_string<char, char_traits<char>, allocator<char>> &&> &_Tuple_impl<0UL, basic_string<char, char_traits<char>, allocator<char>> &&> &remove_reference<bilingual_str>remove_reference<bilingual_str> &remove_reference<bilingual_str> &&const remove_reference<bilingual_str>const remove_reference<bilingual_str> &remove_reference<const NetGroupManager &>remove_reference<const NetGroupManager &> &remove_reference<const NetGroupManager &> &&const remove_reference<const NetGroupManager &>const remove_reference<const NetGroupManager &> &remove_reference<signed int &>remove_reference<signed int &> &remove_reference<signed int &> &&const remove_reference<signed int &>const remove_reference<signed int &> &remove_reference<default_delete<AddrMan>>remove_reference<default_delete<AddrMan>> &remove_reference<default_delete<AddrMan>> &&const remove_reference<default_delete<AddrMan>>const remove_reference<default_delete<AddrMan>> &remove_reference<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>remove_reference<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &remove_reference<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const remove_reference<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const remove_reference<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &_Hashtable_alloc<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>const _Hashtable_alloc<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &~_Hashtable_alloc~_Hashtable_ebo_helper_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const LogFlags, Level>, false>>, true> *_Equality<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Equality<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Equality<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Equality<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Equality<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Rehash_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>_Rehash_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Rehash_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &&const _Rehash_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>>const _Rehash_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, integral_constant<bool, true>> &_Insert<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>_Insert_Insert<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Insert<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &&const _Insert<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false>const _Insert<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, false> &_Map_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>_Map_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Map_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &&const _Map_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true>const _Map_base<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>, true> &_Hashtable_base<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>>_Hashtable_base<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> &&__if_hash_cached__hash_code_base_access &__hash_code_base_access &&const __hash_code_base_accessconst __hash_code_base_access &__if_hash_not_cached__reuse_or_alloc_node_type__eq_base__rehash_base__map_base__hashtable_alloc__alloc_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>, _List_node<basic_string<char, char_traits<char>, allocator<char>>>>__alloc_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>, _List_node<basic_string<char, char_traits<char>, allocator<char>>>> &__alloc_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>, _List_node<basic_string<char, char_traits<char>, allocator<char>>>> &&const __alloc_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>, _List_node<basic_string<char, char_traits<char>, allocator<char>>>>const __alloc_traits<allocator<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>, _List_node<basic_string<char, char_traits<char>, allocator<char>>>> &__alloc_traits<allocator<_List_node<function<..(..)>>>, _List_node<function<..(..)>>>__alloc_traits<allocator<_List_node<function<..(..)>>>, _List_node<function<..(..)>>> &__alloc_traits<allocator<_List_node<function<..(..)>>>, _List_node<function<..(..)>>> &&const __alloc_traits<allocator<_List_node<function<..(..)>>>, _List_node<function<..(..)>>>const __alloc_traits<allocator<_List_node<function<..(..)>>>, _List_node<function<..(..)>>> &remove_const<const CAddress>remove_const<const CAddress> &remove_const<const CAddress> &&const remove_const<const CAddress>const remove_const<const CAddress> &ChronoFormatter<unsigned int, true>ChronoFormatter<unsigned int, true> &ChronoFormatter<unsigned int, true> &&const ChronoFormatter<unsigned int, true>const ChronoFormatter<unsigned int, true> &CustomUintFormatter<8, false>CustomUintFormatter<8, false> &CustomUintFormatter<8, false> &&const CustomUintFormatter<8, false>const CustomUintFormatter<8, false> &remove_const<CAddress>remove_const<CAddress> &remove_const<CAddress> &&const remove_const<CAddress>const remove_const<CAddress> &CustomUintFormatter<2, true>CustomUintFormatter<2, true> &CustomUintFormatter<2, true> &&const CustomUintFormatter<2, true>const CustomUintFormatter<2, true> &is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, int>is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, int> &is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, int> &&const is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, int>const is_convertible<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>, int> &is_convertible<const char *, int>is_convertible<const char *, int> &is_convertible<const char *, int> &&const is_convertible<const char *, int>const is_convertible<const char *, int> &is_convertible<unsigned short, int>is_convertible<unsigned short, int> &is_convertible<unsigned short, int> &&const is_convertible<unsigned short, int>const is_convertible<unsigned short, int> &is_convertible<char[16], int>is_convertible<char[16], int> &is_convertible<char[16], int> &&const is_convertible<char[16], int>const is_convertible<char[16], int> &is_convertible<char[12], int>is_convertible<char[12], int> &is_convertible<char[12], int> &&const is_convertible<char[12], int>const is_convertible<char[12], int> &is_convertible<unsigned long, int>is_convertible<unsigned long, int> &is_convertible<unsigned long, int> &&const is_convertible<unsigned long, int>const is_convertible<unsigned long, int> &is_convertible<signed long, int>is_convertible<signed long, int> &is_convertible<signed long, int> &&const is_convertible<signed long, int>const is_convertible<signed long, int> &is_convertible<char[42], int>is_convertible<char[42], int> &is_convertible<char[42], int> &&const is_convertible<char[42], int>const is_convertible<char[42], int> &is_convertible<double, int>is_convertible<double, int> &is_convertible<double, int> &&const is_convertible<double, int>const is_convertible<double, int> &_Local_iterator_base<LogFlags, pair<const LogFlags, Level>, _Select1st, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, false>_Hashtable_ebo_helper<1, hash<LogFlags>, true>_Hashtable_ebo_helper<1, hash<LogFlags>, true> &&__ebo_h2__ebo_h1__ebo_extract_keyis_enum<LogFlags>is_enumis_enum<LogFlags> &is_enum<LogFlags> &&const is_enum<LogFlags>const is_enum<LogFlags> &__hash_base<unsigned long, LogFlags>__hash_base<unsigned long, LogFlags> &__hash_base<unsigned long, LogFlags> &&const __hash_base<unsigned long, LogFlags>const __hash_base<unsigned long, LogFlags> &tuple_element<0UL, pair<const LogFlags, Level>>tuple_element<0UL, pair<const LogFlags, Level>> &tuple_element<0UL, pair<const LogFlags, Level>> &&const tuple_element<0UL, pair<const LogFlags, Level>>const tuple_element<0UL, pair<const LogFlags, Level>> &remove_reference<const pair<const LogFlags, Level> &>remove_reference<const pair<const LogFlags, Level> &> &remove_reference<const pair<const LogFlags, Level> &> &&const remove_reference<const pair<const LogFlags, Level> &>const remove_reference<const pair<const LogFlags, Level> &> &__aligned_buffer<pair<const LogFlags, Level>>__aligned_buffer<pair<const LogFlags, Level>> &__aligned_buffer<pair<const LogFlags, Level>> &&const __aligned_buffer<pair<const LogFlags, Level>>const __aligned_buffer<pair<const LogFlags, Level>> &rebind<UniValue>rebind<UniValue> &rebind<UniValue> &&const rebind<UniValue>const rebind<UniValue> &__is_custom_pointer_Base_typerebind<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>rebind<_List_node<basic_string<char, char_traits<char>, allocator<char>>>> &rebind<_List_node<basic_string<char, char_traits<char>, allocator<char>>>> &&const rebind<_List_node<basic_string<char, char_traits<char>, allocator<char>>>>const rebind<_List_node<basic_string<char, char_traits<char>, allocator<char>>>> &rebind<LogCategory>rebind<LogCategory> &rebind<LogCategory> &&const rebind<LogCategory>const rebind<LogCategory> &allocator<_Hash_node<pair<const LogFlags, Level>, false>> *_Optional_payload<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true, true, true> *new_allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &const _Rb_tree<basic_string<char, char_traits<char>, allocator<char>>, pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> *const _Rb_tree_key_compare<less<basic_string<char, char_traits<char>, allocator<char>>>>const integral_constant<bool, true>_Rb_tree_node_base *const &const default_delete<AddrMan> *default_delete<AddrMan> *_SGIAssignableConcept<_Tp>const intmax_tstatic_cast<_CR>(_CF::den)const __uniq_ptr_impl<AddrMan, default_delete<AddrMan>> *__uniq_ptr_impl<AddrMan, default_delete<AddrMan>> *const __tuple_element_t<0UL, tuple<AddrMan *, default_delete<AddrMan>>>const __tuple_element_t<0UL, tuple<AddrMan *, default_delete<AddrMan>>> &__tuple_element_t<0UL, tuple<AddrMan *, default_delete<AddrMan>>> &__tuple_element_t<1UL, tuple<AddrMan *, default_delete<AddrMan>>> &std::is_same<TimeType, std::chrono::microseconds>::valuestd::is_same<TimeType, std::chrono::milliseconds>::valuestd::is_same<TimeType, std::chrono::seconds>::value_Optional_payload_base<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> *1000000000.0__allocated_ptr<allocator<_List_node<function<..(..)>>>> &noexcept(__a.destroy(__p))allocator<_Hash_node<pair<const LogFlags, Level>, false>> &&const _ReuseOrAllocNode<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> *_ReuseOrAllocNode<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> *lambda [] type at line 80156, col. 9 &&__alloc_on_copy__pocca_Base_type::is_always_equal::valueconst _Hashtable_alloc<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> *const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const LogFlags, Level>, false>>, true>const _Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const LogFlags, Level>, false>>, true> &_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const LogFlags, Level>, false>>, true> &_Base_type::propagate_on_container_copy_assignment::value_Optional_payload<bool, true, true, true> *_Optional_payload<Network, true, true, true> *_Tuple_impl<0UL, const bool &, const int &, const int &, const int &> *Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> *Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &> *Wrapper<ChronoFormatter<unsigned int, true>, time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> *Wrapper<CustomUintFormatter<8, false>, ServiceFlags &> *array<unsigned char, 32UL> &base_blob<256U> *const array<unsigned char, 32UL> &const base_blob<256U> *Wrapper<CustomUintFormatter<2, true>, const unsigned short &> *Wrapper<CustomUintFormatter<2, true>, unsigned short &> *T()__is_integer<_ValueType1>::__value__is_pointer<_ValueType1>::__value__is_integer<_ValueType1>::__value
			      || __is_pointer<_ValueType1>::__value(__is_integer<_ValueType1>::__value
			      || __is_pointer<_ValueType1>::__value)__is_pointer<_II1>::__value(__is_integer<_ValueType1>::__value
			      || __is_pointer<_ValueType1>::__value)
			     && __is_pointer<_II1>::__value__is_pointer<_II2>::__value(__is_integer<_ValueType1>::__value
			      || __is_pointer<_ValueType1>::__value)
			     && __is_pointer<_II1>::__value
			     && __is_pointer<_II2>::__value__are_same<_ValueType1, _ValueType2>::__value(__is_integer<_ValueType1>::__value
			      || __is_pointer<_ValueType1>::__value)
			     && __is_pointer<_II1>::__value
			     && __is_pointer<_II2>::__value
			     && __are_same<_ValueType1, _ValueType2>::__value((__is_integer<_ValueType1>::__value
			      || __is_pointer<_ValueType1>::__value)
			     && __is_pointer<_II1>::__value
			     && __is_pointer<_II2>::__value
			     && __are_same<_ValueType1, _ValueType2>::__value)const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>>const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> &__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> &const char[325]char[325]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = std::__detail::_Quoted_string<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, char>; fmtT = const void *; bool convertible = false]const char[317]char[317]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = std::__detail::_Quoted_string<const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, char>; fmtT = char; bool convertible = false]const char[206]char[206]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = const char *; fmtT = char; bool convertible = false]basic_ostream<char, char_traits<char>> *const char[216]char[216]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = unsigned short; fmtT = const void *; bool convertible = false]const char[203]char[203]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = char [16]; fmtT = char; bool convertible = false]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = char [12]; fmtT = char; bool convertible = false]const char[215]char[215]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = unsigned long; fmtT = const void *; bool convertible = false]const char[213]char[213]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = signed long; fmtT = const void *; bool convertible = false]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = char [42]; fmtT = char; bool convertible = false]const char[208]char[208]static void tinyformat::detail::formatValueAsType<T, fmtT, convertible>::invoke(std::basic_ostream<char, std::char_traits<char>> &, const T &) [with T = double; fmtT = const void *; bool convertible = false]uninitialized_copy_RefType1_RefType2is_assignable<_RefType2, _RefType1>::valueselect_on_container_copy_construction60680079189834051104811045873349725576460752303423487192153584101141162~new_allocator0xffffffffffffffff8 - Bytes(8 - Bytes)8 * (8 - Bytes)(8 * (8 - Bytes))0xffffffffffffffff >> (8 * (8 - Bytes))is_trivially_move_assignable_vis_trivially_move_assignable<_Tp>::valueis_trivially_copy_assignable_vis_trivially_copy_assignable<_Tp>::valueis_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_assignableis_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_constructibleis_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>> &__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>> &&const __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>const __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>> &__and_<__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>__and_<__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const __and_<__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const __and_<__not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &is_trivially_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_trivially_copy_assignableis_trivially_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_trivially_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_trivially_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_trivially_move_assignableis_trivially_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_trivially_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_trivially_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_trivially_copy_assignable<bool>is_trivially_copy_assignable<bool> &is_trivially_copy_assignable<bool> &&const is_trivially_copy_assignable<bool>const is_trivially_copy_assignable<bool> &is_trivially_move_assignable<bool>is_trivially_move_assignable<bool> &is_trivially_move_assignable<bool> &&const is_trivially_move_assignable<bool>const is_trivially_move_assignable<bool> &is_trivially_copy_assignable<Network>is_trivially_copy_assignable<Network> &is_trivially_copy_assignable<Network> &&const is_trivially_copy_assignable<Network>const is_trivially_copy_assignable<Network> &is_trivially_move_assignable<Network>is_trivially_move_assignable<Network> &is_trivially_move_assignable<Network> &&const is_trivially_move_assignable<Network>const is_trivially_move_assignable<Network> &is_trivially_copy_assignable<bilingual_str>is_trivially_copy_assignable<bilingual_str> &is_trivially_copy_assignable<bilingual_str> &&const is_trivially_copy_assignable<bilingual_str>const is_trivially_copy_assignable<bilingual_str> &is_trivially_move_assignable<bilingual_str>is_trivially_move_assignable<bilingual_str> &is_trivially_move_assignable<bilingual_str> &&const is_trivially_move_assignable<bilingual_str>const is_trivially_move_assignable<bilingual_str> &is_assignable<UniValue &, const UniValue &>is_assignable<UniValue &, const UniValue &> &is_assignable<UniValue &, const UniValue &> &&const is_assignable<UniValue &, const UniValue &>const is_assignable<UniValue &, const UniValue &> &is_nothrow_default_constructible<allocator<UniValue>>is_nothrow_default_constructibleis_nothrow_default_constructible<allocator<UniValue>> &is_nothrow_default_constructible<allocator<UniValue>> &&const is_nothrow_default_constructible<allocator<UniValue>>const is_nothrow_default_constructible<allocator<UniValue>> &__equal<false>__equal<false> &__equal<false> &&const __equal<false>const __equal<false> &__are_same<unsigned char, const unsigned char>__are_same<unsigned char, const unsigned char> &__are_same<unsigned char, const unsigned char> &&const __are_same<unsigned char, const unsigned char>const __are_same<unsigned char, const unsigned char> &__is_pointer<const_iterator>__is_pointer<const_iterator> &__is_pointer<const_iterator> &&const __is_pointer<const_iterator>const __is_pointer<const_iterator> &is_nothrow_copy_constructible<const_iterator>is_nothrow_copy_constructibleis_nothrow_copy_constructible<const_iterator> &is_nothrow_copy_constructible<const_iterator> &&const is_nothrow_copy_constructible<const_iterator>const is_nothrow_copy_constructible<const_iterator> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 2UL, 4UL>__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 2UL, 4UL> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 2UL, 4UL> &&const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 2UL, 4UL>const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 2UL, 4UL> &__allocated_ptr<allocator<_List_node<function<..(..)>>>>const __allocated_ptr<allocator<_List_node<function<..(..)>>>>const __allocated_ptr<allocator<_List_node<function<..(..)>>>> &__allocated_ptris_nothrow_default_constructible<allocator<_List_node<function<..(..)>>>>is_nothrow_default_constructible<allocator<_List_node<function<..(..)>>>> &is_nothrow_default_constructible<allocator<_List_node<function<..(..)>>>> &&const is_nothrow_default_constructible<allocator<_List_node<function<..(..)>>>>const is_nothrow_default_constructible<allocator<_List_node<function<..(..)>>>> &is_nothrow_default_constructible<allocator<CAddress>>is_nothrow_default_constructible<allocator<CAddress>> &is_nothrow_default_constructible<allocator<CAddress>> &&const is_nothrow_default_constructible<allocator<CAddress>>const is_nothrow_default_constructible<allocator<CAddress>> &__and_<is_nothrow_move_constructible<AddrMan *>, is_nothrow_move_assignable<AddrMan *>>__and_<is_nothrow_move_constructible<AddrMan *>, is_nothrow_move_assignable<AddrMan *>> &__and_<is_nothrow_move_constructible<AddrMan *>, is_nothrow_move_assignable<AddrMan *>> &&const __and_<is_nothrow_move_constructible<AddrMan *>, is_nothrow_move_assignable<AddrMan *>>const __and_<is_nothrow_move_constructible<AddrMan *>, is_nothrow_move_assignable<AddrMan *>> &__common_type_impl<double, signed long>__common_type_impl__common_type_impl<double, signed long> &__common_type_impl<double, signed long> &&const __common_type_impl<double, signed long>const __common_type_impl<double, signed long> &__and_<is_same<LogCategory *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<UniValue *, _Ptr>, __not_<is_pointer<_Ptr>>>iterator_traits<const UniValue *>iterator_traits<const UniValue *> &iterator_traits<const UniValue *> &&const iterator_traits<const UniValue *>const iterator_traits<const UniValue *> &__alloc_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node<pair<const LogFlags, Level>, false>>__alloc_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node<pair<const LogFlags, Level>, false>> &__alloc_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node<pair<const LogFlags, Level>, false>> &&const __alloc_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node<pair<const LogFlags, Level>, false>>const __alloc_traits<allocator<_Hash_node<pair<const LogFlags, Level>, false>>, _Hash_node<pair<const LogFlags, Level>, false>> &__or_<__not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>>__or___or_<__not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>> &__or_<__not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>> &&const __or_<__not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>>const __or_<__not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>> &_EqualHelper_EqualEBO_IFcons__is_cons__base_type_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const LogFlags, Level>, false>>, true>_Hashtable_ebo_helper<0, allocator<_Hash_node<pair<const LogFlags, Level>, false>>, true> &&__bucket_alloc_traits__ebo_node_allocenable_if<true, duration<double, ratio<1L, 1L>>>enable_if<true, duration<double, ratio<1L, 1L>>> &enable_if<true, duration<double, ratio<1L, 1L>>> &&const enable_if<true, duration<double, ratio<1L, 1L>>>const enable_if<true, duration<double, ratio<1L, 1L>>> &enable_if<true, duration<signed long, ratio<1L, 1000L>>>enable_if<true, duration<signed long, ratio<1L, 1000L>>> &enable_if<true, duration<signed long, ratio<1L, 1000L>>> &&const enable_if<true, duration<signed long, ratio<1L, 1000L>>>const enable_if<true, duration<signed long, ratio<1L, 1000L>>> &_TC<value, basic_string<char, char_traits<char>, allocator<char>> &&>_TC<<expression>, basic_string<char, char_traits<char>, allocator<char>> &&>_Head_base<0UL, basic_string<char, char_traits<char>, allocator<char>> &&, false>_Head_base<0UL, basic_string<char, char_traits<char>, allocator<char>> &&, false> &const _Head_base<0UL, basic_string<char, char_traits<char>, allocator<char>> &&, false>const _Head_base<0UL, basic_string<char, char_traits<char>, allocator<char>> &&, false> &~_Tp2_PCC<true, const CSubNet, CBanEntry>_PCC<true, const CSubNet, CBanEntry> &_PCC<true, const CSubNet, CBanEntry> &&const _PCC<true, const CSubNet, CBanEntry>const _PCC<true, const CSubNet, CBanEntry> &_PCC<<expression>, const CSubNet, CBanEntry>_PCC<true, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>_PCC<true, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>> &_PCC<true, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>> &&const _PCC<true, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>const _PCC<true, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_iterator<pair<const CSubNet, CBanEntry>>>_PCC<true, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>>_PCC<true, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>> &_PCC<true, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>>const _PCC<true, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>>rebind<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>rebind<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> &rebind<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> &&const rebind<_Rb_tree_node<pair<const CSubNet, CBanEntry>>>const rebind<_Rb_tree_node<pair<const CSubNet, CBanEntry>>> &rebind<pair<const CSubNet, CBanEntry>>rebind<pair<const CSubNet, CBanEntry>> &rebind<pair<const CSubNet, CBanEntry>> &&const rebind<pair<const CSubNet, CBanEntry>>const rebind<pair<const CSubNet, CBanEntry>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &&const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>>const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &_PCC<true, const LogFlags, Level>_PCC<true, const LogFlags, Level> &_PCC<true, const LogFlags, Level> &&const _PCC<true, const LogFlags, Level>const _PCC<true, const LogFlags, Level> &_PCC<<expression>, const LogFlags, Level>is_convertible<pointer, AddrMan *>is_same<optional<bilingual_str>, type>VectorFormatter<DefaultFormatter>VectorFormatter<DefaultFormatter> &VectorFormatter<DefaultFormatter> &&const VectorFormatter<DefaultFormatter>const VectorFormatter<DefaultFormatter> &_Head_base<1UL, default_delete<AddrMan>, true>_Head_base<1UL, default_delete<AddrMan>, true> &const _Head_base<1UL, default_delete<AddrMan>, true>const _Head_base<1UL, default_delete<AddrMan>, true> &_Head_base<0UL, AddrMan *, false>_Head_base<0UL, AddrMan *, false> &const _Head_base<0UL, AddrMan *, false>const _Head_base<0UL, AddrMan *, false> &_Head_base<1UL, default_delete<AddrManImpl>, true>_Head_base<1UL, default_delete<AddrManImpl>, true> &const _Head_base<1UL, default_delete<AddrManImpl>, true>const _Head_base<1UL, default_delete<AddrManImpl>, true> &_Head_base<0UL, AddrManImpl *, false>_Head_base<0UL, AddrManImpl *, false> &const _Head_base<0UL, AddrManImpl *, false>const _Head_base<0UL, AddrManImpl *, false> &_Tuple_impl<3UL, _UHead>_Head_base<3UL, const int &, false>_Head_base<3UL, const int &, false> &const _Head_base<3UL, const int &, false>const _Head_base<3UL, const int &, false> &_Tuple_impl<2UL, _UElements...>_Tuple_impl<2UL, _UHead, _UTails...>_Head_base<2UL, const int &, false>_Head_base<2UL, const int &, false> &const _Head_base<2UL, const int &, false>const _Head_base<2UL, const int &, false> &_Tuple_impl<1UL, _UElements...>_Tuple_impl<1UL, _UHead, _UTails...>_Head_base<1UL, const int &, false>_Head_base<1UL, const int &, false> &const _Head_base<1UL, const int &, false>const _Head_base<1UL, const int &, false> &is_floating_point<double>is_floating_pointis_floating_point<double> &is_floating_point<double> &&const is_floating_point<double>const is_floating_point<double> &is_same<optional<Network>, type>is_same<optional<bool>, type>is_convertible<pointer, AddrManImpl *>is_same<tuple<const bool &, const int &, const int &, const int &>, tuple<_UElements...>>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &&const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &&const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>>const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &&const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &_PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &&const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const _PCC<true, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &_PCC<<expression>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &_PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &&const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const _PCC<true, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &_PCC<<expression>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &&const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>const rebind<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &&const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>const rebind<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>> &rebind<_List_node<function<..(..)>>>rebind<_List_node<function<..(..)>>> &rebind<_List_node<function<..(..)>>> &&const rebind<_List_node<function<..(..)>>>const rebind<_List_node<function<..(..)>>> &rebind<function<..(..)>>rebind<function<..(..)>> &rebind<function<..(..)>> &&const rebind<function<..(..)>>const rebind<function<..(..)>> &is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, type>is_same<UniValue, _U2>__underlying_type_impl<LogFlags, true>is_enum<_Tp>::value__underlying_type_impl<LogFlags, true> &__underlying_type_impl<LogFlags, true> &&const __underlying_type_impl<LogFlags, true>const __underlying_type_impl<LogFlags, true> &is_wchar<double>is_wchar<double> &is_wchar<double> &&const is_wchar<double>const is_wchar<double> &is_wchar<char[42]>is_wchar<char[42]> &is_wchar<char[42]> &&const is_wchar<char[42]>const is_wchar<char[42]> &is_wchar<signed long>is_wchar<signed long> &is_wchar<signed long> &&const is_wchar<signed long>const is_wchar<signed long> &is_wchar<unsigned long>is_wchar<unsigned long> &is_wchar<unsigned long> &&const is_wchar<unsigned long>const is_wchar<unsigned long> &is_wchar<char[12]>is_wchar<char[12]> &is_wchar<char[12]> &&const is_wchar<char[12]>const is_wchar<char[12]> &is_wchar<char[16]>is_wchar<char[16]> &is_wchar<char[16]> &&const is_wchar<char[16]>const is_wchar<char[16]> &is_wchar<unsigned short>is_wchar<unsigned short> &is_wchar<unsigned short> &&const is_wchar<unsigned short>const is_wchar<unsigned short> &is_wchar<const char *>is_wchar<const char *> &is_wchar<const char *> &&const is_wchar<const char *>const is_wchar<const char *> &is_wchar<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>>is_wchar<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>> &is_wchar<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>> &&const is_wchar<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>>const is_wchar<_Quoted_string<const basic_string<char, char_traits<char>, allocator<char>> &, char>> &remove_reference<CAddress &>remove_reference<CAddress &> &remove_reference<CAddress &> &&const remove_reference<CAddress &>const remove_reference<CAddress &> &remove_reference<const CAddress &>remove_reference<const CAddress &> &remove_reference<const CAddress &> &&const remove_reference<const CAddress &>const remove_reference<const CAddress &> &remove_reference<function<..(..)>>remove_reference<function<..(..)>> &remove_reference<function<..(..)>> &&const remove_reference<function<..(..)>>const remove_reference<function<..(..)>> &remove_reference<AddrMan *&>remove_reference<AddrMan *&> &remove_reference<AddrMan *&> &&const remove_reference<AddrMan *&>const remove_reference<AddrMan *&> &remove_reference<tuple<basic_string<char, char_traits<char>, allocator<char>> &&>>remove_reference<tuple<basic_string<char, char_traits<char>, allocator<char>> &&>> &remove_reference<tuple<basic_string<char, char_traits<char>, allocator<char>> &&>> &&const remove_reference<tuple<basic_string<char, char_traits<char>, allocator<char>> &&>>const remove_reference<tuple<basic_string<char, char_traits<char>, allocator<char>> &&>> &__is_trivially_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_trivially_move_constructible_impl__is_trivially_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_trivially_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_trivially_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_trivially_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_trivially_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_trivially_copy_constructible_impl__is_trivially_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_trivially_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_trivially_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_trivially_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_move_constructible_impl__is_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_move_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_move_assignable_impl__is_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_copy_constructible_impl__is_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_copy_constructible_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_copy_assignable_impl__is_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_trivially_move_constructible_impl<bool, true>__is_trivially_move_constructible_impl<bool, true> &__is_trivially_move_constructible_impl<bool, true> &&const __is_trivially_move_constructible_impl<bool, true>const __is_trivially_move_constructible_impl<bool, true> &__is_trivially_copy_constructible_impl<bool, true>__is_trivially_copy_constructible_impl<bool, true> &__is_trivially_copy_constructible_impl<bool, true> &&const __is_trivially_copy_constructible_impl<bool, true>const __is_trivially_copy_constructible_impl<bool, true> &__is_move_constructible_impl<bool, true>__is_move_constructible_impl<bool, true> &__is_move_constructible_impl<bool, true> &&const __is_move_constructible_impl<bool, true>const __is_move_constructible_impl<bool, true> &__is_move_assignable_impl<bool, true>__is_move_assignable_impl<bool, true> &__is_move_assignable_impl<bool, true> &&const __is_move_assignable_impl<bool, true>const __is_move_assignable_impl<bool, true> &__is_copy_constructible_impl<bool, true>__is_copy_constructible_impl<bool, true> &__is_copy_constructible_impl<bool, true> &&const __is_copy_constructible_impl<bool, true>const __is_copy_constructible_impl<bool, true> &__is_copy_assignable_impl<bool, true>__is_copy_assignable_impl<bool, true> &__is_copy_assignable_impl<bool, true> &&const __is_copy_assignable_impl<bool, true>const __is_copy_assignable_impl<bool, true> &__is_trivially_move_constructible_impl<Network, true>__is_trivially_move_constructible_impl<Network, true> &__is_trivially_move_constructible_impl<Network, true> &&const __is_trivially_move_constructible_impl<Network, true>const __is_trivially_move_constructible_impl<Network, true> &__is_trivially_copy_constructible_impl<Network, true>__is_trivially_copy_constructible_impl<Network, true> &__is_trivially_copy_constructible_impl<Network, true> &&const __is_trivially_copy_constructible_impl<Network, true>const __is_trivially_copy_constructible_impl<Network, true> &__is_move_constructible_impl<Network, true>__is_move_constructible_impl<Network, true> &__is_move_constructible_impl<Network, true> &&const __is_move_constructible_impl<Network, true>const __is_move_constructible_impl<Network, true> &__is_move_assignable_impl<Network, true>__is_move_assignable_impl<Network, true> &__is_move_assignable_impl<Network, true> &&const __is_move_assignable_impl<Network, true>const __is_move_assignable_impl<Network, true> &__is_copy_constructible_impl<Network, true>__is_copy_constructible_impl<Network, true> &__is_copy_constructible_impl<Network, true> &&const __is_copy_constructible_impl<Network, true>const __is_copy_constructible_impl<Network, true> &__is_copy_assignable_impl<Network, true>__is_copy_assignable_impl<Network, true> &__is_copy_assignable_impl<Network, true> &&const __is_copy_assignable_impl<Network, true>const __is_copy_assignable_impl<Network, true> &__is_trivially_move_constructible_impl<bilingual_str, true>__is_trivially_move_constructible_impl<bilingual_str, true> &__is_trivially_move_constructible_impl<bilingual_str, true> &&const __is_trivially_move_constructible_impl<bilingual_str, true>const __is_trivially_move_constructible_impl<bilingual_str, true> &__is_trivially_copy_constructible_impl<bilingual_str, true>__is_trivially_copy_constructible_impl<bilingual_str, true> &__is_trivially_copy_constructible_impl<bilingual_str, true> &&const __is_trivially_copy_constructible_impl<bilingual_str, true>const __is_trivially_copy_constructible_impl<bilingual_str, true> &__is_move_constructible_impl<bilingual_str, true>__is_move_constructible_impl<bilingual_str, true> &__is_move_constructible_impl<bilingual_str, true> &&const __is_move_constructible_impl<bilingual_str, true>const __is_move_constructible_impl<bilingual_str, true> &__is_move_assignable_impl<bilingual_str, true>__is_move_assignable_impl<bilingual_str, true> &__is_move_assignable_impl<bilingual_str, true> &&const __is_move_assignable_impl<bilingual_str, true>const __is_move_assignable_impl<bilingual_str, true> &__is_copy_constructible_impl<bilingual_str, true>__is_copy_constructible_impl<bilingual_str, true> &__is_copy_constructible_impl<bilingual_str, true> &&const __is_copy_constructible_impl<bilingual_str, true>const __is_copy_constructible_impl<bilingual_str, true> &__is_copy_assignable_impl<bilingual_str, true>__is_copy_assignable_impl<bilingual_str, true> &__is_copy_assignable_impl<bilingual_str, true> &&const __is_copy_assignable_impl<bilingual_str, true>const __is_copy_assignable_impl<bilingual_str, true> &__and_<is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>>__and_<is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &__and_<is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &&const __and_<is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>>const __and_<is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &__and_<is_destructible<Network>, integral_constant<bool, true>>__and_<is_destructible<Network>, integral_constant<bool, true>> &__and_<is_destructible<Network>, integral_constant<bool, true>> &&const __and_<is_destructible<Network>, integral_constant<bool, true>>const __and_<is_destructible<Network>, integral_constant<bool, true>> &__and_<is_destructible<bool>, integral_constant<bool, true>>__and_<is_destructible<bool>, integral_constant<bool, true>> &__and_<is_destructible<bool>, integral_constant<bool, true>> &&const __and_<is_destructible<bool>, integral_constant<bool, true>>const __and_<is_destructible<bool>, integral_constant<bool, true>> &__and_<is_destructible<bilingual_str>, integral_constant<bool, false>>__and_<is_destructible<bilingual_str>, integral_constant<bool, false>> &__and_<is_destructible<bilingual_str>, integral_constant<bool, false>> &&const __and_<is_destructible<bilingual_str>, integral_constant<bool, false>>const __and_<is_destructible<bilingual_str>, integral_constant<bool, false>> &__uninit_copyconst __aligned_buffer<pair<const LogFlags, Level>> *__aligned_buffer<pair<const LogFlags, Level>> *__normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> *const __normal_iterator<const char *, basic_string<char, char_traits<char>, allocator<char>>> *FormatListN<2> *const Wrapper<CompactSizeFormatter<true>, const unsigned long &> *_Tuple_impl<1UL, const int &, const int &, const int &> *_Optional_payload_base<Network> *_Optional_payload_base<bool> *__do_alloc_on_copy__make_not_void<_Hash_node<pair<const LogFlags, Level>, false>> &__node_type &std::is_nothrow_constructible<_Up, _Args...>::value__to_addressconst _Hash_node_base *const _Hashtable_base<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<false, false, true>> *std::is_nothrow_destructible<_Up>::value__aligned_membuf<function<..(..)>> *~__allocated_ptr__allocated_ptr<allocator<_List_node<function<..(..)>>>> *FormatListN<3> *const new_allocator<CAddress> &new_allocator<CAddress> &FormatListN<1> *FormatArg[1]..(*)(..))[4]_Rb_tree_key_compare<less<basic_string<char, char_traits<char>, allocator<char>>>> *_Link_type &_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *&const _Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *__aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *const _Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *_Select1st<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *is_nothrow_default_constructible<less<basic_string<char, char_traits<char>, allocator<char>>>>is_nothrow_default_constructible<less<basic_string<char, char_traits<char>, allocator<char>>>> &is_nothrow_default_constructible<less<basic_string<char, char_traits<char>, allocator<char>>>> &&const is_nothrow_default_constructible<less<basic_string<char, char_traits<char>, allocator<char>>>>const is_nothrow_default_constructible<less<basic_string<char, char_traits<char>, allocator<char>>>> &is_nothrow_constructible<function<..(..)>, function<..(..)>>is_nothrow_constructible<function<..(..)>, function<..(..)>> &is_nothrow_constructible<function<..(..)>, function<..(..)>> &&const is_nothrow_constructible<function<..(..)>, function<..(..)>>const is_nothrow_constructible<function<..(..)>, function<..(..)>> &is_nothrow_destructible<function<..(..)>>is_nothrow_destructibleis_nothrow_destructible<function<..(..)>> &is_nothrow_destructible<function<..(..)>> &&const is_nothrow_destructible<function<..(..)>>const is_nothrow_destructible<function<..(..)>> &is_nothrow_constructible<pair<const LogFlags, Level>, const pair<const LogFlags, Level> &>is_nothrow_constructible<pair<const LogFlags, Level>, const pair<const LogFlags, Level> &> &is_nothrow_constructible<pair<const LogFlags, Level>, const pair<const LogFlags, Level> &> &&const is_nothrow_constructible<pair<const LogFlags, Level>, const pair<const LogFlags, Level> &>const is_nothrow_constructible<pair<const LogFlags, Level>, const pair<const LogFlags, Level> &> &__make_not_voidpointer_traits<_Hash_node<pair<const LogFlags, Level>, false> *>pointer_traits<_Hash_node<pair<const LogFlags, Level>, false> *> &pointer_traits<_Hash_node<pair<const LogFlags, Level>, false> *> &&const pointer_traits<_Hash_node<pair<const LogFlags, Level>, false> *>const pointer_traits<_Hash_node<pair<const LogFlags, Level>, false> *> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 3UL, 4UL>__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 3UL, 4UL> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 3UL, 4UL> &&const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 3UL, 4UL>const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 3UL, 4UL> &is_destructible<bilingual_str>is_destructibleis_destructible<bilingual_str> &is_destructible<bilingual_str> &&const is_destructible<bilingual_str>const is_destructible<bilingual_str> &is_destructible<bool>is_destructible<bool> &is_destructible<bool> &&const is_destructible<bool>const is_destructible<bool> &is_destructible<Network>is_destructible<Network> &is_destructible<Network> &&const is_destructible<Network>const is_destructible<Network> &is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_assignable<bilingual_str &, const bilingual_str &>is_assignable<bilingual_str &, const bilingual_str &> &is_assignable<bilingual_str &, const bilingual_str &> &&const is_assignable<bilingual_str &, const bilingual_str &>const is_assignable<bilingual_str &, const bilingual_str &> &is_constructible<bilingual_str, const bilingual_str &>is_constructible<bilingual_str, const bilingual_str &> &is_constructible<bilingual_str, const bilingual_str &> &&const is_constructible<bilingual_str, const bilingual_str &>const is_constructible<bilingual_str, const bilingual_str &> &conditional<true, is_copy_assignable<bilingual_str>, is_copy_constructible<bilingual_str>>conditional<true, is_copy_assignable<bilingual_str>, is_copy_constructible<bilingual_str>> &conditional<true, is_copy_assignable<bilingual_str>, is_copy_constructible<bilingual_str>> &&const conditional<true, is_copy_assignable<bilingual_str>, is_copy_constructible<bilingual_str>>const conditional<true, is_copy_assignable<bilingual_str>, is_copy_constructible<bilingual_str>> &is_assignable<bilingual_str &, bilingual_str &&>is_assignable<bilingual_str &, bilingual_str &&> &is_assignable<bilingual_str &, bilingual_str &&> &&const is_assignable<bilingual_str &, bilingual_str &&>const is_assignable<bilingual_str &, bilingual_str &&> &is_constructible<bilingual_str, bilingual_str &&>is_constructible<bilingual_str, bilingual_str &&> &is_constructible<bilingual_str, bilingual_str &&> &&const is_constructible<bilingual_str, bilingual_str &&>const is_constructible<bilingual_str, bilingual_str &&> &conditional<true, is_move_assignable<bilingual_str>, is_move_constructible<bilingual_str>>conditional<true, is_move_assignable<bilingual_str>, is_move_constructible<bilingual_str>> &conditional<true, is_move_assignable<bilingual_str>, is_move_constructible<bilingual_str>> &&const conditional<true, is_move_assignable<bilingual_str>, is_move_constructible<bilingual_str>>const conditional<true, is_move_assignable<bilingual_str>, is_move_constructible<bilingual_str>> &__and_<is_copy_constructible<bilingual_str>, integral_constant<bool, false>>__and_<is_copy_constructible<bilingual_str>, integral_constant<bool, false>> &__and_<is_copy_constructible<bilingual_str>, integral_constant<bool, false>> &&const __and_<is_copy_constructible<bilingual_str>, integral_constant<bool, false>>const __and_<is_copy_constructible<bilingual_str>, integral_constant<bool, false>> &__is_referenceable<bilingual_str>__is_referenceable<bilingual_str> &__is_referenceable<bilingual_str> &&const __is_referenceable<bilingual_str>const __is_referenceable<bilingual_str> &__and_<is_move_constructible<bilingual_str>, integral_constant<bool, false>>__and_<is_move_constructible<bilingual_str>, integral_constant<bool, false>> &__and_<is_move_constructible<bilingual_str>, integral_constant<bool, false>> &&const __and_<is_move_constructible<bilingual_str>, integral_constant<bool, false>>const __and_<is_move_constructible<bilingual_str>, integral_constant<bool, false>> &is_assignable<Network &, const Network &>Network &const Networkconst Network &is_assignable<Network &, const Network &> &is_assignable<Network &, const Network &> &&const is_assignable<Network &, const Network &>const is_assignable<Network &, const Network &> &is_constructible<Network, const Network &>is_constructible<Network, const Network &> &is_constructible<Network, const Network &> &&const is_constructible<Network, const Network &>const is_constructible<Network, const Network &> &conditional<true, is_copy_assignable<Network>, is_copy_constructible<Network>>conditional<true, is_copy_assignable<Network>, is_copy_constructible<Network>> &conditional<true, is_copy_assignable<Network>, is_copy_constructible<Network>> &&const conditional<true, is_copy_assignable<Network>, is_copy_constructible<Network>>const conditional<true, is_copy_assignable<Network>, is_copy_constructible<Network>> &is_assignable<Network &, Network &&>Network &&is_assignable<Network &, Network &&> &is_assignable<Network &, Network &&> &&const is_assignable<Network &, Network &&>const is_assignable<Network &, Network &&> &is_constructible<Network, Network &&>is_constructible<Network, Network &&> &is_constructible<Network, Network &&> &&const is_constructible<Network, Network &&>const is_constructible<Network, Network &&> &conditional<true, is_move_assignable<Network>, is_move_constructible<Network>>conditional<true, is_move_assignable<Network>, is_move_constructible<Network>> &conditional<true, is_move_assignable<Network>, is_move_constructible<Network>> &&const conditional<true, is_move_assignable<Network>, is_move_constructible<Network>>const conditional<true, is_move_assignable<Network>, is_move_constructible<Network>> &__and_<is_copy_constructible<Network>, integral_constant<bool, true>>__and_<is_copy_constructible<Network>, integral_constant<bool, true>> &__and_<is_copy_constructible<Network>, integral_constant<bool, true>> &&const __and_<is_copy_constructible<Network>, integral_constant<bool, true>>const __and_<is_copy_constructible<Network>, integral_constant<bool, true>> &__is_referenceable<Network>__is_referenceable<Network> &__is_referenceable<Network> &&const __is_referenceable<Network>const __is_referenceable<Network> &__and_<is_move_constructible<Network>, integral_constant<bool, true>>__and_<is_move_constructible<Network>, integral_constant<bool, true>> &__and_<is_move_constructible<Network>, integral_constant<bool, true>> &&const __and_<is_move_constructible<Network>, integral_constant<bool, true>>const __and_<is_move_constructible<Network>, integral_constant<bool, true>> &is_assignable<bool &, const bool &>is_assignable<bool &, const bool &> &is_assignable<bool &, const bool &> &&const is_assignable<bool &, const bool &>const is_assignable<bool &, const bool &> &is_constructible<bool, const bool &>is_constructible<bool, const bool &> &is_constructible<bool, const bool &> &&const is_constructible<bool, const bool &>const is_constructible<bool, const bool &> &conditional<true, is_copy_assignable<bool>, is_copy_constructible<bool>>conditional<true, is_copy_assignable<bool>, is_copy_constructible<bool>> &conditional<true, is_copy_assignable<bool>, is_copy_constructible<bool>> &&const conditional<true, is_copy_assignable<bool>, is_copy_constructible<bool>>const conditional<true, is_copy_assignable<bool>, is_copy_constructible<bool>> &is_assignable<bool &, bool &&>is_assignable<bool &, bool &&> &is_assignable<bool &, bool &&> &&const is_assignable<bool &, bool &&>const is_assignable<bool &, bool &&> &is_constructible<bool, bool &&>is_constructible<bool, bool &&> &is_constructible<bool, bool &&> &&const is_constructible<bool, bool &&>const is_constructible<bool, bool &&> &conditional<true, is_move_assignable<bool>, is_move_constructible<bool>>conditional<true, is_move_assignable<bool>, is_move_constructible<bool>> &conditional<true, is_move_assignable<bool>, is_move_constructible<bool>> &&const conditional<true, is_move_assignable<bool>, is_move_constructible<bool>>const conditional<true, is_move_assignable<bool>, is_move_constructible<bool>> &__and_<is_copy_constructible<bool>, integral_constant<bool, true>>__and_<is_copy_constructible<bool>, integral_constant<bool, true>> &__and_<is_copy_constructible<bool>, integral_constant<bool, true>> &&const __and_<is_copy_constructible<bool>, integral_constant<bool, true>>const __and_<is_copy_constructible<bool>, integral_constant<bool, true>> &__is_referenceable<bool>__is_referenceable<bool> &__is_referenceable<bool> &&const __is_referenceable<bool>const __is_referenceable<bool> &__and_<is_move_constructible<bool>, integral_constant<bool, true>>__and_<is_move_constructible<bool>, integral_constant<bool, true>> &__and_<is_move_constructible<bool>, integral_constant<bool, true>> &&const __and_<is_move_constructible<bool>, integral_constant<bool, true>>const __and_<is_move_constructible<bool>, integral_constant<bool, true>> &is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &>is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &> &is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &> &&const is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &>const is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &> &is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &>is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &> &is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &> &&const is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &>const is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, const time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &> &conditional<true, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>conditional<true, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const conditional<true, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const conditional<true, is_copy_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&>is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&> &is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&> &&const is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&>const is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&> &is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&>is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&> &is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&> &&const is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&>const is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &&> &conditional<true, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>conditional<true, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const conditional<true, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const conditional<true, is_move_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>>__and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &__and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &&const __and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>>const __and_<is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &__is_referenceable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>__is_referenceable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &__is_referenceable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const __is_referenceable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const __is_referenceable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &__and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>>__and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &__and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &&const __and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>>const __and_<is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, integral_constant<bool, true>> &__ratio_divide<ratio<1L, 1000000000L>, ratio<1L, 1000L>>__ratio_divide<ratio<1L, 1000000000L>, ratio<1L, 1000L>> &__ratio_divide<ratio<1L, 1000000000L>, ratio<1L, 1000L>> &&const __ratio_divide<ratio<1L, 1000000000L>, ratio<1L, 1000L>>const __ratio_divide<ratio<1L, 1000000000L>, ratio<1L, 1000L>> &tuple_element<0UL, tuple<const bool &, const int &, const int &, const int &>>tuple_element<0UL, tuple<const bool &, const int &, const int &, const int &>> &tuple_element<0UL, tuple<const bool &, const int &, const int &, const int &>> &&const tuple_element<0UL, tuple<const bool &, const int &, const int &, const int &>>const tuple_element<0UL, tuple<const bool &, const int &, const int &, const int &>> &tuple_element<1UL, pair<const LogFlags, Level>>tuple_element<1UL, pair<const LogFlags, Level>> &tuple_element<1UL, pair<const LogFlags, Level>> &&const tuple_element<1UL, pair<const LogFlags, Level>>const tuple_element<1UL, pair<const LogFlags, Level>> &__and_<is_same<function<..(..)> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _U2>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _U1>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _U2>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>, _U1>__and_<is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _U2>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _U1>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _U2>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>>>, _U1>_TC<value, AddrManImpl *, default_delete<AddrManImpl>>_TC<true, AddrManImpl *, default_delete<AddrManImpl>>_TC<true, AddrManImpl *, default_delete<AddrManImpl>> &_TC<true, AddrManImpl *, default_delete<AddrManImpl>> &&const _TC<true, AddrManImpl *, default_delete<AddrManImpl>>const _TC<true, AddrManImpl *, default_delete<AddrManImpl>> &_TC<value, AddrMan *, default_delete<AddrMan>>_TC<true, AddrMan *, default_delete<AddrMan>>_TC<true, AddrMan *, default_delete<AddrMan>> &_TC<true, AddrMan *, default_delete<AddrMan>> &&const _TC<true, AddrMan *, default_delete<AddrMan>>const _TC<true, AddrMan *, default_delete<AddrMan>> &iterator_traits<const CAddress *>iterator_traits<const CAddress *> &iterator_traits<const CAddress *> &&const iterator_traits<const CAddress *>const iterator_traits<const CAddress *> &conditional<true, pair<_Node_iterator<pair<const LogFlags, Level>, false, false>, bool>, _Node_iterator<pair<const LogFlags, Level>, false, false>>conditional<true, pair<_Node_iterator<pair<const LogFlags, Level>, false, false>, bool>, _Node_iterator<pair<const LogFlags, Level>, false, false>> &conditional<true, pair<_Node_iterator<pair<const LogFlags, Level>, false, false>, bool>, _Node_iterator<pair<const LogFlags, Level>, false, false>> &&const conditional<true, pair<_Node_iterator<pair<const LogFlags, Level>, false, false>, bool>, _Node_iterator<pair<const LogFlags, Level>, false, false>>const conditional<true, pair<_Node_iterator<pair<const LogFlags, Level>, false, false>, bool>, _Node_iterator<pair<const LogFlags, Level>, false, false>> &is_same<Level, _U2>is_same<const LogFlags, _U1>__and_<is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _U2>is_same<_Rb_tree_const_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _U1>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _U2>is_same<_Rb_tree_iterator<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>, _U1>__and_<is_same<pair<const CSubNet, CBanEntry> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _U2>is_same<_Rb_tree_const_iterator<pair<const CSubNet, CBanEntry>>, _U1>is_same<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _U2>is_same<_Rb_tree_iterator<pair<const CSubNet, CBanEntry>>, _U1>__and_<is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<CBanEntry, _U2>is_same<const CSubNet, _U1>remove_const<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>remove_const<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &remove_const<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const remove_const<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const remove_const<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &remove_const<Network>remove_const<Network> &remove_const<Network> &&const remove_const<Network>const remove_const<Network> &remove_const<bool>remove_const<bool> &remove_const<bool> &&const remove_const<bool>const remove_const<bool> &remove_const<bilingual_str>remove_const<bilingual_str> &remove_const<bilingual_str> &&const remove_const<bilingual_str>const remove_const<bilingual_str> &is_same<tuple<basic_string<char, char_traits<char>, allocator<char>> &&>, tuple<_UElements...>>is_constructible<pair<const LogFlags, Level>, _Pair &&>enable_if<value, void>_Equal_helper<LogFlags, pair<const LogFlags, Level>, _Select1st, equal_to<LogFlags>, unsigned long, false>is_default_constructible<_Mod_range_hashing>__and_<is_same<_List_node<basic_string<char, char_traits<char>, allocator<char>>> *, _Ptr>, __not_<is_pointer<_Ptr>>>__and_<is_same<_List_node<function<..(..)>> *, _Ptr>, __not_<is_pointer<_Ptr>>>is_same<UniValue *, _Ptr>is_same<LogCategory *, _Ptr>remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &>remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &> &remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &> &&const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &>const remove_reference<const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &> &remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &>remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &> &remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &> &&const remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &>const remove_reference<allocator<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>> &> &is_nothrow_move_assignable<AddrMan *>is_nothrow_move_assignableis_nothrow_move_assignable<AddrMan *> &is_nothrow_move_assignable<AddrMan *> &&const is_nothrow_move_assignable<AddrMan *>const is_nothrow_move_assignable<AddrMan *> &is_nothrow_move_constructible<AddrMan *>is_nothrow_move_constructibleis_nothrow_move_constructible<AddrMan *> &is_nothrow_move_constructible<AddrMan *> &&const is_nothrow_move_constructible<AddrMan *>const is_nothrow_move_constructible<AddrMan *> &iterator_traits<CAddress *>iterator_traits<CAddress *> &iterator_traits<CAddress *> &&const iterator_traits<CAddress *>const iterator_traits<CAddress *> &remove_reference<_Vector_impl &>remove_reference<_Vector_impl &> &remove_reference<_Vector_impl &> &&const remove_reference<_Vector_impl &>const remove_reference<_Vector_impl &> &remove_reference<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>remove_reference<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &remove_reference<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &&const remove_reference<allocator<_Hash_node<pair<const LogFlags, Level>, false>>>const remove_reference<allocator<_Hash_node<pair<const LogFlags, Level>, false>>> &remove_reference<const _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &>remove_reference<const _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &> &remove_reference<const _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &> &&const remove_reference<const _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &>const remove_reference<const _Hashtable<LogFlags, pair<const LogFlags, Level>, allocator<pair<const LogFlags, Level>>, _Select1st, equal_to<LogFlags>, hash<LogFlags>, _Mod_range_hashing, _Default_ranged_hash, _Prime_rehash_policy, _Hashtable_traits<false, false, true>> &> &__is_nothrow_copy_constructible_impl<const_iterator, true>__is_nothrow_copy_constructible_impl__is_nothrow_copy_constructible_impl<const_iterator, true> &__is_nothrow_copy_constructible_impl<const_iterator, true> &&const __is_nothrow_copy_constructible_impl<const_iterator, true>const __is_nothrow_copy_constructible_impl<const_iterator, true> &__iterator_traits<const_iterator, void>__iterator_traits<const_iterator, void> &__iterator_traits<const_iterator, void> &&const __iterator_traits<const_iterator, void>const __iterator_traits<const_iterator, void> &__iterator_traits<__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>, void>__iterator_traits<__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>, void> &__iterator_traits<__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>, void> &&const __iterator_traits<__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>, void>const __iterator_traits<__normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>>, void> &iterator_traits<UniValue *>iterator_traits<UniValue *> &iterator_traits<UniValue *> &&const iterator_traits<UniValue *>const iterator_traits<UniValue *> &__is_trivially_move_assignable_impl<bilingual_str, true>__is_trivially_move_assignable_impl__is_trivially_move_assignable_impl<bilingual_str, true> &__is_trivially_move_assignable_impl<bilingual_str, true> &&const __is_trivially_move_assignable_impl<bilingual_str, true>const __is_trivially_move_assignable_impl<bilingual_str, true> &__is_trivially_copy_assignable_impl<bilingual_str, true>__is_trivially_copy_assignable_impl__is_trivially_copy_assignable_impl<bilingual_str, true> &__is_trivially_copy_assignable_impl<bilingual_str, true> &&const __is_trivially_copy_assignable_impl<bilingual_str, true>const __is_trivially_copy_assignable_impl<bilingual_str, true> &__is_trivially_move_assignable_impl<Network, true>__is_trivially_move_assignable_impl<Network, true> &__is_trivially_move_assignable_impl<Network, true> &&const __is_trivially_move_assignable_impl<Network, true>const __is_trivially_move_assignable_impl<Network, true> &__is_trivially_copy_assignable_impl<Network, true>__is_trivially_copy_assignable_impl<Network, true> &__is_trivially_copy_assignable_impl<Network, true> &&const __is_trivially_copy_assignable_impl<Network, true>const __is_trivially_copy_assignable_impl<Network, true> &__is_trivially_move_assignable_impl<bool, true>__is_trivially_move_assignable_impl<bool, true> &__is_trivially_move_assignable_impl<bool, true> &&const __is_trivially_move_assignable_impl<bool, true>const __is_trivially_move_assignable_impl<bool, true> &__is_trivially_copy_assignable_impl<bool, true>__is_trivially_copy_assignable_impl<bool, true> &__is_trivially_copy_assignable_impl<bool, true> &&const __is_trivially_copy_assignable_impl<bool, true>const __is_trivially_copy_assignable_impl<bool, true> &__is_trivially_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_trivially_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_trivially_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_trivially_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_trivially_move_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_trivially_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>__is_trivially_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__is_trivially_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &&const __is_trivially_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true>const __is_trivially_copy_assignable_impl<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, true> &__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const __and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const __and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &unsigned char(*)[120]const __aligned_membuf<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *_Tuple_impl<0UL, AddrMan *, default_delete<AddrMan>> *Wrapper<VectorFormatter<DefaultFormatter>, vector<CAddress, allocator<CAddress>> &> &&Wrapper<VectorFormatter<DefaultFormatter>, vector<CAddress, allocator<CAddress>> &> &unsigned char(*)[32]allocator<_Hash_node_base *> &__bucket_alloc_type &__make_not_void<_Hash_node_base *> &_Hash_node_base *&__bucket_type &const __bucket_typeconst __bucket_type *_Storage<bool, true> *_Storage<Network, true> *_Head_base<1UL, const int &, false> *_Tuple_impl<2UL, const int &, const int &> *const _Head_base<0UL, const bool &, false>const _Head_base<0UL, const bool &, false> &_Head_base<0UL, const bool &, false> &const Wrapper<ChronoFormatter<unsigned int, true>, const time_point<NodeClock, duration<signed long, ratio<1L, 1L>>> &> *const Wrapper<CompactSizeFormatter<false>, unsigned long &> *const Wrapper<CustomUintFormatter<8, false>, const ServiceFlags &> *const Wrapper<CustomUintFormatter<2, true>, const unsigned short &> *std::numeric_limits<I>::min()std::numeric_limits<I>::max()const type *const __normal_iterator<const UniValue *, vector<UniValue, allocator<UniValue>>> *_Storage<bilingual_str, false> *__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 4UL, 4UL>__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 4UL, 4UL> &__tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 4UL, 4UL> &&const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 4UL, 4UL>const __tuple_compare<tuple<const bool &, const int &, const int &, const int &>, tuple<const bool &, const int &, const int &, const int &>, 4UL, 4UL> &pointer_traits<_Hash_node_base **>pointer_traits<_Hash_node_base **> &pointer_traits<_Hash_node_base **> &&const pointer_traits<_Hash_node_base **>const pointer_traits<_Hash_node_base **> &is_nothrow_destructible<pair<const LogFlags, Level>>is_nothrow_destructible<pair<const LogFlags, Level>> &is_nothrow_destructible<pair<const LogFlags, Level>> &&const is_nothrow_destructible<pair<const LogFlags, Level>>const is_nothrow_destructible<pair<const LogFlags, Level>> &Wrapper<VectorFormatter<DefaultFormatter>, vector<CAddress, allocator<CAddress>> &>const Wrapper<VectorFormatter<DefaultFormatter>, vector<CAddress, allocator<CAddress>> &>const Wrapper<VectorFormatter<DefaultFormatter>, vector<CAddress, allocator<CAddress>> &> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const piecewise_construct_t &, tuple<basic_string<char, char_traits<char>, allocator<char>> &&>, tuple<>>is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const piecewise_construct_t &, tuple<basic_string<char, char_traits<char>, allocator<char>> &&>, tuple<>> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const piecewise_construct_t &, tuple<basic_string<char, char_traits<char>, allocator<char>> &&>, tuple<>> &&const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const piecewise_construct_t &, tuple<basic_string<char, char_traits<char>, allocator<char>> &&>, tuple<>>const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const piecewise_construct_t &, tuple<basic_string<char, char_traits<char>, allocator<char>> &&>, tuple<>> &is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>is_scalaris_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &&const is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>const is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>> &conditional<true, __and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>conditional<true, __and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>> &conditional<true, __and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>> &&const conditional<true, __and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>const conditional<true, __and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<is_same<optional<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>> &__and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>__and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const __and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const __and_<__not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>, is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__is_referenceable<const_iterator>__is_referenceable<const_iterator> &__is_referenceable<const_iterator> &&const __is_referenceable<const_iterator>const __is_referenceable<const_iterator> &is_nothrow_constructible<const_iterator, const const_iterator &>const const_iterator &is_nothrow_constructible<const_iterator, const const_iterator &> &is_nothrow_constructible<const_iterator, const const_iterator &> &&const is_nothrow_constructible<const_iterator, const const_iterator &>const is_nothrow_constructible<const_iterator, const const_iterator &> &tuple_element<0UL, tuple<const int &, const int &, const int &>>tuple_element<0UL, tuple<const int &, const int &, const int &>> &tuple_element<0UL, tuple<const int &, const int &, const int &>> &&const tuple_element<0UL, tuple<const int &, const int &, const int &>>const tuple_element<0UL, tuple<const int &, const int &, const int &>> &tuple_element<0UL, tuple<default_delete<AddrMan>>>tuple_element<0UL, tuple<default_delete<AddrMan>>> &tuple_element<0UL, tuple<default_delete<AddrMan>>> &&const tuple_element<0UL, tuple<default_delete<AddrMan>>>const tuple_element<0UL, tuple<default_delete<AddrMan>>> &tuple_element<0UL, tuple<AddrMan *, default_delete<AddrMan>>>tuple_element<0UL, tuple<AddrMan *, default_delete<AddrMan>>> &tuple_element<0UL, tuple<AddrMan *, default_delete<AddrMan>>> &&const tuple_element<0UL, tuple<AddrMan *, default_delete<AddrMan>>>const tuple_element<0UL, tuple<AddrMan *, default_delete<AddrMan>>> &conditional<true, is_nothrow_move_assignable<AddrMan *>, is_nothrow_move_constructible<AddrMan *>>conditional<true, is_nothrow_move_assignable<AddrMan *>, is_nothrow_move_constructible<AddrMan *>> &conditional<true, is_nothrow_move_assignable<AddrMan *>, is_nothrow_move_constructible<AddrMan *>> &&const conditional<true, is_nothrow_move_assignable<AddrMan *>, is_nothrow_move_constructible<AddrMan *>>const conditional<true, is_nothrow_move_assignable<AddrMan *>, is_nothrow_move_constructible<AddrMan *>> &__is_nothrow_move_constructible_impl<AddrMan *, true>__is_nothrow_move_constructible_impl__is_nothrow_move_constructible_impl<AddrMan *, true> &__is_nothrow_move_constructible_impl<AddrMan *, true> &&const __is_nothrow_move_constructible_impl<AddrMan *, true>const __is_nothrow_move_constructible_impl<AddrMan *, true> &__is_nt_move_assignable_impl<AddrMan *, true>__is_nt_move_assignable_impl__is_nt_move_assignable_impl<AddrMan *, true> &__is_nt_move_assignable_impl<AddrMan *, true> &&const __is_nt_move_assignable_impl<AddrMan *, true>const __is_nt_move_assignable_impl<AddrMan *, true> &is_same<_List_node<function<..(..)>> *, _Ptr>is_same<_List_node<basic_string<char, char_traits<char>, allocator<char>>> *, _Ptr>__and_<is_same<_Hash_node<pair<const LogFlags, Level>, false> *, _Ptr>, __not_<is_pointer<_Ptr>>>conditional<true, __not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>>conditional<true, __not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>> &conditional<true, __not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>> &&const conditional<true, __not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>>const conditional<true, __not_<integral_constant<bool, false>>, is_default_constructible<_Mod_range_hashing>> &__is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&>__is_empty_non_tuple__is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&> &__is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&> &&const __is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&>const __is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&> &is_same<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *, _Ptr>is_same<pair<const CSubNet, CBanEntry> *, _Ptr>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> *, _Ptr>__is_empty_non_tuple<default_delete<AddrMan>>__is_empty_non_tuple<default_delete<AddrMan>> &__is_empty_non_tuple<default_delete<AddrMan>> &&const __is_empty_non_tuple<default_delete<AddrMan>>const __is_empty_non_tuple<default_delete<AddrMan>> &__is_empty_non_tuple<AddrMan *>__is_empty_non_tuple<AddrMan *> &__is_empty_non_tuple<AddrMan *> &&const __is_empty_non_tuple<AddrMan *>const __is_empty_non_tuple<AddrMan *> &__is_empty_non_tuple<default_delete<AddrManImpl>>__is_empty_non_tuple<default_delete<AddrManImpl>> &__is_empty_non_tuple<default_delete<AddrManImpl>> &&const __is_empty_non_tuple<default_delete<AddrManImpl>>const __is_empty_non_tuple<default_delete<AddrManImpl>> &__is_empty_non_tuple<AddrManImpl *>__is_empty_non_tuple<AddrManImpl *> &__is_empty_non_tuple<AddrManImpl *> &&const __is_empty_non_tuple<AddrManImpl *>const __is_empty_non_tuple<AddrManImpl *> &__is_empty_non_tuple<const int &>__is_empty_non_tuple<const int &> &__is_empty_non_tuple<const int &> &&const __is_empty_non_tuple<const int &>const __is_empty_non_tuple<const int &> &is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, map<basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>, less<basic_string<char, char_traits<char>, allocator<char>>>, allocator<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>>>>> *, _Ptr>is_same<pair<const basic_string<char, char_traits<char>, allocator<char>>, vector<UniValue, allocator<UniValue>>> *, _Ptr>is_same<function<..(..)> *, _Ptr>__ratio_multiply<ratio<1L, 1000000000L>, ratio<1000L, 1L>>__ratio_multiply<ratio<1L, 1000000000L>, ratio<1000L, 1L>> &__ratio_multiply<ratio<1L, 1000000000L>, ratio<1000L, 1L>> &&const __ratio_multiply<ratio<1L, 1000000000L>, ratio<1000L, 1L>>const __ratio_multiply<ratio<1L, 1000000000L>, ratio<1000L, 1L>> &conditional<true, integral_constant<bool, true>, is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>conditional<true, integral_constant<bool, true>, is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, integral_constant<bool, true>, is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const conditional<true, integral_constant<bool, true>, is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const conditional<true, integral_constant<bool, true>, is_destructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, integral_constant<bool, true>, is_destructible<Network>>conditional<true, integral_constant<bool, true>, is_destructible<Network>> &conditional<true, integral_constant<bool, true>, is_destructible<Network>> &&const conditional<true, integral_constant<bool, true>, is_destructible<Network>>const conditional<true, integral_constant<bool, true>, is_destructible<Network>> &conditional<true, integral_constant<bool, true>, is_destructible<bool>>conditional<true, integral_constant<bool, true>, is_destructible<bool>> &conditional<true, integral_constant<bool, true>, is_destructible<bool>> &&const conditional<true, integral_constant<bool, true>, is_destructible<bool>>const conditional<true, integral_constant<bool, true>, is_destructible<bool>> &conditional<true, integral_constant<bool, false>, is_destructible<bilingual_str>>conditional<true, integral_constant<bool, false>, is_destructible<bilingual_str>> &conditional<true, integral_constant<bool, false>, is_destructible<bilingual_str>> &&const conditional<true, integral_constant<bool, false>, is_destructible<bilingual_str>>const conditional<true, integral_constant<bool, false>, is_destructible<bilingual_str>> &remove_reference<unsigned char(&)[16]>remove_reference<unsigned char(&)[16]> &remove_reference<unsigned char(&)[16]> &&const remove_reference<unsigned char(&)[16]>const remove_reference<unsigned char(&)[16]> &remove_reference<const unsigned char(&)[16]>remove_reference<const unsigned char(&)[16]> &remove_reference<const unsigned char(&)[16]> &&const remove_reference<const unsigned char(&)[16]>const remove_reference<const unsigned char(&)[16]> &remove_reference<const array<unsigned char, 32UL> &>remove_reference<const array<unsigned char, 32UL> &> &remove_reference<const array<unsigned char, 32UL> &> &&const remove_reference<const array<unsigned char, 32UL> &>const remove_reference<const array<unsigned char, 32UL> &> &remove_reference<array<unsigned char, 32UL> &>remove_reference<array<unsigned char, 32UL> &> &remove_reference<array<unsigned char, 32UL> &> &&const remove_reference<array<unsigned char, 32UL> &>const remove_reference<array<unsigned char, 32UL> &> &rebindremove_reference<unsigned char(&)[4]>remove_reference<unsigned char(&)[4]> &remove_reference<unsigned char(&)[4]> &&const remove_reference<unsigned char(&)[4]>const remove_reference<unsigned char(&)[4]> &const array<unsigned char, 32UL> *array<unsigned char, 32UL> *_Head_base<2UL, const int &, false> *_Tuple_impl<3UL, const int &> *addressofallocator<_Hash_node_base *> *_Head_base<0UL, AddrMan *, false> *_Tuple_impl<1UL, default_delete<AddrMan>> *const unsigned char[120]const unsigned char(*)[120]__gcd1__static_gcd<_R1::num, _R2::den>::value__gcd2__static_gcd<_R2::num, _R1::den>::value__static_gcd<1000L, 1000000000L>_R2::num1000000000_R1::den__static_gcd__static_gcd<1000L, 1000000000L> &__static_gcd<1000L, 1000000000L> &&const __static_gcd<1000L, 1000000000L>const __static_gcd<1000L, 1000000000L> &is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &&const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>>const is_nothrow_destructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> &conditional<false, __undefined, _Hash_node<pair<const LogFlags, Level>, false>>conditional<false, __undefined, _Hash_node<pair<const LogFlags, Level>, false>> &conditional<false, __undefined, _Hash_node<pair<const LogFlags, Level>, false>> &&const conditional<false, __undefined, _Hash_node<pair<const LogFlags, Level>, false>>const conditional<false, __undefined, _Hash_node<pair<const LogFlags, Level>, false>> &tuple_element<0UL, tuple<const int &, const int &>>tuple_element<0UL, tuple<const int &, const int &>> &tuple_element<0UL, tuple<const int &, const int &>> &&const tuple_element<0UL, tuple<const int &, const int &>>const tuple_element<0UL, tuple<const int &, const int &>> &conditional<true, integral_constant<bool, false>, is_copy_constructible<bilingual_str>>conditional<true, integral_constant<bool, false>, is_copy_constructible<bilingual_str>> &conditional<true, integral_constant<bool, false>, is_copy_constructible<bilingual_str>> &&const conditional<true, integral_constant<bool, false>, is_copy_constructible<bilingual_str>>const conditional<true, integral_constant<bool, false>, is_copy_constructible<bilingual_str>> &conditional<true, integral_constant<bool, false>, is_move_constructible<bilingual_str>>conditional<true, integral_constant<bool, false>, is_move_constructible<bilingual_str>> &conditional<true, integral_constant<bool, false>, is_move_constructible<bilingual_str>> &&const conditional<true, integral_constant<bool, false>, is_move_constructible<bilingual_str>>const conditional<true, integral_constant<bool, false>, is_move_constructible<bilingual_str>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<Network>>conditional<true, integral_constant<bool, true>, is_copy_constructible<Network>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<Network>> &&const conditional<true, integral_constant<bool, true>, is_copy_constructible<Network>>const conditional<true, integral_constant<bool, true>, is_copy_constructible<Network>> &conditional<true, integral_constant<bool, true>, is_move_constructible<Network>>conditional<true, integral_constant<bool, true>, is_move_constructible<Network>> &conditional<true, integral_constant<bool, true>, is_move_constructible<Network>> &&const conditional<true, integral_constant<bool, true>, is_move_constructible<Network>>const conditional<true, integral_constant<bool, true>, is_move_constructible<Network>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<bool>>conditional<true, integral_constant<bool, true>, is_copy_constructible<bool>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<bool>> &&const conditional<true, integral_constant<bool, true>, is_copy_constructible<bool>>const conditional<true, integral_constant<bool, true>, is_copy_constructible<bool>> &conditional<true, integral_constant<bool, true>, is_move_constructible<bool>>conditional<true, integral_constant<bool, true>, is_move_constructible<bool>> &conditional<true, integral_constant<bool, true>, is_move_constructible<bool>> &&const conditional<true, integral_constant<bool, true>, is_move_constructible<bool>>const conditional<true, integral_constant<bool, true>, is_move_constructible<bool>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>conditional<true, integral_constant<bool, true>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, integral_constant<bool, true>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const conditional<true, integral_constant<bool, true>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const conditional<true, integral_constant<bool, true>, is_copy_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, integral_constant<bool, true>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>conditional<true, integral_constant<bool, true>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<true, integral_constant<bool, true>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const conditional<true, integral_constant<bool, true>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const conditional<true, integral_constant<bool, true>, is_move_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const int &>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const int &>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const int &>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const int &>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<const int &>> &is_empty<const int &>is_emptyis_empty<const int &> &is_empty<const int &> &&const is_empty<const int &>const is_empty<const int &> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrManImpl *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrManImpl *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrManImpl *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrManImpl *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrManImpl *>> &is_empty<AddrManImpl *>is_empty<AddrManImpl *> &is_empty<AddrManImpl *> &&const is_empty<AddrManImpl *>const is_empty<AddrManImpl *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrManImpl>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrManImpl>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrManImpl>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrManImpl>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrManImpl>>> &is_empty<default_delete<AddrManImpl>>is_empty<default_delete<AddrManImpl>> &is_empty<default_delete<AddrManImpl>> &&const is_empty<default_delete<AddrManImpl>>const is_empty<default_delete<AddrManImpl>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrMan *>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrMan *>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrMan *>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrMan *>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<AddrMan *>> &is_empty<AddrMan *>is_empty<AddrMan *> &is_empty<AddrMan *> &&const is_empty<AddrMan *>const is_empty<AddrMan *> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrMan>>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrMan>>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrMan>>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrMan>>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<default_delete<AddrMan>>> &is_empty<default_delete<AddrMan>>is_empty<default_delete<AddrMan>> &is_empty<default_delete<AddrMan>> &&const is_empty<default_delete<AddrMan>>const is_empty<default_delete<AddrMan>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&>>conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&>> &conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&>> &&const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&>>const conditional<false, integral_constant<bool, false>, __is_empty_non_tuple<basic_string<char, char_traits<char>, allocator<char>> &&>> &is_empty<basic_string<char, char_traits<char>, allocator<char>> &&>is_empty<basic_string<char, char_traits<char>, allocator<char>> &&> &is_empty<basic_string<char, char_traits<char>, allocator<char>> &&> &&const is_empty<basic_string<char, char_traits<char>, allocator<char>> &&>const is_empty<basic_string<char, char_traits<char>, allocator<char>> &&> &is_same<_Hash_node<pair<const LogFlags, Level>, false> *, _Ptr>is_nothrow_assignable<AddrMan *&, AddrMan *&&>is_nothrow_assignableis_nothrow_assignable<AddrMan *&, AddrMan *&&> &is_nothrow_assignable<AddrMan *&, AddrMan *&&> &&const is_nothrow_assignable<AddrMan *&, AddrMan *&&>const is_nothrow_assignable<AddrMan *&, AddrMan *&&> &__is_referenceable<AddrMan *>__is_referenceable<AddrMan *> &__is_referenceable<AddrMan *> &&const __is_referenceable<AddrMan *>const __is_referenceable<AddrMan *> &is_nothrow_constructible<AddrMan *, AddrMan *&&>is_nothrow_constructible<AddrMan *, AddrMan *&&> &is_nothrow_constructible<AddrMan *, AddrMan *&&> &&const is_nothrow_constructible<AddrMan *, AddrMan *&&>const is_nothrow_constructible<AddrMan *, AddrMan *&&> &tuple<default_delete<AddrMan>>tuple<const int &, const int &, const int &>conditional<false, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>conditional<false, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &conditional<false, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const conditional<false, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const conditional<false, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *&>remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *&> &remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *&> &&const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *&>const remove_reference<_Rb_tree_node<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>> *&> &remove_reference<const unsigned char(&)[4]>remove_reference<const unsigned char(&)[4]> &remove_reference<const unsigned char(&)[4]> &&const remove_reference<const unsigned char(&)[4]>const remove_reference<const unsigned char(&)[4]> &remove_reference<const prevector<16U, unsigned char, unsigned int, signed int> &>remove_reference<const prevector<16U, unsigned char, unsigned int, signed int> &> &remove_reference<const prevector<16U, unsigned char, unsigned int, signed int> &> &&const remove_reference<const prevector<16U, unsigned char, unsigned int, signed int> &>const remove_reference<const prevector<16U, unsigned char, unsigned int, signed int> &> &remove_reference<const UniValue &>remove_reference<const UniValue &> &remove_reference<const UniValue &> &&const remove_reference<const UniValue &>const remove_reference<const UniValue &> &tuple<basic_string<char, char_traits<char>, allocator<char>> &&> *_Head_base<1UL, default_delete<AddrMan>, true> *const Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &> *Wrapper<VectorFormatter<DefaultFormatter>, const vector<CAddress, allocator<CAddress>> &> *Wrapper<VectorFormatter<DefaultFormatter>, vector<CAddress, allocator<CAddress>> &> *_Invoker_type &new_allocator<_Hash_node_base *> *const new_allocator<_Hash_node_base *>const new_allocator<_Hash_node_base *> *_Head_base<3UL, const int &, false> *tuple_element<0UL, tuple<const int &>>tuple_element<0UL, tuple<const int &>> &tuple_element<0UL, tuple<const int &>> &&const tuple_element<0UL, tuple<const int &>>const tuple_element<0UL, tuple<const int &>> &conditional<false, __undefined, _Hash_node_base *>conditional<false, __undefined, _Hash_node_base *> &conditional<false, __undefined, _Hash_node_base *> &&const conditional<false, __undefined, _Hash_node_base *>const conditional<false, __undefined, _Hash_node_base *> &conditional<true, __and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>>conditional<true, __and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>> &conditional<true, __and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>> &&const conditional<true, __and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>>const conditional<true, __and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>, __not_<__and_<is_scalar<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_same<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>>> &__and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>__and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &&const __and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>>const __and_<is_constructible<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>, is_assignable<time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>> &, time_point<steady_clock, duration<signed long, ratio<1L, 1000000000L>>>>> &__and_<is_assignable<AddrMan *&, AddrMan *&&>, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>>__and_<is_assignable<AddrMan *&, AddrMan *&&>, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>> &__and_<is_assignable<AddrMan *&, AddrMan *&&>, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>> &&const __and_<is_assignable<AddrMan *&, AddrMan *&&>, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>>const __and_<is_assignable<AddrMan *&, AddrMan *&&>, __is_nt_assignable_impl<AddrMan *&, AddrMan *&&>> &tuple<const int &, const int &>is_void<_Hash_node<pair<const LogFlags, Level>, false>>is_voidis_void<_Hash_node<pair<const LogFlags, Level>, false>> &is_void<_Hash_node<pair<const LogFlags, Level>, false>> &&const is_void<_Hash_node<pair<const LogFlags, Level>, false>>const is_void<_Hash_node<pair<const LogFlags, Level>, false>> &__underlying_type_impl<ServiceFlags, true>__underlying_type_impl<ServiceFlags, true> &__underlying_type_impl<ServiceFlags, true> &&const __underlying_type_impl<ServiceFlags, true>const __underlying_type_impl<ServiceFlags, true> &__static_gcd<1000000000L, 1000L>__static_gcd<1000000000L, 1000L> &__static_gcd<1000000000L, 1000L> &&const __static_gcd<1000000000L, 1000L>const __static_gcd<1000000000L, 1000L> &1152921504606846975..(*&&)(..)sizeof(typename V::value_type)89285MAX_VECTOR_ALLOCATE / sizeof(typename V::value_type)_Tuple_impl<0UL, basic_string<char, char_traits<char>, allocator<char>> &&> *is_nothrow_move_constructible<_Head>::valueis_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &>is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &> &is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &> &&const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &>const is_nothrow_constructible<pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue>, const pair<const basic_string<char, char_traits<char>, allocator<char>>, UniValue> &> &is_nothrow_move_constructible<basic_string<char, char_traits<char>, allocator<char>> &&>is_nothrow_move_constructible<basic_string<char, char_traits<char>, allocator<char>> &&> &is_nothrow_move_constructible<basic_string<char, char_traits<char>, allocator<char>> &&> &&const is_nothrow_move_constructible<basic_string<char, char_traits<char>, allocator<char>> &&>const is_nothrow_move_constructible<basic_string<char, char_traits<char>, allo 9  9]    